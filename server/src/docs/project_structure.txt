--- Folder Structure ---
[.qodo]
[api]
    ├── [controllers]
        ├── [auth]
        ├── authController.js
        ├── cartController.js
        ├── categoryController.js
        ├── orderController.js
        ├── productController.js
        ├── reviewController.js
        └── userController.js
    ├── [middleware]
        ├── authMiddleware.js
        ├── errorHandler.js
        ├── errorMiddleware.js
        ├── loggingMiddleware.js
        └── validationMiddleware.js
    └── [routes]
        ├── authRoutes.js
        ├── cartRoutes.js
        ├── categoryRoutes.js
        ├── orderRoutes.js
        ├── productRoutes.js
        ├── reviewRoutes.js
        └── userRoutes.js
app.js
[common]
    ├── [errors]
        └── apiError.js
    ├── [middleware]
        ├── errorHandler.js
        ├── rateLimiter.js
        ├── requestLogger.js
        └── validate.js
    ├── readme.md
    ├── [types]
        ├── auth.types.js
        ├── common.types.js
        ├── express.d.ts
        ├── order.types.js
        └── product.types.js
    ├── [utils]
        ├── apiFeatures.js
        ├── catchAsync.js
        ├── dateUtils.js
        ├── fileUtils.js
        ├── formatters.js
        ├── responseHandler.js
        ├── securityUtils.js
        └── validatorUtils.js
    └── [validators]
        ├── authValidator.js
        ├── cartValidator.js
        ├── categoryValidator.js
        ├── orderValidator.js
        ├── productValidator.js
        ├── reviewValidator.js
        └── userValidator.js
[config]
    ├── database.js
    ├── environment.js
    ├── fix-indexes.js
    ├── indexes.js
    ├── logger.js
    ├── middleware.js
    └── monitoring.js
[data]
    ├── [dto]
        ├── cartDTO.js
        ├── categoryDTO.js
        ├── orderDTO.js
        ├── productDTO.js
        ├── reviewDTO.js
        └── userDTO.js
    ├── [models]
        ├── cart.model.js
        ├── category.model.js
        ├── order.model.js
        ├── product.model.js
        ├── review.model.js
        └── user.model.js
    └── [repositories]
        ├── cartRepository.js
        ├── categoryRepository.js
        ├── orderRepository.js
        ├── productRepository.js
        ├── reviewRepository.js
        └── userRepository.js
[docs]
    ├── .project_structure_ignore
    └── project_structure.txt
[migrations]
    ├── config.js
    ├── index.js
    ├── migrationFramework.js
    ├── migrationRunner.js
    └── [scripts]
        ├── 001-initial-categories.js
        ├── 002-add-indexes.js
        └── 003-add-admin-user.js
[seeds]
    ├── [data]
        ├── carts.js
        ├── categories.js
        ├── orders.js
        ├── products.js
        ├── reviews.js
        └── users.js
    ├── index.js
    ├── runner.js
    └── [scripts]
        ├── cartSeeder.js
        ├── categorySeeder.js
        ├── orderSeeder.js
        ├── productSeeder.js
        ├── reviewSeeder.js
        └── userSeeder.js
server.js
[services]
    ├── [auth]
        └── authService.js
    ├── [base]
        └── baseService.js
    ├── [cache]
        └── redisCache.js
    ├── [cart]
        └── cartService.js
    ├── [category]
        └── categoryService.js
    ├── [email]
        ├── emailService.js
        └── [templates]
            ├── resetPassword.hbs
            └── verification.hbs
    ├── [order]
        └── orderService.js
    ├── [product]
        └── productService.js
    ├── [review]
        └── reviewService.js
    └── [user]
        └── userService.js
[types]
    └── express.d.ts
[utils]
    ├── apiFeatures.js
    ├── catchAsync.js
    ├── logger.js
    ├── queryAnalyzer.js
    ├── responseHandler.js
    └── validatorUtils.js

--- File Contents ---

--- File: api/controllers/authController.js ---
// @ts-nocheck
/**
 * Controller cho xác thực người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { ApiError } = require('../../middleware/errorHandler');
const User = require('../../data/models/user.model');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../../services/email/emailService');

/**
 * Tạo JWT token
 * @param {Object} user - User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, role: user.role },
    environment.auth.jwtSecret,
    { expiresIn: environment.auth.jwtExpiresIn }
  );
};

/**
 * Tạo refresh token
 * @param {Object} user - User object
 * @returns {String} Refresh token
 */
const generateRefreshToken = (user) => {
  return jwt.sign(
    { id: user._id },
    environment.auth.jwtRefreshSecret,
    { expiresIn: environment.auth.jwtRefreshExpiresIn }
  );
};

/**
 * Đăng ký người dùng mới
 */
exports.register = catchAsync(async (req, res, next) => {
  const { name, email, password, phone } = req.body;
  
  // Kiểm tra email đã tồn tại chưa
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email đã được sử dụng'));
  }
  
  // Tạo verification token
  const verificationToken = crypto.randomBytes(32).toString('hex');
  const verificationTokenExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 giờ
  
  // Tạo user mới
  const newUser = await User.create({
    name,
    email,
    password,
    phone,
    emailVerificationToken: crypto
      .createHash('sha256')
      .update(verificationToken)
      .digest('hex'),
    emailVerificationExpires: verificationTokenExpires,
  });
  
  try {
    // Gửi email xác thực
    const verifyURL = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    await sendEmail({
      to: email,
      subject: 'Xác thực tài khoản RunOut-Biliard',
      template: 'verification',
      context: {
        name,
        verifyURL,
      },
    });
    
    res.status(201).json({
      status: 'success',
      message: 'Người dùng đã được tạo. Vui lòng kiểm tra email để xác thực tài khoản.',
    });
  } catch (error) {
    // Xử lý lỗi gửi email
    logger.error(`Không thể gửi email xác thực: ${error.message}`);
    
    // Xóa user trong trường hợp email không gửi được
    await User.findByIdAndDelete(newUser._id);
    
    return next(new ApiError(
      500,
      'Đã xảy ra lỗi khi gửi email xác thực. Vui lòng thử lại sau.'
    ));
  }
});

/**
 * Đăng nhập
 */
exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  
  // Kiểm tra email và password
  if (!email || !password) {
    return next(new ApiError(400, 'Vui lòng cung cấp email và mật khẩu'));
  }
  
  // Tìm user trong database
  const user = await User.findOne({ email }).select('+password');
  
  // Kiểm tra user tồn tại và password đúng
  if (!user || !(await user.correctPassword(password, user.password))) {
    return next(new ApiError(401, 'Email hoặc mật khẩu không đúng'));
  }
  
  // Kiểm tra email đã xác thực chưa
  if (!user.emailVerified) {
    return next(new ApiError(401, 'Vui lòng xác thực email trước khi đăng nhập'));
  }
  
  // Kiểm tra user có active không
  if (!user.isActive) {
    return next(new ApiError(401, 'Tài khoản của bạn đã bị vô hiệu hóa'));
  }
  
  // Tạo token
  const token = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  // Cập nhật thông tin đăng nhập
  user.lastLogin = Date.now();
  user.loginCount += 1;
  await user.save({ validateBeforeSave: false });
  
  // Không gửi password trong response
  user.password = undefined;
  
  res.status(200).json({
    status: 'success',
    data: {
      user,
      token,
      refreshToken,
    },
  });
});

/**
 * Đăng xuất
 */
exports.logout = catchAsync(async (req, res, next) => {
  // Đối với JWT, không cần làm gì ở phía server
  // Client cần xóa token
  
  res.status(200).json({
    status: 'success',
    message: 'Đăng xuất thành công',
  });
});

/**
 * Làm mới access token bằng refresh token
 */
exports.refreshToken = catchAsync(async (req, res, next) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return next(new ApiError(400, 'Refresh token không được cung cấp'));
  }
  
  try {
    // Xác thực refresh token
    const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);
    
    // Tìm user
    const user = await User.findById(decoded.id);
    
    if (!user || !user.isActive) {
      return next(new ApiError(401, 'Người dùng không tồn tại hoặc đã bị vô hiệu hóa'));
    }
    
    // Tạo token mới
    const newToken = generateToken(user);
    
    res.status(200).json({
      status: 'success',
      data: {
        token: newToken,
      },
    });
  } catch (error) {
    return next(new ApiError(401, 'Refresh token không hợp lệ hoặc đã hết hạn'));
  }
});

/**
 * Quên mật khẩu
 */
exports.forgotPassword = catchAsync(async (req, res, next) => {
  const { email } = req.body;
  
  // Tìm user theo email
  const user = await User.findOne({ email });
  
  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng với email này'));
  }
  
  // Tạo reset token
  const resetToken = user.createPasswordResetToken();
  await user.save({ validateBeforeSave: false });
  
  try {
    // Tạo URL reset password
    const resetURL = `${req.protocol}://${req.get('host')}/reset-password/${resetToken}`;
    
    // Gửi email
    await sendEmail({
      to: user.email,
      subject: 'Đặt lại mật khẩu (có hiệu lực trong 10 phút)',
      template: 'resetPassword',
      context: {
        name: user.name,
        resetURL,
      },
    });
    
    res.status(200).json({
      status: 'success',
      message: 'Token đã được gửi đến email',
    });
  } catch (error) {
    // Xử lý lỗi gửi email
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save({ validateBeforeSave: false });
    
    logger.error(`Không thể gửi email đặt lại mật khẩu: ${error.message}`);
    
    return next(new ApiError(
      500,
      'Có lỗi xảy ra khi gửi email. Vui lòng thử lại sau!'
    ));
  }
});

/**
 * Đặt lại mật khẩu
 */
exports.resetPassword = catchAsync(async (req, res, next) => {
  const { token, password } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Tìm user với token và kiểm tra thời hạn
  const user = await User.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpires: { $gt: Date.now() },
  });
  
  // Kiểm tra nếu token hợp lệ
  if (!user) {
    return next(new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn'));
  }
  
  // Cập nhật mật khẩu
  user.password = password;
  user.resetPasswordToken = undefined;
  user.resetPasswordExpires = undefined;
  await user.save();
  
  // Đăng nhập người dùng
  const jwtToken = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  res.status(200).json({
    status: 'success',
    message: 'Mật khẩu đã được cập nhật',
    data: {
      token: jwtToken,
      refreshToken,
    },
  });
});

/**
 * Xác thực email
 */
exports.verifyEmail = catchAsync(async (req, res, next) => {
  const { token } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Tìm user và kiểm tra thời hạn
  const user = await User.findOne({
    emailVerificationToken: hashedToken,
    emailVerificationExpires: { $gt: Date.now() },
  });
  
  // Kiểm tra nếu token hợp lệ
  if (!user) {
    return next(new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn'));
  }
  
  // Cập nhật trạng thái xác thực
  user.emailVerified = true;
  user.emailVerificationToken = undefined;
  user.emailVerificationExpires = undefined;
  await user.save({ validateBeforeSave: false });
  
  res.status(200).json({
    status: 'success',
    message: 'Email đã được xác thực thành công',
  });
});

--- File: api/controllers/cartController.js ---
/**
 * Cart Controller
 * Xử lý các request liên quan đến giỏ hàng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const cartService = require('../../services/cart/cartService');

/**
 * Lấy giỏ hàng hiện tại của người dùng đăng nhập hoặc khách
 * @route GET /api/carts/mycart
 * @access Public
 */
const getMyCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  // Nếu đã đăng nhập, lấy giỏ hàng theo userId
  if (req.user) {
    userId = req.user.id;
  } else {
    // Nếu chưa đăng nhập, lấy giỏ hàng theo sessionId
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    // Nếu chưa có sessionId, tạo mới
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 ngày
        httpOnly: true
      });
    }
  }
  
  const cart = await cartService.getActiveCart(userId, sessionId);
  return responseHandler.success(res, cart);
});

/**
 * Thêm sản phẩm vào giỏ hàng
 * @route POST /api/carts/items
 * @access Public
 */
const addItemToCart = catchAsync(async (req, res) => {
  const { productId, quantity, attributes } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000,
        httpOnly: true
      });
    }
  }
  
  const updatedCart = await cartService.addItemToCart(
    userId,
    sessionId,
    productId,
    quantity,
    attributes
  );
  
  return responseHandler.success(res, updatedCart);
});

/**
 * Cập nhật số lượng sản phẩm trong giỏ hàng
 * @route PATCH /api/carts/items/:itemId
 * @access Public
 */
const updateCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  const { quantity } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.updateCartItem(userId, sessionId, itemId, quantity);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa sản phẩm khỏi giỏ hàng
 * @route DELETE /api/carts/items/:itemId
 * @access Public
 */
const removeCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeItemFromCart(userId, sessionId, itemId);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa toàn bộ giỏ hàng
 * @route DELETE /api/carts/mycart
 * @access Public
 */
const clearCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  await cartService.clearCart(userId, sessionId);
  return responseHandler.success(res, { message: 'Cart cleared successfully' });
});

/**
 * Áp dụng mã giảm giá vào giỏ hàng
 * @route POST /api/carts/apply-coupon
 * @access Public
 */
const applyCoupon = catchAsync(async (req, res) => {
  const { code } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.applyCoupon(userId, sessionId, code);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa mã giảm giá khỏi giỏ hàng
 * @route DELETE /api/carts/remove-coupon
 * @access Public
 */
const removeCoupon = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeCoupon(userId, sessionId);
  return responseHandler.success(res, updatedCart);
});

/**
 * Hợp nhất giỏ hàng từ session với giỏ hàng người dùng khi đăng nhập
 * @route POST /api/carts/merge
 * @access Private
 */
const mergeCart = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const { sessionId } = req.body;
  
  if (!sessionId) {
    return responseHandler.badRequest(res, 'Session ID is required');
  }
  
  const mergedCart = await cartService.mergeCartsOnLogin(userId, sessionId);
  
  // Xóa cookie giỏ hàng của session
  res.clearCookie('cartSessionId');
  
  return responseHandler.success(res, mergedCart);
});

module.exports = {
  getMyCart,
  addItemToCart,
  updateCartItem,
  removeCartItem,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCart
};

--- File: api/controllers/categoryController.js ---
/**
 * Category Controller
 * Xử lý các request liên quan đến danh mục sản phẩm
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const categoryService = require('../../services/category/categoryService');

/**
 * Lấy tất cả danh mục
 * @route GET /api/categories
 * @access Public
 */
const getAllCategories = catchAsync(async (req, res) => {
  const features = req.query;
  const categories = await categoryService.getAllCategories(features);
  return responseHandler.success(res, categories);
});

/**
 * Lấy danh mục theo ID
 * @route GET /api/categories/:id
 * @access Public
 */
const getCategoryById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const category = await categoryService.getCategoryById(id);
  return responseHandler.success(res, category);
});

/**
 * Lấy tất cả sản phẩm trong danh mục
 * @route GET /api/categories/:id/products
 * @access Public
 */
const getCategoryProducts = catchAsync(async (req, res) => {
  const { id } = req.params;
  const features = req.query;
  const products = await categoryService.getCategoryProducts(id, features);
  return responseHandler.success(res, products);
});

/**
 * Tạo danh mục mới
 * @route POST /api/categories
 * @access Private (Admin only)
 */
const createCategory = catchAsync(async (req, res) => {
  const categoryData = req.body;
  const newCategory = await categoryService.createCategory(categoryData);
  return responseHandler.created(res, newCategory);
});

/**
 * Cập nhật danh mục
 * @route PUT /api/categories/:id
 * @access Private (Admin only)
 */
const updateCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  const categoryData = req.body;
  const updatedCategory = await categoryService.updateCategory(id, categoryData);
  return responseHandler.success(res, updatedCategory);
});

/**
 * Xóa danh mục
 * @route DELETE /api/categories/:id
 * @access Private (Admin only)
 */
const deleteCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  await categoryService.deleteCategory(id);
  return responseHandler.success(res, { message: 'Danh mục đã được xóa thành công' });
});

/**
 * Lấy tất cả danh mục con
 * @route GET /api/categories/:id/subcategories
 * @access Public
 */
const getSubcategories = catchAsync(async (req, res) => {
  const { id } = req.params;
  const subcategories = await categoryService.getSubcategories(id);
  return responseHandler.success(res, subcategories);
});

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getSubcategories
};

--- File: api/controllers/orderController.js ---
/**
 * Order Controller
 * Xử lý các request liên quan đến đơn hàng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const orderService = require('../../services/order/orderService');

/**
 * Lấy tất cả đơn hàng (Admin)
 * @route GET /api/orders
 * @access Private (Admin only)
 */
const getAllOrders = catchAsync(async (req, res) => {
  const features = req.query;
  const orders = await orderService.getAllOrders(features);
  return responseHandler.success(res, orders);
});

/**
 * Lấy đơn hàng theo ID
 * @route GET /api/orders/:id
 * @access Private (Admin hoặc người dùng sở hữu đơn hàng)
 */
const getOrderById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  const order = await orderService.getOrderById(id, userId, isAdmin);
  return responseHandler.success(res, order);
});

/**
 * Lấy đơn hàng của người dùng đăng nhập
 * @route GET /api/orders/myorders
 * @access Private
 */
const getMyOrders = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const features = req.query;
  
  const orders = await orderService.getOrdersByUserId(userId, features);
  return responseHandler.success(res, orders);
});

/**
 * Tạo đơn hàng mới
 * @route POST /api/orders
 * @access Private
 */
const createOrder = catchAsync(async (req, res) => {
  const orderData = req.body;
  const userId = req.user.id;
  
  const newOrder = await orderService.createOrder(orderData, userId);
  return responseHandler.created(res, newOrder);
});

/**
 * Cập nhật trạng thái đơn hàng
 * @route PATCH /api/orders/:id/status
 * @access Private (Admin only)
 */
const updateOrderStatus = catchAsync(async (req, res) => {
  const { id } = req.params;
  const { status, note } = req.body;
  const adminId = req.user.id;
  
  const updatedOrder = await orderService.updateOrderStatus(id, status, note, adminId);
  return responseHandler.success(res, updatedOrder);
});

/**
 * Hủy đơn hàng
 * @route PATCH /api/orders/:id/cancel
 * @access Private (Admin hoặc người dùng sở hữu đơn hàng)
 */
const cancelOrder = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { reason } = req.body;
  
  const cancelledOrder = await orderService.cancelOrder(id, userId, isAdmin, reason);
  return responseHandler.success(res, cancelledOrder);
});

/**
 * Xử lý webhook thanh toán từ VNPay
 * @route POST /api/orders/payment/vnpay-webhook
 * @access Public
 */
const processVnPayWebhook = catchAsync(async (req, res) => {
  const paymentData = req.body;
  await orderService.processPaymentWebhook(paymentData);
  return responseHandler.success(res, { message: 'Payment processed successfully' });
});

/**
 * Xử lý callback từ VNPay
 * @route GET /api/orders/payment/vnpay-return
 * @access Private
 */
const processVnPayReturn = catchAsync(async (req, res) => {
  const paymentData = req.query;
  const result = await orderService.processPaymentReturn(paymentData);
  return responseHandler.success(res, result);
});

module.exports = {
  getAllOrders,
  getOrderById,
  getMyOrders,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processVnPayWebhook,
  processVnPayReturn
};

--- File: api/controllers/productController.js ---
/**
 * ProductController
 * Xử lý các request API liên quan đến sản phẩm
 */

const productService = require('../../services/product/productService');
const catchAsync = require('../../common/utils/catchAsync');
const responseHandler = require('../../common/utils/responseHandler');
const AppError = require('../../common/errors/apiError');

// Tạo đối tượng controller
const productController = {
  /**
   * Lấy danh sách sản phẩm
   * @route GET /api/products
   * @access Public
   */
  getProducts: catchAsync(async (req, res) => {
    const result = await productService.getProducts(req.query);
    responseHandler.success(res, {
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * Lấy chi tiết sản phẩm
   * @route GET /api/products/:id
   * @access Public
   */
  getProductById: catchAsync(async (req, res) => {
    const product = await productService.getProductById(req.params.id);
    responseHandler.success(res, { product });
  }),

  /**
   * Lấy sản phẩm theo slug
   * @route GET /api/products/by-slug/:slug
   * @access Public
   */
  getProductBySlug: catchAsync(async (req, res) => {
    // Sử dụng getProducts với filter theo slug
    const result = await productService.getProducts({
      slug: req.params.slug,
      limit: 1,
    });

    if (!result.products || result.products.length === 0) {
      throw new AppError(404, 'Không tìm thấy sản phẩm');
    }

    // Lấy sản phẩm đầu tiên từ kết quả
    const product = result.products[0];

    // Lấy thêm thông tin chi tiết nếu cần
    const detailedProduct = await productService.getProductById(product.id);

    responseHandler.success(res, { product: detailedProduct });
  }),

  /**
   * Lấy sản phẩm theo danh mục
   * @route GET /api/categories/:categoryId/products
   * @access Public
   */
  getProductsByCategory: catchAsync(async (req, res) => {
    const { categoryId } = req.params;
    const result = await productService.getProductsByCategory(categoryId, req.query);
    responseHandler.success(res, {
      category: result.category,
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * Lấy sản phẩm nổi bật
   * @route GET /api/products/trending
   * @access Public
   */
  getTrendingProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;
    const products = await productService.getTrendingProducts(limit);
    responseHandler.success(res, { products });
  }),

  /**
   * Lấy sản phẩm mới
   * @route GET /api/products/new
   * @access Public
   */
  getNewProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // Sử dụng getProducts với sắp xếp theo ngày tạo mới nhất
    const result = await productService.getProducts({
      limit,
      sort: { createdAt: -1 },
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * Lấy sản phẩm giảm giá
   * @route GET /api/products/sale
   * @access Public
   */
  getSaleProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // Sử dụng getProducts với bộ lọc cho sản phẩm có giá khuyến mãi
    const result = await productService.getProducts({
      limit,
      filters: { salePrice: { $gt: 0 } },
      sort: { salePrice: 1 }, // Sắp xếp theo giá khuyến mãi tăng dần
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * Tìm kiếm sản phẩm
   * @route GET /api/products/search
   * @access Public
   */
  searchProducts: catchAsync(async (req, res) => {
    const { q } = req.query;
    if (!q) {
      throw new AppError(400, 'Vui lòng cung cấp từ khóa tìm kiếm');
    }

    const options = {
      limit: parseInt(req.query.limit) || 10,
      page: parseInt(req.query.page) || 1,
      sort: req.query.sort ? JSON.parse(req.query.sort) : { newest: -1 },
      filters: req.query.filters ? JSON.parse(req.query.filters) : {},
    };

    const result = await productService.searchProducts(q, options);
    responseHandler.success(res, result);
  }),

  /**
   * Tạo sản phẩm mới (Admin)
   * @route POST /api/admin/products
   * @access Private/Admin
   */
  createProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const product = await productService.createProduct(req.body, userId);
    responseHandler.created(res, { product });
  }),

  /**
   * Cập nhật sản phẩm (Admin)
   * @route PUT /api/admin/products/:id
   * @access Private/Admin
   */
  updateProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;
    const product = await productService.updateProduct(id, req.body, userId);
    responseHandler.success(res, { product });
  }),

  /**
   * Xóa sản phẩm (Admin)
   * @route DELETE /api/admin/products/:id
   * @access Private/Admin
   */
  deleteProduct: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.deleteProduct(id);
    responseHandler.success(res, { message: 'Sản phẩm đã được xóa thành công' });
  }),

  /**
   * Cập nhật tồn kho (Admin)
   * @route PATCH /api/admin/products/:id/stock
   * @access Private/Admin
   */
  updateStock: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { quantity } = req.body;

    if (quantity === undefined) {
      throw new AppError(400, 'Vui lòng cung cấp số lượng tồn kho');
    }

    const result = await productService.updateStock(id, parseInt(quantity));
    responseHandler.success(res, result);
  }),

  /**
   * Cập nhật trạng thái sản phẩm (Admin)
   * @route PATCH /api/admin/products/:id/status
   * @access Private/Admin
   */
  updateStatus: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
      throw new AppError(400, 'Vui lòng cung cấp trạng thái');
    }

    const allowedStatuses = ['active', 'draft', 'discontinued'];
    if (!allowedStatuses.includes(status)) {
      throw new AppError(
        400,
        `Trạng thái không hợp lệ. Các trạng thái hợp lệ: ${allowedStatuses.join(', ')}`
      );
    }

    const product = await productService.updateProduct(id, { status }, req.user.id);
    responseHandler.success(res, { product });
  }),

  /**
   * Lấy thống kê sản phẩm (Admin)
   * @route GET /api/admin/products/stats
   * @access Private/Admin
   */
  getProductStats: catchAsync(async (req, res) => {
    const stats = await productService.getProductStats();
    responseHandler.success(res, { stats });
  }),

  /**
   * Lấy sản phẩm liên quan
   * @route GET /api/products/:id/related
   * @access Public
   */
  getRelatedProducts: catchAsync(async (req, res) => {
    const { id } = req.params;
    const limit = parseInt(req.query.limit) || 5;

    const products = await productService.getRelatedProducts(id, limit);
    responseHandler.success(res, { products });
  }),

  /**
   * Tăng số lượt xem sản phẩm
   * @route POST /api/products/:id/view
   * @access Public
   */
  incrementProductView: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.incrementViewCount(id);
    responseHandler.success(res, { message: 'Đã cập nhật lượt xem' });
  }),
};

// Xuất controller
module.exports = productController;


--- File: api/controllers/reviewController.js ---
/**
 * Review Controller
 * Xử lý các request liên quan đến đánh giá sản phẩm
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const reviewService = require('../../services/review/reviewService');

/**
 * Lấy tất cả đánh giá (có phân trang, lọc)
 * @route GET /api/reviews
 * @access Public
 */
const getAllReviews = catchAsync(async (req, res) => {
  const features = req.query;
  const reviews = await reviewService.getAllReviews(features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy đánh giá theo ID
 * @route GET /api/reviews/:id
 * @access Public
 */
const getReviewById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const review = await reviewService.getReviewById(id);
  return responseHandler.success(res, review);
});

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @route GET /api/products/:productId/reviews
 * @access Public
 */
const getProductReviews = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const features = req.query;
  const reviews = await reviewService.getProductReviews(productId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy tất cả đánh giá của một người dùng
 * @route GET /api/users/:userId/reviews
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const getUserReviews = catchAsync(async (req, res) => {
  const { userId } = req.params;
  
  // Kiểm tra quyền truy cập
  const requestUserId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  if (userId !== requestUserId && !isAdmin) {
    return responseHandler.forbidden(res, 'Bạn không có quyền xem đánh giá của người dùng khác');
  }
  
  const features = req.query;
  const reviews = await reviewService.getUserReviews(userId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Tạo đánh giá mới
 * @route POST /api/products/:productId/reviews
 * @access Private
 */
const createReview = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const userId = req.user.id;
  const reviewData = req.body;
  
  const newReview = await reviewService.createReview(productId, userId, reviewData);
  return responseHandler.created(res, newReview);
});

/**
 * Cập nhật đánh giá
 * @route PUT /api/reviews/:id
 * @access Private (Người dùng sở hữu đánh giá)
 */
const updateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const reviewData = req.body;
  
  const updatedReview = await reviewService.updateReview(id, userId, reviewData, isAdmin);
  return responseHandler.success(res, updatedReview);
});

/**
 * Xóa đánh giá
 * @route DELETE /api/reviews/:id
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const deleteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  await reviewService.deleteReview(id, userId, isAdmin);
  return responseHandler.success(res, { message: 'Đánh giá đã được xóa thành công' });
});

/**
 * Upvote hoặc downvote đánh giá
 * @route POST /api/reviews/:id/vote
 * @access Private
 */
const voteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { vote } = req.body; // 1 for upvote, -1 for downvote
  
  const updatedReview = await reviewService.voteReview(id, userId, vote);
  return responseHandler.success(res, updatedReview);
});

/**
 * Kiểm duyệt đánh giá (duyệt hoặc từ chối)
 * @route PATCH /api/reviews/:id/moderate
 * @access Private (Admin only)
 */
const moderateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const adminId = req.user.id;
  const { action, reason } = req.body; // 'approve' or 'reject'
  
  const moderatedReview = await reviewService.moderateReview(id, action, reason, adminId);
  return responseHandler.success(res, moderatedReview);
});

/**
 * Báo cáo đánh giá
 * @route POST /api/reviews/:id/report
 * @access Private
 */
const reportReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { reason, description } = req.body;
  
  const reportedReview = await reviewService.reportReview(id, userId, reason, description);
  return responseHandler.success(res, reportedReview);
});

/**
 * Thêm phản hồi cho đánh giá
 * @route POST /api/reviews/:id/responses
 * @access Private (Admin hoặc người dùng sở hữu sản phẩm)
 */
const addReviewResponse = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { content } = req.body;
  
  const updatedReview = await reviewService.addReviewResponse(id, userId, content, isAdmin);
  return responseHandler.success(res, updatedReview);
});

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse
};

--- File: api/controllers/userController.js ---
/**
 * Controller cho quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const { ApiError, isOwnerOrAdmin } = require('../middleware/authMiddleware');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const responseHandler = require('../../utils/responseHandler');

/**
 * Lấy danh sách người dùng (với phân trang và filter)
 */
exports.getUsers = catchAsync(async (req, res, next) => {
  // Xử lý query params
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;
  const sort = req.query.sort || '-createdAt';

  // Xây dựng filter
  const filter = {};

  // Lọc theo role nếu có
  if (req.query.role) {
    filter.role = req.query.role;
  }

  // Lọc theo trạng thái active
  if (req.query.isActive) {
    filter.isActive = req.query.isActive === 'true';
  }

  // Tìm kiếm theo tên hoặc email
  if (req.query.search) {
    const searchRegex = new RegExp(req.query.search, 'i');
    filter.$or = [{ name: searchRegex }, { email: searchRegex }];
  }

  // Thực hiện query
  const users = await User.find(filter).sort(sort).skip(skip).limit(limit).select('-password');

  // Đếm tổng số users phù hợp với filter
  const total = await User.countDocuments(filter);

  // Tính toán thông tin phân trang
  const totalPages = Math.ceil(total / limit);
  const hasNext = page < totalPages;
  const hasPrev = page > 1;

  responseHandler.success(res, {
    results: users.length,
    pagination: {
      total,
      page,
      limit,
      totalPages,
      hasNext,
      hasPrev,
    },
    data: users,
  });
});

/**
 * Lấy thông tin người dùng theo ID
 * Middleware isOwnerOrAdmin đã được áp dụng ở route
 */
exports.getUserById = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Tìm user
  const user = await User.findById(userId).select('-password');

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  responseHandler.success(res, { data: user });
});

/**
 * Tạo người dùng mới (chỉ admin)
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.createUser = catchAsync(async (req, res, next) => {
  const { name, email, password, role, phone } = req.body;

  // Kiểm tra email đã tồn tại chưa
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email đã được sử dụng'));
  }

  // Tạo user mới
  const newUser = await User.create({
    name,
    email,
    password,
    role,
    phone,
    // Admin tạo user thì mặc định đã xác thực email
    emailVerified: true,
  });

  // Không gửi password trong response
  newUser.password = undefined;

  // Ghi log
  logger.info(`User ${newUser.email} đã được tạo bởi ${req.user.email}`);

  responseHandler.created(res, { data: newUser });
});

/**
 * Cập nhật thông tin người dùng
 * Middleware isOwnerOrAdmin đã được áp dụng ở route
 */
exports.updateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Loại bỏ các trường không được phép cập nhật
  const { password, emailVerified, loginCount, lastLogin, ...updateData } = req.body;

  // Admin có thể cập nhật role
  if (req.user.role !== 'admin') {
    delete updateData.role;
  }

  // Tìm và cập nhật user
  const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
    new: true,
    runValidators: true,
  }).select('-password');

  if (!updatedUser) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  // Ghi log
  logger.info(`User ${updatedUser.email} đã được cập nhật bởi ${req.user.email}`);

  responseHandler.success(res, { data: updatedUser });
});

/**
 * Xóa người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.deleteUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Xóa user
  const user = await User.findByIdAndDelete(userId);

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã bị xóa bởi ${req.user.email}`);

  responseHandler.success(res, { message: 'Người dùng đã được xóa thành công' });
});

/**
 * Lấy thông tin profile người dùng hiện tại
 * Middleware authenticate đã được áp dụng ở route
 */
exports.getProfile = catchAsync(async (req, res, next) => {
  // Thông tin người dùng đã được lưu trong req.user từ middleware authenticate
  const user = req.user;

  responseHandler.success(res, { data: user });
});

/**
 * Thay đổi mật khẩu
 * Middleware authenticate đã được áp dụng ở route
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next function
 */
exports.changePassword = catchAsync(async (req, res, next) => {
  const { currentPassword, newPassword } = req.body;

  // Kiểm tra dữ liệu đầu vào
  if (!currentPassword || !newPassword) {
    return next(new ApiError(400, 'Vui lòng cung cấp mật khẩu hiện tại và mật khẩu mới'));
  }

  // Lấy user hiện tại với password
  /**
   * @type {import('mongoose').Document & {
   *   password: string,
   *   correctPassword: (candidatePassword: string, userPassword: string) => Promise<boolean>
   * }}
   */
  const user = await User.findById(req.user.id).select('+password');

  // Kiểm tra mật khẩu hiện tại
  if (!(await user.correctPassword(currentPassword, user.password))) {
    return next(new ApiError(401, 'Mật khẩu hiện tại không đúng'));
  }

  // Cập nhật mật khẩu
  user.password = newPassword;
  await user.save();

  // Không gửi password trong response
  user.password = undefined;

  // Ghi log
  logger.info(`User ${user.email} đã thay đổi mật khẩu`);

  responseHandler.success(res, { message: 'Mật khẩu đã được cập nhật thành công' });
});

/**
 * Vô hiệu hóa tài khoản người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.deactivateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: false }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã bị vô hiệu hóa bởi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'Tài khoản người dùng đã bị vô hiệu hóa',
    data: user,
  });
});

/**
 * Kích hoạt lại tài khoản người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.activateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: true }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã được kích hoạt lại bởi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'Tài khoản người dùng đã được kích hoạt lại',
    data: user,
  });
});


--- File: api/middleware/authMiddleware.js ---
/**
 * Authentication Middleware
 * Xử lý xác thực và phân quyền cho API endpoints
 */

const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const catchAsync = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const userService = require('../../services/user/userService');
const config = require('../../config/environment');

const authMiddleware = {
  /**
   * Xác thực người dùng qua JWT token
   * Token được cung cấp qua header Authorization
   */
  authenticate: catchAsync(async (req, res, next) => {
    // 1) Lấy token và kiểm tra nếu tồn tại
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies && req.cookies.jwt) {
      token = req.cookies.jwt;
    }

    if (!token) {
      return responseHandler.unauthorized(res, 'Vui lòng đăng nhập để truy cập');
    }

    // 2) Xác thực token
    const decoded = await promisify(jwt.verify)(token, config.jwt.secret);

    // 3) Kiểm tra nếu người dùng vẫn tồn tại
    const user = await userService.getUserById(decoded.id);
    if (!user) {
      return responseHandler.unauthorized(res, 'Người dùng không còn tồn tại');
    }

    // 4) Kiểm tra nếu người dùng đã thay đổi mật khẩu sau khi token được cấp
    if (user.changedPasswordAfter(decoded.iat)) {
      return responseHandler.unauthorized(res, 'Mật khẩu đã thay đổi, vui lòng đăng nhập lại');
    }

    // Lưu thông tin người dùng vào request
    req.user = user;
    next();
  }),

  /**
   * Giới hạn quyền truy cập dựa trên vai trò người dùng
   * @param {...string} roles - Các vai trò được phép truy cập
   */
  restrictTo: (...roles) => {
    return (req, res, next) => {
      // Kiểm tra nếu vai trò của người dùng nằm trong danh sách được phép
      if (!roles.includes(req.user.role)) {
        return responseHandler.forbidden(res, 'Bạn không có quyền thực hiện hành động này');
      }
      next();
    };
  },

  /**
   * Kiểm tra xem người dùng đã xác thực email chưa
   */
  isEmailVerified: (req, res, next) => {
    if (!req.user.emailVerified) {
      return responseHandler.forbidden(res, 'Vui lòng xác thực email của bạn trước');
    }
    next();
  },

  /**
   * Kiểm tra nếu người dùng đang truy cập dữ liệu của chính họ
   * hoặc là admin
   */
  isOwnerOrAdmin: (userIdPath) => {
    return (req, res, next) => {
      const userId = userIdPath.split('.').reduce((obj, prop) => obj[prop], req);

      // Cho phép nếu là admin hoặc chủ sở hữu
      if (req.user.role === 'admin' || req.user.id === userId) {
        return next();
      }

      return responseHandler.forbidden(res, 'Bạn không có quyền truy cập dữ liệu này');
    };
  },
};

module.exports = {
  authenticate: authMiddleware.authenticate,
  restrictTo: authMiddleware.restrictTo,
  isEmailVerified: authMiddleware.isEmailVerified,
  isOwnerOrAdmin: authMiddleware.isOwnerOrAdmin,
};


--- File: api/middleware/errorHandler.js ---
/**
 * Error Handler Middleware
 * Xử lý các lỗi trong API và trả về response phù hợp
 * @author Steve
 * @project RunOut-Biliard
 */

const logger = require('../../config/logger');

/**
 * Class ApiError - Định nghĩa cấu trúc lỗi API
 */
class ApiError extends Error {
  /**
   * Khởi tạo lỗi API
   * @param {number} statusCode - Mã HTTP status
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết (optional)
   * @param {boolean} isOperational - Xác định lỗi là operational hay programming
   * @param {string} stack - Stack trace
   */
  constructor(statusCode, message, errors = [], isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;

    // Thêm timestamp
    this.timestamp = new Date();

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  /**
   * Tạo lỗi 404 Not Found
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static notFound(message = 'Không tìm thấy tài nguyên') {
    return new ApiError(404, message);
  }

  /**
   * Tạo lỗi 400 Bad Request
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết
   * @returns {ApiError} - Đối tượng ApiError
   */
  static badRequest(message = 'Yêu cầu không hợp lệ', errors = []) {
    return new ApiError(400, message, errors);
  }

  /**
   * Tạo lỗi 401 Unauthorized
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static unauthorized(message = 'Không được phép truy cập') {
    return new ApiError(401, message);
  }

  /**
   * Tạo lỗi 403 Forbidden
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static forbidden(message = 'Bạn không có quyền truy cập tài nguyên này') {
    return new ApiError(403, message);
  }

  /**
   * Tạo lỗi 500 Internal Server Error
   * @param {string} message - Thông báo lỗi
   * @param {boolean} isOperational - Xác định lỗi là operational hay programming
   * @returns {ApiError} - Đối tượng ApiError
   */
  static internal(message = 'Lỗi máy chủ nội bộ', isOperational = true) {
    return new ApiError(500, message, [], isOperational);
  }

  /**
   * Tạo lỗi 422 Unprocessable Entity
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết
   * @returns {ApiError} - Đối tượng ApiError
   */
  static validationError(message = 'Lỗi xác thực dữ liệu', errors = []) {
    return new ApiError(422, message, errors);
  }
}

/**
 * Middleware xử lý lỗi
 * @param {Error} err - Đối tượng lỗi
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // Nếu lỗi không phải là ApiError, chuyển đổi thành ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Lỗi máy chủ nội bộ';
    error = new ApiError(statusCode, message, [], false, err.stack);
  }

  // Log lỗi
  if (error.statusCode >= 500) {
    logger.error(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
    logger.error(error.stack);
  } else {
    logger.warn(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
  }

  // Chuẩn bị response
  const response = {
    success: false,
    status: error.statusCode,
    message: error.message,
    errors: error.errors.length > 0 ? error.errors : undefined,
    timestamp: error.timestamp,
    path: req.path,
  };

  // Trong môi trường development, thêm stack trace
  if (process.env.NODE_ENV === 'development') {
    response.stack = error.stack;
  }

  // Gửi response
  res.status(error.statusCode).json(response);
};

/**
 * Middleware bắt lỗi 404 cho các routes không tồn tại
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const notFoundHandler = (req, res, next) => {
  const error = ApiError.notFound(`Không tìm thấy đường dẫn: ${req.originalUrl}`);
  next(error);
};

/**
 * Middleware bắt lỗi validation từ express-validator
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const validationErrorHandler = (req, res, next) => {
  const { validationErrors } = req;

  if (validationErrors && validationErrors.length > 0) {
    const errors = validationErrors.map((error) => ({
      field: error.param,
      message: error.msg,
      value: error.value,
    }));

    const error = ApiError.validationError('Dữ liệu không hợp lệ', errors);
    return next(error);
  }

  next();
};

/**
 * Xử lý lỗi không được bắt trong promise
 */
const setupUnhandledRejectionHandler = () => {
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // Trong môi trường production, có thể cân nhắc tắt server hoặc xử lý graceful shutdown
    // process.exit(1);
  });
};

/**
 * Xử lý lỗi không được bắt
 */
const setupUncaughtExceptionHandler = () => {
  process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception:', error);
    // Trong môi trường production, nên tắt server vì trạng thái có thể không ổn định
    // process.exit(1);
  });
};

module.exports = {
  ApiError,
  errorHandler,
  notFoundHandler,
  validationErrorHandler,
  setupUnhandledRejectionHandler,
  setupUncaughtExceptionHandler,
};


--- File: api/middleware/errorMiddleware.js ---
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'Internal Server Error',
  });
};

module.exports = { errorHandler };


--- File: api/middleware/loggingMiddleware.js ---
const loggingMiddleware = (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  next();
};

module.exports = { loggingMiddleware };


--- File: api/middleware/validationMiddleware.js ---
/**
 * Middleware xác thực dữ liệu sử dụng Joi và các tiện ích khác
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 */

const Joi = require('joi');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;

/**
 * Middleware kiểm tra tính hợp lệ của MongoDB ObjectId
 * @returns {function} Express middleware
 */
const validateMongoId = () => (req, res, next) => {
  const idParam = req.params.id;

  if (!idParam) {
    return res.status(400).json({
      success: false,
      message: 'ID không được cung cấp',
    });
  }

  if (!ObjectId.isValid(idParam)) {
    return res.status(400).json({
      success: false,
      message: 'ID không hợp lệ',
    });
  }

  next();
};

/**
 * Middleware tạo bộ xác thực dữ liệu từ schema Joi
 * @param {Joi.Schema} schema - Joi schema sử dụng để xác thực
 * @returns {function} Express middleware
 */
const validate = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body, {
    abortEarly: false, // Trả về tất cả lỗi thay vì chỉ lỗi đầu tiên
    stripUnknown: true, // Loại bỏ các trường không được định nghĩa trong schema
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'Dữ liệu không hợp lệ',
      errors: errorMessages,
    });
  }

  next();
};

/**
 * Middleware tạo bộ xác thực dữ liệu từ schema Joi cho query params
 * @param {Joi.Schema} schema - Joi schema sử dụng để xác thực
 * @returns {function} Express middleware
 */
const validateQuery = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.query, {
    abortEarly: false,
    stripUnknown: true,
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'Tham số truy vấn không hợp lệ',
      errors: errorMessages,
    });
  }

  next();
};

// Schema mẫu cho sản phẩm (giữ lại từ file gốc)
const productSchema = Joi.object({
  name: Joi.string().min(3).max(100).required(),
  price: Joi.number().min(0).required(),
  description: Joi.string().max(500).required(),
});

/**
 * Middleware xác thực dữ liệu sản phẩm (giữ lại từ file gốc để tương thích ngược)
 * @deprecated Sử dụng hàm validate với schema tương ứng thay thế
 */
const validateProduct = (req, res, next) => {
  const { error } = productSchema.validate(req.body);
  if (error) {
    return res.status(400).json({
      success: false,
      error: error.details[0].message,
    });
  }
  next();
};

/**
 * Các helpers hữu ích cho xác thực dữ liệu
 */
const validationHelpers = {
  /**
   * Tạo một custom validator để xác thực mật khẩu mạnh
   */
  strongPassword: () =>
    Joi.string()
      .min(8)
      .max(30)
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .message(
        'Mật khẩu phải có ít nhất 8 ký tự, bao gồm chữ hoa, chữ thường, số và ký tự đặc biệt'
      ),

  /**
   * Tạo custom validator cho số điện thoại Việt Nam
   */
  vietnamesePhone: () =>
    Joi.string()
      .pattern(/^(0|\+84)([0-9]{9,10})$/)
      .message('Số điện thoại không hợp lệ, phải là số điện thoại Việt Nam'),
};

module.exports = {
  validateMongoId,
  validate,
  validateQuery,
  validateProduct, // Giữ lại để tương thích ngược
  validationHelpers,
};


--- File: api/routes/authRoutes.js ---
/**
 * Routes cho quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 * @typedef {(req: Request, res: Response, next: NextFunction) => any} ExpressMiddleware
 */

const express = require('express');
const userController = require('../controllers/userController');
const { authenticate, restrictTo } = require('../../api/middleware/authMiddleware'); // Cập nhật đường dẫn từ auth thành authMiddleware
const { validateMongoId, validate } = require('../../api/middleware/validationMiddleware');
const userValidator = require('../../common/validators/userValidator');

/**
 * @type {express.Router}
 */
const router = express.Router();

/**
 * @route   POST /api/users
 * @desc    Tạo người dùng mới (chỉ admin)
 * @access  Private/Admin
 */
router.post(
  '/',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (validate(userValidator.adminCreateUser)),
  /** @type {ExpressMiddleware} */ (userController.createUser)
);

/**
 * @route   GET /api/users
 * @desc    Lấy danh sách người dùng (chỉ admin)
 * @access  Private/Admin
 */
router.get(
  '/',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (userController.getUsers)
);

/**
 * @route   GET /api/users/:id
 * @desc    Lấy thông tin người dùng theo ID
 * @access  Private
 */
router.get(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (userController.getUserById)
);

/**
 * @route   PUT /api/users/:id
 * @desc    Cập nhật thông tin người dùng
 * @access  Private
 */
router.put(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (validate(userValidator.updateProfile)),
  /** @type {ExpressMiddleware} */ (userController.updateUser)
);

/**
 * @route   DELETE /api/users/:id
 * @desc    Xóa người dùng (chỉ admin)
 * @access  Private/Admin
 */
router.delete(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (userController.deleteUser)
);

/**
 * @route   GET /api/users/profile/me
 * @desc    Lấy thông tin người dùng hiện tại
 * @access  Private
 */
router.get(
  '/profile/me',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (userController.getProfile)
);

/**
 * @route   PUT /api/users/change-password
 * @desc    Thay đổi mật khẩu
 * @access  Private
 */
router.put(
  '/change-password',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validate(userValidator.changePassword)),
  /** @type {ExpressMiddleware} */ (userController.changePassword)
);

module.exports = router;


--- File: api/routes/cartRoutes.js ---
/**
 * Cart Routes
 * Định nghĩa các routes liên quan đến giỏ hàng
 */

const express = require('express');
const router = express.Router();
const cartController = require('../controllers/cartController');
const validate = require('../../common/middleware/validate');
const cartValidator = require('../../common/validators/cartValidator');
const { authenticate } = require('../middleware/authMiddleware');

// Routes không cần xác thực (có thể sử dụng cả khi đăng nhập và chưa đăng nhập)
router.get('/mycart', cartController.getMyCart);

router.post('/items', validate(cartValidator.addItemValidator), cartController.addItemToCart);

router.patch(
  '/items/:itemId',
  validate(cartValidator.updateItemValidator),
  cartController.updateCartItem
);

router.delete('/items/:itemId', cartController.removeCartItem);

router.delete('/mycart', cartController.clearCart);

router.post(
  '/apply-coupon',
  validate(cartValidator.applyCouponValidator),
  cartController.applyCoupon
);

router.delete('/remove-coupon', cartController.removeCoupon);

// Routes đòi hỏi xác thực
router.post(
  '/merge',
  authenticate(),
  validate(cartValidator.mergeCartsValidator),
  cartController.mergeCart
);

module.exports = router;


--- File: api/routes/categoryRoutes.js ---
/**
 * Review Controller
 * Xử lý các request liên quan đến đánh giá sản phẩm
 */

const catchAsync = require('../../common/utils/catchAsync');
const responseHandler = require('../../common/utils/responseHandler');
const reviewService = require('../../services/review/reviewService');

/**
 * Lấy tất cả đánh giá (có phân trang, lọc)
 * @route GET /api/reviews
 * @access Public
 */
const getAllReviews = catchAsync(async (req, res) => {
  const features = req.query;
  const reviews = await reviewService.getAllReviews(features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy đánh giá theo ID
 * @route GET /api/reviews/:id
 * @access Public
 */
const getReviewById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const review = await reviewService.getReviewById(id);
  return responseHandler.success(res, review);
});

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @route GET /api/products/:productId/reviews
 * @access Public
 */
const getProductReviews = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const features = req.query;
  const reviews = await reviewService.getProductReviews(productId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy tất cả đánh giá của một người dùng
 * @route GET /api/users/:userId/reviews
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const getUserReviews = catchAsync(async (req, res) => {
  const { userId } = req.params;

  // Kiểm tra quyền truy cập
  const requestUserId = req.user.id;
  const isAdmin = req.user.role === 'admin';

  if (userId !== requestUserId && !isAdmin) {
    return responseHandler.forbidden(res, 'Bạn không có quyền xem đánh giá của người dùng khác');
  }

  const features = req.query;
  const reviews = await reviewService.getUserReviews(userId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Tạo đánh giá mới
 * @route POST /api/products/:productId/reviews
 * @access Private
 */
const createReview = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const userId = req.user.id;
  const reviewData = req.body;

  const newReview = await reviewService.createReview(productId, userId, reviewData);
  return responseHandler.created(res, newReview);
});

/**
 * Cập nhật đánh giá
 * @route PUT /api/reviews/:id
 * @access Private (Người dùng sở hữu đánh giá)
 */
const updateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const reviewData = req.body;

  const updatedReview = await reviewService.updateReview(id, userId, reviewData, isAdmin);
  return responseHandler.success(res, updatedReview);
});

/**
 * Xóa đánh giá
 * @route DELETE /api/reviews/:id
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const deleteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';

  await reviewService.deleteReview(id, userId, isAdmin);
  return responseHandler.success(res, { message: 'Đánh giá đã được xóa thành công' });
});

/**
 * Upvote hoặc downvote đánh giá
 * @route POST /api/reviews/:id/vote
 * @access Private
 */
const voteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { vote } = req.body; // 1 for upvote, -1 for downvote

  const updatedReview = await reviewService.voteReview(id, userId, vote);
  return responseHandler.success(res, updatedReview);
});

/**
 * Kiểm duyệt đánh giá (duyệt hoặc từ chối)
 * @route PATCH /api/reviews/:id/moderate
 * @access Private (Admin only)
 */
const moderateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const adminId = req.user.id;
  const { action, reason } = req.body; // 'approve' or 'reject'

  const moderatedReview = await reviewService.moderateReview(id, action, reason, adminId);
  return responseHandler.success(res, moderatedReview);
});

/**
 * Báo cáo đánh giá
 * @route POST /api/reviews/:id/report
 * @access Private
 */
const reportReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { reason, description } = req.body;

  const reportedReview = await reviewService.reportReview(id, userId, reason, description);
  return responseHandler.success(res, reportedReview);
});

/**
 * Thêm phản hồi cho đánh giá
 * @route POST /api/reviews/:id/responses
 * @access Private (Admin hoặc người dùng sở hữu sản phẩm)
 */
const addReviewResponse = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { content } = req.body;

  const updatedReview = await reviewService.addReviewResponse(id, userId, content, isAdmin);
  return responseHandler.success(res, updatedReview);
});

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse,
};


--- File: api/routes/orderRoutes.js ---
/**
 * Review Controller
 * Xử lý các request liên quan đến đánh giá sản phẩm
 */

const catchAsync = require('../../common/utils/catchAsync');
const responseHandler = require('../../common/utils/responseHandler');
const reviewService = require('../../services/review/reviewService');

/**
 * Lấy tất cả đánh giá (có phân trang, lọc)
 * @route GET /api/reviews
 * @access Public
 */
const getAllReviews = catchAsync(async (req, res) => {
  const features = req.query;
  const reviews = await reviewService.getAllReviews(features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy đánh giá theo ID
 * @route GET /api/reviews/:id
 * @access Public
 */
const getReviewById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const review = await reviewService.getReviewById(id);
  return responseHandler.success(res, review);
});

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @route GET /api/products/:productId/reviews
 * @access Public
 */
const getProductReviews = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const features = req.query;
  const reviews = await reviewService.getProductReviews(productId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy tất cả đánh giá của một người dùng
 * @route GET /api/users/:userId/reviews
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const getUserReviews = catchAsync(async (req, res) => {
  const { userId } = req.params;

  // Kiểm tra quyền truy cập
  const requestUserId = req.user.id;
  const isAdmin = req.user.role === 'admin';

  if (userId !== requestUserId && !isAdmin) {
    return responseHandler.forbidden(res, 'Bạn không có quyền xem đánh giá của người dùng khác');
  }

  const features = req.query;
  const reviews = await reviewService.getUserReviews(userId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Tạo đánh giá mới
 * @route POST /api/products/:productId/reviews
 * @access Private
 */
const createReview = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const userId = req.user.id;
  const reviewData = req.body;

  const newReview = await reviewService.createReview(productId, userId, reviewData);
  return responseHandler.created(res, newReview);
});

/**
 * Cập nhật đánh giá
 * @route PUT /api/reviews/:id
 * @access Private (Người dùng sở hữu đánh giá)
 */
const updateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const reviewData = req.body;

  const updatedReview = await reviewService.updateReview(id, userId, reviewData, isAdmin);
  return responseHandler.success(res, updatedReview);
});

/**
 * Xóa đánh giá
 * @route DELETE /api/reviews/:id
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const deleteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';

  await reviewService.deleteReview(id, userId, isAdmin);
  return responseHandler.success(res, { message: 'Đánh giá đã được xóa thành công' });
});

/**
 * Upvote hoặc downvote đánh giá
 * @route POST /api/reviews/:id/vote
 * @access Private
 */
const voteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { vote } = req.body; // 1 for upvote, -1 for downvote

  const updatedReview = await reviewService.voteReview(id, userId, vote);
  return responseHandler.success(res, updatedReview);
});

/**
 * Kiểm duyệt đánh giá (duyệt hoặc từ chối)
 * @route PATCH /api/reviews/:id/moderate
 * @access Private (Admin only)
 */
const moderateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const adminId = req.user.id;
  const { action, reason } = req.body; // 'approve' or 'reject'

  const moderatedReview = await reviewService.moderateReview(id, action, reason, adminId);
  return responseHandler.success(res, moderatedReview);
});

/**
 * Báo cáo đánh giá
 * @route POST /api/reviews/:id/report
 * @access Private
 */
const reportReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { reason, description } = req.body;

  const reportedReview = await reviewService.reportReview(id, userId, reason, description);
  return responseHandler.success(res, reportedReview);
});

/**
 * Thêm phản hồi cho đánh giá
 * @route POST /api/reviews/:id/responses
 * @access Private (Admin hoặc người dùng sở hữu sản phẩm)
 */
const addReviewResponse = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { content } = req.body;

  const updatedReview = await reviewService.addReviewResponse(id, userId, content, isAdmin);
  return responseHandler.success(res, updatedReview);
});

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse,
};


--- File: api/routes/productRoutes.js ---
/**
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 */

const express = require('express');
const router = express.Router();
const productController = require('../controllers/productController');
const authMiddleware = require('../middleware/authMiddleware');

// Kiểm tra xem controller và middleware có tồn tại không
if (!productController) {
  throw new Error('productController không tồn tại');
}

if (!authMiddleware || !authMiddleware.authenticate || !authMiddleware.restrictTo) {
  throw new Error('authMiddleware không tồn tại hoặc thiếu các phương thức cần thiết');
}

// Kiểm tra từng phương thức controller
Object.entries(productController).forEach(([key, value]) => {
  if (typeof value !== 'function') {
    console.warn(`Cảnh báo: productController.${key} không phải là function`);
  }
});

// Routes công khai - các routes cụ thể đặt trước
router.get('/', productController.getProducts);
router.get('/trending', productController.getTrendingProducts);
router.get('/new', productController.getNewProducts);
router.get('/sale', productController.getSaleProducts);
router.get('/search', productController.searchProducts);
router.get('/by-slug/:slug', productController.getProductBySlug);
router.get('/category/:categoryId', productController.getProductsByCategory);

// Routes Admin - đặt route /stats trước route /:id
// Kiểm tra cách sử dụng middleware
router.get(
  '/stats',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.getProductStats
);

// Routes liên quan đến ID cụ thể - đặt routes chi tiết trước
router.get('/:id/related', productController.getRelatedProducts);
router.post('/:id/view', productController.incrementProductView);

// Route lấy chi tiết sản phẩm theo ID - đặt sau các routes cụ thể hơn
router.get('/:id', productController.getProductById);

// Routes Admin cho các thao tác với sản phẩm cụ thể
router.post(
  '/',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.createProduct
);
router.put(
  '/:id',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.updateProduct
);
router.delete(
  '/:id',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.deleteProduct
);
router.patch(
  '/:id/stock',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.updateStock
);
router.patch(
  '/:id/status',
  authMiddleware.authenticate,
  authMiddleware.restrictTo('admin'),
  productController.updateStatus
);

module.exports = router;


--- File: api/routes/reviewRoutes.js ---
/**
 * Review Routes
 * Định nghĩa các routes liên quan đến đánh giá sản phẩm
 */

const express = require('express');
const router = express.Router({ mergeParams: true }); // Cho phép truy cập params từ parent router
const reviewController = require('../controllers/reviewController');
const { validate } = require('../../common/middleware/validate');
const { reviewValidator } = require('../../common/validators/reviewValidator');
const { authMiddleware } = require('../middleware/authMiddleware');

// Routes công khai cho việc đọc đánh giá
router.get('/', reviewController.getAllReviews);
router.get('/:id', reviewController.getReviewById);

// Routes cần xác thực
router.use(authMiddleware.authenticate);

// Đánh giá hay upvote, downvote một đánh giá
router.post('/:id/vote', validate(reviewValidator.voteReview), reviewController.voteReview);

// Báo cáo một đánh giá không phù hợp
router.post('/:id/report', validate(reviewValidator.reportReview), reviewController.reportReview);

// Thêm phản hồi cho đánh giá
router.post(
  '/:id/responses',
  validate(reviewValidator.addReviewResponse),
  reviewController.addReviewResponse
);

// Cập nhật hoặc xóa đánh giá (người dùng chỉ có thể chỉnh sửa/xóa đánh giá của chính họ)
router.put('/:id', validate(reviewValidator.updateReview), reviewController.updateReview);

router.delete('/:id', reviewController.deleteReview);

// Routes chỉ dành cho admin
router.patch(
  '/:id/moderate',
  authMiddleware.restrictTo('admin'),
  validate(reviewValidator.moderateReview),
  reviewController.moderateReview
);

module.exports = router;


--- File: api/routes/userRoutes.js ---
/**
 * Routes cho quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 * @typedef {(req: Request, res: Response, next: NextFunction) => any} ExpressMiddleware
 */

const express = require('express');
const userController = require('../controllers/userController');
const { authenticate, restrictTo } = require('../../api/middleware/authMiddleware'); // Cập nhật từ auth thành authMiddleware
const { validateMongoId, validate } = require('../../api/middleware/validationMiddleware');
const userValidator = require('../../common/validators/userValidator');

/**
 * @type {express.Router}
 */
const router = express.Router();

/**
 * @route   POST /api/users
 * @desc    Tạo người dùng mới (chỉ admin)
 * @access  Private/Admin
 */
router.post(
  '/',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (validate(userValidator.createUser)),
  /** @type {ExpressMiddleware} */ (userController.createUser)
);

/**
 * @route   GET /api/users
 * @desc    Lấy danh sách người dùng (chỉ admin)
 * @access  Private/Admin
 */
router.get(
  '/',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (userController.getUsers)
);

/**
 * @route   GET /api/users/:id
 * @desc    Lấy thông tin người dùng theo ID
 * @access  Private
 */
router.get(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (userController.getUserById)
);

/**
 * @route   PUT /api/users/:id
 * @desc    Cập nhật thông tin người dùng
 * @access  Private
 */
router.put(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (validate(userValidator.updateUser)),
  /** @type {ExpressMiddleware} */ (userController.updateUser)
);

/**
 * @route   DELETE /api/users/:id
 * @desc    Xóa người dùng (chỉ admin)
 * @access  Private/Admin
 */
router.delete(
  '/:id',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (restrictTo('admin')),
  /** @type {ExpressMiddleware} */ (validateMongoId()),
  /** @type {ExpressMiddleware} */ (userController.deleteUser)
);

/**
 * @route   GET /api/users/profile/me
 * @desc    Lấy thông tin người dùng hiện tại
 * @access  Private
 */
router.get(
  '/profile/me',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (userController.getProfile)
);

/**
 * @route   PUT /api/users/change-password
 * @desc    Thay đổi mật khẩu
 * @access  Private
 */
router.put(
  '/change-password',
  /** @type {ExpressMiddleware} */ (authenticate),
  /** @type {ExpressMiddleware} */ (validate(userValidator.changePassword)),
  /** @type {ExpressMiddleware} */ (userController.changePassword)
);

module.exports = router;


--- File: app.js ---
/**
 * Tệp cấu hình Express chính cho ứng dụng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const dotenv = require('dotenv');
const path = require('path');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');

const { connectToDatabase } = require('./config/database');
const config = require('./config/environment');
const logger = require('./config/logger');

// Routes
const productRoutes = require('./api/routes/productRoutes');
const authRoutes = require('./api/routes/authRoutes');
const userRoutes = require('./api/routes/userRoutes');
// const bookingRoutes = require('./api/routes/bookingRoutes');
// const paymentRoutes = require('./api/routes/paymentRoutes');

// Middleware
const { loggingMiddleware } = require('./api/middleware/loggingMiddleware');
const { errorHandler } = require('./api/middleware/errorMiddleware');
// Sửa cách import authMiddleware - không cần import ở đây vì đã import trong routes

// Khởi tạo app Express
const app = express();

// Cấu hình biến môi trường
dotenv.config();

// Kết nối đến cơ sở dữ liệu
connectToDatabase();

// Cấu hình bảo mật
app.use(helmet()); // Thiết lập các HTTP header bảo mật
app.use(mongoSanitize()); // Bảo vệ khỏi SQL injection
app.use(xss()); // Bảo vệ khỏi XSS attacks
app.use(hpp({ whitelist: ['price', 'date', 'rating'] })); // Bảo vệ khỏi HTTP Parameter Pollution

// Rate limiting để chống DDOS và brute force
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 phút
  max: 100, // 100 yêu cầu mỗi IP
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Quá nhiều yêu cầu từ IP này, vui lòng thử lại sau 15 phút',
});

// Áp dụng rate limiting cho tất cả các request API
app.use('/api', limiter);

// CORS config từ biến môi trường
app.use(
  cors({
    origin: config.cors.origin.split(','),
    methods: config.cors.methods,
    credentials: true,
    optionsSuccessStatus: 204,
  })
);

// Middleware nén response
app.use(compression());

// Body parsers
app.use(express.json({ limit: '10kb' })); // Giới hạn kích thước body
app.use(express.urlencoded({ extended: true, limit: '10kb' }));
app.use(cookieParser()); // Xử lý cookies

// Ghi log cho requests trong môi trường phát triển
if (config.app.environment === 'development') {
  app.use(morgan('dev'));
}

// Middleware ghi log tùy chỉnh
app.use(loggingMiddleware);

// Thư mục tĩnh cho uploads và tài nguyên công khai
app.use('/uploads', express.static(path.join(__dirname, '..', config.paths.uploads)));
app.use(express.static(path.join(__dirname, '..', 'public')));

// Routes API
app.use('/api/products', productRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes); // Không cần thêm middleware ở đây vì đã có trong routes
// app.use('/api/bookings', bookingRoutes);
// app.use('/api/payments', paymentRoutes);

// Route sức khỏe hệ thống
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'Hệ thống đang hoạt động',
    environment: config.app.environment,
    timestamp: new Date().toISOString(),
  });
});

// Route trang chủ API
app.get('/', (req, res) => {
  res.json({
    message: 'Chào mừng đến với API RunOut-Biliard!',
    version: '1.0.0',
    docs: '/api/docs',
  });
});

// API Documentation route
app.get('/api/docs', (req, res) => {
  res.redirect('/api-docs'); // Chuyển hướng đến Swagger hoặc trang tài liệu
});

// Xử lý route không tìm thấy
app.all('*', (req, res, next) => {
  const err = new Error(`Không thể tìm thấy ${req.originalUrl} trên server này!`);
  err.status = 'fail';
  err.statusCode = 404;
  next(err);
});

// Middleware xử lý lỗi toàn cục
app.use(errorHandler);

// Xử lý sự kiện process
process.on('SIGTERM', () => {
  logger.info('SIGTERM nhận được. Đang chuẩn bị đóng ứng dụng Express...');
});

// Export app cho server.js sử dụng
module.exports = app;


--- File: common/errors/apiError.js ---
/**
 * Lớp ApiError mở rộng từ Error để xử lý các lỗi API với mã trạng thái
 * @extends Error
 */
class ApiError extends Error {
  /**
   * Tạo một ApiError
   * @param {number} statusCode - Mã trạng thái HTTP
   * @param {string} message - Thông báo lỗi
   * @param {object} [errors] - Các lỗi chi tiết (tùy chọn)
   */
  constructor(statusCode, message, errors = {}) {
    super(message);
    this.statusCode = statusCode;
    this.errors = errors;
    this.name = this.constructor.name;

    // Ghi lại stack trace
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Chuyển đổi lỗi thành định dạng JSON
   * @returns {object} - Đối tượng lỗi dạng JSON
   */
  toJSON() {
    return {
      status: 'error',
      statusCode: this.statusCode,
      message: this.message,
      errors: Object.keys(this.errors).length > 0 ? this.errors : undefined,
    };
  }

  /**
   * Tạo một lỗi BadRequest (400)
   * @param {string} message - Thông báo lỗi
   * @param {object} [errors] - Các lỗi chi tiết (tùy chọn)
   * @returns {ApiError} - Lỗi BadRequest
   */
  static badRequest(message = 'Bad Request', errors = {}) {
    return new ApiError(400, message, errors);
  }

  /**
   * Tạo một lỗi Unauthorized (401)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Unauthorized
   */
  static unauthorized(message = 'Unauthorized') {
    return new ApiError(401, message);
  }

  /**
   * Tạo một lỗi Forbidden (403)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Forbidden
   */
  static forbidden(message = 'Forbidden') {
    return new ApiError(403, message);
  }

  /**
   * Tạo một lỗi NotFound (404)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi NotFound
   */
  static notFound(message = 'Resource not found') {
    return new ApiError(404, message);
  }

  /**
   * Tạo một lỗi Conflict (409)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Conflict
   */
  static conflict(message = 'Resource already exists') {
    return new ApiError(409, message);
  }

  /**
   * Tạo một lỗi InternalServer (500)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi InternalServer
   */
  static internal(message = 'Internal Server Error') {
    return new ApiError(500, message);
  }
}

module.exports = ApiError;


--- File: common/middleware/errorHandler.js ---
const ApiError = require('../errors/apiError');
const logger = require('../../config/logger');

/**
 * Middleware xử lý lỗi toàn cục
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // Nếu lỗi không phải là instance của ApiError, chuyển đổi thành ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Something went wrong';
    error = new ApiError(statusCode, message, false, err.stack);
  }

  // Ghi log lỗi
  if (error.statusCode >= 500) {
    logger.error(error);
  } else {
    logger.warn(`${error.statusCode} - ${error.message}`);
  }

  // Phản hồi cho client
  const response = {
    status: error.status,
    message: error.message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack }),
  };

  // Thêm errors vào response nếu là ValidationError
  if (error.errors) {
    response.errors = error.errors;
  }

  res.status(error.statusCode).json(response);
  next();
};

module.exports = errorHandler;


--- File: common/middleware/rateLimiter.js ---
const rateLimit = require('express-rate-limit');
const BusinessError = require('../errors/apiError');

/**
 * Middleware giới hạn số request trong một khoảng thời gian
 * @param {Object} options - Tùy chọn cấu hình
 */
const rateLimiter = (options = {}) => {
  const defaultOptions = {
    windowMs: 15 * 60 * 1000, // 15 phút
    max: 100, // Giới hạn 100 request mỗi IP trong 15 phút
    message: 'Too many requests from this IP, please try again later',
  };

  const limiterOptions = { ...defaultOptions, ...options };

  return rateLimit({
    windowMs: limiterOptions.windowMs,
    max: limiterOptions.max,
    handler: (req, res, next) => {
      next(new BusinessError(limiterOptions.message, 429));
    },
  });
};

module.exports = rateLimiter;


--- File: common/middleware/requestLogger.js ---
const logger = require('../../config/logger');

/**
 * Middleware ghi log request và response
 */
const requestLogger = (req, res, next) => {
  // Lưu thời gian bắt đầu request
  req.startTime = Date.now();

  // Ghi log request
  logger.info({
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userId: req.user ? req.user.id : 'anonymous',
  });

  // Bắt sự kiện 'finish' để ghi log sau khi request hoàn thành
  res.on('finish', () => {
    const duration = Date.now() - req.startTime;
    logger.info({
      method: req.method,
      url: req.originalUrl,
      status: res.statusCode,
      duration: `${duration}ms`,
    });
  });

  next();
};

module.exports = requestLogger;


--- File: common/middleware/validate.js ---
const { ValidationError } = require('../errors/apiError');

/**
 * Middleware validation dựa trên schema
 * @param {Object} schema - Joi schema hoặc validation schema
 * @param {String} source - Nguồn dữ liệu cần validate ('body', 'query', 'params')
 */
const validate = (schema, source = 'body') => {
  return (req, res, next) => {
    const data = req[source];
    const { error, value } = schema.validate(data, { abortEarly: false });

    if (error) {
      const validationErrors = {};

      error.details.forEach((detail) => {
        const path = detail.path.join('.');
        validationErrors[path] = detail.message;
      });

      return next(new ValidationError('Validation failed', validationErrors));
    }

    // Gán lại dữ liệu đã được validate vào request
    req[source] = value;
    return next();
  };
};

module.exports = validate;


--- File: common/readme.md ---
```
server/
└── src/
    └── common/                    # Shared code dùng chung trong toàn bộ ứng dụng
        ├── errors/                # Custom error classes
        │   ├── apiError.js             # Class định nghĩa các loại lỗi API chung
        │   ├── authError.js            # Lỗi liên quan đến xác thực
        │   ├── validationError.js      # Lỗi liên quan đến validation
        │   ├── notFoundError.js        # Lỗi khi không tìm thấy tài nguyên
        │   ├── forbiddenError.js       # Lỗi về quyền truy cập
        │   └── businessError.js        # Lỗi liên quan đến business logic
        │
        ├── middleware/            # Middleware dùng chung
        │   ├── errorHandler.js         # Middleware xử lý lỗi chung
        │   ├── validate.js             # Middleware validation chung
        │   ├── requestLogger.js        # Middleware ghi log request/response
        │   └── rateLimiter.js          # Giới hạn số request trong một khoảng thời gian
        │
        ├── types/                 # Type definitions và interfaces
        │   ├── express.d.ts            # Type definitions mở rộng cho Express
        │   ├── auth.types.js           # Types liên quan đến authentication
        │   ├── product.types.js        # Types liên quan đến product
        │   ├── order.types.js          # Types liên quan đến order
        │   └── common.types.js         # Types dùng chung
        │
        ├── utils/                 # Các utility functions dùng trong nhiều modules
        │   ├── apiFeatures.js          # Xử lý filtering, sorting, pagination
        │   ├── catchAsync.js           # Wrapper function để xử lý async errors
        │   ├── responseHandler.js      # Format response trả về từ API
        │   ├── validatorUtils.js       # Các helper functions cho validation
        │   ├── dateUtils.js            # Các utility function xử lý datetime
        │   ├── fileUtils.js            # Xử lý file upload, manipulation
        │   ├── securityUtils.js        # Các utility cho hash, token, encrypt
        │   └── formatters.js           # Các hàm format data (currency, phone, etc.)
        │
        └── validators/            # Định nghĩa validation schema và rules
            ├── authValidator.js        # Validation rules cho auth requests
            ├── userValidator.js        # Validation rules cho user requests
            ├── productValidator.js     # Validation rules cho product requests
            ├── categoryValidator.js    # Validation rules cho category requests
            ├── orderValidator.js       # Validation rules cho order requests
            ├── cartValidator.js        # Validation rules cho cart requests
            ├── reviewValidator.js      # Validation rules cho review requests
            └── commonValidator.js      # Validation rules dùng chung

        └── readme.md                 # README file for common package

```
1. errors/
Thư mục này chứa các class định nghĩa lỗi tùy chỉnh để xử lý lỗi một cách nhất quán trong toàn bộ ứng dụng.

apiError.js: Class cơ sở cho tất cả các loại lỗi API. Định nghĩa cấu trúc lỗi với statusCode, message, và các thông tin bổ sung.
authError.js: Lỗi xác thực như token không hợp lệ, hết hạn, không có quyền, v.v.
validationError.js: Lỗi xảy ra khi dữ liệu đầu vào không đạt yêu cầu validation.
notFoundError.js: Lỗi khi tài nguyên không tồn tại (404).
forbiddenError.js: Lỗi khi người dùng không có quyền truy cập tài nguyên (403).
businessError.js: Lỗi liên quan đến logic nghiệp vụ, ví dụ: sản phẩm hết hàng, đơn hàng đã bị hủy, v.v.

2. middleware/
Chứa các middleware dùng chung có thể áp dụng ở nhiều nơi trong ứng dụng.

errorHandler.js: Middleware xử lý tất cả các lỗi, chuyển đổi chúng thành response chuẩn.
validate.js: Middleware xác thực dữ liệu đầu vào dựa trên schema được định nghĩa.
requestLogger.js: Ghi log tất cả các requests và responses để debugging và monitoring.
rateLimiter.js: Giới hạn số lượng request trong một khoảng thời gian để ngăn chặn DoS.

3. types/
Định nghĩa các kiểu dữ liệu và interfaces để đảm bảo tính nhất quán trong toàn bộ ứng dụng.

express.d.ts: Mở rộng kiểu dữ liệu cho Express, ví dụ: thêm thuộc tính user vào Request.
auth.types.js: Định nghĩa các kiểu liên quan đến xác thực như UserRole, TokenPayload.
product.types.js: Định nghĩa các kiểu dữ liệu cho sản phẩm như ProductStatus, ProductVariant.
order.types.js: Định nghĩa các kiểu dữ liệu cho đơn hàng như OrderStatus, PaymentStatus.
common.types.js: Các kiểu dữ liệu dùng chung như PaginationParams, SortDirection.

4. utils/
Các hàm tiện ích dùng chung trong ứng dụng.

apiFeatures.js: Xử lý các tính năng API như filtering, sorting, pagination một cách nhất quán.
catchAsync.js: Wrapper function để bắt lỗi trong các hàm async mà không cần try/catch lặp lại.
responseHandler.js: Chuẩn hóa cấu trúc response từ API (success, error, data, message).
validatorUtils.js: Các hàm hỗ trợ cho validation như isValidEmail, isStrongPassword.
dateUtils.js: Xử lý các operations liên quan đến datetime như format, compare, diff.
fileUtils.js: Xử lý file upload, manipulation, validation.
securityUtils.js: Các hàm liên quan đến bảo mật như hash password, generate token.
formatters.js: Định dạng data như formatCurrency, formatPhoneNumber, formatAddress.

5. validators/
Chứa các schema và rules validation cho dữ liệu đầu vào.

authValidator.js: Validation cho request đăng nhập, đăng ký, đặt lại mật khẩu.
userValidator.js: Validation cho thông tin người dùng, cập nhật profile.
productValidator.js: Validation cho thông tin sản phẩm, thêm/sửa sản phẩm.
categoryValidator.js: Validation cho thông tin danh mục.
orderValidator.js: Validation cho thông tin đơn hàng, cập nhật trạng thái.
cartValidator.js: Validation cho thông tin giỏ hàng, thêm/sửa sản phẩm trong giỏ.
reviewValidator.js: Validation cho đánh giá sản phẩm.
commonValidator.js: Các rules validation dùng chung như validateObjectId, validatePagination.
```


--- File: common/types/auth.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến authentication
 */

// Enum vai trò người dùng
const UserRole = {
  ADMIN: 'admin',
  STAFF: 'staff',
  USER: 'user',
};

// Cấu trúc payload trong JWT token
const TokenPayload = {
  id: String, // ID người dùng
  email: String, // Email người dùng
  role: String, // Vai trò người dùng
  iat: Number, // Issued at - thời điểm token được tạo
  exp: Number, // Expiration - thời điểm token hết hạn
};

// Cấu trúc response khi đăng nhập
const AuthResponse = {
  user: Object, // Thông tin người dùng
  token: String, // Access token
  refreshToken: String, // Refresh token
};

module.exports = {
  UserRole,
  TokenPayload,
  AuthResponse,
};


--- File: common/types/common.types.js ---
/**
 * Các kiểu dữ liệu dùng chung trong ứng dụng
 */

// Tham số phân trang
const PaginationParams = {
  page: Number, // Trang hiện tại
  limit: Number, // Số lượng item mỗi trang
  total: Number, // Tổng số item
  totalPages: Number, // Tổng số trang
};

// Hướng sắp xếp
const SortDirection = {
  ASC: 'asc',
  DESC: 'desc',
};

// Điều kiện lọc
const FilterOperator = {
  EQ: 'eq', // Bằng
  NE: 'ne', // Không bằng
  GT: 'gt', // Lớn hơn
  GTE: 'gte', // Lớn hơn hoặc bằng
  LT: 'lt', // Nhỏ hơn
  LTE: 'lte', // Nhỏ hơn hoặc bằng
  IN: 'in', // Trong tập giá trị
  NIN: 'nin', // Không trong tập giá trị
  REGEX: 'regex', // Khớp với biểu thức chính quy
};

module.exports = {
  PaginationParams,
  SortDirection,
  FilterOperator,
};


--- File: common/types/express.d.ts ---
// Mở rộng kiểu Request từ Express
declare namespace Express {
    export interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
        permissions?: string[];
      };
      startTime?: number;
      correlationId?: string;
    }
  }

--- File: common/types/order.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến đơn hàng
 */

// Enum trạng thái đơn hàng
const OrderStatus = {
  PENDING: 'pending', // Chờ xác nhận
  PROCESSING: 'processing', // Đang xử lý
  PACKED: 'packed', // Đã đóng gói
  SHIPPED: 'shipped', // Đang giao hàng
  DELIVERED: 'delivered', // Đã giao hàng
  CANCELLED: 'cancelled', // Đã hủy
  RETURNED: 'returned', // Đã trả hàng
};

// Enum trạng thái thanh toán
const PaymentStatus = {
  PENDING: 'pending', // Chờ thanh toán
  AUTHORIZED: 'authorized', // Đã ủy quyền
  PAID: 'paid', // Đã thanh toán
  FAILED: 'failed', // Thanh toán thất bại
  REFUNDED: 'refunded', // Đã hoàn tiền
  PARTIALLY_REFUNDED: 'partially_refunded', // Hoàn tiền một phần
};

// Enum phương thức thanh toán
const PaymentMethod = {
  COD: 'cod', // Thanh toán khi nhận hàng
  CREDIT_CARD: 'credit_card', // Thẻ tín dụng
  VNPAY: 'vnpay', // VNPay
  BANK_TRANSFER: 'bank_transfer', // Chuyển khoản ngân hàng
  MOMO: 'momo', // Ví MoMo
};

module.exports = {
  OrderStatus,
  PaymentStatus,
  PaymentMethod,
};


--- File: common/types/product.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến sản phẩm
 */

// Enum trạng thái sản phẩm
const ProductStatus = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  OUT_OF_STOCK: 'out_of_stock',
  COMING_SOON: 'coming_soon',
  DISCONTINUED: 'discontinued',
};

// Enum loại sản phẩm
const ProductType = {
  CUE: 'cue', // Gậy billiard
  BALL: 'ball', // Bi
  ACCESSORIES: 'accessories', // Phụ kiện
  TABLE: 'table', // Bàn billiard
  CHALK: 'chalk', // Phấn
};

module.exports = {
  ProductStatus,
  ProductType,
};


--- File: common/utils/apiFeatures.js ---
/**
 * Class xử lý các tính năng API như filtering, sorting, pagination
 */
class APIFeatures {
  /**
   * @param {Object} query - Mongoose query object
   * @param {Object} queryString - Query string từ Express request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * Filter query dựa trên các tham số
   * Hỗ trợ các operators: gt, gte, lt, lte, in
   */
  filter() {
    const queryObj = { ...this.queryString };
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'q', 'populate'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // Advanced filtering với gte, gt, lte, lt
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in)\b/g, (match) => `$${match}`);

    this.query = this.query.find(JSON.parse(queryStr));
    return this;
  }

  /**
   * Sắp xếp kết quả
   * Format: sort=field,direction (ví dụ: sort=price,-createdAt)
   */
  sort() {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // Default sort theo createdAt giảm dần (mới nhất trước)
      this.query = this.query.sort('-createdAt');
    }
    return this;
  }

  /**
   * Giới hạn các trường được trả về
   * Format: fields=field1,field2,-field3
   */
  limitFields() {
    if (this.queryString.fields) {
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // Mặc định bỏ trường __v
      this.query = this.query.select('-__v');
    }
    return this;
  }

  /**
   * Phân trang kết quả
   * page: Số trang (default: 1)
   * limit: Số items mỗi trang (default: 10)
   */
  paginate() {
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    this.query = this.query.skip(skip).limit(limit);
    return this;
  }

  /**
   * Populate các trường reference
   * Format: populate=field1,field2
   */
  populate() {
    if (this.queryString.populate) {
      const fields = this.queryString.populate.split(',');
      fields.forEach((field) => {
        this.query = this.query.populate(field);
      });
    }
    return this;
  }

  /**
   * Search dựa trên text index
   * Format: q=search term
   */
  search() {
    if (this.queryString.q) {
      this.query = this.query.find({ $text: { $search: this.queryString.q } });
    }
    return this;
  }
}

module.exports = APIFeatures;


--- File: common/utils/catchAsync.js ---
/**
 * Wrapper function để bắt lỗi trong các hàm async
 * Tránh việc phải sử dụng try/catch nhiều lần
 *
 * @param {Function} fn - Async function cần bọc
 * @returns {Function} Middleware function với lỗi đã được xử lý
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

module.exports = catchAsync;


--- File: common/utils/dateUtils.js ---
/**
 * Các hàm tiện ích xử lý datetime
 */
/**
 * no-type
 * @module dateUtils
 * @description Các hàm tiện ích xử lý datetime
 * @example
 * const dateUtils = require('./dateUtils');
 * const formattedDate = dateUtils.formatDate(new Date());
 */
const dateUtils = {
  /**
   * Format date theo định dạng DD/MM/YYYY
   *
   * @param {Date} date - Date object cần format
   * @returns {String} Chuỗi đã format
   */
  formatDate: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();

    return `${day}/${month}/${year}`;
  },

  /**
   * Format datetime theo định dạng DD/MM/YYYY HH:MM
   *
   * @param {Date} date - Date object cần format
   * @returns {String} Chuỗi đã format
   */
  formatDateTime: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');

    return `${day}/${month}/${year} ${hours}:${minutes}`;
  },

  /**
   * Tính số ngày giữa hai ngày
   *
   * @param {Date} startDate - Ngày bắt đầu
   * @param {Date} endDate - Ngày kết thúc
   * @returns {Number} Số ngày
   */
  daysBetween: (startDate, endDate) => {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end.getTime() - start.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    return diffDays;
  },

  /**
   * Thêm số ngày vào một ngày
   *
   * @param {Date} date - Ngày gốc
   * @param {Number} days - Số ngày cần thêm
   * @returns {Date} Ngày mới
   */
  addDays: (date, days) => {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  },

  /**
   * Lấy ngày đầu tiên của tháng
   *
   * @param {Date} date - Ngày bất kỳ trong tháng
   * @returns {Date} Ngày đầu tiên của tháng
   */
  firstDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth(), 1);
  },

  /**
   * Lấy ngày cuối cùng của tháng
   *
   * @param {Date} date - Ngày bất kỳ trong tháng
   * @returns {Date} Ngày cuối cùng của tháng
   */
  lastDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0);
  },

  /**
   * Kiểm tra ngày có phải là ngày hiện tại
   *
   * @param {Date} date - Ngày cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isToday: (date) => {
    const today = new Date();
    const d = new Date(date);

    return (
      d.getDate() === today.getDate() &&
      d.getMonth() === today.getMonth() &&
      d.getFullYear() === today.getFullYear()
    );
  },
};

module.exports = dateUtils;


--- File: common/utils/fileUtils.js ---
const fs = require('fs');
const path = require('path');
const util = require('util');
const crypto = require('crypto');

// Promisify fs functions
const unlinkAsync = util.promisify(fs.unlink);
const mkdirAsync = util.promisify(fs.mkdir);
const statAsync = util.promisify(fs.stat);

/**
 * Các hàm tiện ích xử lý file
 */
const fileUtils = {
  /**
   * Kiểm tra một file có tồn tại
   *
   * @param {String} filePath - Đường dẫn file
   * @returns {Promise<Boolean>} Kết quả kiểm tra
   */
  fileExists: async (filePath) => {
    try {
      await statAsync(filePath);
      return true;
    } catch (error) {
      return false;
    }
  },

  /**
   * Tạo thư mục nếu chưa tồn tại
   *
   * @param {String} dirPath - Đường dẫn thư mục
   * @returns {Promise<void>}
   */
  ensureDirectoryExists: async (dirPath) => {
    if (!fs.existsSync(dirPath)) {
      await mkdirAsync(dirPath, { recursive: true });
    }
  },

  /**
   * Xóa một file
   *
   * @param {String} filePath - Đường dẫn file
   * @returns {Promise<void>}
   */
  removeFile: async (filePath) => {
    if (await fileUtils.fileExists(filePath)) {
      await unlinkAsync(filePath);
    }
  },

  /**
   * Lấy extension của file
   *
   * @param {String} filename - Tên file
   * @returns {String} Extension của file
   */
  getFileExtension: (filename) => {
    return path.extname(filename).toLowerCase();
  },

  /**
   * Kiểm tra file có phải là hình ảnh
   *
   * @param {String} filename - Tên file
   * @returns {Boolean} Kết quả kiểm tra
   */
  isImageFile: (filename) => {
    const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
    const extension = fileUtils.getFileExtension(filename);
    return validExtensions.includes(extension);
  },

  /**
   * Tạo tên file ngẫu nhiên
   *
   * @param {String} originalname - Tên file gốc
   * @returns {String} Tên file mới
   */
  generateUniqueFilename: (originalname) => {
    const extension = fileUtils.getFileExtension(originalname);
    const randomName = crypto.randomBytes(16).toString('hex');
    return `${randomName}${extension}`;
  },

  /**
   * Tính kích thước file theo định dạng readable
   *
   * @param {Number} bytes - Kích thước file tính bằng bytes
   * @returns {String} Kích thước file dạng readable
   */
  formatFileSize: (bytes) => {
    if (bytes === 0) return '0 Bytes';

    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));

    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
  },
};

module.exports = fileUtils;


--- File: common/utils/formatters.js ---
/**
 * Các hàm tiện ích định dạng dữ liệu
 */
const formatters = {
  /**
   * Định dạng số tiền
   *
   * @param {Number} amount - Số tiền cần định dạng
   * @param {String} currency - Đơn vị tiền tệ (mặc định: VND)
   * @returns {String} Chuỗi đã định dạng
   */
  formatCurrency: (amount, currency = 'VND') => {
    const formatter = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
    });

    return formatter.format(amount);
  },

  /**
   * Định dạng số điện thoại Việt Nam
   *
   * @param {String} phone - Số điện thoại cần định dạng
   * @returns {String} Số điện thoại đã định dạng
   */
  formatPhoneNumber: (phone) => {
    if (!phone) return '';

    // Loại bỏ tất cả ký tự không phải số
    const cleaned = phone.replace(/\D/g, '');

    // Kiểm tra độ dài
    if (cleaned.length !== 10) return phone;

    // Định dạng: XXX XXX XXXX
    return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)} ${cleaned.slice(6)}`;
  },

  /**
   * Định dạng địa chỉ
   *
   * @param {Object} address - Object chứa thông tin địa chỉ
   * @returns {String} Địa chỉ đã định dạng
   */
  formatAddress: (address) => {
    if (!address) return '';

    const parts = [];

    if (address.street) parts.push(address.street);
    if (address.city) parts.push(address.city);
    if (address.state) parts.push(address.state);
    if (address.zipCode) parts.push(address.zipCode);
    if (address.country) parts.push(address.country);

    return parts.join(', ');
  },

  /**
   * Rút gọn chuỗi nếu quá dài
   *
   * @param {String} text - Chuỗi cần rút gọn
   * @param {Number} maxLength - Độ dài tối đa
   * @returns {String} Chuỗi đã rút gọn
   */
  truncateText: (text, maxLength = 100) => {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.slice(0, maxLength) + '...';
  },

  /**
   * Chuyển đổi chuỗi thành slug URL
   *
   * @param {String} text - Chuỗi cần chuyển đổi
   * @returns {String} Slug URL
   */
  slugify: (text) => {
    if (!text) return '';

    // Chuyển về chữ thường và thay thế dấu tiếng Việt
    const slug = text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[đĐ]/g, 'd')
      .replace(/[^a-z0-9\s-]/g, '') // Loại bỏ ký tự đặc biệt
      .replace(/\s+/g, '-') // Thay space bằng dấu gạch ngang
      .replace(/-+/g, '-') // Loại bỏ dấu gạch ngang liên tiếp
      .trim();

    return slug;
  },

  /**
   * Định dạng tên người
   *
   * @param {String} firstName - Tên
   * @param {String} lastName - Họ
   * @returns {String} Tên đầy đủ
   */
  formatName: (firstName, lastName) => {
    if (!firstName && !lastName) return '';
    if (!firstName) return lastName;
    if (!lastName) return firstName;

    return `${lastName} ${firstName}`;
  },

  /**
   * Định dạng dữ liệu sản phẩm trước khi trả về client
   *
   * @param {Object} product - Dữ liệu sản phẩm cần định dạng
   * @returns {Object} - Dữ liệu sản phẩm đã được định dạng
   */
  formatProductResponse: (product) => {
    if (!product) return null;

    // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
    const formattedProduct = { ...product };

    // Định dạng giá tiền
    if (formattedProduct.pricing) {
      if (formattedProduct.pricing.regular) {
        formattedProduct.pricing.formattedRegularPrice = formatters.formatCurrency(
          formattedProduct.pricing.regular,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.sale) {
        formattedProduct.pricing.formattedSalePrice = formatters.formatCurrency(
          formattedProduct.pricing.sale,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.finalPrice) {
        formattedProduct.pricing.formattedFinalPrice = formatters.formatCurrency(
          formattedProduct.pricing.finalPrice,
          formattedProduct.pricing.currency || 'VND'
        );
      }
    }

    // Định dạng mô tả ngắn gọn
    if (formattedProduct.description) {
      formattedProduct.shortDescription = formatters.truncateText(
        formattedProduct.description,
        150
      );
    }

    // Định dạng ngày tháng
    if (formattedProduct.dates) {
      if (formattedProduct.dates.created) {
        formattedProduct.dates.formattedCreatedDate = new Date(
          formattedProduct.dates.created
        ).toLocaleDateString('vi-VN');
      }
      if (formattedProduct.dates.updated) {
        formattedProduct.dates.formattedUpdatedDate = new Date(
          formattedProduct.dates.updated
        ).toLocaleDateString('vi-VN');
      }
    }

    // Định dạng trạng thái tồn kho
    if (formattedProduct.inventory) {
      formattedProduct.inventory.statusText = formattedProduct.inventory.inStock
        ? 'Còn hàng'
        : 'Hết hàng';
    }

    // Định dạng đánh giá trung bình
    if (formattedProduct.averageRating !== undefined) {
      formattedProduct.formattedRating = formattedProduct.averageRating.toFixed(1);
    }

    return formattedProduct;
  },
};

module.exports = formatters;


--- File: common/utils/responseHandler.js ---
/**
 * Tiện ích xử lý response chuẩn hóa
 */
const responseHandler = {
  /**
   * Trả về response thành công
   *
   * @param {Object} res - Express response object
   * @param {Object} data - Dữ liệu trả về
   * @param {String} message - Thông báo thành công
   * @param {Number} statusCode - HTTP status code
   */
  success: (res, data = null, message = 'Success', statusCode = 200) => {
    return res.status(statusCode).json({
      status: 'success',
      message,
      data,
    });
  },

  /**
   * Trả về response lỗi
   *
   * @param {Object} res - Express response object
   * @param {String} message - Thông báo lỗi
   * @param {Number} statusCode - HTTP status code
   * @param {Object} errors - Chi tiết lỗi
   */
  error: (res, message = 'Error occurred', statusCode = 400, errors = null) => {
    const response = {
      status: 'error',
      message,
    };

    if (errors) {
      response.errors = errors;
    }

    return res.status(statusCode).json(response);
  },

  /**
   * Trả về response khi tạo thành công
   *
   * @param {Object} res - Express response object
   * @param {Object} data - Dữ liệu trả về
   * @param {String} message - Thông báo thành công
   */
  created: (res, data = null, message = 'Resource created successfully') => {
    return responseHandler.success(res, data, message, 201);
  },

  /**
   * Trả về response không có nội dung
   *
   * @param {Object} res - Express response object
   */
  noContent: (res) => {
    return res.status(204).end();
  },

  /**
   * Trả về response với dữ liệu được phân trang
   *
   * @param {Object} res - Express response object
   * @param {Array} data - Dữ liệu trả về
   * @param {Number} page - Trang hiện tại
   * @param {Number} limit - Số lượng items mỗi trang
   * @param {Number} total - Tổng số items
   */
  paginated: (res, data, page, limit, total) => {
    const totalPages = Math.ceil(total / limit);

    return res.status(200).json({
      status: 'success',
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
      },
    });
  },
};

module.exports = responseHandler;


--- File: common/utils/securityUtils.js ---
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

/**
 * Các hàm tiện ích liên quan đến bảo mật
 */
const securityUtils = {
  /**
   * Hash mật khẩu sử dụng bcrypt
   *
   * @param {String} password - Mật khẩu cần hash
   * @returns {Promise<String>} Mật khẩu đã hash
   */
  hashPassword: async (password) => {
    const saltRounds = 10;
    return await bcrypt.hash(password, saltRounds);
  },

  /**
   * So sánh mật khẩu với hash
   *
   * @param {String} password - Mật khẩu cần kiểm tra
   * @param {String} hash - Hash đã lưu
   * @returns {Promise<Boolean>} Kết quả so sánh
   */
  comparePassword: async (password, hash) => {
    return await bcrypt.compare(password, hash);
  },

  /**
   * Tạo JWT token
   *
   * @param {Object} payload - Dữ liệu cần lưu trong token
   * @param {String} secret - Secret key
   * @param {Object} options - Tùy chọn cho token
   * @returns {String} JWT token
   */
  generateToken: (payload, secret, options = {}) => {
    return jwt.sign(payload, secret, options);
  },

  /**
   * Xác thực và decode JWT token
   *
   * @param {String} token - JWT token
   * @param {String} secret - Secret key
   * @returns {Object} Payload đã decode
   */
  verifyToken: (token, secret) => {
    return jwt.verify(token, secret);
  },

  /**
   * Tạo chuỗi random để làm reset token, verification token...
   *
   * @param {Number} length - Độ dài chuỗi (mặc định: 32)
   * @returns {String} Chuỗi random
   */
  generateRandomToken: (length = 32) => {
    return crypto.randomBytes(length).toString('hex');
  },

  /**
   * Hash một chuỗi sử dụng SHA-256
   *
   * @param {String} data - Chuỗi cần hash
   * @returns {String} Chuỗi đã hash
   */
  hashData: (data) => {
    return crypto.createHash('sha256').update(data).digest('hex');
  },

  /**
   * Mã hóa dữ liệu
   *
   * @param {String} data - Dữ liệu cần mã hóa
   * @param {String} secret - Secret key
   * @returns {String} Dữ liệu đã mã hóa
   */
  encrypt: (data, secret) => {
    const algorithm = 'aes-256-ctr';
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, secret, iv);

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return `${iv.toString('hex')}:${encrypted}`;
  },

  /**
   * Giải mã dữ liệu
   *
   * @param {String} encryptedData - Dữ liệu đã mã hóa
   * @param {String} secret - Secret key
   * @returns {String} Dữ liệu đã giải mã
   */
  decrypt: (encryptedData, secret) => {
    const algorithm = 'aes-256-ctr';
    const [ivHex, encrypted] = encryptedData.split(':');

    const iv = Buffer.from(ivHex, 'hex');
    const decipher = crypto.createDecipheriv(algorithm, secret, iv);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  },
};

module.exports = securityUtils;


--- File: common/utils/validatorUtils.js ---
const mongoose = require('mongoose');

/**
 * Các hàm tiện ích cho validation
 */
const validatorUtils = {
  /**
   * Kiểm tra chuỗi có phải là email hợp lệ
   *
   * @param {String} email - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidEmail: (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  /**
   * Kiểm tra chuỗi có phải là số điện thoại Việt Nam hợp lệ
   *
   * @param {String} phone - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidVietnamesePhone: (phone) => {
    const phoneRegex = /(84|0[3|5|7|8|9])+([0-9]{8})\b/;
    return phoneRegex.test(phone);
  },

  /**
   * Kiểm tra chuỗi có phải là mật khẩu mạnh
   * Yêu cầu: ít nhất 8 ký tự, chứa chữ hoa, chữ thường, số và ký tự đặc biệt
   *
   * @param {String} password - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isStrongPassword: (password) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  },

  /**
   * Kiểm tra chuỗi có phải là MongoDB ObjectId hợp lệ
   *
   * @param {String} id - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidObjectId: (id) => {
    return mongoose.Types.ObjectId.isValid(id);
  },

  /**
   * Kiểm tra giá trị có phải là số nguyên dương
   *
   * @param {Number} value - Giá trị cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isPositiveInteger: (value) => {
    return Number.isInteger(value) && value > 0;
  },

  /**
   * Kiểm tra giá trị có nằm trong khoảng
   *
   * @param {Number} value - Giá trị cần kiểm tra
   * @param {Number} min - Giá trị tối thiểu
   * @param {Number} max - Giá trị tối đa
   * @returns {Boolean} Kết quả kiểm tra
   */
  isInRange: (value, min, max) => {
    return value >= min && value <= max;
  },
};

module.exports = validatorUtils;


--- File: common/validators/authValidator.js ---
/**
 * Auth Validator - Định nghĩa các schema validation cho authentication
 * @author Steve
 * @project RunOut-Biliard
 */

const Joi = require('joi');

// Schema đăng ký
const registerSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().messages({
    'string.min': 'Tên phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên không được vượt quá {#limit} ký tự',
    'string.empty': 'Tên không được để trống',
    'any.required': 'Tên là trường bắt buộc',
  }),

  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.pattern.base': 'Mật khẩu phải chứa ít nhất một chữ hoa, một chữ thường và một chữ số',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là trường bắt buộc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
    'string.empty': 'Xác nhận mật khẩu không được để trống',
    'any.required': 'Xác nhận mật khẩu là trường bắt buộc',
  }),

  phone: Joi.string()
    .pattern(/^(0|\+84)[3|5|7|8|9][0-9]{8}$/)
    .allow('', null)
    .messages({
      'string.pattern.base': 'Số điện thoại không hợp lệ',
    }),
});

// Schema đăng nhập
const loginSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),

  password: Joi.string().required().messages({
    'string.empty': 'Mật khẩu không được để trống',
    'any.required': 'Mật khẩu là trường bắt buộc',
  }),

  rememberMe: Joi.boolean().default(false),
});

// Schema refresh token
const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().required().messages({
    'string.empty': 'Refresh token không được để trống',
    'any.required': 'Refresh token là trường bắt buộc',
  }),
});

// Schema quên mật khẩu
const forgotPasswordSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),
});

// Schema đặt lại mật khẩu
const resetPasswordSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token không được để trống',
    'any.required': 'Token là trường bắt buộc',
  }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.pattern.base': 'Mật khẩu phải chứa ít nhất một chữ hoa, một chữ thường và một chữ số',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là trường bắt buộc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
    'string.empty': 'Xác nhận mật khẩu không được để trống',
    'any.required': 'Xác nhận mật khẩu là trường bắt buộc',
  }),
});

// Schema xác thực email
const verifyEmailSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token không được để trống',
    'any.required': 'Token là trường bắt buộc',
  }),
});

module.exports = {
  register: registerSchema,
  login: loginSchema,
  refreshToken: refreshTokenSchema,
  forgotPassword: forgotPasswordSchema,
  resetPassword: resetPasswordSchema,
  verifyEmail: verifyEmailSchema,
};


--- File: common/validators/cartValidator.js ---
// server/src/common/validators/cartValidator.js

const Joi = require('joi');

const createCartValidator = Joi.object({
  user: Joi.string().allow(null).messages({
    'string.base': 'User ID phải là một chuỗi',
  }),

  sessionId: Joi.string().allow(null).messages({
    'string.base': 'Session ID phải là một chuỗi',
  }),

  items: Joi.array()
    .items(
      Joi.object({
        product: Joi.string().required().messages({
          'string.base': 'Product ID phải là một chuỗi',
          'string.empty': 'Product ID không được để trống',
          'any.required': 'Product ID là bắt buộc',
        }),
        quantity: Joi.number().integer().min(1).required().messages({
          'number.base': 'Số lượng phải là một số',
          'number.integer': 'Số lượng phải là số nguyên',
          'number.min': 'Số lượng phải lớn hơn 0',
          'any.required': 'Số lượng là bắt buộc',
        }),
        attributes: Joi.object().allow(null).default({}),
      })
    )
    .default([]),
})
  .or('user', 'sessionId')
  .messages({
    'object.missing': 'Phải có ít nhất một trong hai trường user hoặc sessionId',
  });

const addItemValidator = Joi.object({
  product: Joi.string().required().messages({
    'string.base': 'Product ID phải là một chuỗi',
    'string.empty': 'Product ID không được để trống',
    'any.required': 'Product ID là bắt buộc',
  }),
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'Số lượng phải là một số',
    'number.integer': 'Số lượng phải là số nguyên',
    'number.min': 'Số lượng phải lớn hơn 0',
    'any.required': 'Số lượng là bắt buộc',
  }),
  attributes: Joi.object().allow(null).default({}),
});

const updateItemValidator = Joi.object({
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'Số lượng phải là một số',
    'number.integer': 'Số lượng phải là số nguyên',
    'number.min': 'Số lượng phải lớn hơn 0',
    'any.required': 'Số lượng là bắt buộc',
  }),
});

const applyCouponValidator = Joi.object({
  code: Joi.string().required().messages({
    'string.base': 'Mã giảm giá phải là một chuỗi',
    'string.empty': 'Mã giảm giá không được để trống',
    'any.required': 'Mã giảm giá là bắt buộc',
  }),
});

const shippingAddressValidator = Joi.object({
  name: Joi.string().required().messages({
    'string.base': 'Tên người nhận phải là một chuỗi',
    'string.empty': 'Tên người nhận không được để trống',
    'any.required': 'Tên người nhận là bắt buộc',
  }),
  phone: Joi.string()
    .required()
    .pattern(/^(0|\+84)([0-9]{9,10})$/)
    .messages({
      'string.base': 'Số điện thoại phải là một chuỗi',
      'string.empty': 'Số điện thoại không được để trống',
      'string.pattern.base': 'Số điện thoại không hợp lệ (phải là số điện thoại Việt Nam)',
      'any.required': 'Số điện thoại là bắt buộc',
    }),
  street: Joi.string().required().messages({
    'string.base': 'Địa chỉ đường phố phải là một chuỗi',
    'string.empty': 'Địa chỉ đường phố không được để trống',
    'any.required': 'Địa chỉ đường phố là bắt buộc',
  }),
  city: Joi.string().required().messages({
    'string.base': 'Thành phố phải là một chuỗi',
    'string.empty': 'Thành phố không được để trống',
    'any.required': 'Thành phố là bắt buộc',
  }),
  state: Joi.string().allow('', null).messages({
    'string.base': 'Tỉnh/Bang phải là một chuỗi',
  }),
  zipCode: Joi.string().required().messages({
    'string.base': 'Mã bưu điện phải là một chuỗi',
    'string.empty': 'Mã bưu điện không được để trống',
    'any.required': 'Mã bưu điện là bắt buộc',
  }),
  country: Joi.string().required().messages({
    'string.base': 'Quốc gia phải là một chuỗi',
    'string.empty': 'Quốc gia không được để trống',
    'any.required': 'Quốc gia là bắt buộc',
  }),
  notes: Joi.string().allow('', null).messages({
    'string.base': 'Ghi chú phải là một chuỗi',
  }),
});

const shippingMethodValidator = Joi.object({
  type: Joi.string().valid('standard', 'express').required().messages({
    'string.base': 'Phương thức vận chuyển phải là một chuỗi',
    'string.empty': 'Phương thức vận chuyển không được để trống',
    'any.only': 'Phương thức vận chuyển phải là một trong các giá trị: standard, express',
    'any.required': 'Phương thức vận chuyển là bắt buộc',
  }),
});

const checkoutValidator = Joi.object({
  cartId: Joi.string().required().messages({
    'string.base': 'Cart ID phải là một chuỗi',
    'string.empty': 'Cart ID không được để trống',
    'any.required': 'Cart ID là bắt buộc',
  }),
  shippingAddress: shippingAddressValidator.required().messages({
    'any.required': 'Địa chỉ giao hàng là bắt buộc',
  }),
  shippingMethod: shippingMethodValidator.required().messages({
    'any.required': 'Phương thức vận chuyển là bắt buộc',
  }),
  paymentMethod: Joi.string()
    .valid('cod', 'bank_transfer', 'vnpay', 'credit_card')
    .required()
    .messages({
      'string.base': 'Phương thức thanh toán phải là một chuỗi',
      'string.empty': 'Phương thức thanh toán không được để trống',
      'any.only':
        'Phương thức thanh toán phải là một trong các giá trị: cod, bank_transfer, vnpay, credit_card',
      'any.required': 'Phương thức thanh toán là bắt buộc',
    }),
  customerNotes: Joi.string().allow('', null).max(500).messages({
    'string.base': 'Ghi chú phải là một chuỗi',
    'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
  }),
});

const mergeCartsValidator = Joi.object({
  sourceCartId: Joi.string().required().messages({
    'string.base': 'Source Cart ID phải là một chuỗi',
    'string.empty': 'Source Cart ID không được để trống',
    'any.required': 'Source Cart ID là bắt buộc',
  }),
  destinationCartId: Joi.string().required().messages({
    'string.base': 'Destination Cart ID phải là một chuỗi',
    'string.empty': 'Destination Cart ID không được để trống',
    'any.required': 'Destination Cart ID là bắt buộc',
  }),
});

module.exports = {
  createCartValidator,
  addItemValidator,
  updateItemValidator,
  applyCouponValidator,
  shippingAddressValidator,
  shippingMethodValidator,
  checkoutValidator,
  mergeCartsValidator,
};


--- File: common/validators/categoryValidator.js ---
/**
 * Category Validator
 * Định nghĩa các validation rules cho category API
 */

const Joi = require('joi');

const categoryValidator = {
  /**
   * Validate khi tạo danh mục mới
   */
  createCategory: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên danh mục phải là chuỗi',
      'string.empty': 'Tên danh mục không được để trống',
      'string.min': 'Tên danh mục phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên danh mục không được vượt quá {#limit} ký tự',
      'any.required': 'Tên danh mục là bắt buộc',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug phải là chuỗi',
      'string.empty': 'Slug không được để trống',
      'string.min': 'Slug phải có ít nhất {#limit} ký tự',
      'string.max': 'Slug không được vượt quá {#limit} ký tự',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'Mô tả phải là chuỗi',
      'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh mục cha phải là chuỗi',
        'string.pattern.base': 'ID danh mục cha không hợp lệ',
      }),

    image: Joi.object({
      url: Joi.string().uri().required().messages({
        'string.base': 'URL hình ảnh phải là chuỗi',
        'string.empty': 'URL hình ảnh không được để trống',
        'string.uri': 'URL hình ảnh không hợp lệ',
        'any.required': 'URL hình ảnh là bắt buộc',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text phải là chuỗi',
        'string.max': 'Alt text không được vượt quá {#limit} ký tự',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon phải là chuỗi',
      'string.max': 'Icon không được vượt quá {#limit} ký tự',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'Mã màu phải là chuỗi',
      'string.max': 'Mã màu không được vượt quá {#limit} ký tự',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Thứ tự phải là số',
      'number.integer': 'Thứ tự phải là số nguyên',
      'number.min': 'Thứ tự không được nhỏ hơn {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive phải là boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible phải là boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured phải là boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),

  /**
   * Validate khi cập nhật danh mục
   */
  updateCategory: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên danh mục phải là chuỗi',
      'string.empty': 'Tên danh mục không được để trống',
      'string.min': 'Tên danh mục phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên danh mục không được vượt quá {#limit} ký tự',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug phải là chuỗi',
      'string.empty': 'Slug không được để trống',
      'string.min': 'Slug phải có ít nhất {#limit} ký tự',
      'string.max': 'Slug không được vượt quá {#limit} ký tự',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'Mô tả phải là chuỗi',
      'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh mục cha phải là chuỗi',
        'string.pattern.base': 'ID danh mục cha không hợp lệ',
      }),

    image: Joi.object({
      url: Joi.string().uri().messages({
        'string.base': 'URL hình ảnh phải là chuỗi',
        'string.empty': 'URL hình ảnh không được để trống',
        'string.uri': 'URL hình ảnh không hợp lệ',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text phải là chuỗi',
        'string.max': 'Alt text không được vượt quá {#limit} ký tự',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon phải là chuỗi',
      'string.max': 'Icon không được vượt quá {#limit} ký tự',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'Mã màu phải là chuỗi',
      'string.max': 'Mã màu không được vượt quá {#limit} ký tự',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Thứ tự phải là số',
      'number.integer': 'Thứ tự phải là số nguyên',
      'number.min': 'Thứ tự không được nhỏ hơn {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive phải là boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible phải là boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured phải là boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),
};

module.exports = { categoryValidator };


--- File: common/validators/orderValidator.js ---
/**
 * Order Validator
 * Định nghĩa các validation rules cho order API
 */

const Joi = require('joi');

const orderValidator = {
  /**
   * Validate khi tạo đơn hàng mới
   */
  createOrder: Joi.object({
    // Thông tin liên hệ
    customerInfo: Joi.object({
      name: Joi.string().min(2).max(100).required().messages({
        'string.base': 'Tên khách hàng phải là chuỗi',
        'string.empty': 'Tên khách hàng không được để trống',
        'string.min': 'Tên khách hàng phải có ít nhất {#limit} ký tự',
        'string.max': 'Tên khách hàng không được vượt quá {#limit} ký tự',
        'any.required': 'Tên khách hàng là bắt buộc',
      }),
      email: Joi.string().email().required().messages({
        'string.base': 'Email phải là chuỗi',
        'string.empty': 'Email không được để trống',
        'string.email': 'Email không hợp lệ',
        'any.required': 'Email là bắt buộc',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .required()
        .messages({
          'string.base': 'Số điện thoại phải là chuỗi',
          'string.empty': 'Số điện thoại không được để trống',
          'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
          'any.required': 'Số điện thoại là bắt buộc',
        }),
    })
      .required()
      .messages({
        'object.base': 'Thông tin khách hàng phải là đối tượng',
        'any.required': 'Thông tin khách hàng là bắt buộc',
      }),

    // Thông tin vận chuyển
    shippingAddress: Joi.object({
      name: Joi.string().min(2).max(100).messages({
        'string.base': 'Tên người nhận phải là chuỗi',
        'string.min': 'Tên người nhận phải có ít nhất {#limit} ký tự',
        'string.max': 'Tên người nhận không được vượt quá {#limit} ký tự',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .messages({
          'string.base': 'Số điện thoại phải là chuỗi',
          'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
        }),
      street: Joi.string().required().messages({
        'string.base': 'Địa chỉ đường phố phải là chuỗi',
        'string.empty': 'Địa chỉ đường phố không được để trống',
        'any.required': 'Địa chỉ đường phố là bắt buộc',
      }),
      city: Joi.string().required().messages({
        'string.base': 'Thành phố phải là chuỗi',
        'string.empty': 'Thành phố không được để trống',
        'any.required': 'Thành phố là bắt buộc',
      }),
      state: Joi.string().allow('').messages({
        'string.base': 'Tỉnh/Bang phải là chuỗi',
      }),
      zipCode: Joi.string().required().messages({
        'string.base': 'Mã bưu điện phải là chuỗi',
        'string.empty': 'Mã bưu điện không được để trống',
        'any.required': 'Mã bưu điện là bắt buộc',
      }),
      country: Joi.string().required().messages({
        'string.base': 'Quốc gia phải là chuỗi',
        'string.empty': 'Quốc gia không được để trống',
        'any.required': 'Quốc gia là bắt buộc',
      }),
      notes: Joi.string().max(500).messages({
        'string.base': 'Ghi chú phải là chuỗi',
        'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
      }),
    })
      .required()
      .messages({
        'object.base': 'Địa chỉ giao hàng phải là đối tượng',
        'any.required': 'Địa chỉ giao hàng là bắt buộc',
      }),

    // Phương thức vận chuyển và thanh toán
    shippingMethod: Joi.string().valid('standard', 'express').required().messages({
      'string.base': 'Phương thức vận chuyển phải là chuỗi',
      'string.empty': 'Phương thức vận chuyển không được để trống',
      'any.only': 'Phương thức vận chuyển không hợp lệ',
      'any.required': 'Phương thức vận chuyển là bắt buộc',
    }),

    paymentMethod: Joi.string().valid('cod', 'credit_card', 'paypal', 'vnpay').required().messages({
      'string.base': 'Phương thức thanh toán phải là chuỗi',
      'string.empty': 'Phương thức thanh toán không được để trống',
      'any.only': 'Phương thức thanh toán không hợp lệ',
      'any.required': 'Phương thức thanh toán là bắt buộc',
    }),

    // Ghi chú đơn hàng
    customerNotes: Joi.string().max(500).messages({
      'string.base': 'Ghi chú phải là chuỗi',
      'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
    }),

    // Mã giảm giá
    couponCode: Joi.string().max(50).messages({
      'string.base': 'Mã giảm giá phải là chuỗi',
      'string.max': 'Mã giảm giá không được vượt quá {#limit} ký tự',
    }),

    // ID giỏ hàng (nếu tạo đơn hàng từ giỏ hàng)
    cartId: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID giỏ hàng phải là chuỗi',
        'string.pattern.base': 'ID giỏ hàng không hợp lệ',
      }),

    // Các mặt hàng trong đơn hàng (bắt buộc nếu không có cartId)
    items: Joi.when('cartId', {
      is: Joi.exist(),
      then: Joi.array(),
      otherwise: Joi.array()
        .items(
          Joi.object({
            product: Joi.string()
              .regex(/^[0-9a-fA-F]{24}$/)
              .required()
              .messages({
                'string.base': 'ID sản phẩm phải là chuỗi',
                'string.pattern.base': 'ID sản phẩm không hợp lệ',
                'any.required': 'ID sản phẩm là bắt buộc',
              }),
            quantity: Joi.number().integer().min(1).required().messages({
              'number.base': 'Số lượng phải là số',
              'number.integer': 'Số lượng phải là số nguyên',
              'number.min': 'Số lượng phải ít nhất là {#limit}',
              'any.required': 'Số lượng là bắt buộc',
            }),
            attributes: Joi.object().default({}),
          })
        )
        .min(1)
        .required()
        .messages({
          'array.base': 'Các mặt hàng phải là mảng',
          'array.min': 'Phải có ít nhất một mặt hàng',
          'any.required': 'Các mặt hàng là bắt buộc',
        }),
    }),
  }),

  /**
   * Validate khi cập nhật trạng thái đơn hàng
   */
  updateOrderStatus: Joi.object({
    status: Joi.string()
      .valid('pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned')
      .required()
      .messages({
        'string.base': 'Trạng thái phải là chuỗi',
        'string.empty': 'Trạng thái không được để trống',
        'any.only': 'Trạng thái không hợp lệ',
        'any.required': 'Trạng thái là bắt buộc',
      }),

    note: Joi.string().max(500).messages({
      'string.base': 'Ghi chú phải là chuỗi',
      'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
    }),
  }),

  /**
   * Validate khi hủy đơn hàng
   */
  cancelOrder: Joi.object({
    reason: Joi.string().max(500).required().messages({
      'string.base': 'Lý do hủy phải là chuỗi',
      'string.empty': 'Lý do hủy không được để trống',
      'string.max': 'Lý do hủy không được vượt quá {#limit} ký tự',
      'any.required': 'Lý do hủy là bắt buộc',
    }),
  }),
};
module.exports = orderValidator;
//     'any.required': 'Vai trò là bắt buộc'


--- File: common/validators/productValidator.js ---
// server/src/common/validators/productValidator.js

const Joi = require('joi');

// const priceRegex = /^\d+(\.\d{1,2})?$/; // Định dạng giá (số nguyên hoặc tối đa 2 chữ số thập phân)
const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/; // Định dạng slug

const createProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).required().messages({
    'string.base': 'Tên sản phẩm phải là một chuỗi',
    'string.empty': 'Tên sản phẩm không được để trống',
    'string.min': 'Tên sản phẩm phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên sản phẩm không được vượt quá {#limit} ký tự',
    'any.required': 'Tên sản phẩm là bắt buộc',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).required().messages({
    'string.base': 'Slug phải là một chuỗi',
    'string.empty': 'Slug không được để trống',
    'string.min': 'Slug phải có ít nhất {#limit} ký tự',
    'string.max': 'Slug không được vượt quá {#limit} ký tự',
    'string.pattern.base': 'Slug chỉ được chứa chữ cái thường, số và dấu gạch ngang',
    'any.required': 'Slug là bắt buộc',
  }),

  description: Joi.object({
    short: Joi.string().max(200).required().messages({
      'string.base': 'Mô tả ngắn phải là một chuỗi',
      'string.empty': 'Mô tả ngắn không được để trống',
      'string.max': 'Mô tả ngắn không được vượt quá {#limit} ký tự',
      'any.required': 'Mô tả ngắn là bắt buộc',
    }),
    long: Joi.string().max(2000).required().messages({
      'string.base': 'Mô tả chi tiết phải là một chuỗi',
      'string.empty': 'Mô tả chi tiết không được để trống',
      'string.max': 'Mô tả chi tiết không được vượt quá {#limit} ký tự',
      'any.required': 'Mô tả chi tiết là bắt buộc',
    }),
  }).required(),

  category: Joi.string().required().messages({
    'string.base': 'Danh mục phải là một chuỗi',
    'string.empty': 'Danh mục không được để trống',
    'any.required': 'Danh mục là bắt buộc',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh mục phụ phải là một chuỗi',
  }),

  brand: Joi.string().required().messages({
    'string.base': 'Thương hiệu phải là một chuỗi',
    'string.empty': 'Thương hiệu không được để trống',
    'any.required': 'Thương hiệu là bắt buộc',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nhà sản xuất phải là một chuỗi',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Quốc gia xuất xứ phải là một chuỗi',
  }),

  price: Joi.number().min(0).required().messages({
    'number.base': 'Giá phải là một số',
    'number.min': 'Giá không được âm',
    'any.required': 'Giá là bắt buộc',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Giá khuyến mãi phải là một số',
    'number.min': 'Giá khuyến mãi không được âm',
  }),

  stock: Joi.number().integer().min(0).required().messages({
    'number.base': 'Số lượng tồn kho phải là một số',
    'number.integer': 'Số lượng tồn kho phải là số nguyên',
    'number.min': 'Số lượng tồn kho không được âm',
    'any.required': 'Số lượng tồn kho là bắt buộc',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU phải là một chuỗi',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean().default(false),
      })
    )
    .min(1)
    .required()
    .messages({
      'array.base': 'Hình ảnh phải là một mảng',
      'array.min': 'Phải có ít nhất {#limit} hình ảnh',
      'any.required': 'Hình ảnh là bắt buộc',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'Tính năng phải là một mảng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean().default(true),
  isPromoted: Joi.boolean().default(false),
  isFeatured: Joi.boolean().default(false),
});

const updateProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).messages({
    'string.base': 'Tên sản phẩm phải là một chuỗi',
    'string.empty': 'Tên sản phẩm không được để trống',
    'string.min': 'Tên sản phẩm phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên sản phẩm không được vượt quá {#limit} ký tự',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).messages({
    'string.base': 'Slug phải là một chuỗi',
    'string.empty': 'Slug không được để trống',
    'string.min': 'Slug phải có ít nhất {#limit} ký tự',
    'string.max': 'Slug không được vượt quá {#limit} ký tự',
    'string.pattern.base': 'Slug chỉ được chứa chữ cái thường, số và dấu gạch ngang',
  }),

  description: Joi.object({
    short: Joi.string().max(200).messages({
      'string.base': 'Mô tả ngắn phải là một chuỗi',
      'string.empty': 'Mô tả ngắn không được để trống',
      'string.max': 'Mô tả ngắn không được vượt quá {#limit} ký tự',
    }),
    long: Joi.string().max(2000).messages({
      'string.base': 'Mô tả chi tiết phải là một chuỗi',
      'string.empty': 'Mô tả chi tiết không được để trống',
      'string.max': 'Mô tả chi tiết không được vượt quá {#limit} ký tự',
    }),
  }),

  category: Joi.string().messages({
    'string.base': 'Danh mục phải là một chuỗi',
    'string.empty': 'Danh mục không được để trống',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh mục phụ phải là một chuỗi',
  }),

  brand: Joi.string().messages({
    'string.base': 'Thương hiệu phải là một chuỗi',
    'string.empty': 'Thương hiệu không được để trống',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nhà sản xuất phải là một chuỗi',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Quốc gia xuất xứ phải là một chuỗi',
  }),

  price: Joi.number().min(0).messages({
    'number.base': 'Giá phải là một số',
    'number.min': 'Giá không được âm',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Giá khuyến mãi phải là một số',
    'number.min': 'Giá khuyến mãi không được âm',
  }),

  stock: Joi.number().integer().min(0).messages({
    'number.base': 'Số lượng tồn kho phải là một số',
    'number.integer': 'Số lượng tồn kho phải là số nguyên',
    'number.min': 'Số lượng tồn kho không được âm',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU phải là một chuỗi',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean(),
      })
    )
    .min(1)
    .messages({
      'array.base': 'Hình ảnh phải là một mảng',
      'array.min': 'Phải có ít nhất {#limit} hình ảnh',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'Tính năng phải là một mảng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean(),
  isPromoted: Joi.boolean(),
  isFeatured: Joi.boolean(),
});
/**
/**
 * Xác thực dữ liệu sản phẩm với nhiều tùy chọn nâng cao
 * @param {Object} data - Dữ liệu sản phẩm cần xác thực
 * @param {Object|Boolean} options - Các tùy chọn xác thực hoặc boolean cho isUpdate
 * @property {Boolean} options.isUpdate - Có phải đang cập nhật không (true) hay đang tạo mới (false)
 * @property {Array<string>} options.fields - Danh sách các trường cần xác thực (nếu chỉ muốn xác thực một số trường)
 * @property {Boolean} options.formatErrors - Có định dạng lỗi thành dạng dễ đọc không
 * @property {Boolean} options.checkBusinessRules - Có kiểm tra các quy tắc nghiệp vụ không
 * @returns {Object} - Kết quả xác thực { error, value, isValid, errorDetails }
 */
const validateProductData = (data, options = {}) => {
  // Xử lý trường hợp options là boolean (tương thích ngược)
  let isUpdate = false;
  let fields = null;
  let formatErrors = false;
  let checkBusinessRules = false;

  // Kiểm tra kiểu dữ liệu của options
  if (typeof options === 'boolean') {
    isUpdate = options;
  } else if (options && typeof options === 'object') {
    // Chỉ lấy các thuộc tính nếu options là object
    isUpdate = options.isUpdate === true;
    fields = Array.isArray(options.fields) ? options.fields : null;
    formatErrors = options.formatErrors === true;
    checkBusinessRules = options.checkBusinessRules === true;
  }

  // Chọn schema phù hợp
  let schema = isUpdate ? updateProductValidator : createProductValidator;

  // Nếu chỉ xác thực một số trường cụ thể
  if (fields && Array.isArray(fields) && fields.length > 0) {
    const schemaToUse = isUpdate ? updateProductValidator : createProductValidator;
    const filteredSchema = Joi.object(
      fields.reduce((acc, field) => {
        if (
          schemaToUse.$_terms &&
          schemaToUse.$_terms.keys &&
          schemaToUse.$_terms.keys.some((k) => k.key === field)
        ) {
          acc[field] = schemaToUse.$_terms.keys.find((k) => k.key === field).schema;
        }
        return acc;
      }, {})
    );
    schema = filteredSchema;
  }

  // Thực hiện xác thực cơ bản
  const validationResult = schema.validate(data, { abortEarly: false });

  // Nếu không cần xử lý thêm, trả về kết quả ngay
  if (!formatErrors && !checkBusinessRules) {
    return {
      ...validationResult,
      isValid: !validationResult.error,
    };
  }

  // Xử lý kết quả
  let result = {
    value: validationResult.value,
    isValid: !validationResult.error,
    errorDetails: null,
  };

  // Định dạng lỗi thành dạng dễ đọc nếu cần
  if (validationResult.error && formatErrors) {
    const errorDetails = {};

    validationResult.error.details.forEach((err) => {
      const field = err.path.join('.');
      if (!errorDetails[field]) {
        errorDetails[field] = [];
      }
      errorDetails[field].push(err.message);
    });

    result.error = validationResult.error;
    result.errorDetails = errorDetails;
  } else {
    result.error = validationResult.error;
  }

  // Kiểm tra các quy tắc nghiệp vụ nếu cần
  if (checkBusinessRules && !result.error) {
    const businessErrors = validateBusinessRules(data, isUpdate);

    if (businessErrors.length > 0) {
      result.isValid = false;
      result.businessErrors = businessErrors;

      if (formatErrors) {
        const errorDetails = result.errorDetails || {};

        businessErrors.forEach((err) => {
          const field = err.field;
          if (!errorDetails[field]) {
            errorDetails[field] = [];
          }
          errorDetails[field].push(err.message);
        });

        result.errorDetails = errorDetails;
      }
    }
  }

  return result;
};
/**
 * Kiểm tra các quy tắc nghiệp vụ phức tạp không thể xác thực bằng Joi
 * @param {Object} data - Dữ liệu sản phẩm
 * @param {Boolean} isUpdate - Có phải đang cập nhật không
 * @returns {Array} - Danh sách lỗi nghiệp vụ
 */
function validateBusinessRules(data, isUpdate) {
  const errors = [];

  // Kiểm tra giá khuyến mãi phải nhỏ hơn giá gốc
  if (data.price && data.salePrice && data.salePrice >= data.price) {
    errors.push({
      field: 'salePrice',
      message: 'Giá khuyến mãi phải nhỏ hơn giá gốc',
    });
  }

  // Kiểm tra nếu có discount thì phải có các trường bắt buộc
  if (data.discount && data.discount.percentage) {
    if (!data.discount.startDate) {
      errors.push({
        field: 'discount.startDate',
        message: 'Ngày bắt đầu khuyến mãi là bắt buộc khi có phần trăm giảm giá',
      });
    }

    if (!data.discount.endDate) {
      errors.push({
        field: 'discount.endDate',
        message: 'Ngày kết thúc khuyến mãi là bắt buộc khi có phần trăm giảm giá',
      });
    }
  }

  // Kiểm tra ít nhất một hình ảnh phải là hình chính
  if (data.images && data.images.length > 0) {
    const hasPrimaryImage = data.images.some((img) => img.isPrimary);
    if (!hasPrimaryImage) {
      errors.push({
        field: 'images',
        message: 'Phải có ít nhất một hình ảnh được đánh dấu là hình chính (isPrimary)',
      });
    }
  }

  return errors;
}
module.exports = {
  createProductValidator,
  updateProductValidator,
  validateProductData,
};


--- File: common/validators/reviewValidator.js ---
/**
 * Review Validator
 * Định nghĩa các validation rules cho review API
 */

const Joi = require('joi');

const reviewValidator = {
  /**
   * Validate khi tạo đánh giá mới
   */
  createReview: Joi.object({
    rating: Joi.number().min(1).max(5).required().messages({
      'number.base': 'Đánh giá sao phải là số',
      'number.min': 'Đánh giá sao không được nhỏ hơn {#limit}',
      'number.max': 'Đánh giá sao không được lớn hơn {#limit}',
      'any.required': 'Đánh giá sao là bắt buộc',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Tiêu đề phải là chuỗi',
      'string.max': 'Tiêu đề không được vượt quá {#limit} ký tự',
    }),

    review: Joi.string().max(2000).required().messages({
      'string.base': 'Nội dung đánh giá phải là chuỗi',
      'string.empty': 'Nội dung đánh giá không được để trống',
      'string.max': 'Nội dung đánh giá không được vượt quá {#limit} ký tự',
      'any.required': 'Nội dung đánh giá là bắt buộc',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL hình ảnh phải là chuỗi',
            'string.empty': 'URL hình ảnh không được để trống',
            'string.uri': 'URL hình ảnh không hợp lệ',
            'any.required': 'URL hình ảnh là bắt buộc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail phải là chuỗi',
            'string.uri': 'URL thumbnail không hợp lệ',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Chú thích hình ảnh phải là chuỗi',
            'string.max': 'Chú thích hình ảnh không được vượt quá {#limit} ký tự',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'Hình ảnh phải là mảng',
        'array.max': 'Không được đăng tải quá {#limit} hình ảnh',
      }),

    order: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID đơn hàng phải là chuỗi',
        'string.pattern.base': 'ID đơn hàng không hợp lệ',
      }),
  }),

  /**
   * Validate khi cập nhật đánh giá
   */
  updateReview: Joi.object({
    rating: Joi.number().min(1).max(5).messages({
      'number.base': 'Đánh giá sao phải là số',
      'number.min': 'Đánh giá sao không được nhỏ hơn {#limit}',
      'number.max': 'Đánh giá sao không được lớn hơn {#limit}',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Tiêu đề phải là chuỗi',
      'string.max': 'Tiêu đề không được vượt quá {#limit} ký tự',
    }),

    review: Joi.string().max(2000).messages({
      'string.base': 'Nội dung đánh giá phải là chuỗi',
      'string.max': 'Nội dung đánh giá không được vượt quá {#limit} ký tự',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL hình ảnh phải là chuỗi',
            'string.empty': 'URL hình ảnh không được để trống',
            'string.uri': 'URL hình ảnh không hợp lệ',
            'any.required': 'URL hình ảnh là bắt buộc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail phải là chuỗi',
            'string.uri': 'URL thumbnail không hợp lệ',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Chú thích hình ảnh phải là chuỗi',
            'string.max': 'Chú thích hình ảnh không được vượt quá {#limit} ký tự',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'Hình ảnh phải là mảng',
        'array.max': 'Không được đăng tải quá {#limit} hình ảnh',
      }),
  }),

  /**
   * Validate khi upvote/downvote đánh giá
   */
  voteReview: Joi.object({
    vote: Joi.number().valid(1, -1).required().messages({
      'number.base': 'Vote phải là số',
      'any.only': 'Vote chỉ có thể là 1 (upvote) hoặc -1 (downvote)',
      'any.required': 'Vote là bắt buộc',
    }),
  }),

  /**
   * Validate khi báo cáo đánh giá
   */
  reportReview: Joi.object({
    reason: Joi.string()
      .valid('spam', 'offensive', 'inappropriate', 'misleading', 'other')
      .required()
      .messages({
        'string.base': 'Lý do phải là chuỗi',
        'string.empty': 'Lý do không được để trống',
        'any.only': 'Lý do không hợp lệ',
        'any.required': 'Lý do là bắt buộc',
      }),

    description: Joi.string()
      .max(500)
      .when('reason', {
        is: 'other',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'Mô tả phải là chuỗi',
        'string.empty': 'Mô tả không được để trống',
        'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
        'any.required': 'Mô tả là bắt buộc khi lý do là "other"',
      }),
  }),

  /**
   * Validate khi kiểm duyệt đánh giá
   */
  moderateReview: Joi.object({
    action: Joi.string().valid('approve', 'reject').required().messages({
      'string.base': 'Hành động phải là chuỗi',
      'string.empty': 'Hành động không được để trống',
      'any.only': 'Hành động phải là "approve" hoặc "reject"',
      'any.required': 'Hành động là bắt buộc',
    }),

    reason: Joi.string()
      .max(500)
      .when('action', {
        is: 'reject',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'Lý do phải là chuỗi',
        'string.empty': 'Lý do không được để trống',
        'string.max': 'Lý do không được vượt quá {#limit} ký tự',
        'any.required': 'Lý do là bắt buộc khi từ chối đánh giá',
      }),
  }),

  /**
   * Validate khi thêm phản hồi cho đánh giá
   */
  addReviewResponse: Joi.object({
    content: Joi.string().min(2).max(1000).required().messages({
      'string.base': 'Nội dung phản hồi phải là chuỗi',
      'string.empty': 'Nội dung phản hồi không được để trống',
      'string.min': 'Nội dung phản hồi phải có ít nhất {#limit} ký tự',
      'string.max': 'Nội dung phản hồi không được vượt quá {#limit} ký tự',
      'any.required': 'Nội dung phản hồi là bắt buộc',
    }),
  }),
};

module.exports = { reviewValidator };


--- File: common/validators/userValidator.js ---
/**
 * User Validator
 * Định nghĩa các validation rules cho user API
 */

const Joi = require('joi');

const userValidator = {
  /**
   * Validate khi đăng ký người dùng mới
   */
  register: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên phải là chuỗi',
      'string.empty': 'Tên không được để trống',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
      'any.required': 'Tên là bắt buộc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu phải là chuỗi',
        'string.empty': 'Mật khẩu không được để trống',
        'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar phải là chuỗi',
      'string.uri': 'Avatar phải là một URL hợp lệ',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en').default('vi'),
      notifications: Joi.object({
        email: Joi.boolean().default(true),
        marketing: Joi.boolean().default(true),
      }).default({
        email: true,
        marketing: true,
      }),
    })
      .optional()
      .default({
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      }),
  }),

  /**
   * Validate khi đăng nhập
   */
  login: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string().required().messages({
      'string.base': 'Mật khẩu phải là chuỗi',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là bắt buộc',
    }),

    rememberMe: Joi.boolean().default(false),
  }),

  /**
   * Validate khi yêu cầu đặt lại mật khẩu
   */
  forgotPassword: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),
  }),

  /**
   * Validate khi đặt lại mật khẩu
   */
  resetPassword: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token phải là chuỗi',
      'string.empty': 'Token không được để trống',
      'any.required': 'Token là bắt buộc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu phải là chuỗi',
        'string.empty': 'Mật khẩu không được để trống',
        'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),
  }),

  /**
   * Validate khi cập nhật thông tin người dùng
   */
  updateProfile: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên phải là chuỗi',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar phải là chuỗi',
      'string.uri': 'Avatar phải là một URL hợp lệ',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en'),
      notifications: Joi.object({
        email: Joi.boolean(),
        marketing: Joi.boolean(),
      }),
    }).optional(),
  }),

  /**
   * Validate khi thay đổi mật khẩu
   */
  changePassword: Joi.object({
    currentPassword: Joi.string().required().messages({
      'string.base': 'Mật khẩu hiện tại phải là chuỗi',
      'string.empty': 'Mật khẩu hiện tại không được để trống',
      'any.required': 'Mật khẩu hiện tại là bắt buộc',
    }),

    newPassword: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu mới phải là chuỗi',
        'string.empty': 'Mật khẩu mới không được để trống',
        'string.min': 'Mật khẩu mới phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu mới không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu mới phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu mới là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('newPassword')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu mới',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),
  }),

  /**
   * Validate khi xác thực email
   */
  verifyEmail: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token phải là chuỗi',
      'string.empty': 'Token không được để trống',
      'any.required': 'Token là bắt buộc',
    }),
  }),

  /**
   * Validate khi admin cập nhật người dùng
   */
  adminUpdateUser: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên phải là chuỗi',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
    }),

    email: Joi.string().email().messages({
      'string.base': 'Email phải là chuỗi',
      'string.email': 'Email không hợp lệ',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').messages({
      'string.base': 'Vai trò phải là chuỗi',
      'any.only': 'Vai trò không hợp lệ',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'Trạng thái hoạt động phải là boolean',
    }),

    emailVerified: Joi.boolean().messages({
      'boolean.base': 'Trạng thái xác thực email phải là boolean',
    }),
  }),

  /**
   * Validate khi tạo người dùng mới (bởi admin)
   */
  adminCreateUser: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên phải là chuỗi',
      'string.empty': 'Tên không được để trống',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
      'any.required': 'Tên là bắt buộc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string().min(8).max(64).required().messages({
      'string.base': 'Mật khẩu phải là chuỗi',
      'string.empty': 'Mật khẩu không được để trống',
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
      'any.required': 'Mật khẩu là bắt buộc',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').default('user').messages({
      'string.base': 'Vai trò phải là chuỗi',
      'any.only': 'Vai trò không hợp lệ',
    }),

    isActive: Joi.boolean().default(true).messages({
      'boolean.base': 'Trạng thái hoạt động phải là boolean',
    }),

    emailVerified: Joi.boolean().default(false).messages({
      'boolean.base': 'Trạng thái xác thực email phải là boolean',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),
  }),
};

module.exports =  userValidator ;


--- File: config/database.js ---
const mongoose = require('mongoose');
const logger = require('./logger');
const { setupIndexes } = require('./indexes');
// Tùy chọn kết nối Mongoose
const options = {
  autoIndex: process.env.NODE_ENV !== 'production', // Tự động tạo index trong môi trường dev
  serverSelectionTimeoutMS: 5000, // Timeout cho việc lựa chọn server
  socketTimeoutMS: 45000, // Đóng socket sau 45 giây không hoạt động
  family: 4, // Sử dụng IPv4, bỏ qua IPv6
};

// Kết nối đến MongoDB
const connectToDatabase = async () => {
  try {
    // Xác định URI dựa vào môi trường
    const uri =
      process.env.NODE_ENV === 'test' ? process.env.MONGODB_URI_TEST : process.env.MONGODB_URI;

    await mongoose.connect(uri, options);

    logger.info('Kết nối thành công đến MongoDB');
    setupIndexes();
    // Xử lý sự kiện khi kết nối bị ngắt
    mongoose.connection.on('disconnected', () => {
      logger.warn('Mất kết nối MongoDB, đang thử kết nối lại...');
      setTimeout(connectToDatabase, 5000);
    });

    // Xử lý sự kiện khi có lỗi
    mongoose.connection.on('error', (err) => {
      logger.error(`Lỗi kết nối MongoDB: ${err.message}`);
    });

    return mongoose.connection;
  } catch (error) {
    logger.error(`Không thể kết nối đến MongoDB: ${error.message}`);
    process.exit(1);
  }
};

// Ngắt kết nối từ MongoDB
const disconnectFromDatabase = async () => {
  try {
    await mongoose.disconnect();
    logger.info('Đã ngắt kết nối từ MongoDB');
  } catch (error) {
    logger.error(`Lỗi khi ngắt kết nối từ MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = {
  connectToDatabase,
  disconnectFromDatabase,
};


--- File: config/environment.js ---
/**
 * Cấu hình biến môi trường
 * @author Steve
 * @project RunOut-Biliard
 */

// Load biến môi trường từ file .env
require('dotenv').config();

// Lấy biến môi trường hoặc giá trị mặc định
const getEnv = (key, defaultValue = undefined) => {
  return process.env[key] || defaultValue;
};

// Biến môi trường
const environment = {
  // Thông tin ứng dụng
  app: {
    name: getEnv('APP_NAME', 'RunOut-Biliard'),
    signature: getEnv('SIGNATURE', 'Steve'),
    environment: getEnv('NODE_ENV', 'development'),
    port: parseInt(getEnv('PORT', '5000'), 10),
    host: getEnv('HOST', 'localhost'),
  },

  // Cơ sở dữ liệu
  db: {
    uri: getEnv('MONGODB_URI', 'mongodb://localhost:27017/runout_biliard'),
    uriTest: getEnv('MONGODB_URI_TEST', 'mongodb://localhost:27017/runout_biliard_test'),
  },

  // Xác thực
  auth: {
    jwtSecret: getEnv('JWT_SECRET', 'your_jwt_secret_key_here'),
    jwtExpiresIn: getEnv('JWT_EXPIRES_IN', '7d'),
    jwtRefreshSecret: getEnv('JWT_REFRESH_SECRET', 'your_refresh_secret_key_here'),
    jwtRefreshExpiresIn: getEnv('JWT_REFRESH_EXPIRES_IN', '30d'),
  },

  // CORS
  cors: {
    origin: getEnv('CORS_ORIGIN', 'http://localhost:3000'),
    methods: getEnv('CORS_METHODS', 'GET,HEAD,PUT,PATCH,POST,DELETE'),
  },

  // Logging
  logging: {
    level: getEnv('LOG_LEVEL', 'info'),
    colorize: getEnv('NODE_ENV', 'development') === 'development',
  },

  // Đường dẫn tĩnh
  paths: {
    uploads: getEnv('UPLOAD_PATH', 'uploads'),
  },

  // Thanh toán
  payment: {
    vnpay: {
      tmnCode: getEnv('VNPAY_TMN_CODE', ''),
      secretKey: getEnv('VNPAY_SECRET_KEY', ''),
      returnUrl: getEnv('VNPAY_RETURN_URL', 'http://localhost:5000/api/payments/vnpay-return'),
      ipnUrl: getEnv('VNPAY_IPN_URL', 'http://localhost:5000/api/payments/vnpay-ipn'),
    },
  },

  // Redis
  redis: {
    url: getEnv('REDIS_URL', 'redis://localhost:6379'),
  },
  // Email
  email: {
    host: getEnv('EMAIL_HOST', 'smtp.example.com'),
    port: parseInt(getEnv('EMAIL_PORT', '587'), 10),
    secure: getEnv('EMAIL_SECURE', 'false') === 'true',
    user: getEnv('EMAIL_USER', 'example@example.com'),
    pass: getEnv('EMAIL_PASS', 'password'),
  },
};

// Validate các biến môi trường quan trọng
const validateEnvironment = () => {
  // Kiểm tra biến môi trường quan trọng
  if (environment.app.environment === 'production') {
    if (!process.env.JWT_SECRET) {
      throw new Error('JWT_SECRET không được cấu hình cho môi trường production');
    }

    if (!process.env.MONGODB_URI) {
      throw new Error('MONGODB_URI không được cấu hình cho môi trường production');
    }
  }
};

// Nếu ở môi trường production, validate các biến môi trường
if (environment.app.environment === 'production') {
  validateEnvironment();
}

module.exports = environment;


--- File: config/fix-indexes.js ---
/**
 * Script để sửa lỗi chỉ mục trùng lặp trong MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');
require('dotenv').config();

async function dropIndexes() {
  try {
    logger.info('Kết nối đến MongoDB để sửa lỗi chỉ mục...');
    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('Kết nối thành công!');

    // Lấy danh sách tất cả các collection trong database
    const collections = await mongoose.connection.db.listCollections().toArray();
    const collectionNames = collections.map((c) => c.name);

    logger.info(`Tìm thấy ${collectionNames.length} collection: ${collectionNames.join(', ')}`);

    // Xử lý từng collection
    for (const collectionName of collectionNames) {
      // Bỏ qua các collection hệ thống
      if (collectionName.startsWith('system.')) {
        logger.info(`Bỏ qua collection hệ thống: ${collectionName}`);
        continue;
      }

      try {
        const collection = mongoose.connection.collection(collectionName);

        // Lấy danh sách tất cả chỉ mục
        const indexes = await collection.indexes();
        logger.info(`Collection ${collectionName}: Tìm thấy ${indexes.length} chỉ mục`);

        // Log tất cả các chỉ mục để tham khảo
        indexes.forEach((index) => {
          logger.info(
            `- Chỉ mục: ${index.name}, Key: ${JSON.stringify(index.key)}, Options: ${JSON.stringify(index)}`
          );
        });

        // Xóa tất cả các chỉ mục trừ _id
        const dropPromises = indexes
          .filter((index) => index.name !== '_id_') // Giữ lại chỉ mục _id
          .map((index) => {
            logger.info(`Đang xóa chỉ mục: ${index.name} trong collection ${collectionName}`);
            return collection
              .dropIndex(index.name)
              .then(() => logger.info(`Đã xóa thành công chỉ mục ${index.name}`))
              .catch((err) => logger.error(`Không thể xóa chỉ mục ${index.name}: ${err.message}`));
          });

        await Promise.all(dropPromises);
        logger.info(`Đã xóa tất cả chỉ mục trừ _id trong collection ${collectionName}`);
      } catch (collectionError) {
        logger.error(`Lỗi khi xử lý collection ${collectionName}: ${collectionError.message}`);
      }
    }

    logger.info('Hoàn tất xóa chỉ mục. Hãy khởi động lại ứng dụng để tạo lại chỉ mục hợp lệ.');
    await mongoose.disconnect();
    logger.info('Đã ngắt kết nối MongoDB');
  } catch (error) {
    logger.error(`Lỗi khi xóa chỉ mục: ${error.message}`);
    throw error;
  }
}

// Chạy script
dropIndexes();


--- File: config/indexes.js ---
/**
 * Cấu hình thiết lập chỉ mục cho MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');

/**
 * Kiểm tra xem chỉ mục có tồn tại chưa
 * @param {Object} collection - Collection MongoDB
 * @param {Object} indexSpec - Chỉ mục cần kiểm tra
 * @returns {Promise<boolean>} - true nếu chỉ mục đã tồn tại
 */
async function indexExists(collection, indexSpec) {
  try {
    const indexes = await collection.indexes();

    // So sánh cấu trúc chỉ mục (chỉ dựa trên các trường)
    const keyString = JSON.stringify(Object.keys(indexSpec).sort());

    for (const index of indexes) {
      const existingKeyString = JSON.stringify(Object.keys(index.key).sort());
      if (existingKeyString === keyString) {
        return true;
      }
    }

    return false;
  } catch (error) {
    logger.error(`Lỗi khi kiểm tra chỉ mục: ${error.message}`);
    return false;
  }
}

/**
 * Thiết lập chỉ mục cho các collection
 */
async function setupIndexes() {
  try {
    logger.info('Thiết lập chỉ mục cơ sở dữ liệu...');

    // Chỉ mục đặc biệt cho Product (text search)
    try {
      const Product = mongoose.model('Product');
      const productCollection = Product.collection;

      const textIndexSpec = {
        name: 'text',
        'description.short': 'text',
        'description.long': 'text',
        brand: 'text',
      };

      // Kiểm tra xem chỉ mục text đã tồn tại chưa
      const productIndexes = await productCollection.indexes();
      const hasTextIndex = productIndexes.some((idx) => idx.textIndexVersion);

      if (!hasTextIndex) {
        logger.info('Tạo chỉ mục text cho collection Product');
        await Product.collection.createIndex(textIndexSpec, {
          weights: {
            name: 10,
            'description.short': 5,
            'description.long': 3,
            brand: 3,
          },
          name: 'product_text_search',
        });
      } else {
        logger.info('Chỉ mục text cho collection Product đã tồn tại, bỏ qua tạo mới');
      }
    } catch (productError) {
      logger.error(`Không thể thiết lập chỉ mục text cho Product: ${productError.message}`);
    }

    // KHÔNG TẠO THÊM CHỈ MỤC TẠI ĐÂY
    // Để các model tự tạo chỉ mục của mình khi khởi động

    logger.info('Hoàn tất thiết lập chỉ mục');
    return true;
  } catch (error) {
    logger.error(`Lỗi khi thiết lập chỉ mục: ${error.message}`);
    throw error;
  }
}

module.exports = { setupIndexes };


--- File: config/logger.js ---
const winston = require('winston');
const path = require('path');

// Định nghĩa các levels của logger
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Chọn level dựa trên môi trường
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  const isDevelopment = env === 'development';
  return isDevelopment ? 'debug' : 'warn';
};

// Tùy chỉnh format cho logs
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf((info) => `${info.timestamp} ${info.level}: ${info.message}`)
);

// Định nghĩa các transports cho logger
const transports = [
  // Ghi log đến console
  new winston.transports.Console(),

  // Ghi log errors vào file
  new winston.transports.File({
    filename: path.join('logs', 'error.log'),
    level: 'error',
  }),

  // Ghi tất cả logs vào file
  new winston.transports.File({
    filename: path.join('logs', 'all.log'),
  }),
];

// Tạo logger với các tùy chọn đã định nghĩa
const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
  // Thêm metadata custom để nhận diện ứng dụng
  defaultMeta: {
    service: process.env.APP_NAME || 'runout-biliard',
    signature: process.env.SIGNATURE || 'Steve',
  },
});

module.exports = logger;


--- File: config/middleware.js ---
/**
 * Cấu hình middleware
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const { rateLimit } = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const csrf = require('csurf');
const environment = require('./environment');
const logger = require('./logger');

/**
 * Cấu hình và áp dụng các middleware cơ bản cho ứng dụng Express
 * @param {express.Application} app - Ứng dụng Express
 */
const setupCommonMiddleware = (app) => {
  // Security middleware
  app.use(
    helmet({
      contentSecurityPolicy: environment.app.environment === 'production',
      crossOriginEmbedderPolicy: environment.app.environment === 'production',
      crossOriginOpenerPolicy: environment.app.environment === 'production',
      crossOriginResourcePolicy: environment.app.environment === 'production',
    })
  ); // Bảo mật HTTP headers

  // CORS middleware
  app.use(
    cors({
      origin: environment.cors.origin,
      methods: environment.cors.methods.split(','),
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'CSRF-Token'],
      exposedHeaders: ['Content-Disposition', 'CSRF-Token'],
      credentials: true,
      maxAge: 86400, // 24 giờ
    })
  );

  // Body parsing middleware
  app.use(express.json({ limit: '10kb' })); // Limit JSON body size
  app.use(express.urlencoded({ extended: true, limit: '10kb' }));

  // Cookie parsing middleware
  app.use(cookieParser(environment.app.cookieSecret));

  // Compression middleware
  app.use(compression());

  // Logger middleware
  if (environment.app.environment === 'development') {
    app.use(morgan('dev'));
  } else {
    // Sử dụng winston cho production
    app.use(
      morgan('combined', {
        stream: {
          write: (message) => logger.http(message.trim()),
        },
      })
    );
  }
};

/**
 * Cấu hình middleware bảo mật bổ sung
 * @param {express.Application} app - Ứng dụng Express
 */
const setupSecurityMiddleware = (app) => {
  // Rate limiting middleware
  const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 phút
    max: 100, // Limit mỗi IP 100 requests mỗi windowMs
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Quá nhiều yêu cầu từ IP này, vui lòng thử lại sau 15 phút',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // Áp dụng rate limit cho tất cả các routes /api
  app.use('/api', apiLimiter);

  // Middleware chống brute force cho authentication
  const authLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 giờ
    max: 5, // Giới hạn 5 lần thử trong 1 giờ
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Quá nhiều lần thử đăng nhập, vui lòng thử lại sau 1 giờ',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Auth rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // Áp dụng auth limiter cho routes đăng nhập/đăng ký
  app.use('/api/auth/login', authLimiter);
  app.use('/api/auth/register', authLimiter);

  // CSRF protection middleware
  if (environment.app.environment === 'production') {
    const csrfProtection = csrf({ cookie: true });

    // Áp dụng CSRF protection cho các routes không phải API public
    app.use('/api/admin', csrfProtection);
    app.use('/api/user', csrfProtection);

    // Middleware để cung cấp CSRF token
    app.get('/api/csrf-token', csrfProtection, (req, res) => {
      res.json({ csrfToken: req.csrfToken() });
    });
  }
};

/**
 * Setup middleware xử lý lỗi
 * @param {express.Application} app - Ứng dụng Express
 */
const setupErrorHandlingMiddleware = (app) => {
  // Middleware xử lý 404 - Phải đặt sau tất cả các routes
  app.use((req, res, next) => {
    res.status(404).json({
      status: 'error',
      message: 'Không tìm thấy tài nguyên yêu cầu',
    });
    next(); // Gọi next() để chuyển sang middleware tiếp theo
  });

  // Middleware xử lý lỗi toàn cục
  app.use((err, req, res, next) => {
    // Xử lý lỗi CSRF
    if (err.code === 'EBADCSRFTOKEN') {
      logger.error(`CSRF attack detected from IP: ${req.ip}`);
      return res.status(403).json({
        status: 'error',
        message: 'Phiên làm việc không hợp lệ, vui lòng thử lại',
      });
    }

    // Log lỗi
    logger.error(`Error: ${err.message}`, {
      stack: err.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
    });

    // Trả về lỗi cho client
    const statusCode = err.statusCode || 500;
    const message =
      environment.app.environment === 'production' && statusCode === 500
        ? 'Đã xảy ra lỗi, vui lòng thử lại sau'
        : err.message;

    res.status(statusCode).json({
      status: 'error',
      message,
      ...(environment.app.environment !== 'production' && { stack: err.stack }),
    });

    next(); // Thêm câu lệnh gọi next() sau khi xử lý lỗi toàn cục
  });
};

/**
 * Setup tất cả middleware
 * @param {express.Application} app - Ứng dụng Express
 */
const setupAllMiddleware = (app) => {
  setupCommonMiddleware(app);
  setupSecurityMiddleware(app);

  // Middleware cho static files
  app.use('/uploads', express.static(environment.paths.uploads));

  // Middleware thêm signature cho tất cả các responses
  app.use((req, res, next) => {
    res.setHeader('X-Powered-By', `RunOut-Biliard - ${environment.app.signature}`);
    next();
  });

  // Middleware xử lý lỗi phải được đặt cuối cùng
  // Lưu ý: Phải gọi sau khi đã thiết lập tất cả các routes
};

module.exports = {
  setupCommonMiddleware,
  setupSecurityMiddleware,
  setupErrorHandlingMiddleware,
  setupAllMiddleware,
};


--- File: config/monitoring.js ---
// server/src/config/monitoring.js (mẫu)
const mongoose = require('mongoose');
const logger = require('./logger');

function setupMongoMonitoring() {
  // Monitor connection events
  mongoose.connection.on('connected', () => {
    logger.info('MongoDB connected');
  });

  mongoose.connection.on('error', (err) => {
    logger.error('MongoDB connection error:', err);
  });

  mongoose.connection.on('disconnected', () => {
    logger.warn('MongoDB disconnected');
  });

  // Monitor DB operations in development
  if (process.env.NODE_ENV === 'development') {
    mongoose.set('debug', (collection, method, query, doc) => {
      logger.debug(`MongoDB ${collection}.${method}`, { query, doc });
    });
  }
}

module.exports = { setupMongoMonitoring };


--- File: data/dto/cartDTO.js ---
// server/src/data/dto/cartDTO.js
class CartDTO {
  constructor(cart) {
    this.id = cart._id;
    this.items = cart.items.map((item) => ({
      id: item._id,
      product: item.product,
      quantity: item.quantity,
      price: item.price,
      attributes: item.attributes,
      addedAt: item.addedAt,
      updatedAt: item.updatedAt,
      totalPrice: item.price * item.quantity,
    }));

    this.subtotal = cart.subtotal;
    this.coupon = cart.coupon;
    this.totalItems = cart.items.reduce((sum, item) => sum + item.quantity, 0);
    this.lastActivity = cart.lastActivity;
    this.updatedAt = cart.updatedAt;
  }

  static fromEntity(cart) {
    return new CartDTO(cart);
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    delete entity.totalItems;

    if (entity.items) {
      entity.items = entity.items.map((item) => {
        const itemEntity = { ...item };
        delete itemEntity.id;
        delete itemEntity.totalPrice;
        return itemEntity;
      });
    }

    return entity;
  }
}

module.exports = CartDTO;


--- File: data/dto/categoryDTO.js ---
// server/src/data/dto/categoryDTO.js
class CategoryDTO {
  constructor(category) {
    this.id = category._id;
    this.name = category.name;
    this.slug = category.slug;
    this.description = category.description;
    this.parent = category.parent;
    this.ancestors = category.ancestors;
    this.level = category.level;
    this.image = category.image;
    this.icon = category.icon;
    this.order = category.order;
    this.isActive = category.isActive;
    this.isVisible = category.isVisible;
    this.createdAt = category.createdAt;
    this.updatedAt = category.updatedAt;
    this.children = category.children || [];
    this.meta = category.meta || {};
    this.meta.title = category.meta?.title || '';
    this.meta.description = category.meta?.description || '';
    this.meta.keywords = category.meta?.keywords || '';
    this.meta.robots = category.meta?.robots || '';
    this.meta.canonical = category.meta?.canonical || '';
  }

  static fromEntity(category) {
    return new CategoryDTO(category);
  }

  static fromEntities(categories) {
    return categories.map((category) => CategoryDTO.fromEntity(category));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  static fromTree(categoryTree) {
    return categoryTree.map((category) => {
      const dto = CategoryDTO.fromEntity(category);
      if (category.children && category.children.length > 0) {
        dto.children = CategoryDTO.fromTree(category.children);
      }
      return dto;
    });
  }
}

module.exports = CategoryDTO;


--- File: data/dto/orderDTO.js ---
// server/src/data/dto/orderDTO.js
class OrderDTO {
  constructor(order) {
    this.id = order._id;
    this.orderNumber = order.orderNumber;
    this.customerInfo = order.customerInfo;
    this.items = order.items;
    this.subtotal = order.subtotal;
    this.shippingCost = order.shippingCost;
    this.tax = order.tax;
    this.discount = order.discount;
    this.totalAmount = order.totalAmount;
    this.shippingAddress = order.shippingAddress;
    this.shippingMethod = order.shippingMethod;
    this.trackingNumber = order.trackingNumber;
    this.paymentMethod = order.paymentMethod;
    this.paymentStatus = order.paymentStatus;
    this.paymentDetails = order.paymentDetails;
    this.status = order.status;
    this.statusHistory = order.statusHistory;
    this.customerNotes = order.customerNotes;
    this.createdAt = order.createdAt;
    this.updatedAt = order.updatedAt;
    this.completedAt = order.completedAt;
    this.cancelledAt = order.cancelledAt;
  }

  static fromEntity(order) {
    return new OrderDTO(order);
  }

  static fromEntities(orders) {
    return orders.map((order) => OrderDTO.fromEntity(order));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }
}

module.exports = OrderDTO;


--- File: data/dto/productDTO.js ---
// server/src/data/dto/productDTO.js

/**
 * ProductDTO
 * Đối tượng chuyển đổi dữ liệu cho sản phẩm
 */
class ProductDTO {
  /**
   * Khởi tạo đối tượng ProductDTO
   * @param {Object} product - Đối tượng sản phẩm từ database
   */
  constructor(product) {
    this.product = product;

    if (product) {
      this.id = product._id;
      this.name = product.name;
      this.slug = product.slug;
      this.description = product.description;
      this.detailedDescription = product.detailedDescription;
      this.price = product.price;
      this.salePrice = product.salePrice;
      this.currency = product.currency || 'VND';
      this.stock = product.stock;
      this.categories = product.categories;
      this.images = product.images;
      this.attributes = product.attributes;
      this.status = product.status;
      this.featured = product.featured;
      this.sku = product.sku;
      this.brand = product.brand;
      this.createdAt = product.createdAt;
      this.updatedAt = product.updatedAt;
    }
  }

  /**
   * Tạo DTO từ entity
   * @param {Object} product - Entity sản phẩm
   * @returns {ProductDTO} - Đối tượng DTO
   */
  static fromEntity(product) {
    return new ProductDTO(product);
  }

  /**
   * Tạo danh sách DTO từ danh sách entity
   * @param {Array} products - Danh sách entity sản phẩm
   * @returns {Array} - Danh sách DTO
   */
  static fromEntities(products) {
    return products.map((product) => ProductDTO.fromEntity(product));
  }

  /**
   * Chuyển đổi DTO thành entity
   * @param {ProductDTO} dto - Đối tượng DTO
   * @returns {Object} - Entity sản phẩm
   */
  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  /**
   * Chuyển đổi đối tượng sản phẩm thành JSON
   * @returns {Object} - Đối tượng JSON chứa thông tin sản phẩm
   */
  toJSON() {
    if (!this.product) return null;

    // Lấy dữ liệu từ đối tượng sản phẩm
    const {
      _id,
      name,
      slug,
      description,
      detailedDescription,
      price,
      salePrice,
      currency,
      stock,
      categories,
      images,
      attributes,
      status,
      featured,
      sku,
      brand,
      weight,
      dimensions,
      tags,
      warranty,
      soldCount,
      viewCount,
      createdAt,
      updatedAt,
    } = this.product;

    // Biến đổi dữ liệu
    return {
      id: _id.toString(),
      name,
      slug,
      description,
      detailedDescription,
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        currency: currency || 'VND',
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inventory: {
        stock,
        inStock: stock > 0,
        status: stock > 0 ? 'Còn hàng' : 'Hết hàng',
      },
      categories: Array.isArray(categories)
        ? categories.map((cat) =>
            typeof cat === 'object' && cat._id ? cat._id.toString() : cat.toString()
          )
        : [],
      images: this._formatImages(images),
      mainImage: this._getMainImage(images),
      attributes: attributes || [],
      status,
      featured,
      sku,
      brand,
      specifications: {
        weight: weight || null,
        dimensions: dimensions || null,
      },
      tags: tags || [],
      warranty: warranty || null,
      stats: {
        soldCount: soldCount || 0,
        viewCount: viewCount || 0,
      },
      dates: {
        created: createdAt,
        updated: updatedAt,
      },
    };
  }

  /**
   * Tạo DTO cho danh sách sản phẩm
   * @param {Array} products - Danh sách sản phẩm
   * @returns {Array} - Danh sách DTO
   */
  static toJSONList(products) {
    if (!Array.isArray(products)) return [];
    return products.map((product) => new ProductDTO(product).toJSON());
  }

  /**
   * Tạo phiên bản rút gọn của DTO cho hiển thị trong danh sách
   * @returns {Object} - Đối tượng JSON rút gọn
   */
  toSummaryJSON() {
    if (!this.product) return null;

    const {
      _id,
      name,
      slug,
      description,
      price,
      salePrice,
      stock,
      images,
      status,
      featured,
      soldCount,
      createdAt,
    } = this.product;

    return {
      id: _id.toString(),
      name,
      slug,
      shortDescription: this._truncateText(description, 100),
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inStock: stock > 0,
      mainImage: this._getMainImage(images),
      status,
      featured,
      soldCount: soldCount || 0,
      createdAt,
    };
  }

  /**
   * Tạo phiên bản chi tiết đầy đủ, bao gồm cả đánh giá và danh mục
   * @param {Array} reviews - Danh sách đánh giá
   * @param {Array} categoryDetails - Thông tin chi tiết danh mục
   * @returns {Object} - Đối tượng JSON chi tiết
   */
  toDetailedJSON(reviews = [], categoryDetails = []) {
    const baseDTO = this.toJSON();

    // Thêm thông tin đánh giá
    baseDTO.reviews = reviews;
    baseDTO.averageRating =
      reviews.length > 0
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
        : 0;

    // Thêm thông tin chi tiết danh mục
    baseDTO.categoryDetails = categoryDetails;

    // Thêm sản phẩm liên quan nếu có
    if (this.relatedProducts) {
      baseDTO.relatedProducts = this.relatedProducts;
    }

    return baseDTO;
  }

  /**
   * Thiết lập sản phẩm liên quan
   * @param {Array} relatedProducts - Danh sách sản phẩm liên quan
   */
  setRelatedProducts(relatedProducts) {
    this.relatedProducts = ProductDTO.toJSONList(relatedProducts);
    return this;
  }

  /**
   * Tính phần trăm giảm giá
   * @param {Number} price - Giá gốc
   * @param {Number} salePrice - Giá khuyến mãi
   * @returns {Number} - Phần trăm giảm giá
   * @private
   */
  _calculateDiscount(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return Math.round(((price - salePrice) / price) * 100);
    }
    return 0;
  }

  /**
   * Lấy giá cuối cùng (sau giảm giá nếu có)
   * @param {Number} price - Giá gốc
   * @param {Number} salePrice - Giá khuyến mãi
   * @returns {Number} - Giá cuối cùng
   * @private
   */
  _getFinalPrice(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return salePrice;
    }
    return price;
  }

  /**
   * Định dạng danh sách hình ảnh
   * @param {Array} images - Danh sách hình ảnh
   * @returns {Array} - Danh sách hình ảnh đã định dạng
   * @private
   */
  _formatImages(images) {
    if (!images || !Array.isArray(images)) return [];

    return images.map((image) => {
      // Nếu image là string (url)
      if (typeof image === 'string') {
        return {
          url: image,
          alt: this.product.name,
          isMain: false,
        };
      }

      // Nếu image là object
      return {
        url: image.url,
        alt: image.alt || this.product.name,
        isMain: !!image.isMain,
      };
    });
  }

  /**
   * Lấy hình ảnh chính của sản phẩm
   * @param {Array} images - Danh sách hình ảnh
   * @returns {String} - URL hình ảnh chính
   * @private
   */
  _getMainImage(images) {
    if (!images || !Array.isArray(images) || images.length === 0) {
      return null;
    }

    // Tìm hình ảnh được đánh dấu là chính
    const mainImage = images.find((img) => {
      if (typeof img === 'object' && img.isMain) {
        return true;
      }
      return false;
    });

    // Nếu có hình ảnh chính, trả về URL
    if (mainImage) {
      return typeof mainImage === 'string' ? mainImage : mainImage.url;
    }

    // Nếu không có hình ảnh chính, lấy hình ảnh đầu tiên
    const firstImage = images[0];
    return typeof firstImage === 'string' ? firstImage : firstImage.url;
  }

  /**
   * Cắt ngắn văn bản
   * @param {String} text - Văn bản
   * @param {Number} maxLength - Độ dài tối đa
   * @returns {String} - Văn bản đã cắt ngắn
   * @private
   */
  _truncateText(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.substring(0, maxLength) + '...';
  }
}

module.exports = ProductDTO;


--- File: data/dto/reviewDTO.js ---
// server/src/data/dto/reviewDTO.js
class ReviewDTO {
  constructor(review) {
    this.id = review._id;
    this.product = review.product;
    this.user = review.user;
    this.rating = review.rating;
    this.title = review.title;
    this.review = review.review;
    this.images = review.images;
    this.isVerifiedPurchase = review.isVerifiedPurchase;
    this.helpfulness = {
      upvotes: review.helpfulness.upvotes,
      downvotes: review.helpfulness.downvotes,
    };
    this.responses = review.responses.map((response) => ({
      id: response._id,
      user: response.user,
      isAdmin: response.isAdmin,
      content: response.content,
      createdAt: response.createdAt,
      updatedAt: response.updatedAt,
    }));
    this.createdAt = review.createdAt;
  }

  static fromEntity(review) {
    return new ReviewDTO(review);
  }

  static fromEntities(reviews) {
    return reviews.map((review) => ReviewDTO.fromEntity(review));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;

    if (entity.responses) {
      entity.responses = entity.responses.map((response) => {
        const responseEntity = { ...response };
        delete responseEntity.id;
        return responseEntity;
      });
    }

    return entity;
  }
}

module.exports = ReviewDTO;


--- File: data/dto/userDTO.js ---
/**
 * DTO cho User - chuyển đổi dữ liệu giữa service layer và client
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Class UserDTO - chuyển đổi dữ liệu User cho response
 */
class UserDTO {
  /**
   * Chuyển đổi từ model User sang DTO
   * @param {Object} user - User model
   * @returns {Object} - User DTO
   */
  static toDTO(user) {
    if (!user) return null;

    // Chuyển đổi user model thành plain object nếu chưa phải
    const userObj = user.toObject ? user.toObject() : user;

    return {
      id: userObj._id.toString(),
      name: userObj.name,
      email: userObj.email,
      role: userObj.role,
      avatar: userObj.avatar,
      phone: userObj.phone || '',
      address: userObj.address || {},
      isActive: userObj.isActive,
      emailVerified: userObj.emailVerified,
      lastLogin: userObj.lastLogin,
      loginCount: userObj.loginCount,
      preferences: userObj.preferences || {
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      },
      createdAt: userObj.createdAt,
      updatedAt: userObj.updatedAt,
    };
  }

  /**
   * Chuyển đổi một mảng User models sang DTO
   * @param {Array} users - Mảng User models
   * @returns {Array} - Mảng User DTOs
   */
  static toList(users) {
    if (!users || !Array.isArray(users)) return [];
    return users.map((user) => UserDTO.toDTO(user));
  }

  /**
   * Chuyển đổi dữ liệu phân trang từ service
   * @param {Object} paginatedResult - Kết quả phân trang từ service
   * @returns {Object} - Kết quả phân trang đã chuyển đổi
   */
  static toPagination(paginatedResult) {
    return {
      data: UserDTO.toList(paginatedResult.data || paginatedResult.users),
      pagination: {
        total: paginatedResult.totalCount || paginatedResult.pagination.total,
        page: paginatedResult.page || paginatedResult.pagination.page,
        limit: paginatedResult.limit || paginatedResult.pagination.limit,
        totalPages: paginatedResult.totalPages || paginatedResult.pagination.totalPages,
        hasNext: paginatedResult.hasNext || paginatedResult.pagination.hasNext,
        hasPrev: paginatedResult.hasPrev || paginatedResult.pagination.hasPrev,
      },
    };
  }

  /**
   * Chuyển đổi dữ liệu cho profile
   * @param {Object} user - User model
   * @returns {Object} - User profile DTO
   */
  static toProfile(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Thêm các thông tin bổ sung cho profile nếu cần
    return {
      ...dto,
      // Có thể thêm các trường khác ở đây
    };
  }

  /**
   * Chuyển đổi dữ liệu cho admin (bao gồm thông tin nhạy cảm hơn)
   * @param {Object} user - User model
   * @returns {Object} - Admin User DTO
   */
  static toAdminDTO(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Thêm các thông tin admin cần
    return {
      ...dto,
      emailVerified: user.emailVerified,
      isActive: user.isActive,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      lastLogin: user.lastLogin,
      loginCount: user.loginCount,
    };
  }
}

module.exports = UserDTO;


--- File: data/models/cart.model.js ---
// server/src/data/models/cart.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CartSchema = new Schema(
  {
    // Thông tin chủ sở hữu
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },
    sessionId: {
      type: String,
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },

    // Danh sách sản phẩm
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        addedAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // Tính toán giá
    subtotal: {
      type: Number,
      default: 0,
    },

    // Mã giảm giá
    coupon: {
      code: String,
      discount: Number,
      appliedAt: Date,
    },

    // Trạng thái
    status: {
      type: String,
      enum: ['active', 'converted', 'abandoned', 'merged'],
      default: 'active',
    },

    // Thời gian hoạt động và hết hạn
    lastActivity: {
      type: Date,
      default: Date.now,
    },
    expiresAt: {
      type: Date,
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },
  },
  {
    timestamps: true,
  }
);

// Indexes - Giữ lại các khai báo chỉ mục rõ ràng và thêm tên
CartSchema.index({ user: 1 }, { sparse: true, name: 'cart_user_idx' });
CartSchema.index({ sessionId: 1 }, { sparse: true, name: 'cart_sessionId_idx' });
CartSchema.index({ status: 1 }, { name: 'cart_status_idx' });
CartSchema.index({ user: 1, status: 1 }, { name: 'cart_user_status_idx' });
CartSchema.index({ sessionId: 1, status: 1 }, { sparse: true, name: 'cart_sessionId_status_idx' });
CartSchema.index(
  { expiresAt: 1 },
  { expireAfterSeconds: 0, sparse: true, name: 'cart_expiresAt_ttl_idx' }
);
CartSchema.index({ 'items.product': 1 }, { name: 'cart_items_product_idx' });

module.exports = mongoose.model('Cart', CartSchema);


--- File: data/models/category.model.js ---
// server/src/data/models/category.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CategorySchema = new Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
    },
    description: String,

    // Cấu trúc phân cấp
    parent: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      default: null,
    },
    ancestors: [
      {
        _id: {
          type: Schema.Types.ObjectId,
          ref: 'Category',
        },
        name: String,
        slug: String,
      },
    ],
    level: {
      type: Number,
      default: 0,
    },

    // Hiển thị
    image: {
      url: String,
      alt: String,
    },
    icon: String,

    // Thứ tự và trạng thái
    order: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    isVisible: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes với tên rõ ràng
CategorySchema.index({ name: 1 }, { name: 'category_name_idx' });
CategorySchema.index({ slug: 1 }, { unique: true, name: 'category_slug_unique_idx' });
CategorySchema.index({ parent: 1 }, { name: 'category_parent_idx' });
CategorySchema.index({ 'ancestors._id': 1 }, { name: 'category_ancestors_idx' });
CategorySchema.index({ level: 1 }, { name: 'category_level_idx' });
CategorySchema.index({ order: 1 }, { name: 'category_order_idx' });
CategorySchema.index({ isActive: 1, isVisible: 1 }, { name: 'category_active_visible_idx' });
CategorySchema.index({ name: 'text', description: 'text' }, { name: 'category_text_search_idx' });

module.exports = mongoose.model('Category', CategorySchema);


--- File: data/models/order.model.js ---
// server/src/data/models/order.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const OrderSchema = new Schema(
  {
    // Thông tin cơ bản
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      // Không cần khai báo index: true ở đây vì đã có trong schema.index()
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // Không cần khai báo index: true ở đây vì đã có trong schema.index()
    },

    // Thông tin liên hệ
    customerInfo: {
      name: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
    },

    // Chi tiết sản phẩm
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        name: {
          type: String,
          required: true,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        totalPrice: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        sku: String,
        image: String,
      },
    ],

    // Tổng tiền
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    shippingCost: {
      type: Number,
      required: true,
      default: 0,
    },
    tax: {
      type: Number,
      required: true,
      default: 0,
    },
    discount: {
      amount: {
        type: Number,
        default: 0,
      },
      code: String,
    },
    totalAmount: {
      type: Number,
      required: true,
      min: 0,
    },

    // Thông tin vận chuyển
    shippingAddress: {
      name: String,
      phone: String,
      street: {
        type: String,
        required: true,
      },
      city: {
        type: String,
        required: true,
      },
      state: String,
      zipCode: {
        type: String,
        required: true,
      },
      country: {
        type: String,
        required: true,
      },
      notes: String,
    },
    shippingMethod: {
      type: String,
      required: true,
    },
    trackingNumber: String,

    // Thông tin thanh toán
    paymentMethod: {
      type: String,
      required: true,
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'authorized', 'paid', 'failed', 'refunded', 'partially_refunded'],
      default: 'pending',
    },
    paymentDetails: {
      provider: String,
      transactionId: String,
      paymentDate: Date,
    },

    // Trạng thái đơn hàng
    status: {
      type: String,
      enum: ['pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned'],
      default: 'pending',
    },

    // Lịch sử trạng thái
    statusHistory: [
      {
        status: {
          type: String,
          enum: [
            'pending',
            'processing',
            'packed',
            'shipped',
            'delivered',
            'cancelled',
            'returned',
          ],
        },
        date: {
          type: Date,
          default: Date.now,
        },
        note: String,
        updatedBy: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
      },
    ],

    // Ghi chú
    customerNotes: String,
    adminNotes: String,

    // Thời gian hoàn thành hoặc hủy
    completedAt: Date,
    cancelledAt: Date,
  },
  {
    timestamps: true,
  }
);

// Indexes
// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Indexes với tên rõ ràng
OrderSchema.index({ orderNumber: 1 }, { unique: true, name: 'order_number_unique_idx' });
OrderSchema.index({ user: 1 }, { name: 'order_user_idx' });
OrderSchema.index({ 'customerInfo.email': 1 }, { name: 'order_customer_email_idx' });
OrderSchema.index({ 'customerInfo.phone': 1 }, { name: 'order_customer_phone_idx' });
OrderSchema.index({ status: 1 }, { name: 'order_status_idx' });
OrderSchema.index({ paymentStatus: 1 }, { name: 'order_payment_status_idx' });
OrderSchema.index({ createdAt: -1 }, { name: 'order_created_desc_idx' });
OrderSchema.index({ completedAt: -1 }, { name: 'order_completed_desc_idx' });
OrderSchema.index({ user: 1, createdAt: -1 }, { name: 'order_user_created_idx' });
OrderSchema.index({ status: 1, createdAt: -1 }, { name: 'order_status_created_idx' });
OrderSchema.index({ 'items.product': 1 }, { name: 'order_items_product_idx' });
module.exports = mongoose.model('Order', OrderSchema);


--- File: data/models/product.model.js ---
// server/src/data/models/product.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

/**
 * Product Model
 * Schema MongoDB cho đối tượng sản phẩm
 */
const ProductSchema = new Schema(
  {
    // Thông tin cơ bản
    name: {
      type: String,
      required: [true, 'Tên sản phẩm là bắt buộc'],
      trim: true,
      maxlength: [200, 'Tên sản phẩm không được vượt quá 200 ký tự'],
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      // Loại bỏ index: true tại đây
    },
    description: {
      short: {
        type: String,
        required: [true, 'Mô tả ngắn sản phẩm là bắt buộc'],
        trim: true,
        maxlength: [500, 'Mô tả ngắn không được vượt quá 500 ký tự'],
      },
      long: {
        type: String,
        trim: true,
      },
    },

    // Danh mục và phân loại
    categories: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Category',
        required: [true, 'Sản phẩm phải thuộc ít nhất một danh mục'],
      },
    ],
    tags: [String],

    // Thương hiệu và nguồn gốc
    brand: {
      type: String,
      required: true,
      trim: true,
    },

    // Giá và tồn kho
    price: {
      type: Number,
      required: [true, 'Giá sản phẩm là bắt buộc'],
      min: [0, 'Giá sản phẩm không được âm'],
    },
    salePrice: {
      type: Number,
      default: 0,
      min: [0, 'Giá khuyến mãi không được âm'],
    },
    currency: {
      type: String,
      default: 'VND',
    },
    stock: {
      type: Number,
      required: [true, 'Số lượng tồn kho là bắt buộc'],
      min: [0, 'Số lượng tồn kho không được âm'],
      default: 0,
    },
    sku: {
      type: String,
      trim: true,
      unique: true,
      sparse: true,
      // Loại bỏ index: true tại đây nếu có
    },

    // Hình ảnh sản phẩm
    images: [
      {
        url: {
          type: String,
          required: true,
        },
        alt: String,
        isMain: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Thuộc tính sản phẩm
    attributes: [
      {
        name: {
          type: String,
          required: true,
        },
        value: {
          type: String,
          required: true,
        },
      },
    ],

    // Đặc điểm sản phẩm
    features: [String],

    // Thông số kỹ thuật
    specifications: {
      weight: Number,
      length: Number,
      diameter: Number,
      material: String,
      tipSize: String,
      wrap: String,
    },

    // Kích thước và trọng lượng
    weight: {
      value: Number,
      unit: {
        type: String,
        default: 'g',
      },
    },
    dimensions: {
      length: Number,
      width: Number,
      height: Number,
      unit: {
        type: String,
        default: 'cm',
      },
    },

    // Bảo hành
    warranty: {
      type: String,
      trim: true,
    },

    // Đánh giá
    ratings: {
      average: {
        type: Number,
        default: 0,
        min: 0,
        max: 5,
      },
      count: {
        type: Number,
        default: 0,
      },
    },

    // Thống kê
    soldCount: {
      type: Number,
      default: 0,
    },
    viewCount: {
      type: Number,
      default: 0,
    },

    // Trạng thái
    status: {
      type: String,
      enum: {
        values: ['active', 'draft', 'discontinued'],
        message: 'Trạng thái phải là: active, draft hoặc discontinued',
      },
      default: 'draft',
    },
    featured: {
      type: Boolean,
      default: false,
    },
    isPromoted: {
      type: Boolean,
      default: false,
    },

    // Thông tin quản lý
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    updatedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Index cho tìm kiếm - giữ lại một chỉ mục text duy nhất
ProductSchema.index(
  {
    name: 'text',
    'description.short': 'text',
    'description.long': 'text',
    brand: 'text',
    'attributes.value': 'text',
  },
  {
    weights: {
      name: 10,
      'description.short': 5,
      'description.long': 3,
      brand: 3,
      'attributes.value': 2,
    },
    name: 'product_text_search_index', // Đặt tên rõ ràng để tránh xung đột
  }
);

// Tạo các index khác để tối ưu truy vấn
// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Tạo các index khác để tối ưu truy vấn
ProductSchema.index({ slug: 1 }, { unique: true, name: 'product_slug_unique_idx' });
ProductSchema.index({ sku: 1 }, { unique: true, sparse: true, name: 'product_sku_unique_idx' });
ProductSchema.index({ status: 1, categories: 1 }, { name: 'product_status_categories_idx' });
ProductSchema.index({ status: 1, price: 1 }, { name: 'product_status_price_idx' });
ProductSchema.index({ status: 1, createdAt: -1 }, { name: 'product_status_created_idx' });
ProductSchema.index({ categories: 1 }, { name: 'product_categories_idx' });
ProductSchema.index({ brand: 1 }, { name: 'product_brand_idx' });
ProductSchema.index({ featured: 1 }, { name: 'product_featured_idx' });
ProductSchema.index({ isPromoted: 1 }, { name: 'product_promoted_idx' });
ProductSchema.index({ 'ratings.average': -1, status: 1 }, { name: 'product_ratings_status_idx' });
ProductSchema.index(
  { status: 1, categories: 1, price: 1 },
  { name: 'product_status_categories_price_idx' }
);

// Virtual để lấy đánh giá
ProductSchema.virtual('reviews', {
  ref: 'Review',
  foreignField: 'productId',
  localField: '_id',
});

// Phương thức để kiểm tra còn hàng
ProductSchema.methods.isInStock = function () {
  return this.stock > 0;
};

// Phương thức để tính giá sau giảm giá
ProductSchema.methods.getFinalPrice = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return this.salePrice;
  }
  return this.price;
};

// Phương thức để tính phần trăm giảm giá
ProductSchema.methods.getDiscountPercentage = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return Math.round(((this.price - this.salePrice) / this.price) * 100);
  }
  return 0;
};

// Middleware trước khi lưu
ProductSchema.pre('save', function (next) {
  // Cập nhật ngày sửa đổi
  this.updatedAt = Date.now();
  next();
});

// Middleware sau khi tìm kiếm
ProductSchema.post('find', function (docs) {
  if (docs) {
    console.log(`Tìm thấy ${docs.length} sản phẩm`);
  }
});

const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;


--- File: data/models/review.model.js ---
// server/src/data/models/review.model.js
// File này không có vấn đề chỉ mục trùng lặp, giữ nguyên nội dung
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const ReviewSchema = new Schema(
  {
    // Thông tin cơ bản
    product: {
      type: Schema.Types.ObjectId,
      ref: 'Product',
      required: true,
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    order: {
      type: Schema.Types.ObjectId,
      ref: 'Order',
    },

    // Nội dung đánh giá
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    title: {
      type: String,
      trim: true,
      maxlength: 100,
    },
    review: {
      type: String,
      trim: true,
      maxlength: 2000,
    },

    // Hình ảnh đính kèm
    images: [
      {
        url: String,
        thumbnail: String,
        caption: String,
      },
    ],

    // Metadata
    isVerifiedPurchase: {
      type: Boolean,
      default: false,
    },
    purchaseDate: Date,

    // Tương tác với đánh giá
    helpfulness: {
      upvotes: {
        type: Number,
        default: 0,
      },
      downvotes: {
        type: Number,
        default: 0,
      },
      voters: [
        {
          user: {
            type: Schema.Types.ObjectId,
            ref: 'User',
          },
          vote: {
            type: Number,
            enum: [1, -1],
          },
          votedAt: {
            type: Date,
            default: Date.now,
          },
        },
      ],
    },

    // Phản hồi
    responses: [
      {
        user: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
        isAdmin: {
          type: Boolean,
          default: false,
        },
        content: {
          type: String,
          required: true,
          trim: true,
          maxlength: 1000,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // Trạng thái
    isVisible: {
      type: Boolean,
      default: true,
    },

    // Thông tin kiểm duyệt
    moderation: {
      status: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
      },
      moderatedBy: {
        type: Schema.Types.ObjectId,
        ref: 'User',
      },
      moderatedAt: Date,
      reason: String,
    },
  },
  {
    timestamps: true,
  }
);

// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Indexes với tên rõ ràng
ReviewSchema.index({ product: 1 }, { name: 'review_product_idx' });
ReviewSchema.index({ user: 1 }, { name: 'review_user_idx' });
ReviewSchema.index({ product: 1, createdAt: -1 }, { name: 'review_product_created_idx' });
ReviewSchema.index({ product: 1, rating: -1 }, { name: 'review_product_rating_idx' });
ReviewSchema.index(
  { product: 1, 'helpfulness.upvotes': -1 },
  { name: 'review_product_upvotes_idx' }
);
ReviewSchema.index({ 'moderation.status': 1 }, { name: 'review_moderation_status_idx' });
ReviewSchema.index(
  { product: 1, 'moderation.status': 1, isVisible: 1 },
  { name: 'review_product_moderation_visible_idx' }
);
ReviewSchema.index({ title: 'text', review: 'text' }, { name: 'review_text_search_idx' });

module.exports = mongoose.model('Review', ReviewSchema);


--- File: data/models/user.model.js ---
// server/src/data/models/user.model.js - Cập nhật cho phần xác thực
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true, // Chỉ giữ unique: true, không cần thêm index: true
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, // Không bao gồm password trong query results
    },
    role: {
      type: String,
      enum: ['user', 'admin', 'staff'],
      default: 'user',
    },
    avatar: String,

    phone: String,
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String,
    },

    isActive: {
      type: Boolean,
      default: true,
    },
    emailVerified: {
      type: Boolean,
      default: false,
    },

    resetPasswordToken: String,
    resetPasswordExpires: Date,
    emailVerificationToken: String,
    emailVerificationExpires: Date,

    refreshToken: String,

    lastLogin: Date,
    loginCount: {
      type: Number,
      default: 0,
    },

    preferences: {
      language: {
        type: String,
        default: 'vi',
      },
      notifications: {
        email: {
          type: Boolean,
          default: true,
        },
        marketing: {
          type: Boolean,
          default: true,
        },
      },
    },
  },
  {
    timestamps: true,
  }
);

// Thêm các chỉ mục phù hợp
// Không cần thêm chỉ mục cho email vì unique: true đã tự tạo chỉ mục
userSchema.index({ role: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ emailVerified: 1 });
userSchema.index({ resetPasswordToken: 1 }, { sparse: true });
userSchema.index({ emailVerificationToken: 1 }, { sparse: true });
userSchema.index({ phone: 1 }, { sparse: true });
userSchema.index({ name: 'text' });

// Hooks
userSchema.pre('save', async function (next) {
  // Chỉ hash mật khẩu nếu nó thay đổi
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Methods
userSchema.methods.comparePassword = async function (candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.generateAuthToken = function () {
  return jwt.sign({ id: this._id, role: this.role }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

userSchema.methods.generateRefreshToken = function () {
  const refreshToken = jwt.sign({ id: this._id }, process.env.JWT_REFRESH_SECRET, {
    expiresIn: process.env.JWT_REFRESH_EXPIRES_IN,
  });

  this.refreshToken = refreshToken;
  return refreshToken;
};

const User = mongoose.model('User', userSchema);

module.exports = User;


--- File: data/repositories/cartRepository.js ---
// server/src/data/repositories/cartRepository.js
const Cart = require('../models/cart.model');
const ApiError = require('../../common/errors/apiError');
const Product = require('../models/product.model');
const mongoose = require('mongoose');

class CartRepository {
  async findByUser(userId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ user: userId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findBySessionId(sessionId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ sessionId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const cart = await query.exec();

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    return cart;
  }

  async create(data) {
    const cart = new Cart({
      ...data,
      status: 'active',
      lastActivity: new Date(),
    });

    // Nếu là giỏ hàng khách vãng lai, đặt thời gian hết hạn
    if (data.sessionId && !data.user) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 days from now
      cart.expiresAt = expiryDate;
    }

    return await cart.save();
  }

  async addItem(cartId, item) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Kiểm tra tồn kho
      const product = await Product.findById(item.product);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < item.quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // Lấy giỏ hàng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // Tìm sản phẩm trong giỏ hàng
      const existingItemIndex = cart.items.findIndex(
        (cartItem) =>
          cartItem.product.toString() === item.product.toString() &&
          JSON.stringify(cartItem.attributes || {}) === JSON.stringify(item.attributes || {})
      );

      const now = new Date();

      if (existingItemIndex > -1) {
        // Cập nhật sản phẩm đã có
        const newQuantity = cart.items[existingItemIndex].quantity + item.quantity;

        if (product.stock < newQuantity) {
          throw new ApiError(400, 'Insufficient stock');
        }

        cart.items[existingItemIndex].quantity = newQuantity;
        cart.items[existingItemIndex].updatedAt = now;
      } else {
        // Thêm sản phẩm mới vào giỏ hàng
        cart.items.push({
          product: item.product,
          quantity: item.quantity,
          price: product.salePrice || product.price,
          attributes: item.attributes || {},
          addedAt: now,
          updatedAt: now,
        });
      }

      // Cập nhật tổng tiền
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // Cập nhật timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // Lưu giỏ hàng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateItemQuantity(cartId, productId, quantity, attributes = {}) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Kiểm tra tồn kho
      const product = await Product.findById(productId);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // Lấy giỏ hàng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // Tìm sản phẩm trong giỏ hàng
      const itemIndex = cart.items.findIndex(
        (item) =>
          item.product.toString() === productId.toString() &&
          JSON.stringify(item.attributes || {}) === JSON.stringify(attributes)
      );

      if (itemIndex === -1) {
        throw new ApiError(404, 'Product not found in cart');
      }

      const now = new Date();

      if (quantity <= 0) {
        // Xóa sản phẩm khỏi giỏ hàng
        cart.items.splice(itemIndex, 1);
      } else {
        // Cập nhật số lượng
        cart.items[itemIndex].quantity = quantity;
        cart.items[itemIndex].updatedAt = now;
      }

      // Cập nhật tổng tiền
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // Cập nhật timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // Lưu giỏ hàng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async removeItem(cartId, productId, attributes = {}) {
    return await this.updateItemQuantity(cartId, productId, 0, attributes);
  }

  async clear(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.items = [];
    cart.subtotal = 0;
    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async applyCoupon(cartId, couponCode, discount) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = {
      code: couponCode,
      discount,
      appliedAt: new Date(),
    };

    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async removeCoupon(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async mergeGuestCart(userId, sessionId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tìm giỏ hàng guest
      const guestCart = await Cart.findOne({ sessionId, status: 'active' });

      // Nếu không có giỏ hàng guest, không cần hợp nhất
      if (!guestCart) {
        await session.commitTransaction();
        return null;
      }

      // Tìm giỏ hàng người dùng
      let userCart = await Cart.findOne({ user: userId, status: 'active' });

      if (!userCart) {
        // Nếu người dùng không có giỏ hàng, chuyển đổi giỏ hàng guest thành của người dùng
        guestCart.user = userId;
        guestCart.sessionId = null;
        guestCart.expiresAt = null;
        guestCart.updatedAt = new Date();
        guestCart.lastActivity = new Date();
        await guestCart.save({ session });

        await session.commitTransaction();
        return guestCart;
      }

      // Hợp nhất các sản phẩm từ giỏ hàng guest vào giỏ hàng người dùng
      const now = new Date();

      for (const guestItem of guestCart.items) {
        // Kiểm tra tồn kho
        const product = await Product.findById(guestItem.product);

        if (product) {
          const existingItemIndex = userCart.items.findIndex(
            (item) =>
              item.product.toString() === guestItem.product.toString() &&
              JSON.stringify(item.attributes || {}) === JSON.stringify(guestItem.attributes || {})
          );

          if (existingItemIndex > -1) {
            // Cộng số lượng nếu sản phẩm đã tồn tại
            const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

            if (product.stock >= newQuantity) {
              userCart.items[existingItemIndex].quantity = newQuantity;
              userCart.items[existingItemIndex].updatedAt = now;
            } else {
              // Nếu không đủ tồn kho, đặt số lượng tối đa có thể
              userCart.items[existingItemIndex].quantity = product.stock;
              userCart.items[existingItemIndex].updatedAt = now;
            }
          } else {
            // Thêm sản phẩm mới
            if (product.stock >= guestItem.quantity) {
              userCart.items.push({
                ...guestItem.toObject(),
                updatedAt: now,
              });
            } else if (product.stock > 0) {
              // Thêm với số lượng tối đa có thể
              userCart.items.push({
                ...guestItem.toObject(),
                quantity: product.stock,
                updatedAt: now,
              });
            }
          }
        }
      }

      // Cập nhật tổng tiền
      userCart.subtotal = userCart.items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      );

      // Giữ lại coupon nếu có
      if (guestCart.coupon && !userCart.coupon) {
        userCart.coupon = guestCart.coupon;
      }

      // Cập nhật timestamps
      userCart.updatedAt = now;
      userCart.lastActivity = now;

      // Lưu giỏ hàng người dùng
      await userCart.save({ session });

      // Đánh dấu giỏ hàng guest đã được hợp nhất
      guestCart.status = 'merged';
      guestCart.updatedAt = now;
      await guestCart.save({ session });

      await session.commitTransaction();
      return userCart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async getCartDetails(cartId) {
    const cart = await Cart.findById(cartId).populate({
      path: 'items.product',
      select: 'name slug images stock price salePrice',
    });

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    // Kiểm tra tồn kho và cập nhật giá (nếu có thay đổi)
    let needsUpdate = false;

    for (const item of cart.items) {
      const product = item.product;

      // Cập nhật giá nếu có thay đổi
      const currentPrice = product.salePrice || product.price;
      if (item.price !== currentPrice) {
        item.price = currentPrice;
        needsUpdate = true;
      }

      // Kiểm tra tồn kho
      if (product.stock < item.quantity) {
        item.quantity = Math.max(0, product.stock);
        needsUpdate = true;
      }
    }

    // Lọc bỏ sản phẩm có số lượng 0
    cart.items = cart.items.filter((item) => item.quantity > 0);

    // Cập nhật tổng tiền
    const newSubtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

    if (cart.subtotal !== newSubtotal) {
      cart.subtotal = newSubtotal;
      needsUpdate = true;
    }

    // Lưu lại giỏ hàng nếu có thay đổi
    if (needsUpdate) {
      cart.updatedAt = new Date();
      cart.lastActivity = new Date();
      await cart.save();
    }

    return cart;
  }
}

module.exports = new CartRepository();


--- File: data/repositories/categoryRepository.js ---
// server/src/data/repositories/categoryRepository.js
const Category = require('../models/category.model');
const ApiError = require('../../common/errors/apiError');
// const mongoose = require('mongoose');

class CategoryRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { order: 1 }, limit = 0, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Category.find(filter).sort(sort);

    // Áp dụng pagination nếu limit > 0
    if (limit > 0) {
      query.skip(skip).limit(limit);
    }

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [categories, totalCount] = await Promise.all([
      query.exec(),
      Category.countDocuments(filter),
    ]);

    if (limit > 0) {
      return {
        data: categories,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };
    }

    return categories;
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Category.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async findBySlug(slug, options = {}) {
    const { populate = [] } = options;

    const query = Category.findOne({ slug });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async create(data) {
    // Kiểm tra slug đã tồn tại chưa
    const existingCategory = await Category.findOne({ slug: data.slug }).exec();

    if (existingCategory) {
      throw new ApiError(409, 'Category with this slug already exists');
    }

    // Nếu có parent, cập nhật ancestors và level
    if (data.parent) {
      const parentCategory = await this.findById(data.parent);

      data.level = parentCategory.level + 1;
      data.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        },
      ];
    } else {
      data.level = 0;
      data.ancestors = [];
    }

    const category = new Category(data);
    return await category.save();
  }

  async update(id, data) {
    // Nếu có cập nhật slug, kiểm tra slug đã tồn tại chưa
    if (data.slug) {
      const existingCategory = await Category.findOne({ slug: data.slug, _id: { $ne: id } }).exec();

      if (existingCategory) {
        throw new ApiError(409, 'Category with this slug already exists');
      }
    }

    // Nếu có thay đổi parent, cập nhật ancestors và level
    if (data.parent !== undefined) {
      if (data.parent) {
        const parentCategory = await this.findById(data.parent);

        // Kiểm tra parent không phải là con của category hiện tại
        if (parentCategory.ancestors.some((a) => a._id.toString() === id)) {
          throw new ApiError(400, 'Cannot set a child category as parent');
        }

        data.level = parentCategory.level + 1;
        data.ancestors = [
          ...parentCategory.ancestors,
          {
            _id: parentCategory._id,
            name: parentCategory.name,
            slug: parentCategory.slug,
          },
        ];
      } else {
        data.level = 0;
        data.ancestors = [];
      }
    }

    const category = await Category.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    // Nếu category đã được cập nhật thành công và name hoặc slug đã thay đổi,
    // cần cập nhật ancestors cho tất cả các category con
    if (data.name || data.slug) {
      await this.updateChildrenAncestors(category);
    }

    return category;
  }

  async updateChildrenAncestors(parentCategory) {
    const childCategories = await Category.find({ parent: parentCategory._id });

    const updatePromises = childCategories.map(async (childCategory) => {
      // Cập nhật ancestors
      const ancestorIndex = childCategory.ancestors.findIndex(
        (a) => a._id.toString() === parentCategory._id.toString()
      );

      if (ancestorIndex !== -1) {
        childCategory.ancestors[ancestorIndex] = {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        };

        await childCategory.save();

        // Cập nhật đệ quy cho con của childCategory
        await this.updateChildrenAncestors(childCategory);
      }
    });

    await Promise.all(updatePromises);
  }

  async delete(id) {
    // Kiểm tra xem category có con không
    const hasChildren = await Category.exists({ parent: id });

    if (hasChildren) {
      throw new ApiError(400, 'Cannot delete category with children');
    }

    const category = await Category.findByIdAndDelete(id);

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return { success: true };
  }

  async getCategoryTree(filter = {}) {
    // Lấy tất cả categories
    const categories = await Category.find(filter).sort({ order: 1 }).lean();

    // Tạo map cho việc tìm kiếm nhanh
    const categoryMap = {};
    categories.forEach((category) => {
      categoryMap[category._id.toString()] = {
        ...category,
        children: [],
      };
    });

    // Xây dựng cây
    const rootCategories = [];

    categories.forEach((category) => {
      const categoryWithChildren = categoryMap[category._id.toString()];

      if (category.parent) {
        const parentId = category.parent.toString();
        if (categoryMap[parentId]) {
          categoryMap[parentId].children.push(categoryWithChildren);
        }
      } else {
        rootCategories.push(categoryWithChildren);
      }
    });

    return rootCategories;
  }

  async getVisibleCategories() {
    return await this.getCategoryTree({ isActive: true, isVisible: true });
  }
}

module.exports = new CategoryRepository();


--- File: data/repositories/orderRepository.js ---
// server/src/data/repositories/orderRepository.js
const Order = require('../models/order.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class OrderRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Order.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [orders, totalCount] = await Promise.all([query.exec(), Order.countDocuments(filter)]);

    return {
      data: orders,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Order.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async findByOrderNumber(orderNumber, options = {}) {
    const { populate = [] } = options;

    const query = Order.findOne({ orderNumber });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tạo order
      const order = new Order(data);
      await order.save({ session });

      await session.commitTransaction();
      return order;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateStatus(id, status, note, updatedBy) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    // Kiểm tra trạng thái hợp lệ
    const validStatusTransitions = {
      pending: ['processing', 'cancelled'],
      processing: ['packed', 'cancelled'],
      packed: ['shipped', 'cancelled'],
      shipped: ['delivered', 'returned'],
      delivered: ['returned'],
      cancelled: [],
      returned: [],
    };

    if (!validStatusTransitions[order.status].includes(status)) {
      throw new ApiError(400, `Invalid status transition from ${order.status} to ${status}`);
    }

    // Cập nhật trạng thái
    order.status = status;

    // Thêm vào lịch sử trạng thái
    order.statusHistory.push({
      status,
      date: new Date(),
      note,
      updatedBy,
    });

    // Cập nhật các trường liên quan đến completion/cancellation
    if (status === 'delivered') {
      order.completedAt = new Date();
    } else if (status === 'cancelled') {
      order.cancelledAt = new Date();
    }

    // Cập nhật trạng thái thanh toán nếu COD
    if (status === 'delivered' && order.paymentMethod === 'cod') {
      order.paymentStatus = 'paid';
      order.paymentDetails.paymentDate = new Date();
    }

    return await order.save();
  }

  async updatePaymentStatus(id, paymentStatus, paymentDetails = {}) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    order.paymentStatus = paymentStatus;

    if (Object.keys(paymentDetails).length > 0) {
      order.paymentDetails = {
        ...order.paymentDetails,
        ...paymentDetails,
      };
    }

    return await order.save();
  }

  async getUserOrders(userId, options = {}) {
    const filter = { user: userId };
    return await this.findAll(filter, options);
  }

  async getOrdersByStatus(status, options = {}) {
    const filter = { status };
    return await this.findAll(filter, options);
  }

  async getOrdersByPaymentStatus(paymentStatus, options = {}) {
    const filter = { paymentStatus };
    return await this.findAll(filter, options);
  }

  async getSalesReport(startDate, endDate) {
    const query = {
      createdAt: {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      },
      status: { $in: ['delivered', 'completed'] },
      paymentStatus: 'paid',
    };

    return await Order.aggregate([
      { $match: query },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' },
            day: { $dayOfMonth: '$createdAt' },
          },
          totalSales: { $sum: '$totalAmount' },
          orders: { $sum: 1 },
          averageOrderValue: { $avg: '$totalAmount' },
        },
      },
      {
        $sort: {
          '_id.year': 1,
          '_id.month': 1,
          '_id.day': 1,
        },
      },
    ]);
  }

  async generateOrderNumber() {
    const year = new Date().getFullYear();

    // Tìm đơn hàng cuối cùng trong năm hiện tại
    const lastOrder = await Order.findOne(
      { orderNumber: new RegExp(`^RO-${year}-`) },
      { orderNumber: 1 },
      { sort: { orderNumber: -1 } }
    );

    let nextNumber = 1;

    if (lastOrder) {
      // Extract số từ orderNumber cuối (RO-2025-0001 -> 1)
      const lastNumber = parseInt(lastOrder.orderNumber.split('-')[2]);
      nextNumber = lastNumber + 1;
    }

    // Format với số 0 đứng trước (1 -> 0001)
    return `RO-${year}-${nextNumber.toString().padStart(4, '0')}`;
  }
}

module.exports = new OrderRepository();


--- File: data/repositories/productRepository.js ---
// server/src/data/repositories/productRepository.js
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');
const redisCache = require('../../services/cache/redisCache'); // Thay thế bằng RedisCache
const logger = require('../../utils/logger'); // Giả định có module logger

class ProductRepository {
  constructor() {
    // Prefix cho cache keys
    this.cachePrefix = 'products';
    // Thời gian cache mặc định (5 phút)
    this.defaultCacheTTL = 300;
  }

  /**
   * Tìm tất cả sản phẩm với phân trang và lọc
   * @param {Object} filter - Bộ lọc
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Kết quả với phân trang
   */
  async findAll(filter = {}, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:all`, { filter, options });

    // Kiểm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy dữ liệu từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Product.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const [products, totalCount] = await Promise.all([
        query.lean().exec(), // Sử dụng lean() để tăng hiệu suất
        Product.countDocuments(filter),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // Lưu vào cache
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('Lỗi khi tìm tất cả sản phẩm:', error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm theo ID
   * @param {string} id - ID sản phẩm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Sản phẩm
   */
  async findById(id, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:id`, { id, options });

    // Kiểm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`Lấy sản phẩm từ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findById(id);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Lưu vào cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi tìm sản phẩm theo ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm theo slug
   * @param {string} slug - Slug sản phẩm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Sản phẩm
   */
  async findBySlug(slug, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:slug`, { slug, options });

    // Kiểm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`Lấy sản phẩm từ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findOne({ slug });

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Lưu vào cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi tìm sản phẩm theo slug ${slug}:`, error);
      throw error;
    }
  }

  /**
   * Tạo sản phẩm mới
   * @param {Object} data - Dữ liệu sản phẩm
   * @returns {Object} - Sản phẩm đã tạo
   */
  async create(data) {
    try {
      const product = new Product(data);
      const savedProduct = await product.save();

      // Xóa cache liên quan đến danh sách sản phẩm
      await this.invalidateProductListCache();

      return savedProduct;
    } catch (error) {
      logger.error('Lỗi khi tạo sản phẩm:', error);
      throw error;
    }
  }

  /**
   * Cập nhật sản phẩm
   * @param {string} id - ID sản phẩm
   * @param {Object} data - Dữ liệu cập nhật
   * @returns {Object} - Sản phẩm đã cập nhật
   */
  async update(id, data) {
    try {
      const product = await Product.findByIdAndUpdate(
        id,
        { ...data, updatedAt: Date.now() },
        { new: true, runValidators: true }
      );

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Xóa cache của sản phẩm này
      await this.invalidateProductCache(id, product.slug);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi cập nhật sản phẩm ${id}:`, error);
      throw error;
    }
  }

  /**
   * Xóa sản phẩm
   * @param {string} id - ID sản phẩm
   * @returns {Object} - Kết quả xóa
   */
  async delete(id) {
    try {
      const product = await Product.findByIdAndDelete(id);

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Xóa cache của sản phẩm này và danh sách sản phẩm
      await this.invalidateProductCache(id, product.slug);
      await this.invalidateProductListCache();

      return { success: true };
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi xóa sản phẩm ${id}:`, error);
      throw error;
    }
  }

  /**
   * Tìm kiếm sản phẩm theo text
   * @param {string} query - Từ khóa tìm kiếm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Kết quả tìm kiếm với phân trang
   */
  async searchProducts(query, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:search`, { query, options });

    // Kiểm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy kết quả tìm kiếm từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { score: { $meta: 'textScore' } }, limit = 50, page = 1 } = options;
    const skip = (page - 1) * limit;

    const textSearchQuery = {
      $text: { $search: query },
      isActive: true,
    };

    try {
      const [products, totalCount] = await Promise.all([
        Product.find(textSearchQuery, { score: { $meta: 'textScore' } })
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .lean()
          .exec(),
        Product.countDocuments(textSearchQuery),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // Lưu vào cache với thời gian ngắn hơn (2 phút) vì dữ liệu tìm kiếm thường thay đổi
      await redisCache.set(cacheKey, result, 120);

      return result;
    } catch (error) {
      logger.error(`Lỗi khi tìm kiếm sản phẩm với từ khóa "${query}":`, error);
      throw error;
    }
  }

  /**
   * Cập nhật đánh giá sản phẩm
   * @param {string} productId - ID sản phẩm
   * @param {Object} rating - Thông tin đánh giá
   * @returns {Object} - Sản phẩm đã cập nhật
   */
  async updateRating(productId, rating) {
    try {
      const product = await Product.findByIdAndUpdate(
        productId,
        { ratings: rating },
        { new: true }
      );

      if (product) {
        // Xóa cache của sản phẩm này
        await this.invalidateProductCache(productId, product.slug);
      }

      return product;
    } catch (error) {
      logger.error(`Lỗi khi cập nhật đánh giá sản phẩm ${productId}:`, error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm với các bộ lọc và hỗ trợ cache
   * @param {Object} filters - Các bộ lọc để tìm sản phẩm
   * @param {Object} options - Các tùy chọn bổ sung
   * @returns {Object} - Kết quả tìm kiếm với phân trang
   */
  async findWithFilters(filters, options = {}) {
    // Tạo cache key dựa trên filters và options
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:filters`, { filters, options });

    // Kiểm tra cache trước
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy kết quả lọc từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const {
      category,
      minPrice,
      maxPrice,
      brand,
      sort = { createdAt: -1 },
      page = 1,
      limit = 20,
    } = filters;

    // Xây dựng query criteria
    const criteria = { isActive: true };

    if (category) {
      criteria.category = mongoose.Types.ObjectId(category);
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      criteria.price = {};
      if (minPrice !== undefined) criteria.price.$gte = minPrice;
      if (maxPrice !== undefined) criteria.price.$lte = maxPrice;
    }

    if (brand) {
      criteria.brand = brand;
    }

    // Sử dụng projection để giảm kích thước response
    const projection = options.projection || {
      name: 1,
      slug: 1,
      price: 1,
      category: 1,
      brand: 1,
      images: { $slice: 1 }, // Chỉ lấy ảnh đầu tiên
      ratings: 1,
    };

    // Tính toán skip value cho pagination
    const skip = (page - 1) * limit;

    try {
      // Thực hiện query với tối ưu
      const products = await Product.find(criteria, projection)
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(); // Sử dụng lean() để tăng hiệu suất

      // Đếm tổng số sản phẩm (sử dụng countDocuments thay vì count)
      const total = await Product.countDocuments(criteria);

      const result = {
        data: products,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit),
        },
      };

      // Lưu kết quả vào cache (TTL 5 phút)
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('Lỗi khi tìm sản phẩm với bộ lọc:', error);
      throw error;
    }
  }

  /**
   * Xóa cache của một sản phẩm cụ thể
   * @param {string} id - ID sản phẩm
   * @param {string} slug - Slug sản phẩm
   * @returns {Promise<void>}
   */
  async invalidateProductCache(id, slug) {
    try {
      // Xóa cache theo ID
      await redisCache.deleteByPattern(`${this.cachePrefix}:id:*${id}*`);

      // Xóa cache theo slug nếu có
      if (slug) {
        await redisCache.deleteByPattern(`${this.cachePrefix}:slug:*${slug}*`);
      }

      logger.info(`Đã xóa cache cho sản phẩm: ${id}`);
    } catch (error) {
      logger.error(`Lỗi khi xóa cache sản phẩm ${id}:`, error);
    }
  }

  /**
   * Xóa cache của danh sách sản phẩm
   * @returns {Promise<void>}
   */
  async invalidateProductListCache() {
    try {
      // Xóa tất cả cache liên quan đến danh sách sản phẩm
      await redisCache.deleteByPattern(`${this.cachePrefix}:all:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:filters:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:search:*`);

      logger.info('Đã xóa cache danh sách sản phẩm');
    } catch (error) {
      logger.error('Lỗi khi xóa cache danh sách sản phẩm:', error);
    }
  }

  /**
   * Lấy sản phẩm nổi bật
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm nổi bật
   */
  async getFeaturedProducts(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:featured`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm nổi bật từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({
        isActive: true,
        isFeatured: true,
      })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 1 giờ)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm nổi bật:', error);
      throw error;
    }
  }

  /**
   * Lấy sản phẩm mới nhất
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm mới nhất
   */
  async getNewArrivals(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:new`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm mới từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 30 phút)
      await redisCache.set(cacheKey, products, 1800);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm mới nhất:', error);
      throw error;
    }
  }

  /**
   * Lấy sản phẩm bán chạy nhất
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm bán chạy
   */
  async getBestSellers(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:bestsellers`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm bán chạy từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ soldCount: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 1 giờ)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm bán chạy:', error);
      throw error;
    }
  }
}

module.exports = new ProductRepository();


--- File: data/repositories/reviewRepository.js ---
// server/src/data/repositories/reviewRepository.js
const Review = require('../models/review.model');
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class ReviewRepository {
  // server/src/data/repositories/reviewRepository.js (tiếp)
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Review.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [reviews, totalCount] = await Promise.all([query.exec(), Review.countDocuments(filter)]);

    return {
      data: reviews,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Review.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const review = await query.exec();

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    return review;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tạo review
      const review = new Review(data);
      await review.save({ session });

      // Cập nhật rating cho product
      await this.updateProductRating(data.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async update(id, data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findByIdAndUpdate(id, data, {
        new: true,
        runValidators: true,
        session,
      });

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // Cập nhật rating cho product
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async delete(id) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findById(id).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      const productId = review.product;

      await Review.findByIdAndDelete(id).session(session);

      // Cập nhật rating cho product
      await this.updateProductRating(productId, session);

      await session.commitTransaction();
      return { success: true };
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateProductRating(productId, session = null) {
    // Lấy tất cả đánh giá được phê duyệt cho sản phẩm
    const aggregateOptions = session ? { session } : {};

    const reviews = await Review.aggregate(
      [
        {
          $match: {
            product: new mongoose.Types.ObjectId(productId),
            'moderation.status': 'approved',
            isVisible: true,
          },
        },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            count: { $sum: 1 },
          },
        },
      ],
      aggregateOptions
    );

    let averageRating = 0;
    let count = 0;

    if (reviews.length > 0) {
      averageRating = reviews[0].averageRating;
      count = reviews[0].count;
    }

    // Cập nhật product
    const updateOptions = session ? { session } : {};

    await Product.findByIdAndUpdate(
      productId,
      {
        'ratings.average': parseFloat(averageRating.toFixed(1)),
        'ratings.count': count,
      },
      updateOptions
    );
  }

  async getProductReviews(productId, options = {}) {
    const { sort = 'newest', page = 1, limit = 10, filter = {} } = options;

    const sortOptions = {
      newest: { createdAt: -1 },
      oldest: { createdAt: 1 },
      highestRating: { rating: -1 },
      lowestRating: { rating: 1 },
      mostHelpful: { 'helpfulness.upvotes': -1 },
    };

    const query = {
      product: productId,
      'moderation.status': 'approved',
      isVisible: true,
      ...filter,
    };

    return await this.findAll(query, {
      sort: sortOptions[sort] || sortOptions.newest,
      page,
      limit,
      populate: [{ path: 'user', select: 'name avatar' }],
    });
  }

  async getUserReviews(userId, options = {}) {
    const query = { user: userId };
    return await this.findAll(query, options);
  }

  async moderateReview(reviewId, action, reason, adminId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Validate action
      if (!['approve', 'reject'].includes(action)) {
        throw new ApiError(400, 'Invalid moderation action');
      }

      // Tìm review
      const review = await Review.findById(reviewId).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // Cập nhật trạng thái kiểm duyệt
      review.moderation = {
        status: action === 'approve' ? 'approved' : 'rejected',
        moderatedBy: adminId,
        moderatedAt: new Date(),
        reason: action === 'reject' ? reason : undefined,
      };

      // Nếu từ chối, ẩn review
      if (action === 'reject') {
        review.isVisible = false;
      }

      // Lưu review
      await review.save({ session });

      // Cập nhật tổng rating cho sản phẩm
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async voteReview(reviewId, userId, vote) {
    // Validate vote
    if (![1, -1].includes(vote)) {
      throw new ApiError(400, 'Invalid vote value');
    }

    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    // Kiểm tra xem người dùng đã vote chưa
    const voterIndex = review.helpfulness.voters.findIndex(
      (voter) => voter.user.toString() === userId.toString()
    );

    if (voterIndex > -1) {
      const previousVote = review.helpfulness.voters[voterIndex].vote;

      // Nếu vote trùng với vote cũ, xóa vote
      if (previousVote === vote) {
        // Cập nhật upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes--;
        } else {
          review.helpfulness.downvotes--;
        }

        // Xóa voter
        review.helpfulness.voters.splice(voterIndex, 1);
      } else {
        // Nếu vote khác với vote cũ, cập nhật vote
        review.helpfulness.voters[voterIndex].vote = vote;
        review.helpfulness.voters[voterIndex].votedAt = new Date();

        // Cập nhật upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes++;
          review.helpfulness.downvotes--;
        } else {
          review.helpfulness.upvotes--;
          review.helpfulness.downvotes++;
        }
      }
    } else {
      // Nếu chưa vote, thêm vote mới
      review.helpfulness.voters.push({
        user: userId,
        vote,
        votedAt: new Date(),
      });

      // Cập nhật upvotes/downvotes
      if (vote === 1) {
        review.helpfulness.upvotes++;
      } else {
        review.helpfulness.downvotes++;
      }
    }

    return await review.save();
  }

  async addResponse(reviewId, userId, content, isAdmin = false) {
    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    review.responses.push({
      user: userId,
      isAdmin,
      content,
      createdAt: new Date(),
    });

    return await review.save();
  }

  async getRatingDistribution(productId) {
    return await Review.aggregate([
      {
        $match: {
          product: new mongoose.Types.ObjectId(productId),
          'moderation.status': 'approved',
          isVisible: true,
        },
      },
      {
        $group: {
          _id: '$rating',
          count: { $sum: 1 },
        },
      },
      {
        $project: {
          rating: '$_id',
          count: 1,
          _id: 0,
        },
      },
      {
        $sort: { rating: -1 },
      },
    ]);
  }
}

module.exports = new ReviewRepository();
// module.exports = ReviewRepository;


--- File: data/repositories/userRepository.js ---
// server/src/data/repositories/userRepository.js
const User = require('../models/user.model');
const ApiError = require('../../common/errors/apiError');

class UserRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, select = '' } = options;
    const skip = (page - 1) * limit;

    const [users, totalCount] = await Promise.all([
      User.find(filter).sort(sort).skip(skip).limit(limit).select(select).exec(),
      User.countDocuments(filter),
    ]);

    return {
      data: users,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, select = '') {
    const user = await User.findById(id).select(select).exec();

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async findByEmail(email) {
    const user = await User.findOne({ email }).exec();
    return user;
  }

  async create(data) {
    // Kiểm tra email đã tồn tại chưa
    const existingUser = await this.findByEmail(data.email);

    if (existingUser) {
      throw new ApiError(409, 'Email already exists');
    }

    const user = new User(data);
    return await user.save();
  }

  async update(id, data) {
    // Nếu có cập nhật email, kiểm tra email đã tồn tại chưa
    if (data.email) {
      const existingUser = await User.findOne({ email: data.email, _id: { $ne: id } }).exec();

      if (existingUser) {
        throw new ApiError(409, 'Email already exists');
      }
    }

    const user = await User.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async delete(id) {
    const user = await User.findByIdAndDelete(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return { success: true };
  }

  async updatePassword(id, newPassword) {
    const user = await User.findById(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    user.password = newPassword;
    return await user.save();
  }

  async findByResetToken(token) {
    return await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() },
    });
  }

  async findByVerificationToken(token) {
    return await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() },
    });
  }

  async updateLoginStats(id) {
    return await User.findByIdAndUpdate(id, {
      $inc: { loginCount: 1 },
      lastLogin: Date.now(),
    });
  }
}

module.exports = new UserRepository();


--- File: docs/.project_structure_ignore ---
*seeds

--- File: docs/project_structure.txt ---


--- File: migrations/config.js ---
/**
 * Cấu hình cho hệ thống migration
 */
const config = {
  // Collection để lưu trạng thái các migrations đã chạy
  migrationCollection: 'migrations',

  // Thư mục chứa các migration scripts
  scriptsDir: './scripts',

  // Môi trường chạy migrations
  environment: process.env.NODE_ENV || 'development',

  // Có bắt buộc migrations phải chạy theo thứ tự không
  requireSequential: true,

  // Logger cho migrations
  logger: console,
};

module.exports = config;


--- File: migrations/index.js ---
const migrationRunner = require('./migrationRunner');
const mongoose = require('mongoose');
const config = require('../config/environment');

/**
 * Lớp lỗi tùy chỉnh cho migrations
 */
class MigrationError extends Error {
  constructor(message, originalError = null) {
    super(message);
    this.name = 'MigrationError';
    this.originalError = originalError;
  }
}

/**
 * Đóng kết nối database
 */
const closeConnection = async () => {
  if (mongoose.connection.readyState !== 0) {
    console.log('Closing database connection...');
    await mongoose.connection.close();
  }
};

/**
 * Chạy migrations
 */
const runMigrations = async () => {
  try {
    // Kết nối database nếu chưa kết nối
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Running migrations...');
    await migrationRunner.migrate();

    console.log('Migrations completed successfully');
  } catch (error) {
    console.error('Error running migrations:', error);
    throw new MigrationError('Failed to run migrations', error);
  }
};

/**
 * Rollback migration gần nhất
 */
const rollbackMigration = async () => {
  try {
    // Kết nối database nếu chưa kết nối
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Rolling back last migration...');
    await migrationRunner.rollback();

    console.log('Rollback completed successfully');
  } catch (error) {
    console.error('Error rolling back migration:', error);
    throw new MigrationError('Failed to rollback migration', error);
  }
};

// Xử lý arguments từ command line
const processArguments = async () => {
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'migrate':
        await runMigrations();
        break;
      case 'rollback':
        await rollbackMigration();
        break;
      default:
        console.log('Usage: node migrations [migrate|rollback]');
        return; // Thoát hàm mà không ném lỗi vì đây không phải lỗi thực sự
    }
  } catch (error) {
    // Xử lý lỗi ở cấp cao nhất
    console.error(`Migration command '${command}' failed:`, error);
    // Đặt mã thoát là 1 để chỉ ra lỗi
    process.exitCode = 1;
  } finally {
    // Đảm bảo đóng kết nối database trong mọi trường hợp
    await closeConnection();
  }
};

// Chỉ chạy nếu được gọi trực tiếp (không phải require)
if (require.main === module) {
  processArguments().catch((error) => {
    console.error('Unhandled error in migrations:', error);
    process.exitCode = 1;
  });
} else {
  // Export functions để có thể gọi từ module khác
  module.exports = {
    runMigrations,
    rollbackMigration,
    closeConnection, // Export thêm hàm đóng kết nối để module khác có thể sử dụng
  };
}


--- File: migrations/migrationFramework.js ---
// server/src/data/migrations/migrationFramework.js
const mongoose = require('mongoose');
const logger = require('../config/logger');

// Migration Model
const migrationSchema = new mongoose.Schema({
  version: {
    type: String,
    required: true,
    unique: true,
  },
  description: {
    type: String,
    required: true,
  },
  appliedAt: {
    type: Date,
    default: Date.now,
  },
});

const Migration = mongoose.model('Migration', migrationSchema);

// Migration Framework
class MigrationFramework {
  constructor() {
    this.migrations = [];
  }

  register(version, description, up, down) {
    this.migrations.push({
      version,
      description,
      up,
      down,
    });

    return this;
  }

  async migrate(targetVersion = null) {
    logger.info('Starting migrations...');

    try {
      // Sắp xếp migrations theo version
      this.migrations.sort((a, b) => {
        return a.version.localeCompare(b.version, undefined, { numeric: true });
      });

      // Lấy tất cả migrations đã được áp dụng
      const appliedMigrations = await Migration.find().sort({ version: 1 });
      const lastAppliedVersion = appliedMigrations.length
        ? appliedMigrations[appliedMigrations.length - 1].version
        : null;

      // Nếu không có targetVersion, dùng migration cuối cùng
      targetVersion = targetVersion || this.migrations[this.migrations.length - 1].version;

      if (lastAppliedVersion === targetVersion) {
        logger.info(`Database already at version ${targetVersion}`);
        return;
      }

      // Lấy danh sách các versions đã áp dụng
      const appliedVersions = appliedMigrations.map((m) => m.version);

      // Nếu downgrade
      if (
        lastAppliedVersion &&
        lastAppliedVersion.localeCompare(targetVersion, undefined, { numeric: true }) > 0
      ) {
        logger.info(`Downgrading from ${lastAppliedVersion} to ${targetVersion}`);

        // Lấy các migrations cần rollback
        const migrationsToRollback = this.migrations
          .filter(
            (m) =>
              m.version.localeCompare(targetVersion, undefined, { numeric: true }) > 0 &&
              appliedVersions.includes(m.version)
          )
          .reverse();

        // Áp dụng rollback
        for (const migration of migrationsToRollback) {
          logger.info(`Rolling back migration ${migration.version}: ${migration.description}`);
          await migration.down();
          await Migration.deleteOne({ version: migration.version });
        }

        logger.info(`Successfully downgraded to version ${targetVersion}`);
      }
      // Nếu upgrade
      else {
        logger.info(`Upgrading to version ${targetVersion}`);

        // Lấy các migrations cần áp dụng
        const migrationsToApply = this.migrations.filter(
          (m) =>
            !appliedVersions.includes(m.version) &&
            m.version.localeCompare(targetVersion, undefined, { numeric: true }) <= 0
        );

        // Áp dụng migrations
        for (const migration of migrationsToApply) {
          logger.info(`Applying migration ${migration.version}: ${migration.description}`);
          await migration.up();
          await Migration.create({
            version: migration.version,
            description: migration.description,
          });
        }

        logger.info(`Successfully upgraded to version ${targetVersion}`);
      }
    } catch (error) {
      logger.error('Migration failed', error);
      throw error;
    }
  }

  // Lấy version hiện tại
  async getCurrentVersion() {
    const lastMigration = await Migration.findOne().sort({ version: -1 });
    return lastMigration ? lastMigration.version : null;
  }
}

module.exports = { MigrationFramework, Migration };


--- File: migrations/migrationRunner.js ---
const mongoose = require('mongoose');
const fs = require('fs');
const path = require('path');
const config = require('./config');

/**
 * Lớp quản lý và chạy migrations
 */
class MigrationRunner {
  constructor() {
    this.db = mongoose.connection;
    this.migrationCollection = this.db.collection(config.migrationCollection);
    this.logger = config.logger;
  }

  /**
   * Lấy danh sách các migrations đã chạy
   * @returns {Promise<Array>} Danh sách migrations đã chạy
   */
  async getCompletedMigrations() {
    try {
      // Nếu collection không tồn tại, tạo mới
      const collections = await this.db.db
        .listCollections({ name: config.migrationCollection })
        .toArray();

      if (collections.length === 0) {
        await this.db.createCollection(config.migrationCollection);
        return [];
      }

      // Lấy danh sách migrations đã chạy
      const completedMigrations = await this.migrationCollection
        .find({})
        .sort({ timestamp: 1 })
        .toArray();
      return completedMigrations.map((migration) => migration.name);
    } catch (error) {
      this.logger.error('Error getting completed migrations:', error);
      throw error;
    }
  }

  /**
   * Đánh dấu một migration đã chạy thành công
   * @param {String} name - Tên migration
   * @returns {Promise<void>}
   */
  async markMigrationAsCompleted(name) {
    try {
      await this.migrationCollection.insertOne({
        name,
        timestamp: new Date(),
        environment: config.environment,
      });

      this.logger.info(`Migration ${name} marked as completed`);
    } catch (error) {
      this.logger.error(`Error marking migration ${name} as completed:`, error);
      throw error;
    }
  }

  /**
   * Lấy danh sách tất cả các migration scripts
   * @returns {Promise<Array>} Danh sách tên các migration scripts
   */
  async getAllMigrationScripts() {
    try {
      const scriptsDir = path.resolve(__dirname, config.scriptsDir);
      const files = fs.readdirSync(scriptsDir);

      // Lọc chỉ lấy các file JavaScript
      return files.filter((file) => file.endsWith('.js')).sort(); // Sắp xếp theo thứ tự tên file
    } catch (error) {
      this.logger.error('Error getting migration scripts:', error);
      throw error;
    }
  }

  /**
   * Lấy danh sách các migrations cần chạy
   * @returns {Promise<Array>} Danh sách tên các migrations cần chạy
   */
  async getPendingMigrations() {
    const completedMigrations = await this.getCompletedMigrations();
    const allMigrations = await this.getAllMigrationScripts();

    // Lọc các migrations chưa chạy
    return allMigrations.filter((migration) => !completedMigrations.includes(migration));
  }

  /**
   * Chạy một migration script
   * @param {String} scriptName - Tên file script
   * @returns {Promise<void>}
   */
  async runMigration(scriptName) {
    try {
      this.logger.info(`Running migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Chạy migration
      if (typeof migration.up !== 'function') {
        throw new Error(`Migration ${scriptName} does not have an 'up' function`);
      }

      await migration.up(this.db);

      // Đánh dấu migration đã hoàn thành
      await this.markMigrationAsCompleted(scriptName);

      this.logger.info(`Migration ${scriptName} completed successfully`);
    } catch (error) {
      this.logger.error(`Error running migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Rollback một migration
   * @param {String} scriptName - Tên file script
   * @returns {Promise<void>}
   */
  async rollbackMigration(scriptName) {
    try {
      this.logger.info(`Rolling back migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Chạy rollback
      if (typeof migration.down !== 'function') {
        throw new Error(`Migration ${scriptName} does not have a 'down' function`);
      }

      await migration.down(this.db);

      // Xóa migration khỏi danh sách đã hoàn thành
      await this.migrationCollection.deleteOne({ name: scriptName });

      this.logger.info(`Migration ${scriptName} rolled back successfully`);
    } catch (error) {
      this.logger.error(`Error rolling back migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Chạy tất cả các migrations chưa hoàn thành
   * @returns {Promise<void>}
   */
  async migrate() {
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info('No pending migrations to run');
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Chạy từng migration theo thứ tự
    for (const migration of pendingMigrations) {
      await this.runMigration(migration);
    }

    this.logger.info('All migrations completed successfully');
  }

  /**
   * Rollback migration cuối cùng đã chạy
   * @returns {Promise<void>}
   */
  async rollback() {
    const completedMigrations = await this.getCompletedMigrations();

    if (completedMigrations.length === 0) {
      this.logger.info('No migrations to roll back');
      return;
    }

    // Lấy migration cuối cùng
    const lastMigration = completedMigrations[completedMigrations.length - 1];

    await this.rollbackMigration(lastMigration);
  }
}

module.exports = new MigrationRunner();


--- File: migrations/scripts/001-initial-categories.js ---
/**
 * Migration: Tạo các danh mục sản phẩm ban đầu
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // Tạo collection categories nếu chưa tồn tại
    const collections = await db.db.listCollections({ name: 'categories' }).toArray();
    if (collections.length === 0) {
      await db.db.createCollection('categories');
    }

    const categories = db.collection('categories');

    // Danh sách các danh mục cơ bản
    const initialCategories = [
      {
        name: 'Gậy Billiard',
        slug: 'gay-billiard',
        description: 'Tất cả các loại gậy billiard chất lượng cao',
        parent: null,
        level: 0,
        order: 1,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Bi Billiard',
        slug: 'bi-billiard',
        description: 'Các bộ bi billiard tiêu chuẩn quốc tế',
        parent: null,
        level: 0,
        order: 2,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Phụ Kiện',
        slug: 'phu-kien',
        description: 'Phụ kiện billiard chất lượng cao',
        parent: null,
        level: 0,
        order: 3,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Chèn các danh mục vào database
    await categories.insertMany(initialCategories);
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const categories = db.collection('categories');

    // Xóa các danh mục đã tạo
    await categories.deleteMany({
      slug: { $in: ['gay-billiard', 'bi-billiard', 'phu-kien'] },
    });
  },
};


--- File: migrations/scripts/002-add-indexes.js ---
/**
 * Migration: Tạo các indexes cho database
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // Index cho User collection
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
    await db.collection('users').createIndex({ role: 1 });

    // Index cho Product collection
    await db.collection('products').createIndex({ slug: 1 }, { unique: true });
    await db.collection('products').createIndex({ category: 1 });
    await db.collection('products').createIndex({ createdAt: -1 });
    await db.collection('products').createIndex({ price: 1 });

    // Text index cho tìm kiếm sản phẩm
    await db.collection('products').createIndex(
      { name: 'text', description: 'text' },
      {
        weights: {
          name: 10,
          description: 5,
        },
        default_language: 'none',
      }
    );

    // Index cho Category collection
    await db.collection('categories').createIndex({ slug: 1 }, { unique: true });
    await db.collection('categories').createIndex({ parent: 1 });

    // Index cho Order collection
    await db.collection('orders').createIndex({ orderNumber: 1 }, { unique: true });
    await db.collection('orders').createIndex({ user: 1 });
    await db.collection('orders').createIndex({ status: 1 });
    await db.collection('orders').createIndex({ createdAt: -1 });

    // Index cho Cart collection
    await db.collection('carts').createIndex({ user: 1 }, { sparse: true });
    await db.collection('carts').createIndex({ sessionId: 1 }, { sparse: true });

    // TTL index cho cart expiration
    await db.collection('carts').createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });

    // Index cho Review collection
    await db.collection('reviews').createIndex({ product: 1 });
    await db.collection('reviews').createIndex({ user: 1 });
    await db.collection('reviews').createIndex({ product: 1, createdAt: -1 });
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    // Drop indexes từ User collection
    await db.collection('users').dropIndex({ email: 1 });
    await db.collection('users').dropIndex({ role: 1 });

    // Drop indexes từ Product collection
    await db.collection('products').dropIndex({ slug: 1 });
    await db.collection('products').dropIndex({ category: 1 });
    await db.collection('products').dropIndex({ createdAt: -1 });
    await db.collection('products').dropIndex({ price: 1 });
    await db.collection('products').dropIndex('name_text_description_text');

    // Drop indexes từ Category collection
    await db.collection('categories').dropIndex({ slug: 1 });
    await db.collection('categories').dropIndex({ parent: 1 });

    // Drop indexes từ Order collection
    await db.collection('orders').dropIndex({ orderNumber: 1 });
    await db.collection('orders').dropIndex({ user: 1 });
    await db.collection('orders').dropIndex({ status: 1 });
    await db.collection('orders').dropIndex({ createdAt: -1 });

    // Drop indexes từ Cart collection
    await db.collection('carts').dropIndex({ user: 1 });
    await db.collection('carts').dropIndex({ sessionId: 1 });
    await db.collection('carts').dropIndex({ expiresAt: 1 });

    // Drop indexes từ Review collection
    await db.collection('reviews').dropIndex({ product: 1 });
    await db.collection('reviews').dropIndex({ user: 1 });
    await db.collection('reviews').dropIndex({ product: 1, createdAt: -1 });
  },
};


--- File: migrations/scripts/003-add-admin-user.js ---
const bcrypt = require('bcrypt');

/**
 * Migration: Tạo user admin mặc định
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    const users = db.collection('users');

    // Kiểm tra xem đã có admin chưa
    const adminExists = await users.findOne({ role: 'admin' });

    if (!adminExists) {
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash('Admin@123', salt);

      // Tạo admin user
      await users.insertOne({
        name: 'Admin',
        email: 'admin@runout-biliard.com',
        password: hashedPassword,
        role: 'admin',
        isActive: true,
        emailVerified: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const users = db.collection('users');

    // Xóa admin user
    await users.deleteOne({ email: 'admin@runout-biliard.com' });
  },
};



--- File: server.js ---
/**
 * Server chính cho ứng dụng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const http = require('http');
const app = require('./app');
const config = require('./config/environment');
const logger = require('./config/logger');

// Lấy PORT từ cấu hình hoặc biến môi trường
const PORT = process.env.PORT || config.app.port || 5000;

// Tạo HTTP server
const server = http.createServer(app);

// Xử lý các lỗi server
server.on('error', (error) => {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof PORT === 'string' ? 'Pipe ' + PORT : 'Port ' + PORT;

  // Xử lý các lỗi server cụ thể với thông báo thân thiện
  switch (error.code) {
    case 'EACCES':
      logger.error(`${bind} yêu cầu quyền nâng cao`);
      throw new Error(`${bind} yêu cầu quyền nâng cao`);
    case 'EADDRINUSE':
      logger.error(`${bind} đã được sử dụng`);
      throw new Error(`${bind} đã được sử dụng`);
    default:
      throw error;
  }
});

// Khởi động server
server.listen(PORT, () => {
  logger.info(`🚀 Server đang chạy trong môi trường ${config.app.environment}`);
  logger.info(`🌐 Địa chỉ: http://${config.app.host}:${PORT}`);
});

// Xử lý tắt server an toàn
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

/**
 * Đóng server một cách an toàn
 */
function gracefulShutdown() {
  logger.info('Nhận tín hiệu tắt server, đang đóng kết nối...');

  server.close(() => {
    logger.info('Server đã đóng, đang ngắt kết nối cơ sở dữ liệu...');

    // Đóng kết nối cơ sở dữ liệu nếu cần
    try {
      if (require('mongoose').connection.readyState) {
        require('mongoose').connection.close(false, () => {
          logger.info('Đã ngắt kết nối MongoDB.');
          throw new Error('Server đã đóng và ngắt kết nối thành công');
        });
      } else {
        throw new Error('Server đã đóng và không cần ngắt kết nối');
      }
    } catch (err) {
      logger.error(`Lỗi khi đóng kết nối: ${err.message}`);
      throw new Error(`Lỗi khi đóng kết nối: ${err.message}`);
    }
  });

  // Nếu server không đóng sau 10s, tắt cưỡng chế
  setTimeout(() => {
    logger.error('Không thể đóng kết nối một cách êm dịu, đang tắt cưỡng chế...');
    throw new Error('Không thể đóng kết nối một cách êm dịu, đang tắt cưỡng chế...');
  }, 10000);
}

// Xử lý các lỗi không bắt được khác
process.on('uncaughtException', (error) => {
  logger.error(`Lỗi không bắt được: ${error.message}`);
  logger.error(error.stack);

  // Trong môi trường sản xuất, đảm bảo server đóng an toàn sau lỗi không bắt được
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Lời hứa bị từ chối không được xử lý:');
  logger.error(`Promise: ${promise}, Reason: ${reason}`);

  // Trong môi trường sản xuất, có thể xem xét tắt ứng dụng
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

module.exports = server; // Export để sử dụng trong kiểm thử


--- File: services/auth/authService.js ---
/**
 * Auth Service - xử lý logic xác thực và phân quyền
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const User = require('../../data/models/user.model');
const { ApiError } = require('../../common/errors/apiError');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../email/emailService');

/**
 * Class AuthService xử lý logic xác thực và phân quyền
 */
class AuthService {
  /**
   * Đăng ký tài khoản mới
   * @param {Object} userData - Thông tin đăng ký
   * @param {string} host - Host để tạo URL xác thực
   * @returns {Promise<Object>} - Thông tin người dùng đã tạo
   */
  async register(userData, host) {
    try {
      const { name, email, password, phone } = userData;

      // Kiểm tra email đã tồn tại chưa
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        throw new ApiError(409, 'Email đã được sử dụng');
      }

      // Tạo verification token
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(verificationToken).digest('hex');

      // Tạo user mới
      const newUser = await User.create({
        name,
        email,
        password,
        phone,
        emailVerificationToken: hashedToken,
        emailVerificationExpires: Date.now() + 24 * 60 * 60 * 1000, // 24 giờ
      });

      // Tạo URL xác thực
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const verifyURL = `${protocol}://${host}/api/auth/verify-email/${verificationToken}`;

      // Gửi email xác thực
      await sendEmail({
        to: email,
        subject: 'Xác thực tài khoản RunOut-Biliard',
        template: 'verification',
        context: {
          name,
          verifyURL,
        },
      });

      // Không gửi mật khẩu và token trong response
      const userObj = newUser.toObject();
      delete userObj.password;
      delete userObj.emailVerificationToken;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi đăng ký: ${error.message}`);
      throw error;
    }
  }

  /**
   * Đăng nhập
   * @param {string} email - Email người dùng
   * @param {string} password - Mật khẩu
   * @returns {Promise<Object>} - Thông tin người dùng và token
   */
  async login(email, password) {
    try {
      // Tìm user và lấy cả password (mặc định password bị loại trừ)
      const user = await User.findOne({ email }).select('+password');

      // Kiểm tra user tồn tại và password đúng
      if (!user || !(await user.correctPassword(password, user.password))) {
        throw new ApiError(401, 'Email hoặc mật khẩu không đúng');
      }

      // Kiểm tra email đã xác thực chưa
      if (!user.emailVerified) {
        throw new ApiError(401, 'Vui lòng xác thực email trước khi đăng nhập');
      }

      // Kiểm tra user có active không
      if (!user.isActive) {
        throw new ApiError(401, 'Tài khoản của bạn đã bị vô hiệu hóa');
      }

      // Tạo JWT token và refresh token
      const token = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // Cập nhật thông tin đăng nhập
      user.lastLogin = Date.now();
      user.loginCount += 1;
      await user.save({ validateBeforeSave: false });

      // Chuyển đổi user thành object và loại bỏ password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token,
        refreshToken,
      };
    } catch (error) {
      logger.error(`Lỗi đăng nhập: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tạo JWT token
   * @param {Object} user - User object
   * @returns {string} - JWT token
   */
  generateToken(user) {
    return jwt.sign({ id: user._id, role: user.role }, environment.auth.jwtSecret, {
      expiresIn: environment.auth.jwtExpiresIn,
    });
  }

  /**
   * Tạo refresh token
   * @param {Object} user - User object
   * @returns {string} - Refresh token
   */
  generateRefreshToken(user) {
    return jwt.sign({ id: user._id }, environment.auth.jwtRefreshSecret, {
      expiresIn: environment.auth.jwtRefreshExpiresIn,
    });
  }

  /**
   * Làm mới token
   * @param {string} refreshToken - Refresh token
   * @returns {Promise<Object>} - Token mới
   */
  async refreshToken(refreshToken) {
    try {
      // Xác thực refresh token
      const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);

      // Tìm user
      const user = await User.findById(decoded.id);

      if (!user || !user.isActive) {
        throw new ApiError(401, 'Người dùng không tồn tại hoặc đã bị vô hiệu hóa');
      }

      // Tạo token mới
      const newToken = this.generateToken(user);

      return { token: newToken };
    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new ApiError(401, 'Refresh token không hợp lệ hoặc đã hết hạn');
      }

      logger.error(`Lỗi refresh token: ${error.message}`);
      throw error;
    }
  }

  /**
   * Quên mật khẩu
   * @param {string} email - Email người dùng
   * @param {string} host - Host để tạo URL reset
   * @returns {Promise<boolean>} - Thành công hay không
   */
  async forgotPassword(email, host) {
    try {
      // Tìm user theo email
      const user = await User.findOne({ email });

      if (!user) {
        throw new ApiError(404, 'Không tìm thấy người dùng với email này');
      }

      // Tạo reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');

      // Lưu token và thời hạn vào database
      user.resetPasswordToken = hashedToken;
      user.resetPasswordExpires = Date.now() + 10 * 60 * 1000; // 10 phút
      await user.save({ validateBeforeSave: false });

      // Tạo URL reset
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const resetURL = `${protocol}://${host}/reset-password/${resetToken}`;

      // Gửi email
      await sendEmail({
        to: user.email,
        subject: 'Đặt lại mật khẩu RunOut-Biliard (có hiệu lực trong 10 phút)',
        template: 'resetPassword',
        context: {
          name: user.name,
          resetURL,
        },
      });

      return true;
    } catch (error) {
      logger.error(`Lỗi quên mật khẩu: ${error.message}`);

      // Nếu gửi email thất bại, xóa các fields reset
      if (error.message.includes('email')) {
        try {
          const user = await User.findOne({ email });
          if (user) {
            user.resetPasswordToken = undefined;
            user.resetPasswordExpires = undefined;
            await user.save({ validateBeforeSave: false });
          }
        } catch (innerError) {
          logger.error(`Lỗi khi xóa token reset: ${innerError.message}`);
        }
      }

      throw error;
    }
  }

  /**
   * Đặt lại mật khẩu
   * @param {string} token - Reset token
   * @param {string} password - Mật khẩu mới
   * @returns {Promise<Object>} - Thông tin người dùng và token
   */
  async resetPassword(token, password) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // Tìm user với token và kiểm tra thời hạn
      const user = await User.findOne({
        resetPasswordToken: hashedToken,
        resetPasswordExpires: { $gt: Date.now() },
      });

      // Kiểm tra nếu token hợp lệ
      if (!user) {
        throw new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn');
      }

      // Cập nhật mật khẩu
      user.password = password;
      user.resetPasswordToken = undefined;
      user.resetPasswordExpires = undefined;
      await user.save();

      // Tạo token mới
      const jwtToken = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // Chuyển đổi user thành object và loại bỏ password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token: jwtToken,
        refreshToken,
      };
    } catch (error) {
      logger.error(`Lỗi đặt lại mật khẩu: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xác thực email
   * @param {string} token - Verification token
   * @returns {Promise<boolean>} - Thành công hay không
   */
  async verifyEmail(token) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // Tìm user và kiểm tra thời hạn
      const user = await User.findOne({
        emailVerificationToken: hashedToken,
        emailVerificationExpires: { $gt: Date.now() },
      });

      // Kiểm tra nếu token hợp lệ
      if (!user) {
        throw new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn');
      }

      // Cập nhật trạng thái xác thực
      user.emailVerified = true;
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });

      return true;
    } catch (error) {
      logger.error(`Lỗi xác thực email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new AuthService();


--- File: services/base/baseService.js ---
/**
 * Base Service - cung cấp các phương thức CRUD cơ bản
 * @author Steve
 * @project RunOut-Biliard
 */

const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * Lớp BaseService cung cấp các phương thức CRUD cơ bản cho các service
 */
class BaseService {
  /**
   * Khởi tạo service với model tương ứng
   * @param {mongoose.Model} model - Mongoose model
   * @param {string} modelName - Tên của model (dùng cho log và thông báo lỗi)
   */
  constructor(model, modelName) {
    this.model = model;
    this.modelName = modelName || model.modelName;
  }

  /**
   * Lấy tất cả documents với filter, sort và pagination
   * @param {Object} filter - Điều kiện filter
   * @param {Object} options - Các options bổ sung (sort, pagination, select)
   * @returns {Promise<{data: Array, pagination: Object}>} - Dữ liệu và thông tin phân trang
   */
  async findAll(filter = {}, options = {}) {
    try {
      const { sort = '-createdAt', page = 1, limit = 10, select = '', populate = '' } = options;

      const skip = (page - 1) * limit;

      // Build query
      let query = this.model.find(filter);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query with sort, skip and limit
      const data = await query.sort(sort).skip(skip).limit(limit);

      // Count total documents matching filter
      const total = await this.model.countDocuments(filter);

      // Calculate pagination info
      const totalPages = Math.ceil(total / limit);
      const hasNext = page < totalPages;
      const hasPrev = page > 1;

      return {
        data,
        pagination: {
          total,
          page,
          limit,
          totalPages,
          hasNext,
          hasPrev,
        },
      };
    } catch (error) {
      logger.error(`Error in ${this.modelName}.findAll: ${error.message}`);
      throw error;
    }
  }

  /**
   * Lấy document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} options - Các options (select, populate)
   * @returns {Promise<Document>} - Document tìm thấy
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async findById(id, options = {}) {
    try {
      const { select = '', populate = '' } = options;

      // Build query
      let query = this.model.findById(id);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query
      const data = await query;

      // Throw error if not found
      if (!data) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return data;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.findById: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tạo document mới
   * @param {Object} data - Dữ liệu cho document mới
   * @returns {Promise<Document>} - Document đã tạo
   */
  async create(data) {
    try {
      const newDoc = await this.model.create(data);
      return newDoc;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.create: ${error.message}`);
      throw error;
    }
  }

  /**
   * Cập nhật document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} data - Dữ liệu cập nhật
   * @param {Object} options - Các options (new, runValidators)
   * @returns {Promise<Document>} - Document đã cập nhật
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async update(id, data, options = {}) {
    try {
      const opts = {
        new: true,
        runValidators: true,
        ...options,
      };

      const updated = await this.model.findByIdAndUpdate(id, data, opts);

      if (!updated) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return updated;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.update: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xóa document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<Document>} - Document đã xóa
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async delete(id) {
    try {
      const deleted = await this.model.findByIdAndDelete(id);

      if (!deleted) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return deleted;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.delete: ${error.message}`);
      throw error;
    }
  }

  /**
   * Kiểm tra sự tồn tại của document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<boolean>} - true nếu document tồn tại, false nếu không
   */
  async exists(id) {
    try {
      const count = await this.model.countDocuments({ _id: id });
      return count > 0;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.exists: ${error.message}`);
      throw error;
    }
  }
}

module.exports = BaseService;


--- File: services/cache/redisCache.js ---
// server/src/services/cache/redisCache.js
const redis = require('redis');
const { promisify } = require('util');
const config = require('../../config/environment');
const { logger } = require('../../utils/logger'); // Sửa cách import logger

class RedisCache {
  constructor() {
    this.isConnected = false;
    this.client = redis.createClient({
      url: config.redis.url,
      retry_strategy: (options) => {
        if (options.error && options.error.code === 'ECONNREFUSED') {
          logger.error('Kết nối Redis bị từ chối. Đảm bảo Redis server đang chạy.');
          return new Error('Kết nối Redis bị từ chối');
        }
        if (options.total_retry_time > 1000 * 60 * 60) {
          logger.error('Đã vượt quá thời gian thử lại kết nối Redis.');
          return new Error('Đã vượt quá thời gian thử lại');
        }
        if (options.attempt > 10) {
          logger.error('Đã vượt quá số lần thử lại kết nối Redis.');
          return undefined;
        }
        // Thử lại sau một khoảng thời gian tăng dần
        return Math.min(options.attempt * 100, 3000);
      },
    });

    // Xử lý sự kiện Redis trước khi promisify
    this.client.on('error', (error) => {
      this.isConnected = false;
      logger.error('Lỗi Redis:', error);
    });

    this.client.on('connect', () => {
      this.isConnected = true;
      logger.info('Đã kết nối thành công đến Redis server');
    });

    this.client.on('reconnecting', () => {
      logger.info('Đang thử kết nối lại đến Redis server...');
    });

    this.client.on('end', () => {
      this.isConnected = false;
      logger.info('Kết nối Redis đã đóng');
    });

    // Promisify các phương thức Redis - Sửa cách thực hiện bind
    this._initPromisifiedMethods();
  }

  /**
   * Khởi tạo các phương thức Redis đã promisify với kiểm tra an toàn
   * @private
   */
  _initPromisifiedMethods() {
    try {
      // Kiểm tra xem client có tồn tại không
      if (!this.client) {
        throw new Error('Redis client chưa được khởi tạo');
      }

      // Sử dụng try-catch riêng cho từng phương thức
      try {
        if (typeof this.client.get === 'function')
          this.getAsync = promisify(this.client.get.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức get');
      }

      try {
        if (typeof this.client.set === 'function')
          this.setAsync = promisify(this.client.set.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức set');
      }

      try {
        if (typeof this.client.del === 'function')
          this.delAsync = promisify(this.client.del.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức del');
      }

      try {
        if (typeof this.client.keys === 'function')
          this.keysAsync = promisify(this.client.keys.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức keys');
      }

      try {
        if (typeof this.client.flushdb === 'function')
          this.flushdbAsync = promisify(this.client.flushdb.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức flushdb');
      }

      try {
        if (typeof this.client.exists === 'function')
          this.existsAsync = promisify(this.client.exists.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức exists');
      }

      try {
        if (typeof this.client.expire === 'function')
          this.expireAsync = promisify(this.client.expire.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức expire');
      }

      try {
        if (typeof this.client.ttl === 'function')
          this.ttlAsync = promisify(this.client.ttl.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức ttl');
      }

      try {
        if (typeof this.client.incr === 'function')
          this.incrAsync = promisify(this.client.incr.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức incr');
      }

      try {
        if (typeof this.client.decr === 'function')
          this.decrAsync = promisify(this.client.decr.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức decr');
      }

      try {
        if (typeof this.client.hgetall === 'function')
          this.hgetallAsync = promisify(this.client.hgetall.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hgetall');
      }

      try {
        if (typeof this.client.hset === 'function')
          this.hsetAsync = promisify(this.client.hset.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hset');
      }

      try {
        if (typeof this.client.hmset === 'function')
          this.hmsetAsync = promisify(this.client.hmset.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hmset');
      }

      try {
        if (typeof this.client.hdel === 'function')
          this.hdelAsync = promisify(this.client.hdel.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hdel');
      }

      logger.info('Các phương thức Redis đã được promisify thành công');
    } catch (error) {
      logger.error('Lỗi khi promisify các phương thức Redis:', error);
      throw new Error('Không thể khởi tạo các phương thức Redis: ' + error.message);
    }
  }

  /**
   * Kiểm tra trạng thái kết nối Redis
   * @returns {boolean} Trạng thái kết nối
   */
  isReady() {
    return this.isConnected;
  }

  /**
   * Lấy dữ liệu từ cache
   * @param {string} key - Khóa cache
   * @returns {Promise<any>} Dữ liệu đã lưu trong cache hoặc null
   */
  async get(key) {
    try {
      const data = await this.getAsync(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error(`Lỗi khi lấy cache với khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Lưu dữ liệu vào cache
   * @param {string} key - Khóa cache
   * @param {any} value - Dữ liệu cần lưu
   * @param {number} ttl - Thời gian sống (giây)
   * @returns {Promise<boolean>} Kết quả lưu cache
   */
  async set(key, value, ttl = 3600) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.setAsync(key, serializedValue, 'EX', ttl);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu cache với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Xóa dữ liệu khỏi cache
   * @param {string} key - Khóa cache
   * @returns {Promise<boolean>} Kết quả xóa cache
   */
  async delete(key) {
    try {
      const result = await this.delAsync(key);
      return result > 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa cache với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Tạo khóa cache từ prefix và tham số
   * @param {string} prefix - Tiền tố cho khóa
   * @param {object} params - Tham số để tạo khóa
   * @returns {string} Khóa cache đã tạo
   */
  generateKey(prefix, params) {
    if (typeof params === 'object') {
      // Sắp xếp các khóa để đảm bảo tính nhất quán
      const sortedParams = {};
      Object.keys(params)
        .sort()
        .forEach((key) => {
          sortedParams[key] = params[key];
        });
      return `${prefix}:${Buffer.from(JSON.stringify(sortedParams)).toString('base64')}`;
    }
    return `${prefix}:${params}`;
  }

  /**
   * Kiểm tra xem khóa có tồn tại trong cache không
   * @param {string} key - Khóa cache
   * @returns {Promise<boolean>} Kết quả kiểm tra
   */
  async exists(key) {
    try {
      const result = await this.existsAsync(key);
      return result === 1;
    } catch (error) {
      logger.error(`Lỗi khi kiểm tra tồn tại khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Cập nhật thời gian hết hạn cho khóa
   * @param {string} key - Khóa cache
   * @param {number} ttl - Thời gian sống mới (giây)
   * @returns {Promise<boolean>} Kết quả cập nhật
   */
  async expire(key, ttl) {
    try {
      const result = await this.expireAsync(key, ttl);
      return result === 1;
    } catch (error) {
      logger.error(`Lỗi khi cập nhật thời gian hết hạn cho khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Lấy thời gian còn lại trước khi khóa hết hạn
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Thời gian còn lại (giây)
   */
  async ttl(key) {
    try {
      return await this.ttlAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi lấy TTL cho khóa ${key}:`, error);
      return -2; // -2 là giá trị Redis trả về khi khóa không tồn tại
    }
  }

  /**
   * Tăng giá trị của khóa lên 1
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Giá trị mới
   */
  async increment(key) {
    try {
      return await this.incrAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi tăng giá trị cho khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Giảm giá trị của khóa đi 1
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Giá trị mới
   */
  async decrement(key) {
    try {
      return await this.decrAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi giảm giá trị cho khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Xóa tất cả các khóa có cùng pattern
   * @param {string} pattern - Mẫu khóa cần xóa (ví dụ: 'products:*')
   * @returns {Promise<number>} Số lượng khóa đã xóa
   */
  async deleteByPattern(pattern) {
    try {
      const keys = await this.keysAsync(pattern);
      if (keys.length > 0) {
        return await this.delAsync(keys);
      }
      return 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa cache theo mẫu ${pattern}:`, error);
      return 0;
    }
  }

  /**
   * Xóa toàn bộ cache
   * @returns {Promise<boolean>} Kết quả xóa cache
   */
  async flush() {
    try {
      await this.flushdbAsync();
      logger.info('Đã xóa toàn bộ cache');
      return true;
    } catch (error) {
      logger.error('Lỗi khi xóa toàn bộ cache:', error);
      return false;
    }
  }

  /**
   * Lấy tất cả các trường và giá trị của một hash
   * @param {string} key - Khóa hash
   * @returns {Promise<object>} Đối tượng chứa các trường và giá trị
   */
  async getHash(key) {
    try {
      const data = await this.hgetallAsync(key);
      if (!data) return null;

      // Chuyển đổi các giá trị từ JSON string sang object
      const result = {};
      for (const field in data) {
        try {
          result[field] = JSON.parse(data[field]);
        } catch (e) {
          result[field] = data[field];
        }
      }
      return result;
    } catch (error) {
      logger.error(`Lỗi khi lấy hash với khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Lưu một trường vào hash
   * @param {string} key - Khóa hash
   * @param {string} field - Tên trường
   * @param {any} value - Giá trị cần lưu
   * @returns {Promise<boolean>} Kết quả lưu hash
   */
  async setHashField(key, field, value) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.hsetAsync(key, field, serializedValue);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu trường hash ${field} với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Lưu nhiều trường vào hash
   * @param {string} key - Khóa hash
   * @param {object} fields - Đối tượng chứa các trường và giá trị
   * @returns {Promise<boolean>} Kết quả lưu hash
   */
  async setHash(key, fields) {
    try {
      const serializedFields = {};
      for (const field in fields) {
        serializedFields[field] = JSON.stringify(fields[field]);
      }
      await this.hmsetAsync(key, serializedFields);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu hash với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Xóa một trường khỏi hash
   * @param {string} key - Khóa hash
   * @param {string} field - Tên trường
   * @returns {Promise<boolean>} Kết quả xóa trường
   */
  async deleteHashField(key, field) {
    try {
      const result = await this.hdelAsync(key, field);
      return result > 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa trường hash ${field} với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Đóng kết nối Redis
   * @returns {Promise<void>}
   */
  async close() {
    return new Promise((resolve) => {
      this.client.quit(() => {
        logger.info('Kết nối Redis đã đóng');
        this.isConnected = false;
        resolve();
      });
    });
  }
}

module.exports = new RedisCache();


--- File: services/cart/cartService.js ---
/**
 * Cart Service
 * Xử lý logic nghiệp vụ cho giỏ hàng
 */

const { ApiError } = require('../../common/errors/apiError');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const crypto = require('crypto');

/**
 * Tạo ID phiên cho khách vãng lai
 * @returns {string} Session ID
 */
const generateSessionId = () => {
  return crypto.randomBytes(16).toString('hex');
};

/**
 * Lấy giỏ hàng đang active của người dùng hoặc khách vãng lai
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Thông tin giỏ hàng
 */
const getActiveCart = async (userId, sessionId) => {
  let cart;

  // Trường hợp 1: User đã đăng nhập
  if (userId) {
    cart = await cartRepository.findOne({ user: userId, status: 'active' });
  }
  // Trường hợp 2: Khách vãng lai
  else if (sessionId) {
    cart = await cartRepository.findOne({ sessionId, status: 'active' });
  }

  // Nếu chưa có giỏ hàng, tạo mới
  if (!cart) {
    const newCart = {
      user: userId || null,
      sessionId: userId ? null : sessionId,
      items: [],
      subtotal: 0,
      status: 'active',
      lastActivity: new Date(),
    };

    // Thời hạn cho giỏ hàng của khách vãng lai
    if (!userId && sessionId) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 ngày
      newCart.expiresAt = expiryDate;
    }

    cart = await cartRepository.create(newCart);
  }

  return cart;
};

/**
 * Thêm sản phẩm vào giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} productId - ID của sản phẩm
 * @param {number} quantity - Số lượng sản phẩm
 * @param {Object} attributes - Các thuộc tính tùy chọn của sản phẩm
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi thêm sản phẩm
 */
const addItemToCart = async (userId, sessionId, productId, quantity, attributes = {}) => {
  // Kiểm tra sản phẩm tồn tại và còn hàng
  const product = await productRepository.findById(productId);

  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  if (!product.isActive) {
    throw new ApiError(400, 'Sản phẩm không khả dụng');
  }

  if (product.stock < quantity) {
    throw new ApiError(400, `Sản phẩm chỉ còn ${product.stock} trong kho`);
  }

  // Lấy giỏ hàng hiện tại hoặc tạo mới
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra xem sản phẩm đã có trong giỏ hàng chưa
  const existingItemIndex = cart.items.findIndex((item) => {
    return (
      item.product.toString() === productId &&
      JSON.stringify(item.attributes) === JSON.stringify(attributes)
    );
  });

  // Tính giá sản phẩm (ưu tiên giá khuyến mãi nếu có)
  const itemPrice = product.salePrice || product.price;

  // Nếu sản phẩm đã có trong giỏ, cập nhật số lượng
  if (existingItemIndex > -1) {
    const existingItem = cart.items[existingItemIndex];
    const newQuantity = existingItem.quantity + quantity;

    // Kiểm tra lại tồn kho
    if (product.stock < newQuantity) {
      throw new ApiError(400, `Không đủ hàng trong kho. Chỉ còn ${product.stock} sản phẩm.`);
    }

    // Cập nhật số lượng và tổng giá
    cart.items[existingItemIndex].quantity = newQuantity;
    cart.items[existingItemIndex].updatedAt = new Date();
  }
  // Nếu chưa có, thêm mới vào giỏ hàng
  else {
    cart.items.push({
      product: productId,
      quantity,
      price: itemPrice,
      attributes,
      addedAt: new Date(),
      updatedAt: new Date(),
    });
  }

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Cập nhật số lượng sản phẩm trong giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} itemId - ID của item trong giỏ hàng
 * @param {number} quantity - Số lượng mới
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi cập nhật
 */
const updateCartItem = async (userId, sessionId, itemId, quantity) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Tìm item trong giỏ hàng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm trong giỏ hàng');
  }

  // Lấy thông tin sản phẩm
  const cartItem = cart.items[itemIndex];
  const product = await productRepository.findById(cartItem.product);

  if (!product) {
    throw new ApiError(404, 'Sản phẩm không còn tồn tại');
  }

  // Kiểm tra tồn kho
  if (product.stock < quantity) {
    throw new ApiError(400, `Không đủ hàng trong kho. Chỉ còn ${product.stock} sản phẩm.`);
  }

  // Cập nhật số lượng
  cart.items[itemIndex].quantity = quantity;
  cart.items[itemIndex].updatedAt = new Date();

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Xóa sản phẩm khỏi giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} itemId - ID của item trong giỏ hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi xóa sản phẩm
 */
const removeItemFromCart = async (userId, sessionId, itemId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra item tồn tại trong giỏ hàng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm trong giỏ hàng');
  }

  // Xóa item khỏi giỏ hàng
  cart.items.splice(itemIndex, 1);

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Xóa toàn bộ giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng trống
 */
const clearCart = async (userId, sessionId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Xóa tất cả items
  cart.items = [];
  cart.subtotal = 0;

  // Xóa mã giảm giá nếu có
  if (cart.coupon) {
    cart.coupon = null;
  }

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Áp dụng mã giảm giá vào giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} code - Mã giảm giá
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu mã giảm giá không hợp lệ
 */
const applyCoupon = async (userId, sessionId, code) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra giỏ hàng có sản phẩm không
  if (cart.items.length === 0) {
    throw new ApiError(400, 'Giỏ hàng trống, không thể áp dụng mã giảm giá');
  }

  // TODO: Triển khai logic xác thực mã giảm giá thực tế
  // Ví dụ đơn giản: kiểm tra mã "WELCOME10" giảm 10% tổng giá trị
  if (code === 'WELCOME10') {
    const discount = Math.round(cart.subtotal * 0.1); // Giảm 10%

    cart.coupon = {
      code,
      discount,
      appliedAt: new Date(),
    };

    // Cập nhật thời gian hoạt động
    cart.lastActivity = new Date();

    // Lưu giỏ hàng
    return await cartRepository.update(cart._id, cart);
  }

  throw new ApiError(400, 'Mã giảm giá không hợp lệ hoặc đã hết hạn');
};

/**
 * Xóa mã giảm giá khỏi giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const removeCoupon = async (userId, sessionId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Xóa mã giảm giá
  cart.coupon = null;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Hợp nhất giỏ hàng khi đăng nhập
 * @param {string} userId - ID của người dùng đã đăng nhập
 * @param {string} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng đã hợp nhất
 */
const mergeCartsOnLogin = async (userId, sessionId) => {
  // Tìm giỏ hàng của khách vãng lai
  const guestCart = await cartRepository.findOne({ sessionId, status: 'active' });

  if (!guestCart) {
    return await getActiveCart(userId, null);
  }

  // Tìm hoặc tạo giỏ hàng của người dùng
  const userCart = await getActiveCart(userId, null);

  // Nếu giỏ hàng khách không có sản phẩm, không cần hợp nhất
  if (guestCart.items.length === 0) {
    // Đánh dấu giỏ hàng khách là đã hợp nhất
    await cartRepository.update(guestCart._id, {
      status: 'merged',
      updatedAt: new Date(),
    });

    return userCart;
  }

  // Hợp nhất các sản phẩm từ giỏ hàng khách vào giỏ hàng người dùng
  for (const guestItem of guestCart.items) {
    const existingItemIndex = userCart.items.findIndex((item) => {
      return (
        item.product.toString() === guestItem.product.toString() &&
        JSON.stringify(item.attributes) === JSON.stringify(guestItem.attributes)
      );
    });

    // Nếu sản phẩm đã có trong giỏ hàng người dùng, cộng số lượng
    if (existingItemIndex > -1) {
      // Lấy thông tin sản phẩm để kiểm tra tồn kho
      const product = await productRepository.findById(guestItem.product);

      if (product) {
        const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

        // Kiểm tra tồn kho
        if (product.stock >= newQuantity) {
          userCart.items[existingItemIndex].quantity = newQuantity;
        } else {
          // Nếu không đủ tồn kho, giới hạn số lượng
          userCart.items[existingItemIndex].quantity = product.stock;
        }

        userCart.items[existingItemIndex].updatedAt = new Date();
      }
    }
    // Nếu sản phẩm chưa có, thêm vào giỏ hàng người dùng
    else {
      // Kiểm tra lại sản phẩm và tồn kho
      const product = await productRepository.findById(guestItem.product);

      if (product && product.isActive) {
        // Điều chỉnh số lượng nếu vượt quá tồn kho
        const quantity = product.stock >= guestItem.quantity ? guestItem.quantity : product.stock;

        if (quantity > 0) {
          userCart.items.push({
            ...guestItem,
            quantity,
            updatedAt: new Date(),
          });
        }
      }
    }
  }

  // Tính lại tổng tiền
  userCart.subtotal = calculateSubtotal(userCart.items);

  // Áp dụng mã giảm giá từ giỏ hàng khách nếu có và giỏ hàng người dùng chưa có
  if (guestCart.coupon && !userCart.coupon) {
    userCart.coupon = {
      ...guestCart.coupon,
      appliedAt: new Date(),
    };
  }

  // Cập nhật thời gian hoạt động
  userCart.lastActivity = new Date();

  // Lưu giỏ hàng người dùng
  const updatedUserCart = await cartRepository.update(userCart._id, userCart);

  // Đánh dấu giỏ hàng khách là đã hợp nhất
  await cartRepository.update(guestCart._id, {
    status: 'merged',
    updatedAt: new Date(),
  });

  return updatedUserCart;
};

/**
 * Tính tổng tiền giỏ hàng
 * @param {Array} items - Các sản phẩm trong giỏ hàng
 * @returns {number} Tổng tiền
 */
const calculateSubtotal = (items) => {
  return items.reduce((total, item) => total + item.price * item.quantity, 0);
};

/**
 * Cập nhật thông tin vận chuyển cho giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {Object} shippingAddress - Thông tin địa chỉ giao hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const updateShippingAddress = async (userId, sessionId, shippingAddress) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Cập nhật địa chỉ giao hàng
  cart.shippingAddress = shippingAddress;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Cập nhật phương thức vận chuyển cho giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {Object} shippingMethod - Thông tin phương thức vận chuyển
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const updateShippingMethod = async (userId, sessionId, shippingMethod) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Cập nhật phương thức vận chuyển
  cart.shippingMethod = shippingMethod;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Đánh dấu giỏ hàng là đã bị bỏ rơi
 * @param {string} cartId - ID của giỏ hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const markCartAsAbandoned = async (cartId) => {
  return await cartRepository.update(cartId, {
    status: 'abandoned',
    updatedAt: new Date(),
  });
};

/**
 * Lấy danh sách giỏ hàng bị bỏ rơi để gửi email nhắc nhở
 * @param {number} hoursSinceLastActivity - Số giờ kể từ lần hoạt động cuối cùng
 * @returns {Promise<Array>} Danh sách giỏ hàng bị bỏ rơi
 */
const getAbandonedCarts = async (hoursSinceLastActivity = 24) => {
  const date = new Date();
  date.setHours(date.getHours() - hoursSinceLastActivity);

  return await cartRepository.find({
    status: 'active',
    lastActivity: { $lt: date },
    items: { $exists: true, $not: { $size: 0 } },
  });
};

module.exports = {
  generateSessionId,
  getActiveCart,
  addItemToCart,
  updateCartItem,
  removeItemFromCart,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCartsOnLogin,
  updateShippingAddress,
  updateShippingMethod,
  markCartAsAbandoned,
  getAbandonedCarts,
};


--- File: services/category/categoryService.js ---
/**
 * Category Service
 * Xử lý logic nghiệp vụ cho danh mục sản phẩm
 */

const { ApiError } = require('../../common/errors/apiError');
const categoryRepository = require('../../data/repositories/categoryRepository');
const productRepository = require('../../data/repositories/productRepository');
const slugify = require('slugify');

/**
 * Lấy tất cả danh mục (có thể lọc, sắp xếp, phân trang)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Array>} Danh sách danh mục
 */
const getAllCategories = async (features = {}) => {
  return await categoryRepository.findAll(features);
};

/**
 * Lấy danh mục theo ID
 * @param {string} id - ID của danh mục
 * @returns {Promise<Object>} Thông tin danh mục
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const getCategoryById = async (id) => {
  const category = await categoryRepository.findById(id);
  if (!category) {
    throw new ApiError(404, 'Không tìm thấy danh mục');
  }
  return category;
};

/**
 * Lấy danh mục theo slug
 * @param {string} slug - Slug của danh mục
 * @returns {Promise<Object>} Thông tin danh mục
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const getCategoryBySlug = async (slug) => {
  const category = await categoryRepository.findOne({ slug });
  if (!category) {
    throw new ApiError(404, 'Không tìm thấy danh mục');
  }
  return category;
};

/**
 * Lấy tất cả sản phẩm trong danh mục
 * @param {string} categoryId - ID của danh mục
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Array>} Danh sách sản phẩm trong danh mục
 */
const getCategoryProducts = async (categoryId, features = {}) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(categoryId);
  
  // Thêm filter cho category vào features
  const categoryFilter = { ...features };
  categoryFilter.filter = { ...categoryFilter.filter, category: categoryId };
  
  // Lấy tất cả các danh mục con
  const subcategories = await getSubcategories(categoryId);
  
  // Nếu có danh mục con, thêm vào filter
  if (subcategories.length > 0) {
    const subcategoryIds = subcategories.map(subcat => subcat._id);
    categoryFilter.filter = { 
      ...categoryFilter.filter, 
      $or: [
        { category: categoryId },
        { category: { $in: subcategoryIds } }
      ]
    };
  }
  
  return await productRepository.findAll(categoryFilter);
};

/**
 * Tạo danh mục mới
 * @param {Object} categoryData - Dữ liệu danh mục
 * @returns {Promise<Object>} Danh mục đã tạo
 */
const createCategory = async (categoryData) => {
  // Nếu không có slug, tạo từ tên
  if (!categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Kiểm tra slug đã tồn tại chưa
  const existingCategory = await categoryRepository.findOne({ slug: categoryData.slug });
  if (existingCategory) {
    throw new ApiError(400, 'Slug đã tồn tại');
  }
  
  // Xử lý danh mục cha và ancestors
  if (categoryData.parent) {
    const parentCategory = await getCategoryById(categoryData.parent);
    
    // Thiết lập level và ancestors
    categoryData.level = parentCategory.level + 1;
    categoryData.ancestors = [
      ...parentCategory.ancestors,
      {
        _id: parentCategory._id,
        name: parentCategory.name,
        slug: parentCategory.slug
      }
    ];
  } else {
    // Danh mục gốc
    categoryData.level = 0;
    categoryData.ancestors = [];
  }
  
  return await categoryRepository.create(categoryData);
};

/**
 * Cập nhật danh mục
 * @param {string} id - ID của danh mục
 * @param {Object} categoryData - Dữ liệu cập nhật
 * @returns {Promise<Object>} Danh mục đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const updateCategory = async (id, categoryData) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(id);
  
  // Nếu thay đổi tên và không cung cấp slug, cập nhật slug
  if (categoryData.name && !categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Kiểm tra slug mới có bị trùng không
  if (categoryData.slug && categoryData.slug !== category.slug) {
    const existingCategory = await categoryRepository.findOne({ 
      slug: categoryData.slug,
      _id: { $ne: id }
    });
    
    if (existingCategory) {
      throw new ApiError(400, 'Slug đã tồn tại');
    }
  }
  
  // Nếu thay đổi danh mục cha
  if (categoryData.parent !== undefined && categoryData.parent !== category.parent) {
    // Không cho phép đặt danh mục con làm cha của chính nó
    const subcategories = await getSubcategories(id);
    const subcategoryIds = subcategories.map(subcat => subcat._id.toString());
    
    if (categoryData.parent && (categoryData.parent === id || subcategoryIds.includes(categoryData.parent))) {
      throw new ApiError(400, 'Không thể đặt danh mục con làm cha của chính nó');
    }
    
    // Cập nhật level và ancestors
    if (categoryData.parent) {
      const parentCategory = await getCategoryById(categoryData.parent);
      
      categoryData.level = parentCategory.level + 1;
      categoryData.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug
        }
      ];
    } else {
      // Chuyển thành danh mục gốc
      categoryData.level = 0;
      categoryData.ancestors = [];
    }
    
    // Cập nhật tất cả danh mục con
    await updateSubcategoryAncestors(id, category.name, category.slug);
  }
  
  // Cập nhật danh mục
  const updatedCategory = await categoryRepository.update(id, categoryData);
  
  // Nếu thay đổi tên hoặc slug, cập nhật ancestors cho tất cả danh mục con
  if ((categoryData.name && categoryData.name !== category.name) ||
      (categoryData.slug && categoryData.slug !== category.slug)) {
    await updateSubcategoryAncestors(id, updatedCategory.name, updatedCategory.slug);
  }
  
  return updatedCategory;
};

/**
 * Xóa danh mục
 * @param {string} id - ID của danh mục
 * @returns {Promise<void>}
 * @throws {ApiError} Nếu không tìm thấy danh mục hoặc có danh mục con
 */
const deleteCategory = async (id) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(id);
  
  // Kiểm tra nếu có danh mục con
  const subcategories = await categoryRepository.find({ parent: id });
  if (subcategories.length > 0) {
    throw new ApiError(400, 'Không thể xóa danh mục có danh mục con');
  }
  
  // Kiểm tra nếu có sản phẩm trong danh mục
  const products = await productRepository.find({ category: id }, { limit: 1 });
  if (products.length > 0) {
    throw new ApiError(400, 'Không thể xóa danh mục có sản phẩm');
  }
  
  // Xóa danh mục
  await categoryRepository.delete(id);
};

/**
 * Lấy tất cả danh mục con trực tiếp
 * @param {string} parentId - ID của danh mục cha
 * @returns {Promise<Array>} Danh sách danh mục con
 */
const getDirectSubcategories = async (parentId) => {
  return await categoryRepository.find({ parent: parentId });
};

/**
 * Lấy tất cả danh mục con (bao gồm cả con của con)
 * @param {string} categoryId - ID của danh mục
 * @returns {Promise<Array>} Danh sách tất cả danh mục con
 */
const getSubcategories = async (categoryId) => {
  return await categoryRepository.findSubcategories(categoryId);
};

/**
 * Cập nhật ancestors cho tất cả danh mục con khi danh mục cha thay đổi
 * @param {string} categoryId - ID của danh mục cha
 * @param {string} categoryName - Tên mới của danh mục cha
 * @param {string} categorySlug - Slug mới của danh mục cha
 * @returns {Promise<void>}
 */
const updateSubcategoryAncestors = async (categoryId, categoryName, categorySlug) => {
  // Lấy tất cả danh mục con trực tiếp
  const directSubcategories = await getDirectSubcategories(categoryId);
  
  // Cập nhật ancestors cho từng danh mục con
  for (const subcategory of directSubcategories) {
    // Tìm vị trí của danh mục cha trong ancestors
    const ancestorIndex = subcategory.ancestors.findIndex(
      ancestor => ancestor._id.toString() === categoryId
    );
    
    if (ancestorIndex !== -1) {
      // Cập nhật thông tin ancestor
      const updatedAncestors = [...subcategory.ancestors];
      updatedAncestors[ancestorIndex] = {
        _id: categoryId,
        name: categoryName,
        slug: categorySlug
      };
      
      // Cập nhật danh mục con
      await categoryRepository.update(subcategory._id, {
        ancestors: updatedAncestors
      });
      
      // Đệ quy cập nhật các danh mục con của con
      await updateSubcategoryAncestors(
        subcategory._id,
        subcategory.name,
        subcategory.slug
      );
    }
  }
};

/**
 * Tạo breadcrumbs từ ancestors
 * @param {string} categoryId - ID của danh mục
 * @returns {Promise<Array>} Danh sách breadcrumbs
 */
const createBreadcrumbs = async (categoryId) => {
  const category = await getCategoryById(categoryId);
  
  // Tạo breadcrumbs từ ancestors và thêm danh mục hiện tại
  const breadcrumbs = [
    ...category.ancestors.map(ancestor => ({
      id: ancestor._id,
      name: ancestor.name,
      slug: ancestor.slug
    })),
    {
      id: category._id,
      name: category.name,
      slug: category.slug
    }
  ];
  
  return breadcrumbs;
};

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryBySlug,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getDirectSubcategories,
  getSubcategories,
  createBreadcrumbs
};

--- File: services/email/emailService.js ---
/**
 * Email Service - xử lý gửi email
 * @author Steve
 * @project RunOut-Biliard
 */

const nodemailer = require('nodemailer');
const path = require('path');
const fs = require('fs').promises;
const handlebars = require('handlebars');
const logger = require('../../config/logger');
const environment = require('../../config/environment');

/**
 * Class EmailService - xử lý gửi email
 */
class EmailService {
  constructor() {
    // Thiết lập transporter
    this.setupTransporter();

    // Đường dẫn đến thư mục chứa templates
    this.templatesDir = path.resolve(__dirname, 'templates');

    // Cache cho templates đã compile
    this.templateCache = {};
  }

  /**
   * Thiết lập transporter cho Nodemailer
   */
  setupTransporter() {
    // Sử dụng cấu hình khác nhau tùy thuộc vào môi trường
    if (environment.app.environment === 'development') {
      // Sử dụng Ethereal cho môi trường development
      this.createTestAccount();
    } else {
      // Sử dụng cấu hình SMTP thực cho production
      this.transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST,
        port: process.env.EMAIL_PORT,
        secure: process.env.EMAIL_SECURE === 'true',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS,
        },
      });
    }
  }

  /**
   * Tạo test account với Ethereal cho môi trường development
   */
  async createTestAccount() {
    try {
      const testAccount = await nodemailer.createTestAccount();

      this.transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email',
        port: 587,
        secure: false,
        auth: {
          user: testAccount.user,
          pass: testAccount.pass,
        },
      });

      logger.info(`Đã tạo test account với Ethereal Email: ${testAccount.user}`);
    } catch (error) {
      logger.error(`Không thể tạo test account: ${error.message}`);

      // Fallback đến cấu hình giả lập
      this.transporter = {
        sendMail: async (mailOptions) => {
          logger.info('Gửi email giả lập:');
          logger.info(`Đến: ${mailOptions.to}`);
          logger.info(`Chủ đề: ${mailOptions.subject}`);
          logger.info(`Nội dung: ${mailOptions.text || mailOptions.html}`);

          return { messageId: `mock_${Date.now()}` };
        },
      };
    }
  }

  /**
   * Đọc và compile template email
   * @param {string} templateName - Tên template
   * @returns {Promise<Function>} - Template đã compile
   */
  async getTemplate(templateName) {
    // Kiểm tra cache
    if (this.templateCache[templateName]) {
      return this.templateCache[templateName];
    }

    try {
      // Đọc file template
      const templatePath = path.join(this.templatesDir, `${templateName}.hbs`);
      const templateSource = await fs.readFile(templatePath, 'utf8');

      // Compile template
      const template = handlebars.compile(templateSource);

      // Lưu vào cache
      this.templateCache[templateName] = template;

      return template;
    } catch (error) {
      logger.error(`Không thể đọc template email '${templateName}': ${error.message}`);
      throw error;
    }
  }

  /**
   * Gửi email
   * @param {Object} options - Tùy chọn email
   * @param {string} options.to - Người nhận
   * @param {string} options.subject - Chủ đề
   * @param {string} options.template - Tên template (không có phần mở rộng)
   * @param {Object} options.context - Dữ liệu cho template
   * @returns {Promise<Object>} - Kết quả gửi email
   */
  async sendEmail(options) {
    try {
      const { to, subject, template, context } = options;

      // Lấy template
      const compiledTemplate = await this.getTemplate(template);

      // Thêm vào các biến toàn cục
      const enhancedContext = {
        ...context,
        appName: environment.app.name,
        signature: environment.app.signature,
        year: new Date().getFullYear(),
        logoUrl: process.env.APP_LOGO_URL || 'https://example.com/logo.png',
      };

      // Render HTML từ template
      const html = compiledTemplate(enhancedContext);

      // Thiết lập mail options
      const mailOptions = {
        from: process.env.EMAIL_FROM || `"${environment.app.name}" <no-reply@example.com>`,
        to,
        subject,
        html,
      };

      // Gửi email
      const info = await this.transporter.sendMail(mailOptions);

      // Log URL để xem email (chỉ trong môi trường development với Ethereal)
      if (environment.app.environment === 'development' && info.messageId) {
        logger.info(`URL xem email: ${nodemailer.getTestMessageUrl(info)}`);
      }

      return info;
    } catch (error) {
      logger.error(`Lỗi gửi email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new EmailService();

// Helper function để sử dụng service dễ dàng hơn
module.exports.sendEmail = (options) => module.exports.sendEmail(options);


--- File: services/email/templates/resetPassword.hbs ---
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Đặt Lại Mật Khẩu</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f9f9f9;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: #ffffff;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .header {
      text-align: center;
      padding: 20px 0;
      border-bottom: 2px solid #f0f0f0;
    }
    .logo {
      max-width: 180px;
      height: auto;
    }
    .content {
      padding: 20px 0;
    }
    .button {
      display: inline-block;
      padding: 12px 30px;
      background-color: #e74c3c;
      color: #ffffff !important;
      text-decoration: none;
      border-radius: 4px;
      font-weight: bold;
      margin: 20px 0;
      text-align: center;
    }
    .button:hover {
      background-color: #c0392b;
    }
    .footer {
      text-align: center;
      padding-top: 20px;
      border-top: 1px solid #f0f0f0;
      font-size: 12px;
      color: #777;
    }
    .warning {
      background-color: #fcf8e3;
      border-left: 4px solid #f0ad4e;
      padding: 10px;
      font-size: 14px;
      margin: 15px 0;
    }
    .note {
      font-size: 14px;
      color: #777;
      font-style: italic;
    }
    @media only screen and (max-width: 600px) {
      .container {
        width: 100%;
        padding: 10px;
      }
      .content {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <img src="{{logoUrl}}" alt="{{appName}}" class="logo">
      <h1>Đặt Lại Mật Khẩu</h1>
    </div>
    <div class="content">
      <p>Xin chào <strong>{{name}}</strong>,</p>
      
      <p>Chúng tôi đã nhận được yêu cầu đặt lại mật khẩu cho tài khoản của bạn tại <strong>{{appName}}</strong>. Vui lòng nhấp vào nút bên dưới để tiến hành đặt lại mật khẩu:</p>
      
      <div style="text-align: center;">
        <a href="{{resetURL}}" class="button">Đặt Lại Mật Khẩu</a>
      </div>
      
      <p>Hoặc, bạn có thể sao chép và dán đường dẫn dưới đây vào trình duyệt của mình:</p>
      
      <p style="word-break: break-all; background-color: #f5f5f5; padding: 10px; border-radius: 3px;">
        {{resetURL}}
      </p>
      
      <div class="warning">
        <strong>Lưu ý quan trọng:</strong> Đường dẫn này sẽ hết hạn sau 10 phút vì lý do bảo mật.
      </div>
      
      <p>Nếu bạn không yêu cầu đặt lại mật khẩu, vui lòng bỏ qua email này hoặc liên hệ với chúng tôi ngay nếu bạn cho rằng có ai đó đang cố gắng truy cập trái phép vào tài khoản của bạn.</p>
      
      <p class="note">* Vì lý do bảo mật, chúng tôi khuyên bạn nên chọn một mật khẩu mạnh mà bạn chưa từng sử dụng cho các dịch vụ khác.</p>
      
      <p>Trân trọng,<br>Đội ngũ {{appName}}</p>
    </div>
    <div class="footer">
      <p>&copy; {{year}} {{appName}}. Tất cả các quyền thuộc về {{signature}}.</p>
      <p>
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Chính sách bảo mật</a> |
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Điều khoản sử dụng</a> |
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Liên hệ</a>
      </p>
    </div>
  </div>
</body>
</html>
{{! This template is used for sending password reset emails. }}
{{! It includes a logo, a greeting, a button to reset the password, and a note about security. }}
{{! The email is styled with CSS for better readability and user experience. }}
{{! The template uses Handlebars syntax for dynamic content rendering. }}
{{! The email is designed to be responsive for mobile devices. }}

--- File: services/email/templates/verification.hbs ---
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xác Thực Tài Khoản</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f9f9f9;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: #ffffff;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .header {
      text-align: center;
      padding: 20px 0;
      border-bottom: 2px solid #f0f0f0;
    }
    .logo {
      max-width: 180px;
      height: auto;
    }
    .content {
      padding: 20px 0;
    }
    .button {
      display: inline-block;
      padding: 12px 30px;
      background-color: #3498db;
      color: #ffffff !important;
      text-decoration: none;
      border-radius: 4px;
      font-weight: bold;
      margin: 20px 0;
      text-align: center;
    }
    .button:hover {
      background-color: #2980b9;
    }
    .footer {
      text-align: center;
      padding-top: 20px;
      border-top: 1px solid #f0f0f0;
      font-size: 12px;
      color: #777;
    }
    .note {
      font-size: 14px;
      color: #777;
      font-style: italic;
    }
    @media only screen and (max-width: 600px) {
      .container {
        width: 100%;
        padding: 10px;
      }
      .content {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <img src="{{logoUrl}}" alt="{{appName}}" class="logo">
      <h1>Xác Thực Tài Khoản</h1>
    </div>
    <div class="content">
      <p>Xin chào <strong>{{name}}</strong>,</p>
      
      <p>Cảm ơn bạn đã đăng ký tài khoản tại <strong>{{appName}}</strong>. Để hoàn tất quá trình đăng ký, vui lòng xác nhận địa chỉ email của bạn bằng cách nhấp vào nút bên dưới:</p>
      
      <div style="text-align: center;">
        <a href="{{verifyURL}}" class="button">Xác Nhận Email</a>
      </div>
      
      <p>Hoặc, bạn có thể sao chép và dán đường dẫn dưới đây vào trình duyệt của mình:</p>
      
      <p style="word-break: break-all; background-color: #f5f5f5; padding: 10px; border-radius: 3px;">
        {{verifyURL}}
      </p>
      
      <p class="note">* Đường dẫn này sẽ hết hạn sau 24 giờ.</p>
      
      <p>Nếu bạn không thực hiện yêu cầu này, vui lòng bỏ qua email này hoặc liên hệ với chúng tôi nếu bạn có thắc mắc.</p>
      
      <p>Trân trọng,<br>Đội ngũ {{appName}}</p>
    </div>
    <div class="footer">
      <p>&copy; {{year}} {{appName}}. Tất cả các quyền thuộc về {{signature}}.</p>
      <p>
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Chính sách bảo mật</a> |
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Điều khoản sử dụng</a> |
        <a href="#" style="color: #777; text-decoration: none; margin: 0 5px;">Liên hệ</a>
      </p>
    </div>
  </div>
</body>
</html>
{{! This template is used for sending account verification emails. }}
{{! It includes a logo, a greeting, a verification button, and a footer with links. }}
{{! The template is styled to be responsive and visually appealing. }}
{{! The placeholders will be replaced with actual values when the email is sent. }}
{{! The template uses Handlebars syntax for dynamic content rendering. }}
{{! Ensure to replace {{logoUrl}}, {{appName}}, {{name}}, {{verifyURL}}, {{year}}, and {{signature}} with actual values. }}
{{! The button color and hover effect can be customized as needed. }}
{{! The note about the expiration of the verification link is included for user awareness. }}
{{! The footer includes links to privacy policy, terms of use, and contact information. }}
{{! The email is designed to be user-friendly and easy to read on both desktop and mobile devices. }}
{{! Make sure to test the email template in different email clients for compatibility. }}
{{! This template is part of a larger email service system for user account management. }}
{{! The email service should handle sending the email with the appropriate SMTP settings. }}
{{! Ensure to validate the email addresses before sending to avoid bounces. }}
{{! Consider adding tracking parameters to the verification link for analytics purposes. }}
{{! The template can be further enhanced with additional styling or branding elements as needed. }}
{{! Always keep user experience in mind when designing email templates. }}
{{! Regularly review and update the template to ensure it meets current design standards. }}
{{! This template is a crucial part of the user onboarding process for the application. }}
{{! Properly test the email template with various email clients to ensure consistent rendering. }}
{{! Consider A/B testing different subject lines or content to improve engagement rates. }}
{{! Monitor the performance of the verification emails to optimize future campaigns. }}
{{! This template is a key component of the user verification process in the application. }}
{{! Ensure that all links are functional and lead to the correct destinations. }}
{{! The design should align with the overall branding of the application for consistency. }}

--- File: services/order/orderService.js ---
/**
 * Order Service
 * Xử lý logic nghiệp vụ cho đơn hàng
 */

const { ApiError } = require('../../common/errors/apiError');
const orderRepository = require('../../data/repositories/orderRepository');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const emailService = require('../email/emailService');
const { generateOrderNumber } = require('../../utils/orderUtils');
const VNPayService = require('./vnpayService');

/**
 * Lấy tất cả đơn hàng (admin)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đơn hàng và thông tin phân trang
 */
const getAllOrders = async (features = {}) => {
  return await orderRepository.findAll(features);
};

/**
 * Lấy đơn hàng theo ID
 * @param {string} id - ID của đơn hàng
 * @param {string} userId - ID của người dùng đang yêu cầu
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Thông tin đơn hàng
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc không có quyền truy cập
 */
const getOrderById = async (id, userId, isAdmin) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra quyền truy cập
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền truy cập đơn hàng này');
  }

  return order;
};

/**
 * Lấy tất cả đơn hàng của một người dùng
 * @param {string} userId - ID của người dùng
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đơn hàng và thông tin phân trang
 */
const getOrdersByUserId = async (userId, features = {}) => {
  // Thêm filter cho user
  const userFilter = { ...features };
  userFilter.filter = { ...userFilter.filter, user: userId };

  return await orderRepository.findAll(userFilter);
};

/**
 * Tạo đơn hàng mới
 * @param {Object} orderData - Dữ liệu đơn hàng
 * @param {string} userId - ID của người dùng đặt hàng
 * @returns {Promise<Object>} Đơn hàng đã tạo
 * @throws {ApiError} Nếu có lỗi khi tạo đơn hàng
 */
const createOrder = async (orderData, userId) => {
  // Khởi tạo đơn hàng
  const orderInfo = {
    orderNumber: await generateOrderNumber(),
    user: userId,
    customerInfo: orderData.customerInfo,
    shippingAddress: orderData.shippingAddress,
    shippingMethod: orderData.shippingMethod,
    paymentMethod: orderData.paymentMethod,
    customerNotes: orderData.customerNotes,
    status: 'pending',
    statusHistory: [
      {
        status: 'pending',
        date: new Date(),
        note: 'Đơn hàng đã được tạo',
      },
    ],
  };

  let items = [];
  let subtotal = 0;

  // Trường hợp 1: Tạo đơn hàng từ giỏ hàng
  if (orderData.cartId) {
    const cart = await cartRepository.findById(orderData.cartId);

    if (!cart) {
      throw new ApiError(404, 'Không tìm thấy giỏ hàng');
    }

    // Kiểm tra quyền truy cập giỏ hàng
    if (cart.user.toString() !== userId) {
      throw new ApiError(403, 'Bạn không có quyền truy cập giỏ hàng này');
    }

    // Chuyển từ cart items sang order items
    items = await Promise.all(
      cart.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Không tìm thấy sản phẩm ${item.product}`);
        }

        // Kiểm tra tồn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `Sản phẩm ${product.name} chỉ còn ${product.stock} sản phẩm trong kho`
          );
        }

        return {
          product: item.product,
          name: product.name,
          price: item.price,
          quantity: item.quantity,
          totalPrice: item.price * item.quantity,
          attributes: item.attributes,
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // Tính tổng tiền
    subtotal = cart.subtotal;

    // Lấy thông tin khuyến mãi từ giỏ hàng
    if (cart.coupon) {
      orderInfo.discount = {
        amount: cart.coupon.discount,
        code: cart.coupon.code,
      };
    }

    // Đánh dấu giỏ hàng đã chuyển thành đơn hàng
    await cartRepository.update(cart._id, { status: 'converted' });
  }
  // Trường hợp 2: Tạo đơn hàng từ danh sách sản phẩm trực tiếp
  else if (orderData.items && orderData.items.length > 0) {
    items = await Promise.all(
      orderData.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Không tìm thấy sản phẩm ${item.product}`);
        }

        // Kiểm tra tồn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `Sản phẩm ${product.name} chỉ còn ${product.stock} sản phẩm trong kho`
          );
        }

        const itemPrice = product.salePrice || product.price;
        const totalPrice = itemPrice * item.quantity;
        subtotal += totalPrice;

        return {
          product: item.product,
          name: product.name,
          price: itemPrice,
          quantity: item.quantity,
          totalPrice,
          attributes: item.attributes || {},
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // Áp dụng mã giảm giá nếu có
    if (orderData.couponCode) {
      // TODO: Triển khai logic áp dụng mã giảm giá
    }
  } else {
    throw new ApiError(400, 'Đơn hàng phải có ít nhất một sản phẩm');
  }

  // Tính giá vận chuyển
  const shippingCost = calculateShippingCost(
    orderData.shippingMethod,
    orderData.shippingAddress.country
  );

  // Tính thuế (nếu có)
  const tax = 0; // TODO: Triển khai tính thuế

  // Tính tổng tiền cuối cùng
  const discount = orderInfo.discount ? orderInfo.discount.amount : 0;
  const totalAmount = subtotal + shippingCost + tax - discount;

  // Hoàn thiện thông tin đơn hàng
  orderInfo.items = items;
  orderInfo.subtotal = subtotal;
  orderInfo.shippingCost = shippingCost;
  orderInfo.tax = tax;
  orderInfo.totalAmount = totalAmount;
  orderInfo.paymentStatus = orderData.paymentMethod === 'cod' ? 'pending' : 'pending';

  // Lưu đơn hàng vào database
  let newOrder;
  try {
    newOrder = await orderRepository.create(orderInfo);
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi tạo đơn hàng: ' + error.message);
  }

  // Cập nhật tồn kho
  try {
    await updateInventory(items);
  } catch (error) {
    // Nếu cập nhật tồn kho thất bại, xóa đơn hàng đã tạo
    try {
      await orderRepository.delete(newOrder._id);
    } catch (deleteError) {
      console.error('Không thể xóa đơn hàng sau khi cập nhật tồn kho thất bại:', deleteError);
    }
    throw new ApiError(500, 'Lỗi khi cập nhật tồn kho: ' + error.message);
  }

  // Tạo URL thanh toán nếu phương thức là vnpay
  if (orderData.paymentMethod === 'vnpay') {
    try {
      const paymentUrl = await VNPayService.createPaymentUrl({
        orderId: newOrder._id,
        amount: totalAmount,
        orderInfo: `Thanh toán đơn hàng ${newOrder.orderNumber}`,
      });

      // Trả về URL thanh toán cùng với đơn hàng
      return { order: newOrder, paymentUrl };
    } catch (error) {
      // Nếu tạo URL thanh toán thất bại, không cần xóa đơn hàng
      // Chỉ ghi log và trả về đơn hàng mà không có URL thanh toán
      console.error('Lỗi khi tạo URL thanh toán VNPay:', error);
      return newOrder;
    }
  }

  // Gửi email xác nhận đơn hàng
  try {
    await sendOrderConfirmationEmail(newOrder);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi nhưng không ảnh hưởng đến việc tạo đơn hàng
    console.error('Lỗi khi gửi email xác nhận đơn hàng:', error);
  }

  return newOrder;
};

/**
 * Cập nhật trạng thái đơn hàng
 * @param {string} id - ID của đơn hàng
 * @param {string} status - Trạng thái mới
 * @param {string} note - Ghi chú khi cập nhật trạng thái
 * @param {string} adminId - ID của admin thực hiện cập nhật
 * @returns {Promise<Object>} Đơn hàng đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc trạng thái không hợp lệ
 */
const updateOrderStatus = async (id, status, note, adminId) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra trạng thái hiện tại và trạng thái mới
  const validStatusTransitions = {
    pending: ['processing', 'cancelled'],
    processing: ['packed', 'cancelled'],
    packed: ['shipped', 'cancelled'],
    shipped: ['delivered', 'returned'],
    delivered: ['returned'],
    cancelled: [],
    returned: [],
  };

  if (!validStatusTransitions[order.status].includes(status)) {
    throw new ApiError(400, `Không thể chuyển từ trạng thái ${order.status} sang ${status}`);
  }

  // Cập nhật trạng thái đơn hàng
  const statusHistory = {
    status,
    date: new Date(),
    note: note || `Đơn hàng đã được chuyển sang trạng thái ${status}`,
    updatedBy: adminId,
  };

  const updateData = {
    status,
    statusHistory: [...order.statusHistory, statusHistory],
  };

  // Cập nhật các trường khác tùy theo trạng thái
  if (status === 'delivered') {
    updateData.completedAt = new Date();

    // Nếu thanh toán là COD, cập nhật trạng thái thanh toán
    if (order.paymentMethod === 'cod') {
      updateData.paymentStatus = 'paid';
      updateData.paymentDetails = {
        ...order.paymentDetails,
        paymentDate: new Date(),
      };
    }
  } else if (status === 'cancelled') {
    updateData.cancelledAt = new Date();

    // Hoàn trả sản phẩm vào kho
    await restoreInventory(order.items);
  } else if (status === 'returned') {
    // Hoàn trả sản phẩm vào kho
    await restoreInventory(order.items);
  }

  // Cập nhật đơn hàng
  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, updateData);
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi cập nhật đơn hàng: ' + error.message);
  }

  // Gửi email thông báo thay đổi trạng thái
  try {
    await sendOrderStatusUpdateEmail(updatedOrder);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi
    console.error('Lỗi khi gửi email thông báo thay đổi trạng thái:', error);
  }

  return updatedOrder;
};

/**
 * Hủy đơn hàng
 * @param {string} id - ID của đơn hàng
 * @param {string} userId - ID của người dùng yêu cầu hủy
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @param {string} reason - Lý do hủy đơn hàng
 * @returns {Promise<Object>} Đơn hàng đã hủy
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc không thể hủy
 */
const cancelOrder = async (id, userId, isAdmin, reason) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra quyền truy cập
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền hủy đơn hàng này');
  }

  // Kiểm tra trạng thái hiện tại
  if (!['pending', 'processing'].includes(order.status)) {
    throw new ApiError(400, 'Chỉ có thể hủy đơn hàng ở trạng thái đang xử lý hoặc chờ xử lý');
  }

  // Nếu đơn hàng đã thanh toán, kiểm tra xem có thể hoàn tiền không
  if (order.paymentStatus === 'paid') {
    // TODO: Xử lý hoàn tiền
  }

  // Cập nhật trạng thái đơn hàng
  const statusHistory = {
    status: 'cancelled',
    date: new Date(),
    note: reason || 'Đơn hàng đã bị hủy bởi người dùng',
    updatedBy: isAdmin ? userId : null,
  };

  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, {
      status: 'cancelled',
      statusHistory: [...order.statusHistory, statusHistory],
      cancelledAt: new Date(),
    });
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi cập nhật trạng thái đơn hàng: ' + error.message);
  }

  // Hoàn trả sản phẩm vào kho
  try {
    await restoreInventory(order.items);
  } catch (error) {
    // Nếu hoàn trả sản phẩm thất bại, ghi log lỗi nhưng vẫn giữ trạng thái đơn hàng đã hủy
    console.error('Lỗi khi hoàn trả sản phẩm vào kho:', error);
  }

  // Gửi email thông báo hủy đơn hàng
  try {
    await sendOrderCancelledEmail(updatedOrder, reason);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi
    console.error('Lỗi khi gửi email thông báo hủy đơn hàng:', error);
  }

  return updatedOrder;
};

/**
 * Xử lý webhook từ cổng thanh toán VNPay
 * @param {Object} paymentData - Dữ liệu từ VNPay
 * @returns {Promise<void>}
 */
const processPaymentWebhook = async (paymentData) => {
  // Xác thực dữ liệu từ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'Dữ liệu thanh toán không hợp lệ');
  }

  // Lấy thông tin đơn hàng từ vnp_OrderInfo hoặc vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Cập nhật trạng thái thanh toán dựa vào response code
  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh toán thành công
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }

    // Gửi email xác nhận thanh toán
    try {
      const updatedOrder = await orderRepository.findById(orderId);
      await sendPaymentConfirmationEmail(updatedOrder);
    } catch (error) {
      // Nếu gửi email thất bại, chỉ ghi log lỗi
      console.error('Lỗi khi gửi email xác nhận thanh toán:', error);
    }
  } else {
    // Thanh toán thất bại
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  }
};

/**
 * Xử lý redirect URL từ cổng thanh toán VNPay
 * @param {Object} paymentData - Dữ liệu từ VNPay
 * @returns {Promise<Object>} Kết quả thanh toán
 */
const processPaymentReturn = async (paymentData) => {
  // Xác thực dữ liệu từ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'Dữ liệu thanh toán không hợp lệ');
  }

  // Lấy thông tin đơn hàng từ vnp_OrderInfo hoặc vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Cập nhật trạng thái thanh toán dựa vào response code
  let result = {};

  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh toán thành công
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });

      // Gửi email xác nhận thanh toán
      try {
        await sendPaymentConfirmationEmail(updatedOrder);
      } catch (emailError) {
        console.error('Lỗi khi gửi email xác nhận thanh toán:', emailError);
      }

      result = {
        success: true,
        message: 'Thanh toán thành công',
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  } else {
    // Thanh toán thất bại
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });

      result = {
        success: false,
        message: 'Thanh toán thất bại',
        errorCode: paymentData.vnp_ResponseCode,
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  }

  return result;
};

/**
 * Tính phí vận chuyển dựa trên phương thức và địa chỉ
 * @param {string} method - Phương thức vận chuyển
 * @param {string} country - Quốc gia giao hàng
 * @returns {number} Phí vận chuyển
 */
const calculateShippingCost = (method, country) => {
  // TODO: Triển khai tính phí vận chuyển thực tế
  const baseCost = method === 'express' ? 50000 : 30000;

  // Tính phí vận chuyển dựa trên quốc gia
  if (country !== 'Việt Nam') {
    return baseCost * 3;
  }

  return baseCost;
};

/**
 * Cập nhật tồn kho sau khi tạo đơn hàng
 * @param {Array} items - Danh sách sản phẩm trong đơn hàng
 * @returns {Promise<void>}
 */
const updateInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, -item.quantity);
  }
};

/**
 * Hoàn trả sản phẩm vào kho khi hủy đơn hàng
 * @param {Array} items - Danh sách sản phẩm trong đơn hàng
 * @returns {Promise<void>}
 */
const restoreInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, item.quantity);
  }
};

/**
 * Gửi email xác nhận đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderConfirmationEmail = async (order) => {
  await emailService.sendOrderConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderDate: order.createdAt,
    orderItems: order.items,
    subtotal: order.subtotal,
    shippingCost: order.shippingCost,
    discount: order.discount ? order.discount.amount : 0,
    tax: order.tax,
    totalAmount: order.totalAmount,
    shippingAddress: order.shippingAddress,
    paymentMethod: order.paymentMethod,
  });
};

/**
 * Gửi email thông báo thay đổi trạng thái đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderStatusUpdateEmail = async (order) => {
  await emailService.sendOrderStatusUpdate(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderStatus: order.status,
    statusNote: order.statusHistory[order.statusHistory.length - 1].note,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * Gửi email thông báo hủy đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @param {string} reason - Lý do hủy đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderCancelledEmail = async (order, reason) => {
  await emailService.sendOrderCancelled(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    cancelReason: reason,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * Gửi email xác nhận thanh toán
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendPaymentConfirmationEmail = async (order) => {
  await emailService.sendPaymentConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    paymentMethod: order.paymentMethod,
    paymentDate: order.paymentDetails.paymentDate,
    totalAmount: order.totalAmount,
    transactionId: order.paymentDetails.transactionId,
  });
};

module.exports = {
  getAllOrders,
  getOrderById,
  getOrdersByUserId,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processPaymentWebhook,
  processPaymentReturn,
};


--- File: services/product/productService.js ---
/**
 * Product Service
 * Xử lý tất cả logic nghiệp vụ liên quan đến sản phẩm
 */

const productRepository = require('../../data/repositories/productRepository');
const categoryRepository = require('../../data/repositories/categoryRepository');
const reviewRepository = require('../../data/repositories/reviewRepository');
const ProductDTO = require('../../data/dto/productDTO');
const ApiFeatures = require('../../utils/apiFeatures');
const AppError = require('../../common/errors/apiError');
const redisClient = require('../cache/redisCache');
const { formatProductResponse } = require('../../common/utils/formatters');
const { validateProductData } = require('../../common/validators/productValidator');

class ProductService {
  constructor() {
    this.productRepository = productRepository;
    this.categoryRepository = categoryRepository;
    this.reviewRepository = reviewRepository;
    this.cacheExpiry = 3600; // 1 giờ
  }

  /**
   * Xử lý lỗi chung cho tất cả các phương thức
   * @param {Error} error - Lỗi cần xử lý
   * @param {string} defaultMessage - Thông báo mặc định nếu không phải AppError
   * @throws {AppError} - Ném lỗi đã được xử lý
   */
  handleError(error, defaultMessage) {
    console.error(`Error in ProductService: ${error.message}`, error);
    if (error instanceof AppError) throw error;
    throw new AppError(defaultMessage, 500);
  }

  /**
   * Quản lý cache
   * @param {string} key - Khóa cache
   * @param {number} expiry - Thời gian hết hạn (giây)
   * @param {Function} dataFn - Hàm lấy dữ liệu nếu cache miss
   * @returns {Promise<any>} - Dữ liệu từ cache hoặc từ hàm dataFn
   */
  async withCache(key, expiry, dataFn) {
    try {
      // Kiểm tra cache
      const cachedData = await redisClient.get(key);
      if (cachedData) {
        console.log(`Cache hit for ${key}`);
        return JSON.parse(cachedData);
      }

      // Cache miss, lấy dữ liệu mới
      const data = await dataFn();

      // Lưu vào cache
      await redisClient.setex(key, expiry || this.cacheExpiry, JSON.stringify(data));

      return data;
    } catch (error) {
      console.error(`Cache error for ${key}:`, error);
      // Nếu có lỗi cache, vẫn trả về dữ liệu
      return await dataFn();
    }
  }

  /**
   * Xóa cache theo pattern
   * @param {string} pattern - Pattern của khóa cache cần xóa
   */
  async invalidateCache(pattern) {
    try {
      if (pattern.includes('*')) {
        // Xóa theo pattern
        const keys = await redisClient.keys(pattern);
        if (keys.length > 0) {
          await redisClient.del(keys);
          console.log(`Invalidated ${keys.length} cache keys matching ${pattern}`);
        }
      } else {
        // Xóa một khóa cụ thể
        await redisClient.del(pattern);
        console.log(`Invalidated cache key: ${pattern}`);
      }
    } catch (error) {
      console.error(`Error invalidating cache ${pattern}:`, error);
      // Không ném lỗi, chỉ ghi log
    }
  }

  /**
   * Lấy danh sách sản phẩm với bộ lọc và phân trang
   * @param {Object} queryParams - Các tham số truy vấn
   * @returns {Promise<{products: Array, totalCount: Number, pagination: Object}>}
   */
  async getProducts(queryParams) {
    try {
      // Tạo khóa cache dựa trên tham số truy vấn
      const cacheKey = `products:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tạo đối tượng ApiFeatures để xử lý phân trang, sắp xếp và lọc
        const features = new ApiFeatures(this.productRepository.query(), queryParams)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Thực hiện truy vấn
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuyển đổi thành DTO
        const productDTOs = products.map((product) => new ProductDTO(product).toJSON());

        // Định dạng phản hồi sản phẩm trước khi trả về
        const formattedProducts = productDTOs.map((product) => formatProductResponse(product));

        // Kết quả trả về
        return {
          products: formattedProducts,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm');
    }
  }

  /**
   * Lấy chi tiết sản phẩm theo ID
   * @param {string} productId - ID của sản phẩm
   * @returns {Promise<Object>} - Thông tin chi tiết sản phẩm
   */
  async getProductById(productId) {
    try {
      const cacheKey = `product:${productId}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Lấy thông tin sản phẩm từ repository
        const product = await this.productRepository.findById(productId);

        if (!product) {
          throw new AppError(404, 'Không tìm thấy sản phẩm');
        }

        // Lấy thêm thông tin đánh giá
        const reviews = await this.reviewRepository.findByProductId(productId);

        // Kết hợp thông tin
        const productDTO = new ProductDTO(product).toJSON();
        productDTO.reviews = reviews;
        productDTO.averageRating =
          reviews.length > 0
            ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
            : 0;

        // Lấy thông tin danh mục
        if (product.categories && product.categories.length) {
          productDTO.categoryDetails = await this.categoryRepository.findByIds(product.categories);
        }

        // Định dạng phản hồi sản phẩm trước khi trả về
        return formatProductResponse(productDTO);
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy thông tin chi tiết sản phẩm');
    }
  }

  /**
   * Tạo sản phẩm mới
   * @param {Object} productData - Dữ liệu sản phẩm
   * @param {String} userId - ID của người dùng tạo sản phẩm
   * @returns {Promise<Object>} - Sản phẩm đã được tạo
   */
  async createProduct(productData, userId) {
    try {
      // Xác thực dữ liệu
      const { error } = validateProductData(productData);
      if (error) {
        throw new AppError(400, `Dữ liệu không hợp lệ: ${error.message}`);
      }

      // Kiểm tra danh mục tồn tại
      if (productData.categories && productData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(productData.categories);
        if (validCategories.length !== productData.categories.length) {
          throw new AppError(400, 'Một hoặc nhiều danh mục không tồn tại');
        }
      }

      // Tạo slug từ tên sản phẩm
      productData.slug = this.createSlugFromName(productData.name);

      // Thêm thông tin người tạo và ngày tạo
      productData.createdBy = userId;
      productData.createdAt = new Date();
      productData.updatedAt = new Date();

      // Lưu vào cơ sở dữ liệu
      const newProduct = await this.productRepository.create(productData);

      // Xóa các cache liên quan
      await this.invalidateCache('products:*');

      // Định dạng phản hồi sản phẩm trước khi trả về
      return formatProductResponse(new ProductDTO(newProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Không thể tạo sản phẩm mới');
    }
  }

  /**
   * Cập nhật sản phẩm
   * @param {string} productId - ID sản phẩm
   * @param {Object} updateData - Dữ liệu cập nhật
   * @param {String} userId - ID người dùng thực hiện cập nhật
   * @returns {Promise<Object>} - Sản phẩm đã được cập nhật
   */
  async updateProduct(productId, updateData, userId) {
    try {
      // Kiểm tra sản phẩm tồn tại
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Xác thực dữ liệu cập nhật
      if (Object.keys(updateData).length > 0) {
        const { error } = validateProductData(updateData, true);
        if (error) {
          throw new AppError(400, `Dữ liệu cập nhật không hợp lệ: ${error.message}`);
        }
      }

      // Kiểm tra danh mục tồn tại nếu được cập nhật
      if (updateData.categories && updateData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(updateData.categories);
        if (validCategories.length !== updateData.categories.length) {
          throw new AppError(400, 'Một hoặc nhiều danh mục không tồn tại');
        }
      }

      // Cập nhật slug nếu tên được thay đổi
      if (updateData.name) {
        updateData.slug = this.createSlugFromName(updateData.name);
      }

      // Thêm thông tin người cập nhật và ngày cập nhật
      updateData.updatedBy = userId;
      updateData.updatedAt = new Date();

      // Cập nhật trong cơ sở dữ liệu
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, updateData);

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      // Định dạng phản hồi sản phẩm trước khi trả về
      return formatProductResponse(new ProductDTO(updatedProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Không thể cập nhật sản phẩm');
    }
  }

  /**
   * Xóa sản phẩm
   * @param {string} productId - ID sản phẩm
   * @returns {Promise<Boolean>} - Kết quả xóa
   */
  async deleteProduct(productId) {
    try {
      // Kiểm tra sản phẩm tồn tại
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Kiểm tra sản phẩm có trong đơn hàng không
      // TODO: Add this check when OrderRepository is available

      // Xóa sản phẩm
      await this.productRepository.findByIdAndDelete(productId);

      // Xóa các đánh giá của sản phẩm
      await this.reviewRepository.deleteByProductId(productId);

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      return true;
    } catch (error) {
      this.handleError(error, 'Không thể xóa sản phẩm');
    }
  }

  /**
   * Cập nhật số lượng tồn kho
   * @param {string} productId - ID sản phẩm
   * @param {number} quantity - Số lượng cập nhật
   * @returns {Promise<Object>} - Thông tin tồn kho đã cập nhật
   */
  async updateStock(productId, quantity) {
    try {
      if (isNaN(quantity)) {
        throw new AppError(400, 'Số lượng tồn kho không hợp lệ');
      }

      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Cập nhật tồn kho
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, {
        stock: quantity,
        updatedAt: new Date(),
      });

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);

      // Sử dụng updatedProduct để trả về thông tin cập nhật
      const stockInfo = {
        productId,
        name: updatedProduct.name,
        stock: updatedProduct.stock,
        status: updatedProduct.stock > 0 ? 'Còn hàng' : 'Hết hàng',
      };

      // Định dạng phản hồi trước khi trả về
      return formatProductResponse(stockInfo);
    } catch (error) {
      this.handleError(error, 'Không thể cập nhật tồn kho');
    }
  }

  /**
   * Lấy sản phẩm nổi bật
   * @param {number} limit - Số lượng sản phẩm trả về
   * @returns {Promise<Array>} - Danh sách sản phẩm nổi bật
   */
  async getTrendingProducts(limit = 10) {
    try {
      const cacheKey = `products:trending:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Thực hiện truy vấn
        const trending = await this.productRepository.getTrendingProducts(limit);

        // Chuyển đổi thành DTO và định dạng phản hồi
        return trending.map((product) => formatProductResponse(new ProductDTO(product).toJSON()));
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm nổi bật');
    }
  }

  /**
   * Lấy sản phẩm theo danh mục
   * @param {string} categoryId - ID danh mục
   * @param {Object} queryParams - Các tham số truy vấn
   * @returns {Promise<Object>} - Danh sách sản phẩm và thông tin phân trang
   */
  async getProductsByCategory(categoryId, queryParams) {
    try {
      // Kiểm tra danh mục tồn tại
      const category = await this.categoryRepository.findById(categoryId);
      if (!category) {
        throw new AppError(404, 'Không tìm thấy danh mục');
      }

      // Tạo khóa cache
      const cacheKey = `products:category:${categoryId}:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Thêm bộ lọc danh mục
        const categoryFilter = { categories: categoryId };
        const mergedQuery = { ...queryParams, ...categoryFilter };

        // Tạo đối tượng ApiFeatures
        const features = new ApiFeatures(this.productRepository.query(), mergedQuery)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Thực hiện truy vấn
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuyển đổi thành DTO và định dạng phản hồi
        const productDTOs = products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // Thêm thông tin danh mục
        return {
          category: {
            id: category._id,
            name: category.name,
            description: category.description,
          },
          products: productDTOs,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm theo danh mục');
    }
  }

  /**
   * Tìm kiếm sản phẩm
   * @param {string} query - Từ khóa tìm kiếm
   * @param {Object} options - Các tùy chọn tìm kiếm
   * @returns {Promise<Object>} - Kết quả tìm kiếm
   */
  async searchProducts(query, options = {}) {
    try {
      if (!query || query.trim() === '') {
        throw new AppError(400, 'Từ khóa tìm kiếm không được để trống');
      }

      // Tạo khóa cache
      const cacheKey = `products:search:${query}:${JSON.stringify(options)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tạo truy vấn tìm kiếm
        const searchOptions = {
          query,
          limit: options.limit || 10,
          page: options.page || 1,
          sort: options.sort || { relevance: -1 },
          filters: options.filters || {},
        };

        // Thực hiện tìm kiếm
        const searchResults = await this.productRepository.search(searchOptions);

        // Chuyển đổi thành DTO và định dạng phản hồi
        const productDTOs = searchResults.products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // Kết quả tìm kiếm
        return {
          products: productDTOs,
          totalCount: searchResults.total,
          pagination: {
            currentPage: searchOptions.page,
            pageSize: searchOptions.limit,
            totalPages: Math.ceil(searchResults.total / searchOptions.limit),
          },
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể tìm kiếm sản phẩm');
    }
  }

  /**
   * Lấy thống kê sản phẩm
   * @returns {Promise<Object>} Thống kê sản phẩm
   */
  async getProductStats() {
    try {
      const cacheKey = 'products:stats';

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tổng số sản phẩm
        const totalProducts = await this.productRepository.countDocuments();

        // Số sản phẩm theo trạng thái
        const activeProducts = await this.productRepository.countDocuments({ status: 'active' });
        const draftProducts = await this.productRepository.countDocuments({ status: 'draft' });
        const discontinuedProducts = await this.productRepository.countDocuments({
          status: 'discontinued',
        });

        // Số sản phẩm có giảm giá
        const productsOnSale = await this.productRepository.countDocuments({
          salePrice: { $gt: 0 },
        });

        // Số sản phẩm hết hàng
        const outOfStockProducts = await this.productRepository.countDocuments({
          stock: 0,
          status: 'active',
        });

        // Số sản phẩm theo danh mục
        const categoryCounts = await this.productRepository.aggregateByCategoryWithCount();

        // Số sản phẩm theo thương hiệu
        const brandCounts = await this.productRepository.aggregateByBrandWithCount();

        // Sản phẩm được xem nhiều nhất
        const mostViewedProducts = await this.productRepository.findMostViewed(5);

        return {
          totalProducts,
          byStatus: {
            active: activeProducts,
            draft: draftProducts,
            discontinued: discontinuedProducts,
          },
          productsOnSale,
          outOfStockProducts,
          byCategory: categoryCounts,
          byBrand: brandCounts,
          mostViewed: mostViewedProducts,
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy thống kê sản phẩm');
    }
  }

  /**
   * Tạo slug từ tên sản phẩm
   * @param {string} name - Tên sản phẩm
   * @returns {string} - Slug đã tạo
   */
  createSlugFromName(name) {
    return name
      .toLowerCase()
      .replace(/[^\w ]+/g, '')
      .replace(/ +/g, '-');
  }

  /**
   * Cập nhật số lượng xem sản phẩm
   * @param {string} productId - ID sản phẩm
   * @returns {Promise<void>}
   */
  async incrementViewCount(productId) {
    try {
      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Tăng số lượt xem
      await this.productRepository.findByIdAndUpdate(productId, {
        $inc: { viewCount: 1 },
        updatedAt: new Date(),
      });

      // Không cần xóa cache vì thông tin này không quan trọng để invalidate cache ngay lập tức
    } catch (error) {
      // Chỉ ghi log lỗi, không ném lỗi vì đây không phải thao tác quan trọng
      console.error(`Error incrementing view count for product ${productId}:`, error);
    }
  }

  /**
   * Lấy sản phẩm liên quan
   * @param {string} productId - ID sản phẩm
   * @param {number} limit - Số lượng sản phẩm trả về
   * @returns {Promise<Array>} - Danh sách sản phẩm liên quan
   */
  async getRelatedProducts(productId, limit = 5) {
    try {
      const cacheKey = `products:related:${productId}:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Lấy thông tin sản phẩm
        const product = await this.productRepository.findById(productId);
        if (!product) {
          throw new AppError(404, 'Không tìm thấy sản phẩm');
        }

        // Lấy sản phẩm cùng danh mục
        const relatedProducts = await this.productRepository.findRelated(
          productId,
          product.categories,
          limit
        );

        // Chuyển đổi thành DTO và định dạng phản hồi
        return relatedProducts.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm liên quan');
    }
  }
}

module.exports = new ProductService();


--- File: services/review/reviewService.js ---
/**
 * Review Service
 * Xử lý logic nghiệp vụ cho đánh giá sản phẩm
 */

const { ApiError } = require('../../common/errors/apiError');
const reviewRepository = require('../../data/repositories/reviewRepository');
const productRepository = require('../../data/repositories/productRepository');
const orderRepository = require('../../data/repositories/orderRepository');
const userRepository = require('../../data/repositories/userRepository');

/**
 * Lấy tất cả đánh giá (có thể lọc, sắp xếp, phân trang)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getAllReviews = async (features = {}) => {
  return await reviewRepository.findAll(features);
};

/**
 * Lấy đánh giá theo ID
 * @param {string} id - ID của đánh giá
 * @returns {Promise<Object>} Thông tin đánh giá
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const getReviewById = async (id) => {
  const review = await reviewRepository.findById(id);
  if (!review) {
    throw new ApiError(404, 'Không tìm thấy đánh giá');
  }
  return review;
};

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @param {string} productId - ID của sản phẩm
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getProductReviews = async (productId, features = {}) => {
  // Kiểm tra sản phẩm tồn tại
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  // Thêm filter cho product vào features
  const productFilter = { ...features };
  productFilter.filter = {
    ...productFilter.filter,
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  };

  return await reviewRepository.findAll(productFilter);
};

/**
 * Lấy tất cả đánh giá của một người dùng
 * @param {string} userId - ID của người dùng
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getUserReviews = async (userId, features = {}) => {
  // Kiểm tra người dùng tồn tại
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Không tìm thấy người dùng');
  }

  // Thêm filter cho user vào features
  const userFilter = { ...features };
  userFilter.filter = {
    ...userFilter.filter,
    user: userId,
  };

  return await reviewRepository.findAll(userFilter);
};

/**
 * Tạo đánh giá mới
 * @param {string} productId - ID của sản phẩm
 * @param {string} userId - ID của người dùng đánh giá
 * @param {Object} reviewData - Dữ liệu đánh giá
 * @returns {Promise<Object>} Đánh giá đã tạo
 * @throws {ApiError} Nếu có lỗi khi tạo đánh giá
 */
const createReview = async (productId, userId, reviewData) => {
  // Kiểm tra sản phẩm tồn tại
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  // Kiểm tra người dùng tồn tại
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Không tìm thấy người dùng');
  }

  // Kiểm tra xem người dùng đã đánh giá sản phẩm này chưa
  const existingReview = await reviewRepository.findOne({
    product: productId,
    user: userId,
  });

  if (existingReview) {
    throw new ApiError(400, 'Bạn đã đánh giá sản phẩm này rồi');
  }

  // Kiểm tra xem người dùng đã mua sản phẩm này chưa
  const verificationResult = await verifyPurchase(userId, productId);

  // Khởi tạo đánh giá
  const newReview = {
    product: productId,
    user: userId,
    rating: reviewData.rating,
    title: reviewData.title,
    review: reviewData.review,
    images: reviewData.images || [],
    isVerifiedPurchase: verificationResult.isVerified,
    ratings: {
      average: 0,
      count: 0,
    },
  };

  // Nếu có đơn hàng và là mua hàng đã xác minh, thêm thông tin đơn hàng
  if (verificationResult.isVerified && verificationResult.orderId) {
    newReview.order = verificationResult.orderId;
    newReview.purchaseDate = verificationResult.purchaseDate;
  }

  // Kiểm tra nếu cần kiểm duyệt
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration) {
    newReview.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = false;
  } else {
    newReview.moderation = {
      status: 'approved',
      moderatedAt: new Date(),
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = true;
  }

  // Tạo đánh giá mới
  const createdReview = await reviewRepository.create(newReview);

  // Nếu không cần kiểm duyệt, cập nhật rating của sản phẩm
  if (!needModeration) {
    await updateProductRating(productId);
  }

  return createdReview;
};

/**
 * Cập nhật đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng yêu cầu cập nhật
 * @param {Object} reviewData - Dữ liệu cập nhật
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Đánh giá đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc không có quyền
 */
const updateReview = async (id, userId, reviewData, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra quyền cập nhật
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền cập nhật đánh giá này');
  }

  // Dữ liệu cần cập nhật
  const updateData = {};

  // Chỉ cập nhật các trường được phép
  if (reviewData.rating !== undefined) updateData.rating = reviewData.rating;
  if (reviewData.title !== undefined) updateData.title = reviewData.title;
  if (reviewData.review !== undefined) updateData.review = reviewData.review;
  if (reviewData.images !== undefined) updateData.images = reviewData.images;

  // Cập nhật thời gian
  updateData.updatedAt = new Date();

  // Nếu cần kiểm duyệt, đưa về trạng thái chờ kiểm duyệt lại
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration && !isAdmin) {
    updateData.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    updateData.isVisible = false;
  }

  // Cập nhật đánh giá
  const updatedReview = await reviewRepository.update(id, updateData);

  // Nếu không cần kiểm duyệt hoặc là admin, cập nhật rating của sản phẩm
  if (!needModeration || isAdmin) {
    await updateProductRating(review.product);
  }

  return updatedReview;
};

/**
 * Xóa đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng yêu cầu xóa
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<void>}
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc không có quyền
 */
const deleteReview = async (id, userId, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra quyền xóa
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền xóa đánh giá này');
  }

  // Lưu ID sản phẩm để cập nhật rating sau
  const productId = review.product;

  // Xóa đánh giá
  await reviewRepository.delete(id);

  // Cập nhật rating của sản phẩm
  await updateProductRating(productId);
};

/**
 * Vote (upvote/downvote) đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng vote
 * @param {number} vote - Loại vote (1: upvote, -1: downvote)
 * @returns {Promise<Object>} Đánh giá đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const voteReview = async (id, userId, vote) => {
  // Kiểm tra vote hợp lệ
  if (vote !== 1 && vote !== -1) {
    throw new ApiError(400, 'Vote không hợp lệ');
  }

  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Người dùng không thể vote đánh giá của chính mình
  if (review.user.toString() === userId) {
    throw new ApiError(400, 'Bạn không thể vote đánh giá của chính mình');
  }

  // Kiểm tra xem người dùng đã vote chưa
  const existingVoteIndex = review.helpfulness.voters.findIndex(
    (voter) => voter.user.toString() === userId
  );

  // Nếu đã vote, cập nhật vote
  if (existingVoteIndex > -1) {
    const existingVote = review.helpfulness.voters[existingVoteIndex];

    // Nếu vote giống nhau, hủy vote
    if (existingVote.vote === vote) {
      // Cập nhật số lượng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes -= 1;
      } else {
        review.helpfulness.downvotes -= 1;
      }

      // Xóa vote khỏi danh sách
      review.helpfulness.voters.splice(existingVoteIndex, 1);
    }
    // Nếu vote khác nhau, cập nhật vote
    else {
      // Cập nhật số lượng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes += 1;
        review.helpfulness.downvotes -= 1;
      } else {
        review.helpfulness.upvotes -= 1;
        review.helpfulness.downvotes += 1;
      }

      // Cập nhật vote
      review.helpfulness.voters[existingVoteIndex] = {
        user: userId,
        vote: vote,
        votedAt: new Date(),
      };
    }
  }
  // Nếu chưa vote, thêm vote mới
  else {
    // Cập nhật số lượng upvote/downvote
    if (vote === 1) {
      review.helpfulness.upvotes += 1;
    } else {
      review.helpfulness.downvotes += 1;
    }

    // Thêm vote mới
    review.helpfulness.voters.push({
      user: userId,
      vote: vote,
      votedAt: new Date(),
    });
  }

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    helpfulness: review.helpfulness,
  });
};

/**
 * Kiểm duyệt đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} action - Hành động (approve/reject)
 * @param {string} reason - Lý do từ chối (nếu reject)
 * @param {string} adminId - ID của admin thực hiện kiểm duyệt
 * @returns {Promise<Object>} Đánh giá đã kiểm duyệt
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc action không hợp lệ
 */
const moderateReview = async (id, action, reason, adminId) => {
  // Kiểm tra action hợp lệ
  if (action !== 'approve' && action !== 'reject') {
    throw new ApiError(400, 'Action không hợp lệ');
  }

  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra nếu đã kiểm duyệt với cùng action
  if (review.moderation.status === action) {
    throw new ApiError(400, `Đánh giá đã được ${action === 'approve' ? 'duyệt' : 'từ chối'} rồi`);
  }

  // Dữ liệu cập nhật
  const updateData = {
    moderation: {
      status: action,
      moderatedAt: new Date(),
      moderatedBy: adminId,
      reason: action === 'reject' ? reason : null,
    },
    isVisible: action === 'approve',
  };

  // Cập nhật đánh giá
  const moderatedReview = await reviewRepository.update(id, updateData);

  // Cập nhật rating của sản phẩm
  await updateProductRating(review.product);

  return moderatedReview;
};

/**
 * Báo cáo đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng báo cáo
 * @param {string} reason - Lý do báo cáo
 * @param {string} description - Mô tả chi tiết
 * @returns {Promise<Object>} Đánh giá đã báo cáo
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc đã báo cáo
 */
const reportReview = async (id, userId, reason, description) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra người dùng đã báo cáo chưa
  const alreadyReported = review.reports.some((report) => report.user.toString() === userId);

  if (alreadyReported) {
    throw new ApiError(400, 'Bạn đã báo cáo đánh giá này rồi');
  }

  // Thêm báo cáo mới
  const newReport = {
    user: userId,
    reason,
    description,
    createdAt: new Date(),
    status: 'pending',
  };

  review.reports.push(newReport);

  // Nếu có quá nhiều báo cáo, tự động ẩn đánh giá chờ kiểm duyệt
  if (review.reports.length >= 3 && review.isVisible) {
    review.isVisible = false;
    review.moderation.status = 'pending';
  }

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    reports: review.reports,
    isVisible: review.isVisible,
    moderation: review.moderation,
  });
};

/**
 * Thêm phản hồi cho đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng thêm phản hồi
 * @param {string} content - Nội dung phản hồi
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Đánh giá đã thêm phản hồi
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const addReviewResponse = async (id, userId, content, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Thêm phản hồi mới
  const newResponse = {
    user: userId,
    isAdmin,
    content,
    createdAt: new Date(),
  };

  // Nếu chưa có phản hồi, khởi tạo mảng
  if (!review.responses) {
    review.responses = [];
  }

  review.responses.push(newResponse);

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    responses: review.responses,
  });
};

/**
 * Kiểm tra xem người dùng đã mua sản phẩm hay chưa
 * @param {string} userId - ID của người dùng
 * @param {string} productId - ID của sản phẩm
 * @returns {Promise<Object>} Kết quả xác minh
 */
const verifyPurchase = async (userId, productId) => {
  // Tìm đơn hàng đã hoàn thành chứa sản phẩm
  const orders = await orderRepository.find({
    user: userId,
    status: { $in: ['delivered', 'completed'] },
    'items.product': productId,
  });

  if (!orders || orders.length === 0) {
    return { isVerified: false };
  }

  // Sắp xếp theo thời gian để lấy đơn hàng gần nhất
  orders.sort((a, b) => b.createdAt - a.createdAt);
  const latestOrder = orders[0];

  return {
    isVerified: true,
    orderId: latestOrder._id,
    purchaseDate: latestOrder.createdAt,
  };
};

/**
 * Cập nhật rating trung bình của sản phẩm
 * @param {string} productId - ID của sản phẩm
 * @returns {Promise<void>}
 */
const updateProductRating = async (productId) => {
  // Lấy tất cả đánh giá đã được phê duyệt và hiển thị
  const reviews = await reviewRepository.find({
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  });

  // Nếu không có đánh giá, đặt rating về 0
  if (!reviews || reviews.length === 0) {
    await productRepository.update(productId, {
      'ratings.average': 0,
      'ratings.count': 0,
    });
    return;
  }

  // Tính rating trung bình
  const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
  const averageRating = Number((totalRating / reviews.length).toFixed(1));

  // Cập nhật sản phẩm
  await productRepository.update(productId, {
    'ratings.average': averageRating,
    'ratings.count': reviews.length,
  });
};

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse,
  verifyPurchase,
  updateProductRating,
};


--- File: services/user/userService.js ---
/**
 * User Service - xử lý logic quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const BaseService = require('../base/baseService');
const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * Class UserService xử lý logic quản lý người dùng
 * Kế thừa từ BaseService để có các phương thức CRUD cơ bản
 */
class UserService extends BaseService {
  constructor() {
    super(User, 'User');
  }

  /**
   * Tạo người dùng mới
   * @override
   * @param {Object} userData - Thông tin người dùng
   * @returns {Promise<Object>} - Người dùng đã tạo
   */
  async create(userData) {
    try {
      // Kiểm tra email đã tồn tại chưa
      const existingUser = await User.findOne({ email: userData.email });
      if (existingUser) {
        throw new ApiError(409, 'Email đã được sử dụng');
      }

      // Người dùng được tạo bởi admin mặc định đã xác thực email
      const newUserData = {
        ...userData,
        emailVerified: true,
      };

      // Tạo người dùng mới
      const newUser = await super.create(newUserData);

      // Loại bỏ password khỏi response
      const userObj = newUser.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi tạo người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Cập nhật thông tin người dùng
   * @override
   * @param {string} id - ID người dùng
   * @param {Object} updateData - Thông tin cập nhật
   * @param {Object} options - Tùy chọn
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async update(id, updateData, options = {}) {
    try {
      // Tạo bản sao của đối tượng updateData
      const safeUpdateData = { ...updateData };

      // Danh sách các trường nhạy cảm cần loại bỏ
      const sensitiveFields = [
        'password',
        'emailVerified',
        'loginCount',
        'lastLogin',
        'resetPasswordToken',
        'resetPasswordExpires',
        'emailVerificationToken',
        'emailVerificationExpires',
      ];

      // Loại bỏ các trường nhạy cảm
      sensitiveFields.forEach((field) => {
        delete safeUpdateData[field];
      });

      // Xử lý riêng trường role
      const { role } = updateData;
      delete safeUpdateData.role;

      // Admin có thể cập nhật role
      if (options.isAdmin && role) {
        safeUpdateData.role = role;
      }

      // Cập nhật thông tin người dùng
      const updatedUser = await super.update(id, safeUpdateData);

      return updatedUser;
    } catch (error) {
      logger.error(`Lỗi cập nhật người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Thay đổi mật khẩu
   * @param {string} userId - ID người dùng
   * @param {string} currentPassword - Mật khẩu hiện tại
   * @param {string} newPassword - Mật khẩu mới
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async changePassword(userId, currentPassword, newPassword) {
    try {
      // Lấy user với password
      const user = await User.findById(userId).select('+password');

      if (!user) {
        throw new ApiError(404, 'Người dùng không tồn tại');
      }

      // Kiểm tra mật khẩu hiện tại
      if (!(await user.correctPassword(currentPassword, user.password))) {
        throw new ApiError(401, 'Mật khẩu hiện tại không đúng');
      }

      // Cập nhật mật khẩu
      user.password = newPassword;
      await user.save();

      // Loại bỏ password khỏi response
      const userObj = user.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi thay đổi mật khẩu: ${error.message}`);
      throw error;
    }
  }

  /**
   * Vô hiệu hóa tài khoản
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async deactivateUser(userId) {
    try {
      const user = await this.findById(userId);

      // Cập nhật trạng thái active
      user.isActive = false;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`Lỗi vô hiệu hóa tài khoản: ${error.message}`);
      throw error;
    }
  }

  /**
   * Kích hoạt lại tài khoản
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async activateUser(userId) {
    try {
      const user = await this.findById(userId);

      // Cập nhật trạng thái active
      user.isActive = true;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`Lỗi kích hoạt tài khoản: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tìm kiếm người dùng với các tiêu chí nâng cao
   * @param {Object} criteria - Tiêu chí tìm kiếm
   * @param {Object} options - Tùy chọn (pagination, sort)
   * @returns {Promise<Object>} - Kết quả tìm kiếm với phân trang
   */
  async search(criteria, options = {}) {
    try {
      const filter = {};

      // Xử lý các tiêu chí tìm kiếm
      if (criteria.name) {
        filter.name = { $regex: criteria.name, $options: 'i' };
      }

      if (criteria.email) {
        filter.email = { $regex: criteria.email, $options: 'i' };
      }

      if (criteria.phone) {
        filter.phone = { $regex: criteria.phone, $options: 'i' };
      }

      if (criteria.role) {
        filter.role = criteria.role;
      }

      if (criteria.isActive !== undefined) {
        filter.isActive = criteria.isActive;
      }

      if (criteria.emailVerified !== undefined) {
        filter.emailVerified = criteria.emailVerified;
      }

      // Tìm kiếm kết hợp theo text
      if (criteria.search) {
        filter.$or = [
          { name: { $regex: criteria.search, $options: 'i' } },
          { email: { $regex: criteria.search, $options: 'i' } },
          { phone: { $regex: criteria.search, $options: 'i' } },
        ];
      }

      // Tìm kiếm theo khoảng thời gian đăng ký
      if (criteria.createdFrom || criteria.createdTo) {
        filter.createdAt = {};

        if (criteria.createdFrom) {
          filter.createdAt.$gte = new Date(criteria.createdFrom);
        }

        if (criteria.createdTo) {
          filter.createdAt.$lte = new Date(criteria.createdTo);
        }
      }

      // Lấy kết quả với phân trang
      return await this.findAll(filter, {
        ...options,
        select: '-password',
      });
    } catch (error) {
      logger.error(`Lỗi tìm kiếm người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xóa người dùng và dữ liệu liên quan
   * @override
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Thông tin người dùng đã xóa
   */
  async delete(userId) {
    try {
      // Xóa dữ liệu liên quan đến người dùng trước (nếu cần)
      // TODO: Xóa dữ liệu liên quan như giỏ hàng, đơn hàng, đánh giá

      // Xóa người dùng
      const user = await super.delete(userId);

      return user;
    } catch (error) {
      logger.error(`Lỗi xóa người dùng: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new UserService();


--- File: types/express.d.ts ---
import { Document } from 'mongoose';

declare global {
  namespace Express {
    interface Request {
      user?: Document & {
        id: string;
        name: string;
        email: string;
        role: string;
        changedPasswordAfter?: (timestamp: number) => boolean;
        [key: string]: any;
      };
      resource?: Document & {
        user?: any;
        [key: string]: any;
      };
    }
  }
}

// Đảm bảo file này được coi là một module
export {};

--- File: utils/apiFeatures.js ---
/**
 * API Features Utility - xử lý các tính năng API phổ biến như filtering, sorting, pagination
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('mongoose').Query<any, any>} MongooseQuery
 */

class APIFeatures {
  /**
   * Khởi tạo class với query và queryString
   * @param {MongooseQuery} query - Mongoose query ban đầu
   * @param {Object} queryString - Query parameters từ request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * Lọc dữ liệu theo các trường
   * @returns {APIFeatures} - Instance của class để chaining
   */
  filter() {
    // Tạo bản sao của query string
    const queryObj = { ...this.queryString };

    // Các trường loại trừ khỏi filtering
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'search'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // Xử lý advanced filtering (gt, gte, lt, lte, in, nin)
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in|nin)\b/g, (match) => `$${match}`);

    // Áp dụng filter vào query
    this.query = this.query.find(JSON.parse(queryStr));

    return this;
  }

  /**
   * Thêm tìm kiếm text
   * @returns {APIFeatures} - Instance của class để chaining
   */
  search() {
    if (this.queryString.search) {
      // Tạo điều kiện tìm kiếm
      const searchQuery = {
        $or: [
          { name: { $regex: this.queryString.search, $options: 'i' } },
          { description: { $regex: this.queryString.search, $options: 'i' } },
        ],
      };

      // Áp dụng tìm kiếm vào query
      this.query = this.query.find(searchQuery);
    }

    return this;
  }

  /**
   * Sắp xếp kết quả
   * @returns {APIFeatures} - Instance của class để chaining
   */
  sort() {
    if (this.queryString.sort) {
      // Chuyển đổi chuỗi sort thành format cho MongoDB
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // Mặc định sắp xếp theo thời gian tạo giảm dần
      this.query = this.query.sort('-createdAt');
    }

    return this;
  }

  /**
   * Giới hạn các trường được trả về
   * @returns {APIFeatures} - Instance của class để chaining
   */
  limitFields() {
    if (this.queryString.fields) {
      // Chuyển đổi chuỗi fields thành format cho MongoDB
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // Mặc định loại bỏ trường __v
      this.query = this.query.select('-__v');
    }

    return this;
  }

  /**
   * Phân trang kết quả
   * @returns {APIFeatures} - Instance của class để chaining
   */
  paginate() {
    // Chuyển đổi page và limit thành số
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    // Áp dụng skip và limit vào query
    this.query = this.query.skip(skip).limit(limit);

    return this;
  }

  /**
   * Áp dụng tất cả các tính năng vào query
   * @returns {MongooseQuery} - Query đã được xử lý
   */
  build() {
    return this.filter().search().sort().limitFields().paginate().query;
  }
}

module.exports = APIFeatures;


--- File: utils/catchAsync.js ---
/**
 * Utility wrapper để xử lý lỗi async cho controllers
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Bọc hàm async để xử lý lỗi mà không cần try-catch trong mỗi controller
 * @param {Function} fn - Hàm async cần được bọc
 * @returns {Function} - Middleware function với xử lý lỗi
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

module.exports = catchAsync;


--- File: utils/logger.js ---
/**
 * Module logger sử dụng Winston
 * Cung cấp các phương thức để ghi log với các cấp độ khác nhau
 */
const winston = require('winston');
const path = require('path');
const fs = require('fs');

// Tạo thư mục logs nếu chưa tồn tại
const logDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

// Định dạng thời gian cho log
const timeFormat = () => {
  return new Date().toLocaleString('vi-VN', {
    timeZone: 'Asia/Ho_Chi_Minh',
  });
};

// Tạo logger với Winston
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp({ format: timeFormat }),
    winston.format.printf(({ timestamp, level, message }) => {
      return `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    })
  ),
  transports: [
    // Ghi log ra console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ timestamp, level, message }) => {
          return `[${timestamp}] ${level}: ${message}`;
        })
      ),
    }),
    // Ghi log lỗi vào file
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
    }),
    // Ghi tất cả log vào file
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
    }),
  ],
  exitOnError: false,
});

// Thêm stream để sử dụng với Morgan (nếu cần)
logger.stream = {
  write: function (message) {
    logger.info(message.trim());
  },
};

module.exports = { logger };


--- File: utils/queryAnalyzer.js ---
// src/utils/queryAnalyzer.js
// const mongoose = require('mongoose');
const fs = require('fs').promises;
const path = require('path');

/**
 * Lớp QueryAnalyzer cung cấp các công cụ để phân tích và tối ưu hóa truy vấn MongoDB
 */
class QueryAnalyzer {
  /**
   * Phân tích truy vấn find() và trả về thông tin chi tiết về hiệu suất
   * @param {mongoose.Model} model - Model Mongoose cần phân tích
   * @param {Object} query - Điều kiện truy vấn
   * @param {Object} options - Tùy chọn bổ sung (projection, sort, skip, limit)
   * @returns {Object} Kết quả phân tích truy vấn
   */
  static async analyzeQuery(model, query, options = {}) {
    // Ghi lại thời gian bắt đầu
    const startTime = Date.now();

    // Lấy explain plan cho truy vấn
    const explain = await model
      .find(query, options.projection)
      .sort(options.sort || {})
      .skip(options.skip || 0)
      .limit(options.limit || 10)
      .explain('executionStats');

    // Trích xuất thống kê thực thi
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Phân tích kết quả
    const result = {
      collection: model.collection.name,
      queryShape: JSON.stringify(query),
      executionTimeMs: executionStats.executionTimeMillis,
      totalDocsExamined: executionStats.totalDocsExamined,
      totalKeysExamined: executionStats.totalKeysExamined,
      docsReturned: executionStats.nReturned,
      indexesUsed: this._getIndexesUsed(queryPlanner.winningPlan),
      isOptimal: this._isQueryOptimal(executionStats),
      recommendations: this.generateRecommendations(explain),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log nếu truy vấn chậm
    if (result.executionTimeMs > 100) {
      await this.logSlowQuery(result);
    }

    return result;
  }

  /**
   * Phân tích truy vấn aggregate và trả về thông tin chi tiết về hiệu suất
   * @param {mongoose.Model} model - Model Mongoose cần phân tích
   * @param {Array} pipeline - Pipeline aggregation
   * @returns {Object} Kết quả phân tích truy vấn
   */
  static async analyzeAggregate(model, pipeline) {
    const startTime = Date.now();

    // Thêm stage $explain vào cuối pipeline
    const explainPipeline = [...pipeline, { $explain: true }];
    const explainResults = await model.aggregate(explainPipeline).exec();

    // Phân tích kết quả từ explain
    const result = {
      collection: model.collection.name,
      pipeline: JSON.stringify(pipeline),
      executionTimeMs: explainResults[0]?.executionStats?.executionTimeMillis || 0,
      stages: this._analyzeAggregateStages(explainResults[0]),
      recommendations: this._generateAggregateRecommendations(explainResults[0]),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log nếu truy vấn chậm
    if (result.executionTimeMs > 200) {
      await this.logSlowQuery(result, 'aggregate');
    }

    return result;
  }

  /**
   * Phân tích các stage trong aggregate pipeline
   * @private
   * @param {Object} explainResult - Kết quả từ explain
   * @returns {Array} Thông tin về các stage
   */
  static _analyzeAggregateStages(explainResult) {
    if (!explainResult || !explainResult.stages) {
      return [];
    }

    return explainResult.stages.map((stage) => {
      const stageName = Object.keys(stage)[0];
      return {
        name: stageName,
        timeMs: stage[stageName]?.executionTimeMillisEstimate || 0,
      };
    });
  }

  /**
   * Tạo khuyến nghị cho truy vấn aggregate
   * @private
   * @param {Object} explainResult - Kết quả từ explain
   * @returns {Array} Danh sách khuyến nghị
   */
  static _generateAggregateRecommendations(explainResult) {
    const recommendations = [];

    if (!explainResult) return recommendations;

    // Kiểm tra các stage tốn nhiều thời gian
    if (explainResult.stages) {
      const expensiveStages = explainResult.stages
        .filter((stage) => {
          const stageName = Object.keys(stage)[0];
          return stage[stageName]?.executionTimeMillisEstimate > 100;
        })
        .map((stage) => Object.keys(stage)[0]);

      if (expensiveStages.length > 0) {
        recommendations.push(
          `Các stage tốn nhiều thời gian: ${expensiveStages.join(', ')}. Xem xét tối ưu hóa hoặc thêm chỉ mục.`
        );
      }
    }

    // Kiểm tra sử dụng $match sớm
    const pipelineStr = JSON.stringify(explainResult);
    if (
      !pipelineStr.includes('"$match"') ||
      pipelineStr.indexOf('"$match"') > pipelineStr.indexOf('"$project"')
    ) {
      recommendations.push(
        'Đặt $match càng sớm càng tốt trong pipeline để lọc dữ liệu trước khi xử lý.'
      );
    }

    return recommendations;
  }

  /**
   * Lấy danh sách các chỉ mục được sử dụng
   * @private
   * @param {Object} plan - Kế hoạch thực thi
   * @returns {String} Tên chỉ mục hoặc thông báo không sử dụng chỉ mục
   */
  static _getIndexesUsed(plan) {
    if (!plan) return 'Không có thông tin kế hoạch';

    // Kiểm tra nếu kế hoạch trực tiếp có chỉ mục
    if (plan.indexName) {
      return plan.indexName;
    }

    // Kiểm tra trong inputStage
    if (plan.inputStage?.indexName) {
      return plan.inputStage.indexName;
    }

    // Kiểm tra đệ quy trong inputStages (cho trường hợp OR hoặc AND)
    if (plan.inputStages) {
      const indexNames = plan.inputStages
        .map((stage) => this._getIndexesUsed(stage))
        .filter((name) => name !== 'No index used (COLLSCAN)');

      if (indexNames.length > 0) {
        return indexNames.join(', ');
      }
    }

    return 'No index used (COLLSCAN)';
  }

  /**
   * Kiểm tra xem truy vấn có tối ưu không
   * @private
   * @param {Object} stats - Thống kê thực thi
   * @returns {Boolean} Truy vấn có tối ưu không
   */
  static _isQueryOptimal(stats) {
    // Truy vấn được coi là tối ưu nếu:
    // 1. Số lượng tài liệu kiểm tra gần với số lượng tài liệu trả về
    // 2. Thời gian thực thi dưới ngưỡng (ví dụ: 50ms)
    return stats.totalDocsExamined <= stats.nReturned * 1.2 && stats.executionTimeMillis < 50;
  }

  /**
   * Tạo khuyến nghị dựa trên kết quả explain
   * @param {Object} explain - Kết quả từ explain()
   * @returns {Array} Danh sách khuyến nghị
   */
  static generateRecommendations(explain) {
    const recommendations = [];
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Kiểm tra việc sử dụng chỉ mục
    const indexesUsed = this._getIndexesUsed(queryPlanner.winningPlan);
    if (indexesUsed === 'No index used (COLLSCAN)') {
      recommendations.push(
        'Truy vấn không sử dụng chỉ mục nào. Xem xét thêm chỉ mục cho mẫu truy vấn này.'
      );

      // Đề xuất chỉ mục cụ thể
      const suggestedIndex = this.suggestIndex(queryPlanner.parsedQuery);
      if (suggestedIndex) {
        recommendations.push(`Chỉ mục đề xuất: ${suggestedIndex}`);
      }
    }

    // Kiểm tra nếu kiểm tra quá nhiều tài liệu
    if (executionStats.totalDocsExamined > executionStats.nReturned * 3) {
      recommendations.push(
        'Truy vấn đang kiểm tra quá nhiều tài liệu so với số lượng trả về. Xem xét sử dụng chỉ mục chọn lọc hơn.'
      );
    }

    // Kiểm tra thời gian thực thi
    if (executionStats.executionTimeMillis > 100) {
      recommendations.push(
        'Thời gian thực thi truy vấn cao. Xem xét tối ưu hóa truy vấn hoặc thêm chỉ mục.'
      );
    }

    // Kiểm tra sắp xếp
    const sortStage = this._findSortStage(queryPlanner.winningPlan);
    if (sortStage && sortStage.sortPattern) {
      const sortFields = Object.keys(sortStage.sortPattern);
      if (
        indexesUsed === 'No index used (COLLSCAN)' ||
        !this._isSortCoveredByIndex(sortFields, indexesUsed)
      ) {
        recommendations.push(
          `Sắp xếp không được hỗ trợ bởi chỉ mục. Xem xét thêm chỉ mục bao gồm các trường sắp xếp: ${sortFields.join(', ')}`
        );
      }
    }

    return recommendations;
  }

  /**
   * Tìm stage sắp xếp trong kế hoạch truy vấn
   * @private
   * @param {Object} plan - Kế hoạch truy vấn
   * @returns {Object|null} Stage sắp xếp hoặc null nếu không tìm thấy
   */
  static _findSortStage(plan) {
    if (!plan) return null;

    if (plan.stage === 'SORT') {
      return plan;
    }

    if (plan.inputStage) {
      return this._findSortStage(plan.inputStage);
    }

    if (plan.inputStages) {
      for (const stage of plan.inputStages) {
        const sortStage = this._findSortStage(stage);
        if (sortStage) return sortStage;
      }
    }

    return null;
  }

  /**
   * Kiểm tra xem sắp xếp có được hỗ trợ bởi chỉ mục không
   * @private
   * @param {Array} sortFields - Các trường sắp xếp
   * @param {String} indexName - Tên chỉ mục
   * @returns {Boolean} Sắp xếp có được hỗ trợ không
   */
  static _isSortCoveredByIndex(sortFields, indexName) {
    // Phương thức này cần thông tin về cấu trúc chỉ mục
    // Trong thực tế, bạn cần truy vấn thông tin chỉ mục từ MongoDB
    // Đây là một triển khai đơn giản
    if (indexName === 'No index used (COLLSCAN)') {
      return false;
    }

    // Giả định rằng tên chỉ mục có dạng: collection_field1_field2_...
    const indexFields = indexName.split('_').slice(1);

    // Kiểm tra xem tất cả các trường sắp xếp có trong chỉ mục không
    return sortFields.every((field) => indexFields.includes(field));
  }

  /**
   * Đề xuất chỉ mục dựa trên truy vấn
   * @param {Object} parsedQuery - Truy vấn đã phân tích
   * @returns {String} Đề xuất chỉ mục
   */
  static suggestIndex(parsedQuery) {
    if (!parsedQuery) return null;

    const fields = [];

    // Phân tích các trường trong truy vấn
    for (const field in parsedQuery) {
      // Bỏ qua các toán tử đặc biệt
      if (field.startsWith('$')) continue;

      fields.push(field);
    }

    if (fields.length === 0) return null;

    // Tạo chuỗi đề xuất chỉ mục
    return `{ ${fields.map((f) => `"${f}": 1`).join(', ')} }`;
  }

  /**
   * Ghi log truy vấn chậm
   * @param {Object} queryInfo - Thông tin truy vấn
   * @param {String} queryType - Loại truy vấn (find, aggregate, ...)
   * @returns {Promise<void>}
   */
  static async logSlowQuery(queryInfo, queryType = 'find') {
    try {
      const logDir = path.join(process.cwd(), 'logs');

      // Tạo thư mục logs nếu chưa tồn tại
      try {
        await fs.mkdir(logDir, { recursive: true });
      } catch (err) {
        if (err.code !== 'EEXIST') throw err;
      }

      const logFile = path.join(logDir, 'slow-queries.log');
      const timestamp = new Date().toISOString();

      const logEntry = {
        timestamp,
        queryType,
        ...queryInfo,
      };

      await fs.appendFile(logFile, JSON.stringify(logEntry) + '\n', 'utf8');
    } catch (error) {
      console.error('Lỗi khi ghi log truy vấn chậm:', error);
    }
  }

  /**
   * Phân tích tất cả các chỉ mục trong collection
   * @param {mongoose.Model} model - Model Mongoose
   * @returns {Promise<Array>} Danh sách chỉ mục và thông tin
   */
  static async analyzeIndexes(model) {
    // Lấy thông tin về tất cả các chỉ mục
    const indexes = await model.collection.indexes();

    // Phân tích từng chỉ mục
    return Promise.all(
      indexes.map(async (index) => {
        // Lấy thống kê sử dụng chỉ mục
        const stats = await model.collection.stats();

        return {
          name: index.name,
          fields: index.key,
          unique: !!index.unique,
          sparse: !!index.sparse,
          size: stats.indexSizes?.[index.name] || 0,
          usage: await this._getIndexUsageStats(model, index.name),
        };
      })
    );
  }

  /**
   * Lấy thống kê sử dụng chỉ mục
   * @private
   * @param {mongoose.Model} model - Model Mongoose
   * @param {String} indexName - Tên chỉ mục
   * @returns {Promise<Object>} Thống kê sử dụng
   */
  static async _getIndexUsageStats(model, indexName) {
    try {
      // Sử dụng aggregation để lấy thông tin sử dụng chỉ mục
      const result = await model.db.db.command({
        aggregate: model.collection.collectionName,
        pipeline: [{ $indexStats: {} }, { $match: { name: indexName } }],
        cursor: {},
      });

      if (result?.cursor?.firstBatch?.length > 0) {
        const stats = result.cursor.firstBatch[0];
        return {
          operations: stats.accesses.ops,
          since: stats.accesses.since,
        };
      }

      return { operations: 0, since: new Date() };
    } catch (error) {
      console.error(`Lỗi khi lấy thống kê sử dụng chỉ mục ${indexName}:`, error);
      return { operations: 0, since: new Date(), error: error.message };
    }
  }

  /**
   * Tạo báo cáo hiệu suất truy vấn
   * @param {mongoose.Model} model - Model Mongoose
   * @param {Number} days - Số ngày để phân tích
   * @returns {Promise<Object>} Báo cáo hiệu suất
   */
  static async generatePerformanceReport(model, days = 7) {
    try {
      // Phân tích chỉ mục
      const indexes = await this.analyzeIndexes(model);

      // Đọc log truy vấn chậm
      const slowQueries = await this._readSlowQueriesLog(days);

      // Lọc các truy vấn liên quan đến collection này
      const collectionQueries = slowQueries.filter((q) => q.collection === model.collection.name);

      // Phân tích các mẫu truy vấn phổ biến
      const queryPatterns = this._analyzeQueryPatterns(collectionQueries);

      // Tạo báo cáo
      return {
        collection: model.collection.name,
        indexes,
        slowQueriesCount: collectionQueries.length,
        averageExecutionTime: this._calculateAverage(
          collectionQueries.map((q) => q.executionTimeMs)
        ),
        commonQueryPatterns: queryPatterns,
        indexRecommendations: this._generateIndexRecommendations(queryPatterns, indexes),
      };
    } catch (error) {
      console.error('Lỗi khi tạo báo cáo hiệu suất:', error);
      return { error: error.message };
    }
  }

  /**
   * Đọc log truy vấn chậm
   * @private
   * @param {Number} days - Số ngày để đọc
   * @returns {Promise<Array>} Danh sách truy vấn chậm
   */
  static async _readSlowQueriesLog(days) {
    try {
      const logFile = path.join(process.cwd(), 'logs', 'slow-queries.log');

      // Kiểm tra xem file log có tồn tại không
      try {
        await fs.access(logFile);
      } catch (err) {
        return []; // File không tồn tại
      }

      // Đọc file log
      const content = await fs.readFile(logFile, 'utf8');
      const lines = content.split('\n').filter((line) => line.trim());

      // Phân tích từng dòng
      const queries = lines
        .map((line) => {
          try {
            return JSON.parse(line);
          } catch (err) {
            return null;
          }
        })
        .filter((q) => q !== null);

      // Lọc theo ngày
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      return queries.filter((q) => {
        const queryDate = new Date(q.timestamp);
        return queryDate >= cutoffDate;
      });
    } catch (error) {
      console.error('Lỗi khi đọc log truy vấn chậm:', error);
      return [];
    }
  }

  /**
   * Phân tích các mẫu truy vấn phổ biến
   * @private
   * @param {Array} queries - Danh sách truy vấn
   * @returns {Array} Các mẫu truy vấn phổ biến
   */
  static _analyzeQueryPatterns(queries) {
    const patterns = {};

    // Nhóm các truy vấn theo mẫu
    queries.forEach((query) => {
      if (!query.queryShape) return;

      if (!patterns[query.queryShape]) {
        patterns[query.queryShape] = {
          pattern: query.queryShape,
          count: 0,
          totalTime: 0,
          examples: [],
        };
      }

      patterns[query.queryShape].count++;
      patterns[query.queryShape].totalTime += query.executionTimeMs;

      // Lưu tối đa 3 ví dụ
      if (patterns[query.queryShape].examples.length < 3) {
        patterns[query.queryShape].examples.push({
          timestamp: query.timestamp,
          executionTimeMs: query.executionTimeMs,
        });
      }
    });

    // Chuyển đổi thành mảng và sắp xếp theo số lượng
    return Object.values(patterns)
      .map((p) => ({
        ...p,
        averageTime: p.totalTime / p.count,
      }))
      .sort((a, b) => b.count - a.count);
  }

  /**
   * Tạo đề xuất chỉ mục dựa trên mẫu truy vấn
   * @private
   * @param {Array} queryPatterns - Các mẫu truy vấn
   * @param {Array} existingIndexes - Các chỉ mục hiện có
   * @returns {Array} Đề xuất chỉ mục
   */
  static _generateIndexRecommendations(queryPatterns, existingIndexes) {
    const recommendations = [];

    queryPatterns.forEach((pattern) => {
      try {
        // Phân tích mẫu truy vấn
        const queryObj = JSON.parse(pattern.pattern);

        // Lấy các trường trong truy vấn
        const queryFields = Object.keys(queryObj).filter((key) => !key.startsWith('$'));

        if (queryFields.length === 0) return;

        // Kiểm tra xem đã có chỉ mục nào bao gồm các trường này chưa
        const hasMatchingIndex = existingIndexes.some((index) => {
          const indexFields = Object.keys(index.fields);
          return queryFields.every((field) => indexFields.includes(field));
        });

        if (!hasMatchingIndex) {
          recommendations.push({
            queryPattern: pattern.pattern,
            suggestedIndex: `{ ${queryFields.map((f) => `"${f}": 1`).join(', ')} }`,
            queryCount: pattern.count,
            averageTime: pattern.averageTime,
          });
        }
      } catch (error) {
        // Bỏ qua các mẫu không hợp lệ
      }
    });

    return recommendations;
  }

  /**
   * Tính giá trị trung bình của một mảng số
   * @private
   * @param {Array} values - Mảng các giá trị
   * @returns {Number} Giá trị trung bình
   */
  static _calculateAverage(values) {
    if (values.length === 0) return 0;
    return values.reduce((sum, val) => sum + val, 0) / values.length;
  }
}

module.exports = QueryAnalyzer;


--- File: utils/responseHandler.js ---
/**
 * Response Handler Utility - định dạng chuẩn hóa cho responses
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Gửi response thành công
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo thành công
 * @param {*} data - Dữ liệu trả về
 */
exports.sendSuccess = (res, statusCode = 200, message = 'Success', data = null) => {
  const response = {
    status: 'success',
    message,
  };

  if (data !== null) {
    response.data = data;
  }

  res.status(statusCode).json(response);
};

/**
 * Gửi response lỗi
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo lỗi
 * @param {Object} errors - Chi tiết lỗi (optional)
 */
exports.sendError = (res, statusCode = 500, message = 'Error', errors = null) => {
  const response = {
    status: 'error',
    message,
  };

  if (errors !== null) {
    response.errors = errors;
  }

  res.status(statusCode).json(response);
};

/**
 * Gửi response với dữ liệu phân trang
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo
 * @param {Array} data - Dữ liệu trả về
 * @param {Object} pagination - Thông tin phân trang
 */
exports.sendPaginated = (
  res,
  statusCode = 200,
  message = 'Success',
  data = [],
  pagination = {}
) => {
  const response = {
    status: 'success',
    message,
    data,
    pagination,
  };

  res.status(statusCode).json(response);
};

/**
 * Gửi response cho created
 * @param {Object} res - Express response object
 * @param {string} message - Thông báo
 * @param {*} data - Dữ liệu trả về
 */
exports.sendCreated = (res, message = 'Created successfully', data = null) => {
  exports.sendSuccess(res, 201, message, data);
};

/**
 * Gửi response không có nội dung
 * @param {Object} res - Express response object
 */
exports.sendNoContent = (res) => {
  res.status(204).end();
};


--- File: utils/validatorUtils.js ---
/**
 * Validator Utilities - Các hàm hỗ trợ validate dữ liệu
 * @author Steve
 * @project RunOut-Biliard
 */

const mongoose = require('mongoose');

/**
 * Kiểm tra ID MongoDB hợp lệ
 * @param {string} id - ID cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isValidMongoId = (id) => {
  return mongoose.Types.ObjectId.isValid(id);
};

/**
 * Kiểm tra số điện thoại Việt Nam hợp lệ
 * @param {string} phone - Số điện thoại cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isValidVNPhone = (phone) => {
  return /^(0|\+84)[3|5|7|8|9][0-9]{8}$/.test(phone);
};

/**
 * Kiểm tra mật khẩu đủ mạnh
 * Yêu cầu:
 * - Ít nhất 8 ký tự
 * - Có ít nhất 1 chữ hoa
 * - Có ít nhất 1 chữ thường
 * - Có ít nhất 1 chữ số
 * @param {string} password - Mật khẩu cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isStrongPassword = (password) => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /[0-9]/.test(password);

  return password.length >= minLength && hasUpperCase && hasLowerCase && hasNumbers;
};

/**
 * Mã hóa một chuỗi thành slug
 * @param {string} text - Chuỗi cần mã hóa
 * @returns {string} - Slug đã tạo
 */
exports.slugify = (text) => {
  return text
    .toString()
    .normalize('NFD') // tách dấu thành các ký tự riêng biệt
    .replace(/[\u0300-\u036f]/g, '') // loại bỏ dấu
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // thay khoảng trắng bằng dấu gạch
    .replace(/[^\w-]+/g, '') // loại bỏ các ký tự đặc biệt
    .replace(/--+/g, '-'); // thay nhiều dấu gạch liên tiếp bằng một dấu
};

/**
 * Loại bỏ dấu tiếng Việt
 * @param {string} str - Chuỗi cần xử lý
 * @returns {string} - Chuỗi đã loại bỏ dấu
 */
exports.removeVietnameseAccents = (str) => {
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/đ/g, 'd')
    .replace(/Đ/g, 'D');
};

/**
 * Kiểm tra một giá trị có thuộc một enum không
 * @param {*} value - Giá trị cần kiểm tra
 * @param {Array} enumValues - Mảng các giá trị hợp lệ
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isInEnum = (value, enumValues) => {
  return enumValues.includes(value);
};

/**
 * Tạo một mã ngẫu nhiên
 * @param {number} length - Độ dài mã
 * @returns {string} - Mã ngẫu nhiên
 */
exports.generateRandomCode = (length = 6) => {
  const characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let result = '';

  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
};

/**
 * Chuẩn hóa số điện thoại về định dạng 0xxxxxxxxx
 * @param {string} phone - Số điện thoại cần chuẩn hóa
 * @returns {string} - Số điện thoại đã chuẩn hóa
 */
exports.normalizePhone = (phone) => {
  if (!phone) return '';

  // Loại bỏ các ký tự không phải số
  let normalized = phone.replace(/\D/g, '');

  // Đổi +84 thành 0
  if (normalized.startsWith('84')) {
    normalized = '0' + normalized.substring(2);
  }

  return normalized;
};

