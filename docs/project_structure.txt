--- Folder Structure ---
[.qodo]
README.md
cautructhumuc.md
[client]
    ‚îú‚îÄ‚îÄ .eslintrc.js
    ‚îú‚îÄ‚îÄ .prettierrc
    ‚îú‚îÄ‚îÄ [.qodo]
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ cau_truc_du_an.md
    ‚îú‚îÄ‚îÄ [docs]
    ‚îú‚îÄ‚îÄ jsconfig.json
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ [public]
        ‚îî‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ [src]
        ‚îú‚îÄ‚îÄ App.js
        ‚îú‚îÄ‚îÄ [api]
            ‚îú‚îÄ‚îÄ [controllers]
                ‚îî‚îÄ‚îÄ productController.js
        ‚îú‚îÄ‚îÄ [assets]
            ‚îú‚îÄ‚îÄ [css]
                ‚îî‚îÄ‚îÄ index.css
            ‚îî‚îÄ‚îÄ [images]
        ‚îú‚îÄ‚îÄ [components]
            ‚îú‚îÄ‚îÄ [common]
                ‚îú‚îÄ‚îÄ [Button]
                    ‚îú‚îÄ‚îÄ Button.js
                    ‚îî‚îÄ‚îÄ Button.test.js
                ‚îú‚îÄ‚îÄ [Card]
                    ‚îî‚îÄ‚îÄ Card.js
                ‚îú‚îÄ‚îÄ [Input]
                    ‚îî‚îÄ‚îÄ Input.js
                ‚îú‚îÄ‚îÄ [LoadingSpiner]
                    ‚îî‚îÄ‚îÄ index.js
                ‚îú‚îÄ‚îÄ [Modal]
                    ‚îî‚îÄ‚îÄ index.js
                ‚îú‚îÄ‚îÄ [Pagination]
                    ‚îî‚îÄ‚îÄ index.js
                ‚îú‚îÄ‚îÄ [Toast]
                    ‚îî‚îÄ‚îÄ index.js
                ‚îî‚îÄ‚îÄ [Watermark]
                    ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [feature]
                ‚îú‚îÄ‚îÄ [Admin]
                    ‚îú‚îÄ‚îÄ [Dashboard]
                        ‚îú‚îÄ‚îÄ DashboardStats.js
                        ‚îú‚îÄ‚îÄ RecentOrders.js
                        ‚îî‚îÄ‚îÄ SalesChart.js
                    ‚îú‚îÄ‚îÄ [OrderManager]
                        ‚îú‚îÄ‚îÄ OrderDetail.js
                        ‚îî‚îÄ‚îÄ OrderTable.js
                    ‚îú‚îÄ‚îÄ [ProductManager]
                        ‚îú‚îÄ‚îÄ ProductForm.js
                        ‚îî‚îÄ‚îÄ ProductTable.js
                    ‚îî‚îÄ‚îÄ [UserManager]
                        ‚îî‚îÄ‚îÄ UserTable.js
                ‚îú‚îÄ‚îÄ [Cart]
                    ‚îú‚îÄ‚îÄ AddToCart.js
                    ‚îú‚îÄ‚îÄ CartItem.js
                    ‚îú‚îÄ‚îÄ CartList.js
                    ‚îî‚îÄ‚îÄ CartSummary.js
                ‚îú‚îÄ‚îÄ [Category]
                    ‚îî‚îÄ‚îÄ CategoryBreadcrumb.js
                ‚îú‚îÄ‚îÄ [Product]
                    ‚îú‚îÄ‚îÄ ProductCard.js
                    ‚îú‚îÄ‚îÄ ProductFilter.js
                    ‚îú‚îÄ‚îÄ ProductList.js
                    ‚îî‚îÄ‚îÄ ProductList.test.js
                ‚îú‚îÄ‚îÄ [Review]
                    ‚îú‚îÄ‚îÄ ReviewForm.js
                    ‚îú‚îÄ‚îÄ ReviewItem.js
                    ‚îú‚îÄ‚îÄ ReviewList.js
                    ‚îî‚îÄ‚îÄ ReviewStats.js
                ‚îú‚îÄ‚îÄ [Search]
                    ‚îú‚îÄ‚îÄ RecentSearches.js
                    ‚îî‚îÄ‚îÄ SearchBar.js
                ‚îî‚îÄ‚îÄ [User]
                    ‚îú‚îÄ‚îÄ OrderDetail.js
                    ‚îú‚îÄ‚îÄ ProfileSidebar.js
                    ‚îú‚îÄ‚îÄ UserOrders.js
                    ‚îî‚îÄ‚îÄ UserProfile.js
        ‚îú‚îÄ‚îÄ [hooks]
            ‚îú‚îÄ‚îÄ useDebounce.js
            ‚îú‚îÄ‚îÄ useForm.js
            ‚îú‚îÄ‚îÄ useLocalStorage.js
            ‚îî‚îÄ‚îÄ useOutsideClick.js
        ‚îú‚îÄ‚îÄ index.js
        ‚îú‚îÄ‚îÄ [pages]
            ‚îú‚îÄ‚îÄ [Admin]
                ‚îî‚îÄ‚îÄ [Dashboard]
                    ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Auth]
                ‚îú‚îÄ‚îÄ [Login]
                    ‚îî‚îÄ‚îÄ index.js
                ‚îî‚îÄ‚îÄ [Register]
                    ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Cart]
                ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Home]
                ‚îú‚îÄ‚îÄ [NotFound]
                ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Info]
                ‚îú‚îÄ‚îÄ Contact.js
                ‚îú‚îÄ‚îÄ FAQ.js
                ‚îú‚îÄ‚îÄ Privacy.js
                ‚îú‚îÄ‚îÄ Return.js
                ‚îú‚îÄ‚îÄ Shipping.js
                ‚îî‚îÄ‚îÄ Terms.js
            ‚îú‚îÄ‚îÄ [NotFound]
                ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [ProductDetail]
                ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Products]
                ‚îî‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ [Profile]
                ‚îú‚îÄ‚îÄ OrderDetail.js
                ‚îú‚îÄ‚îÄ Orders.js
                ‚îî‚îÄ‚îÄ index.js
            ‚îî‚îÄ‚îÄ [Search]
                ‚îî‚îÄ‚îÄ index.js
        ‚îú‚îÄ‚îÄ [services]
            ‚îú‚îÄ‚îÄ adminService.js
            ‚îú‚îÄ‚îÄ api.js
            ‚îú‚îÄ‚îÄ authService.js
            ‚îú‚îÄ‚îÄ cartService.js
            ‚îú‚îÄ‚îÄ notificationService.js
            ‚îú‚îÄ‚îÄ orderService.js
            ‚îú‚îÄ‚îÄ paymentService.js
            ‚îú‚îÄ‚îÄ productService.js
            ‚îú‚îÄ‚îÄ reviewService.js
            ‚îú‚îÄ‚îÄ userService.js
            ‚îî‚îÄ‚îÄ wishlistService.js
        ‚îú‚îÄ‚îÄ [store]
            ‚îú‚îÄ‚îÄ hooks.js
            ‚îú‚îÄ‚îÄ index.js
            ‚îî‚îÄ‚îÄ [slices]
                ‚îú‚îÄ‚îÄ adminSlice.js
                ‚îú‚îÄ‚îÄ authSlice.js
                ‚îú‚îÄ‚îÄ cartSlice.js
                ‚îú‚îÄ‚îÄ notificationSlice.js
                ‚îú‚îÄ‚îÄ orderSlice.js
                ‚îú‚îÄ‚îÄ productSlice.js
                ‚îú‚îÄ‚îÄ reviewSlice.js
                ‚îú‚îÄ‚îÄ searchSlice.js
                ‚îú‚îÄ‚îÄ uiSlice.js
                ‚îú‚îÄ‚îÄ userSlice.js
                ‚îî‚îÄ‚îÄ wishlistSlice.js
        ‚îî‚îÄ‚îÄ [utils]
            ‚îú‚îÄ‚îÄ authToken.js
            ‚îî‚îÄ‚îÄ formatters.js
    ‚îú‚îÄ‚îÄ tailwind.config.js
    ‚îî‚îÄ‚îÄ webpack.config.md
[docker]
    ‚îú‚îÄ‚îÄ Dockerfile.client
    ‚îú‚îÄ‚îÄ Dockerfile.server
    ‚îî‚îÄ‚îÄ docker-compose.yml
docker-compose.prod.yml
[docs]
    ‚îî‚îÄ‚îÄ CI-CD-Guide.md
[nginx]
    ‚îî‚îÄ‚îÄ [conf.d]
        ‚îî‚îÄ‚îÄ default.conf
[prometheus]
    ‚îî‚îÄ‚îÄ prometheus.yml
[scripts]
    ‚îú‚îÄ‚îÄ init-structure.sh
    ‚îú‚îÄ‚îÄ mongodb-backup.sh
    ‚îî‚îÄ‚îÄ setup-directory-structure.sh
[server]
    ‚îú‚îÄ‚îÄ .eslintrc.js
    ‚îú‚îÄ‚îÄ .prettierrc
    ‚îú‚îÄ‚îÄ [.qodo]
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ jest.config.js
    ‚îú‚îÄ‚îÄ jsconfig.json
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ [src]
        ‚îú‚îÄ‚îÄ [api]
            ‚îú‚îÄ‚îÄ [controllers]
                ‚îú‚îÄ‚îÄ authController.js
                ‚îú‚îÄ‚îÄ cartController.js
                ‚îú‚îÄ‚îÄ categoryController.js
                ‚îú‚îÄ‚îÄ orderController.js
                ‚îú‚îÄ‚îÄ productController.js
                ‚îú‚îÄ‚îÄ reviewController.js
                ‚îî‚îÄ‚îÄ userController.js
            ‚îú‚îÄ‚îÄ [middleware]
                ‚îú‚îÄ‚îÄ authMiddleware.js
                ‚îú‚îÄ‚îÄ errorHandler.js
                ‚îú‚îÄ‚îÄ errorMiddleware.js
                ‚îú‚îÄ‚îÄ loggingMiddleware.js
                ‚îî‚îÄ‚îÄ validationMiddleware.js
        ‚îú‚îÄ‚îÄ app.js
        ‚îú‚îÄ‚îÄ [common]
            ‚îú‚îÄ‚îÄ [errors]
                ‚îî‚îÄ‚îÄ apiError.js
            ‚îú‚îÄ‚îÄ [middleware]
                ‚îú‚îÄ‚îÄ errorHandler.js
                ‚îú‚îÄ‚îÄ rateLimiter.js
                ‚îú‚îÄ‚îÄ requestLogger.js
                ‚îî‚îÄ‚îÄ validate.js
            ‚îú‚îÄ‚îÄ readme.md
            ‚îú‚îÄ‚îÄ [types]
                ‚îú‚îÄ‚îÄ auth.types.js
                ‚îú‚îÄ‚îÄ common.types.js
                ‚îú‚îÄ‚îÄ express.d.ts
                ‚îú‚îÄ‚îÄ order.types.js
                ‚îî‚îÄ‚îÄ product.types.js
            ‚îú‚îÄ‚îÄ [utils]
                ‚îú‚îÄ‚îÄ apiFeatures.js
                ‚îú‚îÄ‚îÄ catchAsync.js
                ‚îú‚îÄ‚îÄ dateUtils.js
                ‚îú‚îÄ‚îÄ fileUtils.js
                ‚îú‚îÄ‚îÄ formatters.js
                ‚îú‚îÄ‚îÄ responseHandler.js
                ‚îú‚îÄ‚îÄ securityUtils.js
                ‚îî‚îÄ‚îÄ validatorUtils.js
            ‚îî‚îÄ‚îÄ [validators]
                ‚îú‚îÄ‚îÄ authValidator.js
                ‚îú‚îÄ‚îÄ cartValidator.js
                ‚îú‚îÄ‚îÄ categoryValidator.js
                ‚îú‚îÄ‚îÄ orderValidator.js
                ‚îú‚îÄ‚îÄ productValidator.js
                ‚îú‚îÄ‚îÄ reviewValidator.js
                ‚îî‚îÄ‚îÄ userValidator.js
        ‚îú‚îÄ‚îÄ [config]
            ‚îú‚îÄ‚îÄ database.js
            ‚îú‚îÄ‚îÄ environment.js
            ‚îú‚îÄ‚îÄ fix-indexes.js
            ‚îú‚îÄ‚îÄ indexes.js
            ‚îú‚îÄ‚îÄ logger.js
            ‚îú‚îÄ‚îÄ middleware.js
            ‚îî‚îÄ‚îÄ monitoring.js
        ‚îú‚îÄ‚îÄ [data]
            ‚îú‚îÄ‚îÄ [dto]
                ‚îú‚îÄ‚îÄ cartDTO.js
                ‚îú‚îÄ‚îÄ categoryDTO.js
                ‚îú‚îÄ‚îÄ orderDTO.js
                ‚îú‚îÄ‚îÄ productDTO.js
                ‚îú‚îÄ‚îÄ reviewDTO.js
                ‚îî‚îÄ‚îÄ userDTO.js
            ‚îú‚îÄ‚îÄ [models]
                ‚îú‚îÄ‚îÄ cart.model.js
                ‚îú‚îÄ‚îÄ category.model.js
                ‚îú‚îÄ‚îÄ order.model.js
                ‚îú‚îÄ‚îÄ product.model.js
                ‚îú‚îÄ‚îÄ review.model.js
                ‚îî‚îÄ‚îÄ user.model.js
            ‚îî‚îÄ‚îÄ [repositories]
                ‚îú‚îÄ‚îÄ cartRepository.js
                ‚îú‚îÄ‚îÄ categoryRepository.js
                ‚îú‚îÄ‚îÄ orderRepository.js
                ‚îú‚îÄ‚îÄ productRepository.js
                ‚îú‚îÄ‚îÄ reviewRepository.js
                ‚îî‚îÄ‚îÄ userRepository.js
        ‚îú‚îÄ‚îÄ [migrations]
            ‚îú‚îÄ‚îÄ config.js
            ‚îú‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ migrationFramework.js
            ‚îú‚îÄ‚îÄ migrationRunner.js
            ‚îî‚îÄ‚îÄ [scripts]
                ‚îú‚îÄ‚îÄ 001-initial-categories.js
                ‚îú‚îÄ‚îÄ 002-add-indexes.js
                ‚îî‚îÄ‚îÄ 003-add-admin-user.js
        ‚îú‚îÄ‚îÄ [seeds]
            ‚îú‚îÄ‚îÄ [data]
                ‚îú‚îÄ‚îÄ carts.js
                ‚îú‚îÄ‚îÄ categories.js
                ‚îú‚îÄ‚îÄ orders.js
                ‚îú‚îÄ‚îÄ products.js
                ‚îú‚îÄ‚îÄ reviews.js
                ‚îî‚îÄ‚îÄ users.js
            ‚îú‚îÄ‚îÄ index.js
            ‚îú‚îÄ‚îÄ runner.js
            ‚îî‚îÄ‚îÄ [scripts]
                ‚îú‚îÄ‚îÄ cartSeeder.js
                ‚îú‚îÄ‚îÄ categorySeeder.js
                ‚îú‚îÄ‚îÄ orderSeeder.js
                ‚îú‚îÄ‚îÄ productSeeder.js
                ‚îú‚îÄ‚îÄ reviewSeeder.js
                ‚îî‚îÄ‚îÄ userSeeder.js
        ‚îú‚îÄ‚îÄ server.js
        ‚îú‚îÄ‚îÄ [services]
            ‚îú‚îÄ‚îÄ [auth]
                ‚îî‚îÄ‚îÄ authService.js
            ‚îú‚îÄ‚îÄ [base]
                ‚îî‚îÄ‚îÄ baseService.js
            ‚îú‚îÄ‚îÄ [cache]
                ‚îî‚îÄ‚îÄ redisCache.js
            ‚îú‚îÄ‚îÄ [cart]
                ‚îî‚îÄ‚îÄ cartService.js
            ‚îú‚îÄ‚îÄ [category]
                ‚îî‚îÄ‚îÄ categoryService.js
            ‚îú‚îÄ‚îÄ [email]
                ‚îú‚îÄ‚îÄ emailService.js
            ‚îú‚îÄ‚îÄ [order]
                ‚îî‚îÄ‚îÄ orderService.js
            ‚îú‚îÄ‚îÄ [product]
                ‚îî‚îÄ‚îÄ productService.js
            ‚îú‚îÄ‚îÄ [review]
                ‚îî‚îÄ‚îÄ reviewService.js
            ‚îî‚îÄ‚îÄ [user]
                ‚îî‚îÄ‚îÄ userService.js
        ‚îú‚îÄ‚îÄ [types]
            ‚îî‚îÄ‚îÄ express.d.ts
        ‚îî‚îÄ‚îÄ [utils]
            ‚îú‚îÄ‚îÄ apiFeatures.js
            ‚îú‚îÄ‚îÄ catchAsync.js
            ‚îú‚îÄ‚îÄ logger.js
            ‚îú‚îÄ‚îÄ queryAnalyzer.js
            ‚îú‚îÄ‚îÄ responseHandler.js
            ‚îî‚îÄ‚îÄ validatorUtils.js
    ‚îî‚îÄ‚îÄ [tests]
        ‚îú‚îÄ‚îÄ [integration]
            ‚îú‚îÄ‚îÄ [api]
            ‚îî‚îÄ‚îÄ [repositories]
                ‚îú‚îÄ‚îÄ repositoryConsistency.test.js
                ‚îî‚îÄ‚îÄ userRepository.test.js
        ‚îú‚îÄ‚îÄ setup.js
        ‚îî‚îÄ‚îÄ [unit]
            ‚îú‚îÄ‚îÄ [controllers]
            ‚îú‚îÄ‚îÄ [repositories]
            ‚îî‚îÄ‚îÄ [services]

--- File Contents ---

--- File: README.md ---


--- File: cautructhumuc.md ---
```
runout-biliard/
‚îú‚îÄ‚îÄ server/                   # Backend Node.js/Express
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.js
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ .eslintrc.js
‚îÇ   ‚îú‚îÄ‚îÄ .prettierrc
‚îÇ   ‚îú‚îÄ‚îÄ jest.config.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ client/                   # Frontend React
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ .eslintrc.js
‚îÇ   ‚îú‚îÄ‚îÄ .prettierrc
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.server
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile.client
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îú‚îÄ‚îÄ ci.yml
‚îÇ       ‚îî‚îÄ‚îÄ deploy.yml
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```


--- File: client/.eslintrc.js ---
module.exports = {
    env: {
      browser: true,
      es2021: true,
      node: true,
      jest: true,
    },
    extends: [
      'eslint:recommended',
      'plugin:react/recommended',
      'plugin:react-hooks/recommended',
      'plugin:prettier/recommended',
    ],
    parserOptions: {
      ecmaFeatures: {
        jsx: true,
      },
      ecmaVersion: 12,
      sourceType: 'module',
    },
    plugins: ['react', 'react-hooks', 'prettier'],
    rules: {
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
      'prettier/prettier': 'error',
      'no-unused-vars': 'warn',
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
  };

--- File: client/.prettierrc ---
{
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "printWidth": 100,
    "bracketSpacing": true,
    "endOfLine": "auto"
  }

--- File: client/README.md ---
1. T·ªïng quan c·∫•u tr√∫c
client/
‚îú‚îÄ‚îÄ public/                # Static files
‚îÇ   ‚îú‚îÄ‚îÄ index.html         # HTML template
‚îÇ   ‚îú‚îÄ‚îÄ favicon.ico        # Website icon
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json      # PWA manifest
‚îÇ   ‚îî‚îÄ‚îÄ assets/            # Static assets
‚îú‚îÄ‚îÄ src/                   # Source code
‚îÇ   ‚îú‚îÄ‚îÄ index.js           # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ App.js             # Main component
‚îÇ   ‚îú‚îÄ‚îÄ assets/            # Assets (images, fonts, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ components/        # Reusable components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/             # Custom React hooks
‚îÇ   ‚îú‚îÄ‚îÄ pages/             # Page components
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # Route definitions
‚îÇ   ‚îú‚îÄ‚îÄ services/          # API services
‚îÇ   ‚îú‚îÄ‚îÄ store/             # Redux state management
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # Utility functions
‚îú‚îÄ‚îÄ .env                   # Environment variables
‚îú‚îÄ‚îÄ .eslintrc.js           # ESLint configuration
‚îú‚îÄ‚îÄ .prettierrc            # Prettier configuration
‚îú‚îÄ‚îÄ jsconfig.json          # JavaScript configuration
‚îú‚îÄ‚îÄ package.json           # Dependencies & scripts
‚îú‚îÄ‚îÄ tailwind.config.js     # Tailwind CSS configuration
‚îî‚îÄ‚îÄ README.md              # Project documentation
2. C·∫•u tr√∫c chi ti·∫øt t·ª´ng th√†nh ph·∫ßn
2.1. /src/components/
Components ƒë∆∞·ª£c chia th√†nh 3 lo·∫°i ch√≠nh:
components/
‚îú‚îÄ‚îÄ common/                # C√°c components d√πng chung
‚îÇ   ‚îú‚îÄ‚îÄ Button/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.js      # Component ch√≠nh
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Button.test.js # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ Card/
‚îÇ   ‚îú‚îÄ‚îÄ Input/
‚îÇ   ‚îú‚îÄ‚îÄ Modal/
‚îÇ   ‚îú‚îÄ‚îÄ Dropdown/
‚îÇ   ‚îú‚îÄ‚îÄ Pagination/
‚îÇ   ‚îú‚îÄ‚îÄ Alert/
‚îÇ   ‚îú‚îÄ‚îÄ Badge/
‚îÇ   ‚îú‚îÄ‚îÄ Breadcrumb/
‚îÇ   ‚îú‚îÄ‚îÄ LoadingSpinner/
‚îÇ   ‚îú‚îÄ‚îÄ Empty/
‚îÇ   ‚îú‚îÄ‚îÄ ErrorMessage/
‚îÇ   ‚îú‚îÄ‚îÄ Tag/
‚îÇ   ‚îú‚îÄ‚îÄ Tooltip/
‚îÇ   ‚îú‚îÄ‚îÄ Tabs/
‚îÇ   ‚îú‚îÄ‚îÄ Avatar/
‚îÇ   ‚îú‚îÄ‚îÄ Rating/
‚îÇ   ‚îú‚îÄ‚îÄ Toast/
‚îÇ   ‚îî‚îÄ‚îÄ Watermark/
‚îÇ
‚îú‚îÄ‚îÄ layout/                # Components li√™n quan ƒë·∫øn layout
‚îÇ   ‚îú‚îÄ‚îÄ Header/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Logo.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Navigation.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserMenu.js
‚îÇ   ‚îú‚îÄ‚îÄ Footer/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FooterLinks.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Copyright.js
‚îÇ   ‚îú‚îÄ‚îÄ Sidebar/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SidebarItem.js
‚îÇ   ‚îú‚îÄ‚îÄ MainLayout/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ AuthLayout/
‚îÇ       ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îî‚îÄ‚îÄ feature/               # Components cho c√°c t√≠nh nƒÉng c·ª• th·ªÉ
    ‚îú‚îÄ‚îÄ Auth/
    ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ RegisterForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ForgotPasswordForm.js
    ‚îÇ   ‚îî‚îÄ‚îÄ ResetPasswordForm.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ User/
    ‚îÇ   ‚îú‚îÄ‚îÄ UserProfile.js
    ‚îÇ   ‚îú‚îÄ‚îÄ UserAvatar.js
    ‚îÇ   ‚îú‚îÄ‚îÄ UserSettings.js
    ‚îÇ   ‚îî‚îÄ‚îÄ UserOrders.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Product/
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductCard.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductList.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductDetail.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductImages.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductInfo.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductFilter.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductSort.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ProductPagination.js
    ‚îÇ   ‚îî‚îÄ‚îÄ RelatedProducts.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Category/
    ‚îÇ   ‚îú‚îÄ‚îÄ CategoryList.js
    ‚îÇ   ‚îú‚îÄ‚îÄ CategoryItem.js
    ‚îÇ   ‚îî‚îÄ‚îÄ CategoryBreadcrumb.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Cart/
    ‚îÇ   ‚îú‚îÄ‚îÄ CartItem.js
    ‚îÇ   ‚îú‚îÄ‚îÄ CartList.js
    ‚îÇ   ‚îú‚îÄ‚îÄ CartSummary.js
    ‚îÇ   ‚îú‚îÄ‚îÄ AddToCart.js
    ‚îÇ   ‚îî‚îÄ‚îÄ MiniCart.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Checkout/
    ‚îÇ   ‚îú‚îÄ‚îÄ CheckoutForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ShippingForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ PaymentForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ OrderSummary.js
    ‚îÇ   ‚îî‚îÄ‚îÄ OrderConfirmation.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Review/
    ‚îÇ   ‚îú‚îÄ‚îÄ ReviewForm.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ReviewList.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ReviewItem.js
    ‚îÇ   ‚îî‚îÄ‚îÄ ReviewStats.js
    ‚îÇ
    ‚îú‚îÄ‚îÄ Search/
    ‚îÇ   ‚îú‚îÄ‚îÄ SearchBar.js
    ‚îÇ   ‚îú‚îÄ‚îÄ SearchResults.js
    ‚îÇ   ‚îú‚îÄ‚îÄ SearchFilters.js
    ‚îÇ   ‚îî‚îÄ‚îÄ RecentSearches.js
    ‚îÇ
    ‚îî‚îÄ‚îÄ Admin/
        ‚îú‚îÄ‚îÄ Dashboard/
        ‚îÇ   ‚îú‚îÄ‚îÄ DashboardStats.js
        ‚îÇ   ‚îú‚îÄ‚îÄ RecentOrders.js
        ‚îÇ   ‚îî‚îÄ‚îÄ SalesChart.js
        ‚îú‚îÄ‚îÄ ProductManager/
        ‚îÇ   ‚îú‚îÄ‚îÄ ProductTable.js
        ‚îÇ   ‚îú‚îÄ‚îÄ ProductForm.js
        ‚îÇ   ‚îî‚îÄ‚îÄ ProductBulkActions.js
        ‚îú‚îÄ‚îÄ OrderManager/
        ‚îÇ   ‚îú‚îÄ‚îÄ OrderTable.js
        ‚îÇ   ‚îú‚îÄ‚îÄ OrderDetail.js
        ‚îÇ   ‚îî‚îÄ‚îÄ OrderStatusUpdate.js
        ‚îî‚îÄ‚îÄ UserManager/
            ‚îú‚îÄ‚îÄ UserTable.js
            ‚îî‚îÄ‚îÄ UserForm.js
2.2. /src/pages/
pages/
‚îú‚îÄ‚îÄ Home/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Auth/
‚îÇ   ‚îú‚îÄ‚îÄ Login/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Register/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ ForgotPassword/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ ResetPassword/
‚îÇ       ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Products/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ ProductDetail/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Cart/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Checkout/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ Success.js
‚îÇ
‚îú‚îÄ‚îÄ Search/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Profile/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Settings.js
‚îÇ   ‚îú‚îÄ‚îÄ Orders.js
‚îÇ   ‚îî‚îÄ‚îÄ Reviews.js
‚îÇ
‚îú‚îÄ‚îÄ Admin/
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Edit.js
‚îÇ   ‚îú‚îÄ‚îÄ Orders/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Detail.js
‚îÇ   ‚îî‚îÄ‚îÄ Users/
‚îÇ       ‚îú‚îÄ‚îÄ index.js
‚îÇ       ‚îî‚îÄ‚îÄ Edit.js
‚îÇ
‚îî‚îÄ‚îÄ NotFound/
    ‚îî‚îÄ‚îÄ index.js
2.3. /src/routes/
routes/
‚îú‚îÄ‚îÄ index.js           # C·∫•u h√¨nh t·∫•t c·∫£ routes
‚îú‚îÄ‚îÄ paths.js           # Constants cho path URLs
‚îú‚îÄ‚îÄ PrivateRoute.js    # Higher-order component b·∫£o v·ªá routes
‚îî‚îÄ‚îÄ PublicRoute.js     # Higher-order component cho public routes
2.4. /src/hooks/
hooks/
‚îú‚îÄ‚îÄ useAuth.js         # Hook x·ª≠ l√Ω authentication
‚îú‚îÄ‚îÄ useCart.js         # Hook qu·∫£n l√Ω gi·ªè h√†ng
‚îú‚îÄ‚îÄ useDebounce.js     # Hook debounce gi√° tr·ªã
‚îú‚îÄ‚îÄ useForm.js         # Hook qu·∫£n l√Ω form
‚îú‚îÄ‚îÄ useLocalStorage.js # Hook t∆∞∆°ng t√°c v·ªõi localStorage
‚îú‚îÄ‚îÄ useOutsideClick.js # Hook ph√°t hi·ªán click b√™n ngo√†i element
‚îú‚îÄ‚îÄ usePayment.js      # Hook x·ª≠ l√Ω thanh to√°n
‚îú‚îÄ‚îÄ useProduct.js      # Hook l·∫•y th√¥ng tin s·∫£n ph·∫©m
‚îú‚îÄ‚îÄ useSearch.js       # Hook x·ª≠ l√Ω t√¨m ki·∫øm
‚îî‚îÄ‚îÄ useWindowSize.js   # Hook l·∫•y k√≠ch th∆∞·ªõc c·ª≠a s·ªï
2.5. /src/services/
services/
‚îú‚îÄ‚îÄ api.js             # C·∫•u h√¨nh Axios/Fetch
‚îú‚îÄ‚îÄ authService.js     # API cho authentication
‚îú‚îÄ‚îÄ cartService.js     # API cho cart operations
‚îú‚îÄ‚îÄ categoryService.js # API cho category operations
‚îú‚îÄ‚îÄ orderService.js    # API cho order operations
‚îú‚îÄ‚îÄ paymentService.js  # API cho payment integration
‚îú‚îÄ‚îÄ productService.js  # API cho product operations
‚îú‚îÄ‚îÄ reviewService.js   # API cho review operations
‚îú‚îÄ‚îÄ searchService.js   # API cho search functionality
‚îî‚îÄ‚îÄ userService.js     # API cho user operations
2.6. /src/store/
store/
‚îú‚îÄ‚îÄ index.js           # C·∫•u h√¨nh Redux store
‚îú‚îÄ‚îÄ hooks.js           # Custom Redux hooks (useAppDispatch, useAppSelector)
‚îÇ
‚îî‚îÄ‚îÄ slices/
    ‚îú‚îÄ‚îÄ authSlice.js   # State management cho authentication
    ‚îú‚îÄ‚îÄ cartSlice.js   # State management cho shopping cart
    ‚îú‚îÄ‚îÄ productSlice.js # State management cho products
    ‚îú‚îÄ‚îÄ categorySlice.js # State management cho categories
    ‚îú‚îÄ‚îÄ orderSlice.js  # State management cho orders
    ‚îú‚îÄ‚îÄ reviewSlice.js # State management cho reviews
    ‚îú‚îÄ‚îÄ searchSlice.js # State management cho search
    ‚îú‚îÄ‚îÄ uiSlice.js     # State management cho UI (modals, sidebars, etc.)
    ‚îî‚îÄ‚îÄ userSlice.js   # State management cho user profile
2.7. /src/utils/
utils/
‚îú‚îÄ‚îÄ authToken.js       # Utilities x·ª≠ l√Ω JWT tokens
‚îú‚îÄ‚îÄ formatters.js      # Formatting functions (dates, currency, etc.)
‚îú‚îÄ‚îÄ validators.js      # Validation functions
‚îú‚îÄ‚îÄ storage.js         # Local/session storage helpers
‚îú‚îÄ‚îÄ errorHandler.js    # Error handling utilities
‚îú‚îÄ‚îÄ analytics.js       # Analytics helpers
‚îú‚îÄ‚îÄ constants.js       # Application constants
‚îî‚îÄ‚îÄ helpers.js         # C√°c helper functions kh√°c
2.8. /src/assets/
assets/
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ index.css      # Global CSS
‚îÇ
‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ logo.png
‚îÇ   ‚îú‚îÄ‚îÄ banners/
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îî‚îÄ‚îÄ products/
‚îÇ
‚îî‚îÄ‚îÄ fonts/
    ‚îî‚îÄ‚îÄ ...


--- File: client/cau_truc_du_an.md ---

1. T·ªïng quan c·∫•u tr√∫c¬†client/
‚îú‚îÄ‚îÄ public/ # Static files
‚îÇ ‚îú‚îÄ‚îÄ index.html # HTML template
‚îÇ ‚îú‚îÄ‚îÄ favicon.ico # Website icon
‚îÇ ‚îú‚îÄ‚îÄ manifest.json # PWA manifest
‚îÇ ‚îî‚îÄ‚îÄ assets/ # Static assets
‚îú‚îÄ‚îÄ src/ # Source code
‚îÇ ‚îú‚îÄ‚îÄ index.js # Entry point
‚îÇ ‚îú‚îÄ‚îÄ App.js # Main component
‚îÇ ‚îú‚îÄ‚îÄ assets/ # Assets (images, fonts, etc.)
‚îÇ ‚îú‚îÄ‚îÄ components/ # Reusable components
‚îÇ ‚îú‚îÄ‚îÄ hooks/ # Custom React hooks
‚îÇ ‚îú‚îÄ‚îÄ pages/ # Page components
‚îÇ ‚îú‚îÄ‚îÄ routes/ # Route definitions
‚îÇ ‚îú‚îÄ‚îÄ services/ # API services
‚îÇ ‚îú‚îÄ‚îÄ store/ # Redux state management
‚îÇ ‚îî‚îÄ‚îÄ utils/ # Utility functions
‚îú‚îÄ‚îÄ .env # Environment variables
‚îú‚îÄ‚îÄ .eslintrc.js # ESLint configuration
‚îú‚îÄ‚îÄ .prettierrc # Prettier configuration
‚îú‚îÄ‚îÄ jsconfig.json # JavaScript configuration
‚îú‚îÄ‚îÄ package.json # Dependencies & scripts
‚îú‚îÄ‚îÄ tailwind.config.js # Tailwind CSS configuration
‚îî‚îÄ‚îÄ README.md # Project documentation

2. /src/components/

components/
‚îú‚îÄ‚îÄ common/ # C√°c components d√πng chung
‚îÇ ‚îú‚îÄ‚îÄ Button/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Button.js # Component ch√≠nh
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Button.test.js # Unit tests
‚îÇ ‚îú‚îÄ‚îÄ Card/
‚îÇ ‚îú‚îÄ‚îÄ Input/
‚îÇ ‚îú‚îÄ‚îÄ Modal/
‚îÇ ‚îú‚îÄ‚îÄ Dropdown/
‚îÇ ‚îú‚îÄ‚îÄ Pagination/
‚îÇ ‚îú‚îÄ‚îÄ Alert/
‚îÇ ‚îú‚îÄ‚îÄ Badge/
‚îÇ ‚îú‚îÄ‚îÄ Breadcrumb/
‚îÇ ‚îú‚îÄ‚îÄ LoadingSpinner/
‚îÇ ‚îú‚îÄ‚îÄ Empty/
‚îÇ ‚îú‚îÄ‚îÄ ErrorMessage/
‚îÇ ‚îú‚îÄ‚îÄ Tag/
‚îÇ ‚îú‚îÄ‚îÄ Tooltip/
‚îÇ ‚îú‚îÄ‚îÄ Tabs/
‚îÇ ‚îú‚îÄ‚îÄ Avatar/
‚îÇ ‚îú‚îÄ‚îÄ Rating/
‚îÇ ‚îú‚îÄ‚îÄ Toast/
‚îÇ ‚îî‚îÄ‚îÄ Watermark/
‚îÇ
‚îú‚îÄ‚îÄ layout/ # Components li√™n quan ƒë·∫øn layout
‚îÇ ‚îú‚îÄ‚îÄ Header/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ index.js
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Logo.js
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Navigation.js
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ UserMenu.js
‚îÇ ‚îú‚îÄ‚îÄ Footer/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ index.js
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ FooterLinks.js
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Copyright.js
‚îÇ ‚îú‚îÄ‚îÄ Sidebar/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ index.js
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ SidebarItem.js
‚îÇ ‚îú‚îÄ‚îÄ MainLayout/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ index.js
‚îÇ ‚îî‚îÄ‚îÄ AuthLayout/
‚îÇ ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îî‚îÄ‚îÄ feature/ # Components cho c√°c t√≠nh nƒÉng c·ª• th·ªÉ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Auth/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ LoginForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ RegisterForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ForgotPasswordForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ ResetPasswordForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ User/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ UserProfile.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ UserAvatar.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ UserSettings.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ UserOrders.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Product/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductCard.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductList.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductDetail.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductImages.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductInfo.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductFilter.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductSort.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductPagination.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ RelatedProducts.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Category/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CategoryList.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CategoryItem.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ CategoryBreadcrumb.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Cart/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CartItem.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CartList.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CartSummary.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ AddToCart.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ MiniCart.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Checkout/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ CheckoutForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ShippingForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ PaymentForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ OrderSummary.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ OrderConfirmation.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Review/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ReviewForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ReviewList.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ReviewItem.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ ReviewStats.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Search/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ SearchBar.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ SearchResults.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ SearchFilters.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ RecentSearches.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îî‚îÄ‚îÄ Admin/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ Dashboard/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ DashboardStats.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ RecentOrders.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ SalesChart.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ ProductManager/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductTable.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ ProductForm.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ ProductBulkActions.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ OrderManager/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ OrderTable.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îú‚îÄ‚îÄ OrderDetail.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îÇ ‚îî‚îÄ‚îÄ OrderStatusUpdate.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îî‚îÄ‚îÄ UserManager/
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îú‚îÄ‚îÄ UserTable.js
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚îî‚îÄ‚îÄ UserForm.js

2.2. /src/pages/

pages/
‚îú‚îÄ‚îÄ Home/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Auth/
‚îÇ   ‚îú‚îÄ‚îÄ Login/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Register/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ ForgotPassword/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ ResetPassword/
‚îÇ       ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Products/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ ProductDetail/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Cart/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Checkout/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îî‚îÄ‚îÄ Success.js
‚îÇ
‚îú‚îÄ‚îÄ Search/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ
‚îú‚îÄ‚îÄ Profile/
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Settings.js
‚îÇ   ‚îú‚îÄ‚îÄ Orders.js
‚îÇ   ‚îî‚îÄ‚îÄ Reviews.js
‚îÇ
‚îú‚îÄ‚îÄ Admin/
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ Products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Edit.js
‚îÇ   ‚îú‚îÄ‚îÄ Orders/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Detail.js
‚îÇ   ‚îî‚îÄ‚îÄ Users/
‚îÇ       ‚îú‚îÄ‚îÄ index.js
‚îÇ       ‚îî‚îÄ‚îÄ Edit.js
‚îÇ
‚îî‚îÄ‚îÄ NotFound/
    ‚îî‚îÄ‚îÄ index.js
2.3. /src/routes/
routes/
‚îú‚îÄ‚îÄ index.js           # C·∫•u h√¨nh t·∫•t c·∫£ routes
‚îú‚îÄ‚îÄ paths.js           # Constants cho path URLs
‚îú‚îÄ‚îÄ PrivateRoute.js    # Higher-order component b·∫£o v·ªá routes
‚îî‚îÄ‚îÄ PublicRoute.js     # Higher-order component cho public routes
2.4. /src/hooks/
hooks/
‚îú‚îÄ‚îÄ useAuth.js         # Hook x·ª≠ l√Ω authentication
‚îú‚îÄ‚îÄ useCart.js         # Hook qu·∫£n l√Ω gi·ªè h√†ng
‚îú‚îÄ‚îÄ useDebounce.js     # Hook debounce gi√° tr·ªã
‚îú‚îÄ‚îÄ useForm.js         # Hook qu·∫£n l√Ω form
‚îú‚îÄ‚îÄ useLocalStorage.js # Hook t∆∞∆°ng t√°c v·ªõi localStorage
‚îú‚îÄ‚îÄ useOutsideClick.js # Hook ph√°t hi·ªán click b√™n ngo√†i element
‚îú‚îÄ‚îÄ usePayment.js      # Hook x·ª≠ l√Ω thanh to√°n
‚îú‚îÄ‚îÄ useProduct.js      # Hook l·∫•y th√¥ng tin s·∫£n ph·∫©m
‚îú‚îÄ‚îÄ useSearch.js       # Hook x·ª≠ l√Ω t√¨m ki·∫øm
‚îî‚îÄ‚îÄ useWindowSize.js   # Hook l·∫•y k√≠ch th∆∞·ªõc c·ª≠a s·ªï
2.5. /src/services/
services/
‚îú‚îÄ‚îÄ api.js             # C·∫•u h√¨nh Axios/Fetch
‚îú‚îÄ‚îÄ authService.js     # API cho authentication
‚îú‚îÄ‚îÄ cartService.js     # API cho cart operations
‚îú‚îÄ‚îÄ categoryService.js # API cho category operations
‚îú‚îÄ‚îÄ orderService.js    # API cho order operations
‚îú‚îÄ‚îÄ paymentService.js  # API cho payment integration
‚îú‚îÄ‚îÄ productService.js  # API cho product operations
‚îú‚îÄ‚îÄ reviewService.js   # API cho review operations
‚îú‚îÄ‚îÄ searchService.js   # API cho search functionality
‚îî‚îÄ‚îÄ userService.js     # API cho user operations
2.6. /src/store/
store/
‚îú‚îÄ‚îÄ index.js           # C·∫•u h√¨nh Redux store
‚îú‚îÄ‚îÄ hooks.js           # Custom Redux hooks (useAppDispatch, useAppSelector)
‚îÇ
‚îî‚îÄ‚îÄ slices/
    ‚îú‚îÄ‚îÄ authSlice.js   # State management cho authentication
    ‚îú‚îÄ‚îÄ cartSlice.js   # State management cho shopping cart
    ‚îú‚îÄ‚îÄ productSlice.js # State management cho products
    ‚îú‚îÄ‚îÄ categorySlice.js # State management cho categories
    ‚îú‚îÄ‚îÄ orderSlice.js  # State management cho orders
    ‚îú‚îÄ‚îÄ reviewSlice.js # State management cho reviews
    ‚îú‚îÄ‚îÄ searchSlice.js # State management cho search
    ‚îú‚îÄ‚îÄ uiSlice.js     # State management cho UI (modals, sidebars, etc.)
    ‚îî‚îÄ‚îÄ userSlice.js   # State management cho user profile
2.7. /src/utils/
utils/
‚îú‚îÄ‚îÄ authToken.js       # Utilities x·ª≠ l√Ω JWT tokens
‚îú‚îÄ‚îÄ formatters.js      # Formatting functions (dates, currency, etc.)
‚îú‚îÄ‚îÄ validators.js      # Validation functions
‚îú‚îÄ‚îÄ storage.js         # Local/session storage helpers
‚îú‚îÄ‚îÄ errorHandler.js    # Error handling utilities
‚îú‚îÄ‚îÄ analytics.js       # Analytics helpers
‚îú‚îÄ‚îÄ constants.js       # Application constants
‚îî‚îÄ‚îÄ helpers.js         # C√°c helper functions kh√°c
2.8. /src/assets/
assets/
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ index.css      # Global CSS
‚îÇ
‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ logo.png
‚îÇ   ‚îú‚îÄ‚îÄ banners/
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îî‚îÄ‚îÄ products/
‚îÇ
‚îî‚îÄ‚îÄ fonts/


--- File: client/jsconfig.json ---
{
    "compilerOptions": {
      "baseUrl": "src",
      "paths": {
        "components/*": ["components/*"],
        "hooks/*": ["hooks/*"],
        "pages/*": ["pages/*"],
        "services/*": ["services/*"],
        "store/*": ["store/*"],
        "utils/*": ["utils/*"],
        "routes/*": ["routes/*"],
        "assets/*": ["assets/*"]
      },
      "checkJs": true,
      "jsx": "react-jsx"
    },
    "include": ["src"]
  }

--- File: client/package.json ---
{
    "name": "runout-biliard-client",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
        "@reduxjs/toolkit": "^2.0.1",
        "@tailwindcss/forms": "^0.5.10",
        "axios": "^1.6.2",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-hook-form": "^7.49.0",
        "react-query": "^3.39.3",
        "react-redux": "^9.0.2",
        "react-router-dom": "^6.20.1",
        "tailwindcss": "^3.4.17",
        "yup": "^1.3.2"
    },
    "devDependencies": {
        "@testing-library/jest-dom": "^6.1.5",
        "@testing-library/react": "^14.1.2",
        "@testing-library/user-event": "^14.5.1",
        "@types/jest": "^29.5.14",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "eslint-plugin-react": "^7.33.2",
        "eslint-plugin-react-hooks": "^4.6.0",
        "postcss": "^8.4.32",
        "prettier": "^3.1.0",
        "react-scripts": "5.0.1"
    },
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject",
        "lint": "eslint src",
        "lint:fix": "eslint src --fix",
        "format": "prettier --write \"src/**/*.{js,jsx}\""
    },
    "eslintConfig": {
        "extends": [
            "react-app",
            "react-app/jest"
        ]
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    },
    "proxy": "http://localhost:5000"
}


--- File: client/public/index.html ---
<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="RunOut-Biliard - C·ª≠a h√†ng Bi-a chuy√™n nghi·ªáp"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>RunOut-Biliard</title>
    <meta name="copyright" content="¬© 2025 RunOut-Biliard. T·∫•t c·∫£ c√°c quy·ªÅn thu·ªôc v·ªÅ Steve." />
  </head>
  <body>
    <noscript>B·∫°n c·∫ßn b·∫≠t JavaScript ƒë·ªÉ ch·∫°y ·ª©ng d·ª•ng n√†y.</noscript>
    <div id="root"></div>
  </body>
</html>

--- File: client/src/App.js ---
// File: client/src/App.js
import React, { Suspense } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import MainLayout from './components/layout/MainLayout';
import AuthLayout from './components/layout/AuthLayout';
import LoadingSpinner from './components/common/LoadingSpiner/index.js';
import { selectIsAuthenticated } from './store/slices/authSlice';
import { ROUTES } from './routes/paths';
// Lazy-loaded pages
const HomePage = React.lazy(() => import('./pages/Home'));
const LoginPage = React.lazy(() => import('./pages/Auth/Login'));
const RegisterPage = React.lazy(() => import('./pages/Auth/Register'));
const NotFoundPage = React.lazy(() => import('./pages/NotFound'));

// Watermark
const Watermark = ({ children }) => {
  return (
    <div className="relative">
      {children}
      <div className="absolute bottom-4 right-4 opacity-30 text-gray-500 font-bold rotate-330 select-none pointer-events-none">
        &copy; Steve
      </div>
    </div>
  );
};

function App() {
  const isAuthenticated = useSelector(selectIsAuthenticated);

  return (
    <Watermark>
      <Suspense fallback={<LoadingSpinner fullScreen />}>
        <Routes>
          {/* Public routes */}
          <Route element={<MainLayout />}>
            <Route path={ROUTES.HOME} element={<HomePage />} />
          </Route>

          {/* Auth routes */}
          <Route element={<AuthLayout />}>
            <Route
              path={ROUTES.LOGIN}
              element={isAuthenticated ? <Navigate to="/" replace /> : <LoginPage />}
            />
            <Route
              path={ROUTES.REGISTER}
              element={isAuthenticated ? <Navigate to="/" replace /> : <RegisterPage />}
            />
          </Route>

          {/* 404 route */}
          <Route path={ROUTES.NOT_FOUND} element={<NotFoundPage />} />
          <Route path="*" element={<Navigate to={ROUTES.NOT_FOUND} replace />} />
        </Routes>
      </Suspense>
    </Watermark>
  );
}

export default App;


--- File: client/src/api/controllers/productController.js ---
// server/src/api/controllers/productController.js

const { Product } = require('../../data/models/product.model');
const productRepository = require('../../data/repositories/productRepository');
const ApiError = require('../../middleware/apiError');
const catchAsync = require('../../utils/catchAsync');
const responseHandler = require('../../utils/responseHandler');

/**
 * L·∫•y danh s√°ch s·∫£n ph·∫©m v·ªõi pagination v√† filter
 */
exports.getProducts = catchAsync(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  const sort = req.query.sort || '-createdAt';
  
  // X√¢y d·ª±ng filter t·ª´ query params
  const filter = {};
  
  // L·ªçc theo danh m·ª•c
  if (req.query.category) {
    filter.category = req.query.category;
  }
  
  // L·ªçc theo gi√°
  if (req.query.minPrice || req.query.maxPrice) {
    filter.price = {};
    if (req.query.minPrice) filter.price.$gte = parseFloat(req.query.minPrice);
    if (req.query.maxPrice) filter.price.$lte = parseFloat(req.query.maxPrice);
  }
  
  // L·ªçc theo th∆∞∆°ng hi·ªáu
  if (req.query.brand) {
    filter.brand = req.query.brand;
  }
  
  // L·ªçc theo t√¨nh tr·∫°ng t·ªìn kho
  if (req.query.inStock === 'true') {
    filter.stock = { $gt: 0 };
  }
  
  // M·∫∑c ƒë·ªãnh ch·ªâ hi·ªÉn th·ªã s·∫£n ph·∫©m active
  filter.isActive = true;
  
  const result = await productRepository.findAll(filter, {
    page,
    limit,
    sort,
    populate: 'category'
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

/**
 * L·∫•y chi ti·∫øt s·∫£n ph·∫©m theo ID
 */
exports.getProductById = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  
  const product = await productRepository.findById(id, {
    populate: 'category'
  });
  
  if (!product) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m'));
  }
  
  responseHandler.success(res, product);
});

/**
 * L·∫•y s·∫£n ph·∫©m theo danh m·ª•c
 */
exports.getProductsByCategory = catchAsync(async (req, res) => {
  const { categoryId } = req.params;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  const sort = req.query.sort || '-createdAt';
  
  const filter = {
    category: categoryId,
    isActive: true
  };
  
  // √Åp d·ª•ng c√°c filter kh√°c n·∫øu c√≥
  if (req.query.minPrice || req.query.maxPrice) {
    filter.price = {};
    if (req.query.minPrice) filter.price.$gte = parseFloat(req.query.minPrice);
    if (req.query.maxPrice) filter.price.$lte = parseFloat(req.query.maxPrice);
  }
  
  const result = await productRepository.findAll(filter, {
    page,
    limit,
    sort
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

/**
 * T√¨m ki·∫øm s·∫£n ph·∫©m
 */
exports.searchProducts = catchAsync(async (req, res) => {
  const { q } = req.query;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  
  if (!q) {
    return responseHandler.success(res, {
      data: [],
      totalPages: 0,
      currentPage: page,
      totalItems: 0
    });
  }
  
  const result = await productRepository.search(q, {
    page,
    limit
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

--- File: client/src/assets/css/index.css ---
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.content-wrapper {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

--- File: client/src/components/common/Button/Button.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {'primary'|'secondary'|'outline'|'danger'} [props.variant='primary']
 * @param {'sm'|'md'|'lg'} [props.size='md']
 * @param {boolean} [props.isLoading=false]
 * @param {React.ReactNode} [props.leftIcon]
 * @param {React.ReactNode} [props.rightIcon]
 */
const Button = ({
  children,
  variant = 'primary',
  size = 'md',
  isLoading = false,
  leftIcon,
  rightIcon,
  className = '',
  disabled = false,
  ...rest
}) => {
  const baseClasses = 'font-medium rounded focus:outline-none transition-colors';

  const variantClasses = {
    primary: 'bg-blue-600 hover:bg-blue-700 text-white',
    secondary: 'bg-gray-600 hover:bg-gray-700 text-white',
    outline: 'bg-transparent border border-blue-600 text-blue-600 hover:bg-blue-50',
    danger: 'bg-red-600 hover:bg-red-700 text-white',
  };

  const sizeClasses = {
    sm: 'py-1 px-3 text-sm',
    md: 'py-2 px-4 text-base',
    lg: 'py-3 px-5 text-lg',
  };

  const buttonClasses = `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`;

  return (
    <button className={buttonClasses} disabled={isLoading || disabled} {...rest}>
      {isLoading ? (
        <span className="flex items-center justify-center">
          <svg
            className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          ƒêang x·ª≠ l√Ω...
        </span>
      ) : (
        <span className="flex items-center justify-center">
          {leftIcon && <span className="mr-2">{leftIcon}</span>}
          {children}
          {rightIcon && <span className="ml-2">{rightIcon}</span>}
        </span>
      )}
    </button>
  );
};

export default Button;


--- File: client/src/components/common/Button/Button.test.js ---
// src/components/common/Button/Button.test.js
// File test cho component Button trong th∆∞ m·ª•c src/components/common/Button

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

describe('Button component', () => {
  test('renders button with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  describe('variant tests', () => {
    test('applies the correct primary variant class', () => {
      const { container } = render(<Button variant="primary">Primary Button</Button>);
      expect(container.firstChild).toHaveClass('bg-blue-600');
    });

    test('applies the correct secondary variant class', () => {
      const { container } = render(<Button variant="secondary">Secondary Button</Button>);
      expect(container.firstChild).toHaveClass('bg-gray-600');
    });

    test('applies the correct outline variant class', () => {
      const { container } = render(<Button variant="outline">Outline Button</Button>);
      expect(container.firstChild).toHaveClass('bg-transparent');
      expect(container.firstChild).toHaveClass('border-blue-600');
    });

    test('applies the correct danger variant class', () => {
      const { container } = render(<Button variant="danger">Danger Button</Button>);
      expect(container.firstChild).toHaveClass('bg-red-600');
    });
  });

  describe('size tests', () => {
    test('applies the correct small size class', () => {
      const { container } = render(<Button size="sm">Small Button</Button>);
      expect(container.firstChild).toHaveClass('py-1 px-3 text-sm');
    });

    test('applies the correct medium size class', () => {
      const { container } = render(<Button size="md">Medium Button</Button>);
      expect(container.firstChild).toHaveClass('py-2 px-4 text-base');
    });

    test('applies the correct large size class', () => {
      const { container } = render(<Button size="lg">Large Button</Button>);
      expect(container.firstChild).toHaveClass('py-3 px-5 text-lg');
    });
  });

  test('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('is disabled when isLoading is true', () => {
    render(<Button isLoading>Loading</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  test('shows loading spinner when isLoading is true', () => {
    render(<Button isLoading>Loading</Button>);
    // T√¨m SVG loading spinner thay v√¨ s·ª≠ d·ª•ng data-testid
    const loadingSpinner = document.querySelector('svg.animate-spin');
    expect(loadingSpinner).toBeInTheDocument();
  });

  test('renders with left icon when provided', () => {
    const leftIcon = <span>üîç</span>;
    render(<Button leftIcon={leftIcon}>Search</Button>);
    expect(screen.getByText('üîç')).toBeInTheDocument();
  });

  test('renders with right icon when provided', () => {
    const rightIcon = <span>‚Üí</span>;
    render(<Button rightIcon={rightIcon}>Next</Button>);
    expect(screen.getByText('‚Üí')).toBeInTheDocument();
  });

  test('applies custom className when provided', () => {
    const { container } = render(<Button className="custom-class">Custom Button</Button>);
    expect(container.firstChild).toHaveClass('custom-class');
  });

  test('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled Button</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});


--- File: client/src/components/common/Card/Card.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {React.ReactNode} props.children
 * @param {React.ReactNode} [props.header]
 * @param {React.ReactNode} [props.footer]
 * @param {string} [props.className]
 */
const Card = ({ children, header, footer, className = '', ...rest }) => {
  return (
    <div className={`bg-white rounded-lg shadow-md overflow-hidden ${className}`} {...rest}>
      {header && <div className="px-6 py-4 border-b border-gray-200">{header}</div>}
      <div className="p-6">{children}</div>
      {footer && <div className="px-6 py-4 border-t border-gray-200">{footer}</div>}
    </div>
  );
};

export default Card;


--- File: client/src/components/common/Input/Input.js ---
import React, { forwardRef } from 'react';

/**
 * @param {Object} props
 * @param {string} [props.id]
 * @param {string} [props.label]
 * @param {string} [props.error]
 * @param {string} [props.helperText]
 * @param {React.ReactNode} [props.leftIcon]
 * @param {React.ReactNode} [props.rightIcon]
 */
const Input = forwardRef(
  ({ id, label, error, helperText, leftIcon, rightIcon, className = '', ...rest }, ref) => {
    const inputId = id || `input-${Math.random().toString(36).substring(2, 9)}`;

    return (
      <div className="mb-4">
        {label && (
          <label htmlFor={inputId} className="block text-sm font-medium text-gray-700 mb-1">
            {label}
          </label>
        )}

        <div className="relative">
          {leftIcon && (
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              {leftIcon}
            </div>
          )}

          <input
            id={inputId}
            ref={ref}
            className={`
            block w-full rounded-md shadow-sm 
            ${leftIcon ? 'pl-10' : 'pl-3'} 
            ${rightIcon ? 'pr-10' : 'pr-3'} 
            py-2 border 
            ${error ? 'border-red-500 focus:ring-red-500 focus:border-red-500' : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500'} 
            ${className}
          `}
            {...rest}
          />

          {rightIcon && (
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
              {rightIcon}
            </div>
          )}
        </div>

        {error && <p className="mt-1 text-sm text-red-600">{error}</p>}

        {helperText && !error && <p className="mt-1 text-sm text-gray-500">{helperText}</p>}
      </div>
    );
  }
);

Input.displayName = 'Input';

export default Input;


--- File: client/src/components/common/LoadingSpiner/index.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {boolean} [props.fullScreen=false]
 * @param {string} [props.size='md']
 * @param {string} [props.className]
 */
const LoadingSpinner = ({ fullScreen = false, size = 'md', className = '' }) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12',
    xl: 'h-16 w-16',
  };

  const spinnerSize = sizeClasses[size] || sizeClasses.md;

  const spinner = (
    <svg
      className={`animate-spin text-blue-600 ${spinnerSize} ${className}`}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      ></circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
  );

  if (fullScreen) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white bg-opacity-75 z-50">
        {spinner}
      </div>
    );
  }

  return spinner;
};

export default LoadingSpinner;


--- File: client/src/components/common/Modal/index.js ---
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { CSSTransition } from 'react-transition-group';
import { useOutsideClick } from '../../../hooks/useOutsideClick';

const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  size = 'md',
  closeOnOverlayClick = true,
  showCloseButton = true,
  footer = null,
}) => {
  const modalRef = useRef(null);
  const nodeRef = useRef(null);

  // Handle outside click
  useOutsideClick(modalRef, () => {
    if (closeOnOverlayClick) {
      onClose();
    }
  });

  // Handle escape key press
  useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEsc);
      document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
    }

    return () => {
      document.removeEventListener('keydown', handleEsc);
      document.body.style.overflow = ''; // Re-enable scrolling when modal is closed
    };
  }, [isOpen, onClose]);

  // Determine modal width based on size
  const getModalWidth = () => {
    switch (size) {
      case 'sm':
        return 'max-w-md';
      case 'lg':
        return 'max-w-3xl';
      case 'xl':
        return 'max-w-5xl';
      case 'full':
        return 'max-w-full mx-4';
      default:
        return 'max-w-xl';
    }
  };

  return createPortal(
    <CSSTransition
      in={isOpen}
      timeout={300}
      classNames={{
        enter: 'opacity-0',
        enterActive: 'opacity-100 transition-opacity duration-300',
        exit: 'opacity-100',
        exitActive: 'opacity-0 transition-opacity duration-300',
      }}
      unmountOnExit
      nodeRef={nodeRef}
    >
      <div
        ref={nodeRef}
        className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"
      >
        <div
          ref={modalRef}
          className={`bg-white rounded-lg shadow-xl w-full ${getModalWidth()} max-h-[90vh] flex flex-col`}
        >
          {/* Modal header */}
          <div className="px-6 py-4 border-b flex justify-between items-center">
            <h3 className="text-lg font-medium text-gray-900">{title}</h3>
            {showCloseButton && (
              <button type="button" className="text-gray-400 hover:text-gray-500" onClick={onClose}>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  className="h-6 w-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            )}
          </div>

          {/* Modal body */}
          <div className="px-6 py-4 overflow-y-auto flex-1">{children}</div>

          {/* Modal footer */}
          {footer && <div className="px-6 py-4 border-t">{footer}</div>}
        </div>
      </div>
    </CSSTransition>,
    document.body
  );
};

export default Modal;


--- File: client/src/components/common/Pagination/index.js ---
import React from 'react';
import classNames from 'classnames';

const Pagination = ({ currentPage, totalPages, onPageChange, siblingCount = 1 }) => {
  // Generate page numbers
  const getPageNumbers = () => {
    const totalPageNumbers = siblingCount + 5; // Current + first + last + 2 ellipsis + siblings

    // If total pages is less than total page numbers, show all pages
    if (totalPages <= totalPageNumbers) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Calculate left and right bounds
    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);
    const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPages);

    // Show ellipsis
    const shouldShowLeftDots = leftSiblingIndex > 2;
    const shouldShowRightDots = rightSiblingIndex < totalPages - 1;

    // Always show first and last pages
    const firstPageIndex = 1;
    const lastPageIndex = totalPages;

    // Handle edge cases
    if (!shouldShowLeftDots && shouldShowRightDots) {
      // Show more pages on the left
      const leftItemCount = 3 + 2 * siblingCount;
      const leftRange = Array.from({ length: leftItemCount }, (_, i) => i + 1);

      return [...leftRange, '...', lastPageIndex];
    }

    if (shouldShowLeftDots && !shouldShowRightDots) {
      // Show more pages on the right
      const rightItemCount = 3 + 2 * siblingCount;
      const rightRange = Array.from(
        { length: rightItemCount },
        (_, i) => totalPages - rightItemCount + i + 1
      );

      return [firstPageIndex, '...', ...rightRange];
    }

    if (shouldShowLeftDots && shouldShowRightDots) {
      // Show pages around current page with dots on both sides
      const middleRange = Array.from(
        { length: rightSiblingIndex - leftSiblingIndex + 1 },
        (_, i) => leftSiblingIndex + i
      );

      return [firstPageIndex, '...', ...middleRange, '...', lastPageIndex];
    }
  };

  const pageNumbers = getPageNumbers();

  return (
    <div className="flex justify-center mt-8">
      <nav className="inline-flex">
        {/* Previous button */}
        <button
          className={classNames('px-3 py-1 rounded-l-md border border-gray-300', {
            'bg-gray-100 text-gray-500 cursor-not-allowed': currentPage === 1,
            'bg-white hover:bg-gray-50 text-gray-700': currentPage !== 1,
          })}
          onClick={() => currentPage > 1 && onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          Tr∆∞·ªõc
        </button>

        {/* Page numbers */}
        {pageNumbers.map((pageNumber, index) => (
          <button
            key={index}
            className={classNames('px-3 py-1 border-t border-b border-gray-300', {
              'bg-blue-500 text-white': pageNumber === currentPage,
              'bg-white hover:bg-gray-50 text-gray-700':
                pageNumber !== currentPage && pageNumber !== '...',
              'bg-white text-gray-500': pageNumber === '...',
            })}
            onClick={() => pageNumber !== '...' && onPageChange(pageNumber)}
            disabled={pageNumber === '...'}
          >
            {pageNumber}
          </button>
        ))}

        {/* Next button */}
        <button
          className={classNames('px-3 py-1 rounded-r-md border border-gray-300', {
            'bg-gray-100 text-gray-500 cursor-not-allowed': currentPage === totalPages,
            'bg-white hover:bg-gray-50 text-gray-700': currentPage !== totalPages,
          })}
          onClick={() => currentPage < totalPages && onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          Sau
        </button>
      </nav>
    </div>
  );
};

export default Pagination;


--- File: client/src/components/common/Toast/index.js ---
import React, { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import classNames from 'classnames';

// Toast component
const Toast = ({ message, type = 'info', duration = 3000, onClose }) => {
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    if (!duration) return;

    const timer = setTimeout(() => {
      setIsVisible(false);
      setTimeout(onClose, 300); // Wait for animation to complete
    }, duration);

    return () => clearTimeout(timer);
  }, [duration, onClose]);

  // Icon based on type
  const getIcon = () => {
    switch (type) {
      case 'success':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-green-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        );
      case 'error':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-red-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        );
      case 'warning':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-yellow-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
            />
          </svg>
        );
      default:
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-blue-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
        );
    }
  };

  return (
    <div
      className={classNames(
        'fixed top-4 right-4 z-50 flex items-center bg-white rounded-lg shadow-lg border-l-4 p-4 transition-all duration-300',
        {
          'translate-x-0 opacity-100': isVisible,
          'translate-x-full opacity-0': !isVisible,
          'border-green-500': type === 'success',
          'border-red-500': type === 'error',
          'border-yellow-500': type === 'warning',
          'border-blue-500': type === 'info',
        }
      )}
    >
      <div className="mr-3">{getIcon()}</div>
      <div className="flex-1">
        <p className="text-sm text-gray-700">{message}</p>
      </div>
      <button
        className="ml-4 text-gray-400 hover:text-gray-500"
        onClick={() => {
          setIsVisible(false);
          setTimeout(onClose, 300);
        }}
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M6 18L18 6M6 6l12 12"
          />
        </svg>
      </button>
    </div>
  );
};

// ToastContainer component
const ToastContainer = () => {
  const [toasts, setToasts] = useState([]);

  // Add toast
  const addToast = (toast) => {
    const id = Date.now();
    setToasts((prevToasts) => [...prevToasts, { ...toast, id }]);
    return id;
  };

  // Remove toast
  const removeToast = (id) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  };

  // Expose methods globally
  useEffect(() => {
    window.toast = {
      success: (message, duration) => addToast({ message, type: 'success', duration }),
      error: (message, duration) => addToast({ message, type: 'error', duration }),
      warning: (message, duration) => addToast({ message, type: 'warning', duration }),
      info: (message, duration) => addToast({ message, type: 'info', duration }),
    };
  }, []);

  return createPortal(
    <div>
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={() => removeToast(toast.id)}
        />
      ))}
    </div>,
    document.body
  );
};

export default ToastContainer;


--- File: client/src/components/common/Watermark/index.js ---
// client/src/components/common/Watermark/index.js

import React from 'react';

const Watermark = ({ children }) => {
  return (
    <div className="relative">
      {children}
      <div className="absolute bottom-4 right-4 opacity-30 text-gray-500 font-bold rotate-330 select-none pointer-events-none">
        ¬© Steve
      </div>
    </div>
  );
};

export default Watermark;


--- File: client/src/components/feature/Admin/Dashboard/DashboardStats.js ---
// src/components/feature/Admin/Dashboard/DashboardStats.js
// V·ªã tr√≠: Component hi·ªÉn th·ªã c√°c th·ªëng k√™ t·ªïng quan tr√™n Dashboard Admin

import React from 'react';
import { Link } from 'react-router-dom';
import {
  ShoppingBagIcon,
  CurrencyDollarIcon,
  UserGroupIcon,
  ShoppingCartIcon,
  ArrowUpIcon,
  ArrowDownIcon,
} from '@heroicons/react/24/outline';

/**
 * Component hi·ªÉn th·ªã m·ªôt th·∫ª th·ªëng k√™ ƒë∆°n l·∫ª
 */
const StatCard = ({ title, value, icon: Icon, color, bgColor, change, linkTo }) => {
  const isPositive = change >= 0;

  return (
    <Link
      to={linkTo}
      className="bg-white rounded-lg shadow-md p-6 transition-all duration-300 hover:shadow-lg"
    >
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-gray-500 font-medium">{title}</p>
          <p className="text-2xl font-bold mt-1">{value}</p>

          {change !== undefined && (
            <div
              className={`flex items-center mt-2 text-sm ${isPositive ? 'text-green-600' : 'text-red-600'}`}
            >
              {isPositive ? (
                <ArrowUpIcon className="h-4 w-4 mr-1" />
              ) : (
                <ArrowDownIcon className="h-4 w-4 mr-1" />
              )}
              <span>{Math.abs(change)}% so v·ªõi th√°ng tr∆∞·ªõc</span>
            </div>
          )}
        </div>

        <div className={`p-3 rounded-full ${bgColor}`}>
          <Icon className={`h-6 w-6 ${color}`} />
        </div>
      </div>
    </Link>
  );
};

/**
 * Component hi·ªÉn th·ªã t·∫•t c·∫£ c√°c th·ªëng k√™ t·ªïng quan tr√™n Dashboard
 */
const DashboardStats = ({ stats = {} }) => {
  // ƒê·ªãnh nghƒ©a c√°c th·∫ª th·ªëng k√™
  const statsItems = [
    {
      title: 'T·ªïng doanh thu',
      value: new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(
        stats?.totalRevenue || 0
      ),
      icon: CurrencyDollarIcon,
      color: 'text-green-700',
      bgColor: 'bg-green-100',
      change: stats?.revenueChange,
      linkTo: '/admin/orders',
    },
    {
      title: 'ƒê∆°n h√†ng',
      value: stats?.totalOrders || 0,
      icon: ShoppingCartIcon,
      color: 'text-blue-700',
      bgColor: 'bg-blue-100',
      change: stats?.ordersChange,
      linkTo: '/admin/orders',
    },
    {
      title: 'S·∫£n ph·∫©m',
      value: stats?.totalProducts || 0,
      icon: ShoppingBagIcon,
      color: 'text-purple-700',
      bgColor: 'bg-purple-100',
      change: stats?.productsChange,
      linkTo: '/admin/products',
    },
    {
      title: 'Kh√°ch h√†ng',
      value: stats?.totalCustomers || 0,
      icon: UserGroupIcon,
      color: 'text-orange-700',
      bgColor: 'bg-orange-100',
      change: stats?.customersChange,
      linkTo: '/admin/users',
    },
  ];

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-medium text-gray-900">T·ªïng quan</h3>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        {statsItems.map((item, index) => (
          <StatCard
            key={index}
            title={item.title}
            value={item.value}
            icon={item.icon}
            color={item.color}
            bgColor={item.bgColor}
            change={item.change}
            linkTo={item.linkTo}
          />
        ))}
      </div>
    </div>
  );
};

export default DashboardStats;


--- File: client/src/components/feature/Admin/Dashboard/RecentOrders.js ---
// src/components/feature/Admin/Dashboard/RecentOrders.js
// V·ªã tr√≠: Component hi·ªÉn th·ªã danh s√°ch ƒë∆°n h√†ng g·∫ßn ƒë√¢y tr√™n Dashboard Admin

import React from 'react';
import { Link } from 'react-router-dom';
import { formatDate, formatPrice } from '../../../../utils/formatters';
import { Button, LoadingSpinner } from '../../../common';

/**
 * Component hi·ªÉn th·ªã tr·∫°ng th√°i ƒë∆°n h√†ng d∆∞·ªõi d·∫°ng badge
 */
const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Ch·ªù x√°c nh·∫≠n', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'ƒêang x·ª≠ l√Ω', color: 'bg-blue-100 text-blue-800' },
    shipped: { text: 'ƒêang giao h√†ng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'ƒê√£ giao h√†ng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'ƒê√£ h·ªßy', color: 'bg-red-100 text-red-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

/**
 * Component hi·ªÉn th·ªã danh s√°ch ƒë∆°n h√†ng g·∫ßn ƒë√¢y
 */
const RecentOrders = ({ orders = [], isLoading = false, onViewAllClick }) => {
  // X·ª≠ l√Ω s·ª± ki·ªán khi nh·∫•p v√†o n√∫t "Xem t·∫•t c·∫£"
  const handleViewAllClick = (e) => {
    if (onViewAllClick) {
      e.preventDefault();
      onViewAllClick();
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden h-full flex flex-col">
      <div className="p-4 border-b flex justify-between items-center">
        <h2 className="text-lg font-semibold text-gray-900">ƒê∆°n h√†ng g·∫ßn ƒë√¢y</h2>
      </div>

      {isLoading ? (
        <div className="flex-grow flex items-center justify-center p-8">
          <LoadingSpinner size="medium" />
        </div>
      ) : (
        <div className="overflow-x-auto flex-grow">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  M√£ ƒë∆°n h√†ng
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Kh√°ch h√†ng
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Ng√†y ƒë·∫∑t
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  T·ªïng ti·ªÅn
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Tr·∫°ng th√°i
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {orders.length > 0 ? (
                orders.map((order) => (
                  <tr key={order._id || order.id} className="hover:bg-gray-50">
                    <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-blue-600">
                      <Link to={`/admin/orders/${order._id || order.id}`}>{order.orderNumber}</Link>
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                      {order.customerInfo.name}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                      {formatDate(order.createdAt)}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                      {formatPrice(order.totalAmount)}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap">
                      <OrderStatusBadge status={order.status} />
                    </td>
                  </tr>
                ))
              ) : (
                <tr>
                  <td colSpan="5" className="px-4 py-8 text-center text-sm text-gray-500">
                    Kh√¥ng c√≥ ƒë∆°n h√†ng n√†o g·∫ßn ƒë√¢y
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )}

      <div className="p-4 border-t bg-gray-50">
        <Link to="/admin/orders" onClick={handleViewAllClick}>
          <Button variant="secondary" size="sm" fullWidth>
            Xem t·∫•t c·∫£ ƒë∆°n h√†ng
          </Button>
        </Link>
      </div>
    </div>
  );
};

export default RecentOrders;


--- File: client/src/components/feature/Admin/Dashboard/SalesChart.js ---
// src/components/feature/Admin/Dashboard/SalesChart.js
// V·ªã tr√≠: Component bi·ªÉu ƒë·ªì doanh s·ªë b√°n h√†ng tr√™n Dashboard Admin, hi·ªÉn th·ªã doanh thu theo c√°c kho·∫£ng th·ªùi gian kh√°c nhau

import React, { useState, useEffect } from 'react';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from 'recharts';
import { LoadingSpinner, ErrorAlert } from '../../../common';

/**
 * Component hi·ªÉn th·ªã bi·ªÉu ƒë·ªì doanh s·ªë b√°n h√†ng
 * @param {Object} props - Props c·ªßa component
 * @param {Array} props.data - D·ªØ li·ªáu doanh s·ªë
 * @param {string} props.period - Kho·∫£ng th·ªùi gian hi·ªán t·∫°i (today, week, month, year)
 * @param {boolean} props.isLoading - Tr·∫°ng th√°i ƒëang t·∫£i d·ªØ li·ªáu
 * @param {string} props.error - Th√¥ng b√°o l·ªói (n·∫øu c√≥)
 * @param {Function} props.onPeriodChange - H√†m x·ª≠ l√Ω khi thay ƒë·ªïi kho·∫£ng th·ªùi gian
 */
const SalesChart = ({
  data = [],
  period = 'month',
  isLoading = false,
  error = null,
  onPeriodChange = () => {},
}) => {
  // ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn cho tr·ª•c Y
  const formatYAxis = (value) => {
    if (value >= 1000000000) {
      return `${(value / 1000000000).toFixed(1)}B`;
    }
    if (value >= 1000000) {
      return `${(value / 1000000).toFixed(1)}M`;
    }
    if (value >= 1000) {
      return `${(value / 1000).toFixed(0)}K`;
    }
    return value;
  };

  // ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn cho tooltip
  const formatTooltipValue = (value) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      maximumFractionDigits: 0,
    }).format(value);
  };

  // L·∫•y t·ªïng doanh thu t·ª´ d·ªØ li·ªáu
  const totalRevenue = data.reduce((sum, item) => sum + (item.revenue || 0), 0);

  // ƒê·ªãnh d·∫°ng t·ªïng doanh thu
  const formattedTotalRevenue = new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    maximumFractionDigits: 0,
  }).format(totalRevenue);

  // C√°c t√πy ch·ªçn kho·∫£ng th·ªùi gian
  const periodOptions = [
    { value: 'today', label: 'H√¥m nay' },
    { value: 'week', label: 'Tu·∫ßn' },
    { value: 'month', label: 'Th√°ng' },
    { value: 'year', label: 'NƒÉm' },
  ];

  // X·ª≠ l√Ω thay ƒë·ªïi kho·∫£ng th·ªùi gian
  const handlePeriodChange = (newPeriod) => {
    if (period !== newPeriod) {
      onPeriodChange(newPeriod);
    }
  };

  // Hi·ªÉn th·ªã tr·∫°ng th√°i loading
  if (isLoading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6 h-80 flex items-center justify-center">
        <LoadingSpinner size="large" />
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden h-full flex flex-col">
      <div className="p-4 border-b flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h2 className="text-lg font-semibold text-gray-900">Doanh thu</h2>
          <p className="text-sm text-gray-500 mt-1">
            T·ªïng doanh thu: <span className="font-medium">{formattedTotalRevenue}</span>
          </p>
        </div>

        <div className="flex flex-wrap gap-2">
          {periodOptions.map((option) => (
            <button
              key={option.value}
              className={`px-3 py-1 text-sm rounded-md transition-colors ${
                period === option.value
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
              }`}
              onClick={() => handlePeriodChange(option.value)}
            >
              {option.label}
            </button>
          ))}
        </div>
      </div>

      {error ? (
        <div className="p-4 flex-grow">
          <ErrorAlert message={error} />
        </div>
      ) : data.length === 0 ? (
        <div className="p-4 flex-grow flex items-center justify-center">
          <p className="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu doanh thu cho kho·∫£ng th·ªùi gian n√†y</p>
        </div>
      ) : (
        <div className="p-4 h-80 flex-grow">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
              <defs>
                <linearGradient id="colorRevenue" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="#3B82F6" stopOpacity={0} />
                </linearGradient>
                <linearGradient id="colorProfit" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#10B981" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="#10B981" stopOpacity={0} />
                </linearGradient>
              </defs>

              <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f0f0f0" />

              <XAxis
                dataKey="name"
                tickMargin={10}
                axisLine={false}
                tickLine={false}
                tick={{ fill: '#6B7280', fontSize: 12 }}
              />

              <YAxis
                tickFormatter={formatYAxis}
                axisLine={false}
                tickLine={false}
                tickMargin={10}
                tick={{ fill: '#6B7280', fontSize: 12 }}
              />

              <Tooltip
                formatter={(value, name) => {
                  const labels = {
                    revenue: 'Doanh thu',
                    profit: 'L·ª£i nhu·∫≠n',
                  };
                  return [formatTooltipValue(value), labels[name] || name];
                }}
                labelFormatter={(label) => `Th·ªùi gian: ${label}`}
                contentStyle={{
                  backgroundColor: 'rgba(255, 255, 255, 0.9)',
                  border: '1px solid #e2e8f0',
                  borderRadius: '0.375rem',
                  boxShadow: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
                }}
              />

              <Legend
                verticalAlign="top"
                height={36}
                formatter={(value) => {
                  const labels = {
                    revenue: 'Doanh thu',
                    profit: 'L·ª£i nhu·∫≠n',
                  };
                  return labels[value] || value;
                }}
              />

              <Area
                type="monotone"
                dataKey="revenue"
                stroke="#3B82F6"
                strokeWidth={2}
                fillOpacity={1}
                fill="url(#colorRevenue)"
                activeDot={{ r: 6 }}
              />

              {data.some((item) => 'profit' in item) && (
                <Area
                  type="monotone"
                  dataKey="profit"
                  stroke="#10B981"
                  strokeWidth={2}
                  fillOpacity={1}
                  fill="url(#colorProfit)"
                  activeDot={{ r: 6 }}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        </div>
      )}
    </div>
  );
};

export default SalesChart;


--- File: client/src/components/feature/Admin/OrderManager/OrderDetail.js ---
// src/components/feature/Admin/OrderManager/OrderDetail.js
import React from 'react';
import { formatDate, formatPrice } from '../../../../utils/formatters';
import { Button } from '../../../common/Button/Button';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Ch·ªù x√°c nh·∫≠n', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'ƒêang x·ª≠ l√Ω', color: 'bg-blue-100 text-blue-800' },
    packed: { text: 'ƒê√≥ng g√≥i', color: 'bg-indigo-100 text-indigo-800' },
    shipped: { text: 'ƒêang giao h√†ng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'ƒê√£ giao h√†ng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'ƒê√£ h·ªßy', color: 'bg-red-100 text-red-800' },
    returned: { text: 'ƒê√£ tr·∫£ h√†ng', color: 'bg-gray-100 text-gray-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const OrderStatusFlow = ({ currentStatus, onChangeStatus }) => {
  const statuses = [
    { key: 'pending', label: 'Ch·ªù x√°c nh·∫≠n' },
    { key: 'processing', label: 'ƒêang x·ª≠ l√Ω' },
    { key: 'packed', label: 'ƒê√£ ƒë√≥ng g√≥i' },
    { key: 'shipped', label: 'ƒêang giao h√†ng' },
    { key: 'delivered', label: 'ƒê√£ giao h√†ng' },
  ];

  // T√¨m v·ªã tr√≠ status hi·ªán t·∫°i
  const currentIndex = statuses.findIndex((s) => s.key === currentStatus);

  return (
    <div className="my-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-medium text-gray-900">Tr·∫°ng th√°i ƒë∆°n h√†ng</h3>

        {/* N√∫t c·∫≠p nh·∫≠t tr·∫°ng th√°i */}
        {currentStatus !== 'cancelled' &&
          currentStatus !== 'delivered' &&
          currentStatus !== 'returned' && (
            <div className="flex space-x-2">
              <select
                className="block w-40 pl-3 pr-10 py-1.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                defaultValue=""
              >
                <option value="" disabled>
                  C·∫≠p nh·∫≠t tr·∫°ng th√°i
                </option>
                {statuses.map((status, index) => {
                  // Ch·ªâ cho ph√©p ƒë·ªïi sang tr·∫°ng th√°i ti·∫øp theo
                  if (index === currentIndex + 1) {
                    return (
                      <option key={status.key} value={status.key}>
                        {status.label}
                      </option>
                    );
                  }
                  return null;
                })}
                <option value="cancelled">H·ªßy ƒë∆°n h√†ng</option>
              </select>

              <Button size="sm">C·∫≠p nh·∫≠t</Button>
            </div>
          )}
      </div>

      <div className="relative">
        {/* Progress line */}
        <div className="absolute top-4 left-4 right-4 h-0.5 bg-gray-200">
          <div
            className={`h-0.5 bg-blue-500 ${
              currentStatus === 'cancelled' || currentStatus === 'returned'
                ? 'w-0' // Kh√¥ng c√≥ progress n·∫øu ƒë∆°n h√†ng b·ªã h·ªßy ho·∫∑c tr·∫£ l·∫°i
                : `w-${(currentIndex * 100) / (statuses.length - 1)}%`
            }`}
          ></div>
        </div>

        <div className="flex justify-between relative">
          {statuses.map((status, index) => {
            const isCompleted =
              index <= currentIndex &&
              currentStatus !== 'cancelled' &&
              currentStatus !== 'returned';
            const isCurrent = status.key === currentStatus;

            return (
              <div key={status.key} className="flex flex-col items-center z-10">
                <div
                  className={`w-8 h-8 rounded-full flex items-center justify-center ${
                    isCompleted
                      ? 'bg-blue-500 text-white'
                      : currentStatus === 'cancelled' && index === 0
                        ? 'bg-red-500 text-white'
                        : currentStatus === 'returned' && index === statuses.length - 1
                          ? 'bg-gray-500 text-white'
                          : 'bg-gray-200'
                  } ${isCurrent ? 'ring-2 ring-blue-300' : ''}`}
                >
                  {isCompleted ? '‚úì' : index + 1}
                </div>
                <p className={`text-xs mt-2 ${isCompleted ? 'font-medium' : 'text-gray-500'}`}>
                  {status.label}
                </p>
              </div>
            );
          })}
        </div>
      </div>

      {/* Tr·∫°ng th√°i ƒë·∫∑c bi·ªát */}
      {(currentStatus === 'cancelled' || currentStatus === 'returned') && (
        <div
          className={`mt-6 p-4 rounded-md ${
            currentStatus === 'cancelled' ? 'bg-red-50 text-red-800' : 'bg-gray-50 text-gray-800'
          }`}
        >
          <div className="flex">
            <div className="flex-shrink-0">{currentStatus === 'cancelled' ? '‚ö†Ô∏è' : '‚Ü©Ô∏è'}</div>
            <div className="ml-3">
              <h3 className="text-sm font-medium">
                {currentStatus === 'cancelled' ? 'ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy' : 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c tr·∫£ l·∫°i'}
              </h3>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const OrderDetail = ({ order, onChangeStatus }) => {
  return (
    <div className="bg-white shadow-sm rounded-lg divide-y divide-gray-200">
      {/* Header */}
      <div className="px-6 py-4">
        <div className="flex justify-between items-start">
          <div>
            <h2 className="text-lg font-medium text-gray-900">ƒê∆°n h√†ng #{order.orderNumber}</h2>
            <p className="text-sm text-gray-500 mt-1">Ng√†y ƒë·∫∑t: {formatDate(order.createdAt)}</p>
          </div>
          <OrderStatusBadge status={order.status} />
        </div>
      </div>

      {/* Order Status Flow */}
      <div className="px-6 py-4">
        <OrderStatusFlow currentStatus={order.status} onChangeStatus={onChangeStatus} />
      </div>

      {/* Customer & Shipping Info */}
      <div className="px-6 py-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-3">Th√¥ng tin kh√°ch h√†ng</h3>
            <p className="text-sm text-gray-700">{order.customerInfo.name}</p>
            <p className="text-sm text-gray-700">{order.customerInfo.email}</p>
            <p className="text-sm text-gray-700">{order.customerInfo.phone}</p>
          </div>

          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-3">Th√¥ng tin giao h√†ng</h3>
            <p className="text-sm text-gray-700">{order.shippingAddress.name}</p>
            <p className="text-sm text-gray-700">{order.shippingAddress.phone}</p>
            <p className="text-sm text-gray-700">{order.shippingAddress.street}</p>
            <p className="text-sm text-gray-700">
              {order.shippingAddress.city}, {order.shippingAddress.zipCode}
            </p>
            {order.shippingAddress.notes && (
              <p className="text-sm text-gray-700 mt-2">
                <span className="font-medium">Ghi ch√∫:</span> {order.shippingAddress.notes}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* Payment Info */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Th√¥ng tin thanh to√°n</h3>
        <div className="flex items-center">
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              order.paymentStatus === 'paid'
                ? 'bg-green-100 text-green-800'
                : 'bg-yellow-100 text-yellow-800'
            }`}
          >
            {order.paymentStatus === 'paid' ? 'ƒê√£ thanh to√°n' : 'Ch∆∞a thanh to√°n'}
          </span>

          <span className="ml-4 text-sm text-gray-700">
            Ph∆∞∆°ng th·ª©c:{' '}
            {order.paymentMethod === 'cod'
              ? 'Thanh to√°n khi nh·∫≠n h√†ng (COD)'
              : 'Thanh to√°n qua VNPay'}
          </span>
        </div>

        {order.paymentDetails && order.paymentDetails.transactionId && (
          <p className="text-sm text-gray-700 mt-2">
            M√£ giao d·ªãch: {order.paymentDetails.transactionId}
          </p>
        )}
      </div>

      {/* Order Items */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Chi ti·∫øt ƒë∆°n h√†ng</h3>

        <div className="mt-4 border rounded-lg overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  S·∫£n ph·∫©m
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  ƒê∆°n gi√°
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  S·ªë l∆∞·ª£ng
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Th√†nh ti·ªÅn
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {order.items.map((item) => (
                <tr key={item._id || item.product}>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      {item.image && (
                        <div className="flex-shrink-0 h-10 w-10 mr-3">
                          <img
                            className="h-10 w-10 rounded-md object-cover"
                            src={item.image}
                            alt={item.name}
                          />
                        </div>
                      )}
                      <div>
                        <div className="text-sm font-medium text-gray-900">{item.name}</div>
                        {item.sku && <div className="text-sm text-gray-500">SKU: {item.sku}</div>}
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {formatPrice(item.price)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {item.quantity}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {formatPrice(item.price * item.quantity)}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Order Summary */}
      <div className="px-6 py-4">
        <div className="flex flex-col space-y-2 sm:w-64 sm:ml-auto">
          <div className="flex justify-between text-sm">
            <span className="text-gray-600">T·∫°m t√≠nh:</span>
            <span className="font-medium">{formatPrice(order.subtotal)}</span>
          </div>

          {order.discount && order.discount.amount > 0 && (
            <div className="flex justify-between text-sm text-green-600">
              <span>Gi·∫£m gi√°:</span>
              <span>-{formatPrice(order.discount.amount)}</span>
            </div>
          )}

          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Ph√≠ v·∫≠n chuy·ªÉn:</span>
            <span>{formatPrice(order.shippingCost)}</span>
          </div>

          {order.tax > 0 && (
            <div className="flex justify-between text-sm">
              <span className="text-gray-600">Thu·∫ø:</span>
              <span>{formatPrice(order.tax)}</span>
            </div>
          )}

          <div className="flex justify-between text-base font-medium pt-2 border-t mt-2">
            <span>T·ªïng c·ªông:</span>
            <span>{formatPrice(order.totalAmount)}</span>
          </div>
        </div>
      </div>

      {/* Order History */}
      {order.statusHistory && order.statusHistory.length > 0 && (
        <div className="px-6 py-4">
          <h3 className="text-lg font-medium text-gray-900 mb-3">L·ªãch s·ª≠ ƒë∆°n h√†ng</h3>

          <div className="flow-root">
            <ul className="-mb-8">
              {order.statusHistory.map((history, index) => (
                <li key={index}>
                  <div className="relative pb-8">
                    {index !== order.statusHistory.length - 1 ? (
                      <span
                        className="absolute top-4 left-4 -ml-px h-full w-0.5 bg-gray-200"
                        aria-hidden="true"
                      ></span>
                    ) : null}
                    <div className="relative flex space-x-3">
                      <div>
                        <span className="h-8 w-8 rounded-full bg-blue-500 flex items-center justify-center ring-8 ring-white">
                          <svg
                            className="h-4 w-4 text-white"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                            />
                          </svg>
                        </span>
                      </div>
                      <div className="min-w-0 flex-1 pt-1.5 flex justify-between space-x-4">
                        <div>
                          <p className="text-sm text-gray-900">
                            <OrderStatusBadge status={history.status} />
                            {history.note && <span className="ml-2">{history.note}</span>}
                          </p>
                        </div>
                        <div className="text-sm text-gray-500 whitespace-nowrap">
                          {formatDate(history.date)}
                        </div>
                      </div>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          </div>
        </div>
      )}

      {/* Admin Notes */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Ghi ch√∫ qu·∫£n tr·ªã</h3>

        <div className="mt-1">
          <textarea
            rows={3}
            className="shadow-sm block w-full sm:text-sm border-gray-300 rounded-md"
            placeholder="Th√™m ghi ch√∫ v·ªÅ ƒë∆°n h√†ng n√†y..."
            defaultValue={order.adminNotes || ''}
          />
        </div>

        <div className="mt-2 flex justify-end">
          <Button size="sm">L∆∞u ghi ch√∫</Button>
        </div>
      </div>
    </div>
  );
};

export default OrderDetail;


--- File: client/src/components/feature/Admin/OrderManager/OrderTable.js ---
// src/components/feature/Admin/OrderManager/OrderTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatDate, formatPrice } from '../../../../utils/formatters';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Ch·ªù x√°c nh·∫≠n', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'ƒêang x·ª≠ l√Ω', color: 'bg-blue-100 text-blue-800' },
    packed: { text: 'ƒê√≥ng g√≥i', color: 'bg-indigo-100 text-indigo-800' },
    shipped: { text: 'ƒêang giao h√†ng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'ƒê√£ giao h√†ng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'ƒê√£ h·ªßy', color: 'bg-red-100 text-red-800' },
    returned: { text: 'ƒê√£ tr·∫£ h√†ng', color: 'bg-gray-100 text-gray-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const PaymentStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Ch·ªù thanh to√°n', color: 'bg-yellow-100 text-yellow-800' },
    authorized: { text: 'ƒê√£ ·ªßy quy·ªÅn', color: 'bg-blue-100 text-blue-800' },
    paid: { text: 'ƒê√£ thanh to√°n', color: 'bg-green-100 text-green-800' },
    failed: { text: 'Th·∫•t b·∫°i', color: 'bg-red-100 text-red-800' },
    refunded: { text: 'ƒê√£ ho√†n ti·ªÅn', color: 'bg-gray-100 text-gray-800' },
    partially_refunded: { text: 'Ho√†n ti·ªÅn m·ªôt ph·∫ßn', color: 'bg-orange-100 text-orange-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const OrderTable = ({ orders, onChangeStatus }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const ordersPerPage = 10;

  // Ph√¢n trang
  const indexOfLastOrder = currentPage * ordersPerPage;
  const indexOfFirstOrder = indexOfLastOrder - ordersPerPage;
  const currentOrders = orders.slice(indexOfFirstOrder, indexOfLastOrder);
  const totalPages = Math.ceil(orders.length / ordersPerPage);

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      M√£ ƒë∆°n h√†ng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Kh√°ch h√†ng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Ng√†y ƒë·∫∑t
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      T·ªïng ti·ªÅn
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Tr·∫°ng th√°i ƒë∆°n h√†ng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Thanh to√°n
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">Chi ti·∫øt</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentOrders.map((order) => (
                    <tr key={order._id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {order.orderNumber}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <div>{order.customerInfo.name}</div>
                        <div className="text-xs">{order.customerInfo.email}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatDate(order.createdAt)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatPrice(order.totalAmount)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <OrderStatusBadge status={order.status} />
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <PaymentStatusBadge status={order.paymentStatus} />
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/orders/${order._id}`}
                          className="text-blue-600 hover:text-blue-900"
                        >
                          Chi ti·∫øt
                        </Link>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hi·ªÉn th·ªã <span className="font-medium">{indexOfFirstOrder + 1}</span> ƒë·∫øn{' '}
              <span className="font-medium">{Math.min(indexOfLastOrder, orders.length)}</span> c·ªßa{' '}
              <span className="font-medium">{orders.length}</span> ƒë∆°n h√†ng
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default OrderTable;


--- File: client/src/components/feature/Admin/ProductManager/ProductForm.js ---
// src/components/feature/Admin/ProductManager/ProductForm.js
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Button } from '../../../common/Button/Button';
import { Input } from '../../../common/Input/Input';

const schema = yup.object({
  name: yup.string().required('T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
  description: yup.object({
    short: yup.string().required('M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
    long: yup.string().required('M√¥ t·∫£ chi ti·∫øt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
  }),
  category: yup.string().required('Danh m·ª•c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
  brand: yup.string().required('Th∆∞∆°ng hi·ªáu kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
  price: yup.number().required('Gi√° kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng').min(0, 'Gi√° kh√¥ng ƒë∆∞·ª£c √¢m'),
  stock: yup.number().required('S·ªë l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng').min(0, 'S·ªë l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c √¢m'),
  sku: yup.string(),
  features: yup.array().of(yup.string()),
  specifications: yup.object(),
});

const ProductForm = ({ product, categories, onSubmit, isSubmitting }) => {
  const [features, setFeatures] = useState(product?.features || ['']);
  const [imageUrls, setImageUrls] = useState(product?.images?.map((img) => img.url) || ['']);
  const [specificationFields, setSpecificationFields] = useState(
    product?.specifications
      ? Object.entries(product.specifications).map(([key, value]) => ({ key, value }))
      : [{ key: '', value: '' }]
  );

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      name: product?.name || '',
      description: {
        short: product?.description?.short || '',
        long: product?.description?.long || '',
      },
      category: product?.category || '',
      brand: product?.brand || '',
      price: product?.price || 0,
      salePrice: product?.salePrice || 0,
      stock: product?.stock || 0,
      sku: product?.sku || '',
      isActive: product?.isActive ?? true,
      isPromoted: product?.isPromoted ?? false,
      isFeatured: product?.isFeatured ?? false,
      features: product?.features || [''],
      specifications: product?.specifications || {},
    },
  });

  // C·∫≠p nh·∫≠t features v√† specifications v√†o form data
  useEffect(() => {
    setValue('features', features.filter(Boolean));

    const specsObject = {};
    specificationFields.forEach((field) => {
      if (field.key && field.value) {
        specsObject[field.key] = field.value;
      }
    });
    setValue('specifications', specsObject);
  }, [features, specificationFields, setValue]);

  // X·ª≠ l√Ω th√™m/x√≥a feature
  const handleAddFeature = () => {
    setFeatures([...features, '']);
  };

  const handleRemoveFeature = (index) => {
    const newFeatures = [...features];
    newFeatures.splice(index, 1);
    setFeatures(newFeatures);
  };

  const handleFeatureChange = (index, value) => {
    const newFeatures = [...features];
    newFeatures[index] = value;
    setFeatures(newFeatures);
  };

  // X·ª≠ l√Ω th√™m/x√≥a specification
  const handleAddSpecification = () => {
    setSpecificationFields([...specificationFields, { key: '', value: '' }]);
  };

  const handleRemoveSpecification = (index) => {
    const newFields = [...specificationFields];
    newFields.splice(index, 1);
    setSpecificationFields(newFields);
  };

  const handleSpecificationChange = (index, field, value) => {
    const newFields = [...specificationFields];
    newFields[index][field] = value;
    setSpecificationFields(newFields);
  };

  // X·ª≠ l√Ω th√™m/x√≥a h√¨nh ·∫£nh
  const handleAddImage = () => {
    setImageUrls([...imageUrls, '']);
  };

  const handleRemoveImage = (index) => {
    const newUrls = [...imageUrls];
    newUrls.splice(index, 1);
    setImageUrls(newUrls);
  };

  const handleImageChange = (index, value) => {
    const newUrls = [...imageUrls];
    newUrls[index] = value;
    setImageUrls(newUrls);
  };

  // X·ª≠ l√Ω submit form
  const onFormSubmit = (data) => {
    // Th√™m h√¨nh ·∫£nh v√†o data
    const images = imageUrls.filter(Boolean).map((url, index) => ({
      url,
      alt: `${data.name} - H√¨nh ${index + 1}`,
      isPrimary: index === 0,
    }));

    // Submit with images
    onSubmit({ ...data, images });
  };

  return (
    <form onSubmit={handleSubmit(onFormSubmit)} className="space-y-8">
      {/* Th√¥ng tin c∆° b·∫£n */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Th√¥ng tin c∆° b·∫£n</h3>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="md:col-span-2">
            <Input
              label="T√™n s·∫£n ph·∫©m"
              {...register('name')}
              error={errors.name?.message}
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Danh m·ª•c <span className="text-red-500">*</span>
            </label>
            <select
              {...register('category')}
              className={`mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md ${
                errors.category ? 'border-red-300' : ''
              }`}
            >
              <option value="">Ch·ªçn danh m·ª•c</option>
              {categories.map((category) => (
                <option key={category._id} value={category._id}>
                  {category.name}
                </option>
              ))}
            </select>
            {errors.category && (
              <p className="mt-1 text-sm text-red-600">{errors.category.message}</p>
            )}
          </div>

          <div>
            <Input
              label="Th∆∞∆°ng hi·ªáu"
              {...register('brand')}
              error={errors.brand?.message}
              required
            />
          </div>

          <div>
            <Input
              label="Gi√° (VND)"
              type="number"
              {...register('price')}
              error={errors.price?.message}
              required
            />
          </div>

          <div>
            <Input
              label="Gi√° khuy·∫øn m√£i (VND)"
              type="number"
              {...register('salePrice')}
              error={errors.salePrice?.message}
            />
          </div>

          <div>
            <Input
              label="S·ªë l∆∞·ª£ng t·ªìn kho"
              type="number"
              {...register('stock')}
              error={errors.stock?.message}
              required
            />
          </div>

          <div>
            <Input label="SKU" {...register('sku')} error={errors.sku?.message} />
          </div>

          <div className="md:col-span-2">
            <Input
              label="M√¥ t·∫£ ng·∫Øn"
              {...register('description.short')}
              error={errors.description?.short?.message}
              required
              multiline
              rows={2}
            />
          </div>

          <div className="md:col-span-2">
            <Input
              label="M√¥ t·∫£ chi ti·∫øt"
              {...register('description.long')}
              error={errors.description?.long?.message}
              required
              multiline
              rows={6}
            />
          </div>
        </div>

        <div className="mt-6 space-y-4">
          <div className="flex items-center">
            <input
              type="checkbox"
              id="isActive"
              {...register('isActive')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isActive" className="ml-2 block text-sm text-gray-900">
              S·∫£n ph·∫©m ƒëang b√°n
            </label>
          </div>

          <div className="flex items-center">
            <input
              type="checkbox"
              id="isPromoted"
              {...register('isPromoted')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isPromoted" className="ml-2 block text-sm text-gray-900">
              S·∫£n ph·∫©m ƒë∆∞·ª£c qu·∫£ng b√°
            </label>
          </div>

          <div className="flex items-center">
            <input
              type="checkbox"
              id="isFeatured"
              {...register('isFeatured')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isFeatured" className="ml-2 block text-sm text-gray-900">
              S·∫£n ph·∫©m n·ªïi b·∫≠t
            </label>
          </div>
        </div>
      </div>

      {/* T√≠nh nƒÉng s·∫£n ph·∫©m */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">T√≠nh nƒÉng s·∫£n ph·∫©m</h3>

        <div className="space-y-4">
          {features.map((feature, index) => (
            <div key={index} className="flex items-center space-x-2">
              <Input
                placeholder={`T√≠nh nƒÉng ${index + 1}`}
                value={feature}
                onChange={(e) => handleFeatureChange(index, e.target.value)}
                className="flex-1"
              />

              <button
                type="button"
                onClick={() => handleRemoveFeature(index)}
                className="text-red-500 hover:text-red-700"
              >
                X√≥a
              </button>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddFeature}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Th√™m t√≠nh nƒÉng
          </button>
        </div>
      </div>

      {/* Th√¥ng s·ªë k·ªπ thu·∫≠t */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Th√¥ng s·ªë k·ªπ thu·∫≠t</h3>

        <div className="space-y-4">
          {specificationFields.map((field, index) => (
            <div key={index} className="grid grid-cols-2 gap-4">
              <Input
                placeholder="T√™n th√¥ng s·ªë"
                value={field.key}
                onChange={(e) => handleSpecificationChange(index, 'key', e.target.value)}
              />

              <div className="flex items-center space-x-2">
                <Input
                  placeholder="Gi√° tr·ªã"
                  value={field.value}
                  onChange={(e) => handleSpecificationChange(index, 'value', e.target.value)}
                  className="flex-1"
                />

                <button
                  type="button"
                  onClick={() => handleRemoveSpecification(index)}
                  className="text-red-500 hover:text-red-700"
                >
                  X√≥a
                </button>
              </div>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddSpecification}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Th√™m th√¥ng s·ªë
          </button>
        </div>
      </div>

      {/* H√¨nh ·∫£nh s·∫£n ph·∫©m */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">H√¨nh ·∫£nh s·∫£n ph·∫©m</h3>

        <div className="space-y-4">
          {imageUrls.map((url, index) => (
            <div key={index} className="flex items-center space-x-2">
              <Input
                placeholder="URL h√¨nh ·∫£nh"
                value={url}
                onChange={(e) => handleImageChange(index, e.target.value)}
                className="flex-1"
              />

              <button
                type="button"
                onClick={() => handleRemoveImage(index)}
                className="text-red-500 hover:text-red-700"
              >
                X√≥a
              </button>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddImage}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Th√™m h√¨nh ·∫£nh
          </button>
        </div>
      </div>

      {/* Submit button */}
      <div className="flex justify-end space-x-3">
        <Button type="button" variant="outline" onClick={() => window.history.back()}>
          H·ªßy
        </Button>
        <Button type="submit" isLoading={isSubmitting}>
          {product ? 'C·∫≠p nh·∫≠t s·∫£n ph·∫©m' : 'Th√™m s·∫£n ph·∫©m'}
        </Button>
      </div>
    </form>
  );
};

export default ProductForm;


--- File: client/src/components/feature/Admin/ProductManager/ProductTable.js ---
// src/components/feature/Admin/ProductManager/ProductTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatPrice } from '../../../../utils/formatters';

const ProductTable = ({ products, onDelete }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const productsPerPage = 10;

  // Ph√¢n trang
  const indexOfLastProduct = currentPage * productsPerPage;
  const indexOfFirstProduct = indexOfLastProduct - productsPerPage;
  const currentProducts = products.slice(indexOfFirstProduct, indexOfLastProduct);
  const totalPages = Math.ceil(products.length / productsPerPage);

  // X·ª≠ l√Ω x√≥a s·∫£n ph·∫©m
  const handleDelete = (productId) => {
    if (window.confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s·∫£n ph·∫©m n√†y?')) {
      onDelete(productId);
    }
  };

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      S·∫£n ph·∫©m
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Danh m·ª•c
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Gi√°
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      T·ªìn kho
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Tr·∫°ng th√°i
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">H√†nh ƒë·ªông</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentProducts.map((product) => (
                    <tr key={product._id}>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <div className="flex-shrink-0 h-10 w-10">
                            <img
                              className="h-10 w-10 rounded-md object-cover"
                              src={product.images[0] || '/placeholder.jpg'}
                              alt={product.name}
                            />
                          </div>
                          <div className="ml-4">
                            <div className="text-sm font-medium text-gray-900">{product.name}</div>
                            <div className="text-sm text-gray-500">SKU: {product.sku || 'N/A'}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{product.category.name}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{formatPrice(product.price)}</div>
                        {product.salePrice && (
                          <div className="text-xs text-gray-500 line-through">
                            {formatPrice(product.salePrice)}
                          </div>
                        )}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{product.stock}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            product.isActive
                              ? 'bg-green-100 text-green-800'
                              : 'bg-red-100 text-red-800'
                          }`}
                        >
                          {product.isActive ? 'ƒêang b√°n' : 'Ng·ª´ng b√°n'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/products/edit/${product._id}`}
                          className="text-blue-600 hover:text-blue-900 mr-4"
                        >
                          S·ª≠a
                        </Link>
                        <button
                          onClick={() => handleDelete(product._id)}
                          className="text-red-600 hover:text-red-900"
                        >
                          X√≥a
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hi·ªÉn th·ªã <span className="font-medium">{indexOfFirstProduct + 1}</span> ƒë·∫øn{' '}
              <span className="font-medium">{Math.min(indexOfLastProduct, products.length)}</span>{' '}
              c·ªßa <span className="font-medium">{products.length}</span> s·∫£n ph·∫©m
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default ProductTable;


--- File: client/src/components/feature/Admin/UserManager/UserTable.js ---
// src/components/feature/Admin/UserManager/UserTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatDate } from '../../../../utils/formatters';

const UserTable = ({ users, onChangeStatus }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const usersPerPage = 10;

  // Ph√¢n trang
  const indexOfLastUser = currentPage * usersPerPage;
  const indexOfFirstUser = indexOfLastUser - usersPerPage;
  const currentUsers = users.slice(indexOfFirstUser, indexOfLastUser);
  const totalPages = Math.ceil(users.length / usersPerPage);

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Ng∆∞·ªùi d√πng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Vai tr√≤
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Tr·∫°ng th√°i
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Ng√†y ƒëƒÉng k√Ω
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      ƒê∆°n h√†ng
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">H√†nh ƒë·ªông</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentUsers.map((user) => (
                    <tr key={user._id}>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <div className="flex-shrink-0 h-10 w-10">
                            {user.avatar ? (
                              <img
                                className="h-10 w-10 rounded-full"
                                src={user.avatar}
                                alt={user.name}
                              />
                            ) : (
                              <div className="h-10 w-10 rounded-full bg-blue-500 flex items-center justify-center text-white font-semibold">
                                {user.name.charAt(0).toUpperCase()}
                              </div>
                            )}
                          </div>
                          <div className="ml-4">
                            <div className="text-sm font-medium text-gray-900">{user.name}</div>
                            <div className="text-sm text-gray-500">{user.email}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            user.role === 'admin'
                              ? 'bg-purple-100 text-purple-800'
                              : user.role === 'staff'
                                ? 'bg-blue-100 text-blue-800'
                                : 'bg-green-100 text-green-800'
                          }`}
                        >
                          {user.role === 'admin'
                            ? 'Admin'
                            : user.role === 'staff'
                              ? 'Nh√¢n vi√™n'
                              : 'Ng∆∞·ªùi d√πng'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            user.isActive
                              ? 'bg-green-100 text-green-800'
                              : 'bg-red-100 text-red-800'
                          }`}
                        >
                          {user.isActive ? 'Ho·∫°t ƒë·ªông' : 'ƒê√£ kh√≥a'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatDate(user.createdAt)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {user.orderCount || 0}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/users/${user._id}`}
                          className="text-blue-600 hover:text-blue-900 mr-4"
                        >
                          Chi ti·∫øt
                        </Link>
                        <button
                          onClick={() => onChangeStatus(user._id, !user.isActive)}
                          className={`${
                            user.isActive
                              ? 'text-red-600 hover:text-red-900'
                              : 'text-green-600 hover:text-green-900'
                          }`}
                        >
                          {user.isActive ? 'Kh√≥a' : 'K√≠ch ho·∫°t'}
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hi·ªÉn th·ªã <span className="font-medium">{indexOfFirstUser + 1}</span> ƒë·∫øn{' '}
              <span className="font-medium">{Math.min(indexOfLastUser, users.length)}</span> c·ªßa{' '}
              <span className="font-medium">{users.length}</span> ng∆∞·ªùi d√πng
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default UserTable;


--- File: client/src/components/feature/Cart/AddToCart.js ---
// src/components/feature/Cart/AddToCart.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { addToCart } from '../../../store/slices/cartSlice';
import { Button } from '../../common/Button/Button';

const AddToCart = ({ product }) => {
  const dispatch = useDispatch();
  const [quantity, setQuantity] = useState(1);
  const { loading } = useSelector((state) => state.cart);

  const handleQuantityChange = (newQuantity) => {
    if (newQuantity < 1 || newQuantity > product.stock) return;
    setQuantity(newQuantity);
  };

  const handleAddToCart = () => {
    dispatch(
      addToCart({
        productId: product._id,
        quantity,
      })
    );
  };

  if (product.stock < 1) {
    return (
      <div className="mt-6">
        <p className="text-red-500 mb-2">H·∫øt h√†ng</p>
        <Button variant="outline" disabled className="w-full">
          H·∫øt h√†ng
        </Button>
      </div>
    );
  }

  return (
    <div className="mt-6">
      <div className="flex items-center mb-4">
        <span className="mr-3">S·ªë l∆∞·ª£ng:</span>
        <div className="flex items-center border rounded">
          <button
            className="px-3 py-1 text-gray-500"
            onClick={() => handleQuantityChange(quantity - 1)}
            disabled={quantity <= 1}
          >
            -
          </button>
          <span className="px-4 py-1">{quantity}</span>
          <button
            className="px-3 py-1 text-gray-500"
            onClick={() => handleQuantityChange(quantity + 1)}
            disabled={quantity >= product.stock}
          >
            +
          </button>
        </div>
        <span className="ml-3 text-sm text-gray-500">{product.stock} s·∫£n ph·∫©m c√≥ s·∫µn</span>
      </div>

      <Button onClick={handleAddToCart} isLoading={loading} className="w-full">
        Th√™m v√†o gi·ªè h√†ng
      </Button>
    </div>
  );
};

export default AddToCart;


--- File: client/src/components/feature/Cart/CartItem.js ---
// src/components/feature/Cart/CartItem.js
import React from 'react';
import { useDispatch } from 'react-redux';
import { updateCartItem, removeFromCart } from '../../../store/slices/cartSlice';
import { Button } from '../../common/Button/Button';
import { formatPrice } from '../../../utils/formatters';

const CartItem = ({ item }) => {
  const dispatch = useDispatch();

  const handleQuantityChange = (newQuantity) => {
    if (newQuantity < 1) return;
    dispatch(
      updateCartItem({
        productId: item.product._id,
        quantity: newQuantity,
      })
    );
  };

  const handleRemove = () => {
    dispatch(removeFromCart(item.product._id));
  };

  return (
    <div className="flex items-center justify-between p-4 border-b">
      <div className="flex items-center space-x-4">
        <img
          src={item.product.images[0] || '/assets/placeholder.jpg'}
          alt={item.product.name}
          className="w-16 h-16 object-cover"
        />

        <div>
          <h3 className="font-medium">{item.product.name}</h3>
          <p className="text-gray-500 text-sm">{formatPrice(item.price)}</p>
        </div>
      </div>

      <div className="flex items-center space-x-4">
        <div className="flex items-center border rounded">
          <button
            className="px-2 py-1 text-gray-500"
            onClick={() => handleQuantityChange(item.quantity - 1)}
          >
            -
          </button>
          <span className="px-3 py-1">{item.quantity}</span>
          <button
            className="px-2 py-1 text-gray-500"
            onClick={() => handleQuantityChange(item.quantity + 1)}
          >
            +
          </button>
        </div>

        <div className="text-right">
          <p className="font-bold">{formatPrice(item.price * item.quantity)}</p>
        </div>

        <Button onClick={handleRemove} variant="outline" size="sm">
          X√≥a
        </Button>
      </div>
    </div>
  );
};

export default CartItem;


--- File: client/src/components/feature/Cart/CartList.js ---
// src/components/feature/Cart/CartList.js
import React from 'react';
import { useSelector } from 'react-redux';
import CartItem from './CartItem';
import { Empty } from '../../common/Empty';

const CartList = () => {
  const { items } = useSelector((state) => state.cart);

  if (!items.length) {
    return <Empty message="Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng" />;
  }

  return (
    <div className="rounded-lg border bg-white">
      <div className="p-4 border-b bg-gray-50">
        <h2 className="font-semibold">Gi·ªè h√†ng c·ªßa b·∫°n</h2>
      </div>
      <div>
        {items.map((item) => (
          <CartItem key={item.product._id} item={item} />
        ))}
      </div>
    </div>
  );
};

export default CartList;


--- File: client/src/components/feature/Cart/CartSummary.js ---
// src/components/feature/Cart/CartSummary.js
import React from 'react';
import { useSelector } from 'react-redux';
import { Link } from 'react-router-dom';
import { Button } from '../../common/Button/Button';
import { formatPrice } from '../../../utils/formatters';

const CartSummary = () => {
  const { items, subtotal, discount } = useSelector((state) => state.cart);
  const totalItems = items.reduce((acc, item) => acc + item.quantity, 0);
  const total = subtotal - (discount || 0);

  return (
    <div className="rounded-lg border bg-white p-4">
      <h2 className="font-semibold mb-4">T·ªïng ƒë∆°n h√†ng</h2>

      <div className="space-y-2 border-b pb-3 mb-3">
        <div className="flex justify-between">
          <span className="text-gray-600">S·ªë l∆∞·ª£ng s·∫£n ph·∫©m:</span>
          <span>{totalItems}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">T·∫°m t√≠nh:</span>
          <span>{formatPrice(subtotal)}</span>
        </div>
        {discount > 0 && (
          <div className="flex justify-between text-green-600">
            <span>Gi·∫£m gi√°:</span>
            <span>-{formatPrice(discount)}</span>
          </div>
        )}
      </div>

      <div className="flex justify-between font-bold mb-6">
        <span>T·ªïng c·ªông:</span>
        <span>{formatPrice(total)}</span>
      </div>

      <Link to="/checkout">
        <Button className="w-full">Ti·∫øn h√†nh thanh to√°n</Button>
      </Link>
    </div>
  );
};

export default CartSummary;


--- File: client/src/components/feature/Category/CategoryBreadcrumb.js ---
// client/src/components/feature/Category/CategoryBreadcrumb.js

import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { fetchCategoryById } from '../../../store/slices/categorySlice';
import { PATHS } from '../../../routes/paths';

const CategoryBreadcrumb = ({ categoryId }) => {
  const dispatch = useDispatch();
  const { categories } = useSelector(state => state.categories);
  const [breadcrumbs, setBreadcrumbs] = useState([]);
  
  useEffect(() => {
    if (categoryId) {
      dispatch(fetchCategoryById(categoryId));
    }
  }, [dispatch, categoryId]);
  
  useEffect(() => {
    if (categoryId && categories[categoryId]) {
      const category = categories[categoryId];
      
      // T·∫°o breadcrumb t·ª´ ancestors
      const breadcrumbItems = [
        { name: 'Trang Ch·ªß', path: PATHS.HOME },
        { name: 'S·∫£n Ph·∫©m', path: PATHS.PRODUCTS }
      ];
      
      // Th√™m ancestors n·∫øu c√≥
      if (category.ancestors && category.ancestors.length > 0) {
        category.ancestors.forEach(ancestor => {
          breadcrumbItems.push({
            name: ancestor.name,
            path: `${PATHS.PRODUCTS}?category=${ancestor._id}`
          });
        });
      }
      
      // Th√™m category hi·ªán t·∫°i
      breadcrumbItems.push({
        name: category.name,
        path: `${PATHS.PRODUCTS}?category=${category._id}`,
        active: true
      });
      
      setBreadcrumbs(breadcrumbItems);
    } else {
      // Default breadcrumb n·∫øu kh√¥ng c√≥ category
      setBreadcrumbs([
        { name: 'Trang Ch·ªß', path: PATHS.HOME },
        { name: 'S·∫£n Ph·∫©m', path: PATHS.PRODUCTS, active: true }
      ]);
    }
  }, [categoryId, categories]);
  
  return (
    <nav className="flex py-3 px-5 text-gray-700 bg-gray-50 rounded-lg mb-6" aria-label="Breadcrumb">
      <ol className="inline-flex items-center space-x-1 md:space-x-3">
        {breadcrumbs.map((item, index) => (
          <li key={index} className="inline-flex items-center">
            {index > 0 && (
              <svg className="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd"></path>
              </svg>
            )}
            
            {item.active ? (
              <span className="ml-1 md:ml-2 text-sm font-medium text-gray-500">
                {item.name}
              </span>
            ) : (
              <Link
                to={item.path}
                className={`ml-1 md:ml-2 text-sm font-medium text-blue-600 hover:text-blue-800 ${index === 0 ? '' : 'ml-2'}`}
              >
                {item.name}
              </Link>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
};

export default CategoryBreadcrumb;

--- File: client/src/components/feature/Product/ProductCard.js ---
// src/components/feature/Product/ProductCard.js
// Component hi·ªÉn th·ªã th√¥ng tin s·∫£n ph·∫©m trong trang danh s√°ch s·∫£n ph·∫©m

import React from 'react';
import { Link } from 'react-router-dom';
import Button from '../../../components/common/Button/Button';
import Card from '../../../components/common/Card/Card';
import { formatPrice } from '../../../utils/formatters';
import { useDispatch } from 'react-redux';
import { addToCart } from '../../../store/slices/cartSlice';

const ProductCard = ({ product }) => {
  const dispatch = useDispatch();

  const handleAddToCart = () => {
    dispatch(
      addToCart({
        productId: product.id,
        quantity: 1,
      })
    );
  };

  return (
    <Card className="product-card">
      <Link to={`/products/${product.id}`} className="block relative">
        <img
          src={product.images[0]?.url || '/placeholder.png'}
          alt={product.name}
          className="w-full h-48 object-cover rounded-t-lg"
        />
        {product.isPromoted && (
          <span className="absolute top-2 right-2 bg-red-500 text-white px-2 py-1 text-xs font-bold rounded">
            Khuy·∫øn m√£i
          </span>
        )}
      </Link>
      <div className="p-4">
        <h3 className="text-lg font-semibold mb-1">{product.name}</h3>
        <p className="text-gray-600 text-sm mb-2">{product.brand}</p>
        <p className="text-gray-800 font-bold mb-3">{formatPrice(product.price)}</p>
        <Button variant="primary" size="sm" onClick={handleAddToCart} className="w-full">
          Th√™m v√†o gi·ªè h√†ng
        </Button>
      </div>
    </Card>
  );
};

// S·ª≠ d·ª•ng React.memo ƒë·ªÉ tr√°nh re-render kh√¥ng c·∫ßn thi·∫øt
export default React.memo(ProductCard);


--- File: client/src/components/feature/Product/ProductFilter.js ---
// client/src/components/feature/Product/ProductFilter.js

import React, { useState } from 'react';
import { useDebounce } from '../../../hooks/useDebounce';

const ProductFilter = ({ onFilterChange }) => {
  const [filters, setFilters] = useState({
    minPrice: '',
    maxPrice: '',
    brand: '',
    inStock: false,
  });

  const debouncedFilters = useDebounce(filters, 500);

  // G·ªçi onFilterChange khi filters thay ƒë·ªïi
  React.useEffect(() => {
    onFilterChange(debouncedFilters);
  }, [debouncedFilters, onFilterChange]);

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFilters((prev) => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value,
    }));
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow mb-6">
      <h3 className="text-lg font-bold mb-4">L·ªçc S·∫£n Ph·∫©m</h3>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Kho·∫£ng Gi√°</label>
        <div className="flex space-x-2">
          <input
            type="number"
            name="minPrice"
            placeholder="T·ª´"
            value={filters.minPrice}
            onChange={handleChange}
            className="w-1/2 p-2 border rounded"
          />
          <input
            type="number"
            name="maxPrice"
            placeholder="ƒê·∫øn"
            value={filters.maxPrice}
            onChange={handleChange}
            className="w-1/2 p-2 border rounded"
          />
        </div>
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Th∆∞∆°ng Hi·ªáu</label>
        <select
          name="brand"
          value={filters.brand}
          onChange={handleChange}
          className="w-full p-2 border rounded"
        >
          <option value="">T·∫•t c·∫£</option>
          <option value="ProCue">ProCue</option>
          <option value="StarterCue">StarterCue</option>
          <option value="MasterBall">MasterBall</option>
        </select>
      </div>

      <div className="mb-4">
        <label className="flex items-center">
          <input
            type="checkbox"
            name="inStock"
            checked={filters.inStock}
            onChange={handleChange}
            className="mr-2"
          />
          <span className="text-sm">Ch·ªâ hi·ªÉn th·ªã s·∫£n ph·∫©m c√≤n h√†ng</span>
        </label>
      </div>
    </div>
  );
};

export default ProductFilter;


--- File: client/src/components/feature/Product/ProductList.js ---
// client/src/components/feature/Product/ProductList.js

import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchProducts } from '../../../store/slices/productSlice';
import { addToCart } from '../../../store/slices/cartSlice';
import ProductCard from './ProductCard';
import { LoadingSpinner } from '../../../components/common';

const ProductList = ({ categoryId, filters = {} }) => {
  const dispatch = useDispatch();
  const { products, loading, error } = useSelector((state) => state.products);
  const [filteredProducts, setFilteredProducts] = useState([]);

  useEffect(() => {
    dispatch(fetchProducts({ categoryId, ...filters }));
  }, [dispatch, categoryId, filters]);

  useEffect(() => {
    setFilteredProducts(products);
  }, [products]);

  const handleAddToCart = (productId) => {
    dispatch(addToCart({ productId, quantity: 1 }));
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <div className="text-red-500">Error: {error}</div>;
  }

  if (!filteredProducts.length) {
    return <div className="text-center py-8">Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p.</div>;
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {filteredProducts.map((product) => (
        <ProductCard key={product.id} product={product} onAddToCart={handleAddToCart} />
      ))}
    </div>
  );
};

export default ProductList;


--- File: client/src/components/feature/Product/ProductList.test.js ---
// src/components/feature/Product/ProductList.test.js

import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import ProductList from './ProductList';
import { configureStore } from '@reduxjs/toolkit';
import productReducer from '../../../store/slices/productSlice';
import cartReducer from '../../../store/slices/cartSlice';

// Mock data
const mockProducts = [
  {
    id: '1',
    name: 'G·∫≠y Billiard Pro Series X1',
    brand: 'ProCue',
    price: 1500000,
    images: ['/assets/products/cue1.jpg'],
  },
  {
    id: '2',
    name: 'B·ªô bi-a Pro Tournament',
    brand: 'GameMaster',
    price: 850000,
    images: ['/assets/products/balls1.jpg'],
  },
];

// Test store
const testStore = configureStore({
  reducer: {
    products: productReducer,
    cart: cartReducer,
  },
  preloadedState: {
    products: {
      products: [],
      isLoading: false,
      error: null,
      filters: {},
    },
    cart: {
      items: [],
      total: 0,
    },
  },
});

// Test wrapper
const TestWrapper = ({ children }) => (
  <Provider store={testStore}>
    <BrowserRouter>{children}</BrowserRouter>
  </Provider>
);

describe('ProductList component', () => {
  test('renders empty state when no products', () => {
    render(<ProductList products={[]} />, { wrapper: TestWrapper });
    expect(screen.getByText('Kh√¥ng c√≥ s·∫£n ph·∫©m')).toBeInTheDocument();
  });

  test('renders correct number of products', () => {
    render(<ProductList products={mockProducts} />, { wrapper: TestWrapper });
    expect(screen.getAllByRole('article')).toHaveLength(2);
  });

  test('displays product names correctly', () => {
    render(<ProductList products={mockProducts} />, { wrapper: TestWrapper });
    expect(screen.getByText('G·∫≠y Billiard Pro Series X1')).toBeInTheDocument();
    expect(screen.getByText('B·ªô bi-a Pro Tournament')).toBeInTheDocument();
  });
});


--- File: client/src/components/feature/Review/ReviewForm.js ---
// src/components/feature/Review/ReviewForm.js
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Button } from '../../common/Button/Button';
import { Input } from '../../common/Input/Input';

const schema = yup.object({
  rating: yup.number().required('Vui l√≤ng ch·ªçn s·ªë sao').min(1, 'Vui l√≤ng ch·ªçn s·ªë sao'),
  title: yup.string().required('Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ'),
  content: yup.string().required('Vui l√≤ng nh·∫≠p n·ªôi dung ƒë√°nh gi√°'),
});

const ReviewForm = ({ productId, onSubmit, isSubmitting }) => {
  const [selectedRating, setSelectedRating] = useState(0);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      rating: 0,
      title: '',
      content: '',
    },
  });

  const handleRatingClick = (rating) => {
    setSelectedRating(rating);
  };

  const submitHandler = (data) => {
    onSubmit({ ...data, productId });
  };

  return (
    <form onSubmit={handleSubmit(submitHandler)} className="bg-white p-6 rounded-lg border">
      <h3 className="text-lg font-semibold mb-4">Vi·∫øt ƒë√°nh gi√°</h3>

      <div className="mb-4">
        <label className="block mb-2">ƒê√°nh gi√° c·ªßa b·∫°n</label>
        <div className="flex items-center mb-1">
          {[1, 2, 3, 4, 5].map((rating) => (
            <button
              key={rating}
              type="button"
              onClick={() => handleRatingClick(rating)}
              className="text-2xl text-yellow-400 focus:outline-none"
            >
              {rating <= selectedRating ? '‚òÖ' : '‚òÜ'}
            </button>
          ))}
          <input type="hidden" value={selectedRating} {...register('rating')} />
        </div>
        {errors.rating && <p className="text-red-500 text-sm">{errors.rating.message}</p>}
      </div>

      <div className="mb-4">
        <Input label="Ti√™u ƒë·ªÅ" {...register('title')} error={errors.title?.message} />
      </div>

      <div className="mb-6">
        <Input
          label="N·ªôi dung ƒë√°nh gi√°"
          {...register('content')}
          error={errors.content?.message}
          multiline
          rows={4}
        />
      </div>

      <Button type="submit" isLoading={isSubmitting}>
        G·ª≠i ƒë√°nh gi√°
      </Button>
    </form>
  );
};

export default ReviewForm;


--- File: client/src/components/feature/Review/ReviewItem.js ---
// src/components/feature/Review/ReviewItem.js
import React from 'react';
import { formatDate } from '../../../utils/formatters';

const ReviewItem = ({ review }) => {
  const renderStars = (rating) => {
    return Array.from({ length: 5 }).map((_, index) => (
      <span key={index} className="text-yellow-400">
        {index < rating ? '‚òÖ' : '‚òÜ'}
      </span>
    ));
  };

  return (
    <div className="border-b pb-4 mb-4 last:border-b-0 last:mb-0 last:pb-0">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center">
          <div className="font-semibold mr-3">{review.user.name}</div>
          <div className="text-yellow-400">{renderStars(review.rating)}</div>
        </div>
        <div className="text-gray-500 text-sm">{formatDate(review.createdAt)}</div>
      </div>

      <h4 className="font-medium mb-1">{review.title}</h4>
      <p className="text-gray-700">{review.content}</p>

      {review.response && (
        <div className="mt-3 pl-4 border-l-2 border-gray-300">
          <p className="text-sm font-semibold">Ph·∫£n h·ªìi t·ª´ c·ª≠a h√†ng:</p>
          <p className="text-sm text-gray-700">{review.response.content}</p>
        </div>
      )}
    </div>
  );
};

export default ReviewItem;


--- File: client/src/components/feature/Review/ReviewList.js ---
// src/components/feature/Review/ReviewList.js
import React from 'react';
import ReviewItem from './ReviewItem';
import { Empty } from '../../common/Empty';

const ReviewList = ({ reviews, loading, error }) => {
  if (loading) {
    return <div className="text-center p-4">ƒêang t·∫£i ƒë√°nh gi√°...</div>;
  }

  if (error) {
    return <div className="text-center text-red-500 p-4">{error}</div>;
  }

  if (!reviews || reviews.length === 0) {
    return <Empty message="Ch∆∞a c√≥ ƒë√°nh gi√° n√†o" />;
  }

  return (
    <div className="bg-white p-6 rounded-lg border">
      <h3 className="text-lg font-semibold mb-4">ƒê√°nh gi√° ({reviews.length})</h3>

      <div>
        {reviews.map((review) => (
          <ReviewItem key={review._id} review={review} />
        ))}
      </div>
    </div>
  );
};

export default ReviewList;


--- File: client/src/components/feature/Review/ReviewStats.js ---
// src/components/feature/Review/ReviewStats.js
import React from 'react';

const ReviewStats = ({ stats }) => {
  const { average, count, distribution } = stats;

  const renderStars = (rating) => {
    return Array.from({ length: 5 }).map((_, index) => (
      <span key={index} className="text-yellow-400 text-lg">
        {index < Math.floor(rating) ? '‚òÖ' : '‚òÜ'}
      </span>
    ));
  };

  const renderDistribution = () => {
    return [5, 4, 3, 2, 1].map((rating) => {
      const count = distribution[rating] || 0;
      const percentage = count > 0 ? (count / stats.count) * 100 : 0;

      return (
        <div key={rating} className="flex items-center mb-1">
          <div className="w-12 text-sm">{rating} sao</div>
          <div className="w-full mx-4 bg-gray-200 rounded-full h-2.5">
            <div
              className="bg-yellow-400 h-2.5 rounded-full"
              style={{ width: `${percentage}%` }}
            ></div>
          </div>
          <div className="w-12 text-sm text-right">{count}</div>
        </div>
      );
    });
  };

  return (
    <div className="bg-white p-6 rounded-lg border mb-6">
      <div className="flex flex-col md:flex-row md:items-center mb-4">
        <div className="flex flex-col items-center mr-6 mb-4 md:mb-0">
          <div className="text-4xl font-bold text-center">
            {average ? average.toFixed(1) : '0.0'}
          </div>
          <div className="mb-1">{renderStars(average || 0)}</div>
          <div className="text-sm text-gray-500">({count} ƒë√°nh gi√°)</div>
        </div>

        <div className="flex-1">{renderDistribution()}</div>
      </div>
    </div>
  );
};

export default ReviewStats;


--- File: client/src/components/feature/Search/RecentSearches.js ---
import React from 'react';

const RecentSearches = ({ searches, onSelect }) => {
  if (searches.length === 0) return null;

  return (
    <div className="absolute z-10 w-full mt-1 bg-white shadow-lg rounded-md border border-gray-200 max-h-60 overflow-y-auto">
      <div className="p-2 text-sm text-gray-500 border-b">T√¨m ki·∫øm g·∫ßn ƒë√¢y</div>
      <ul>
        {searches.map((term, index) => (
          <li key={index}>
            <button
              className="w-full px-4 py-2 text-left hover:bg-gray-100 text-gray-700 flex items-center"
              onClick={() => onSelect(term)}
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-4 w-4 mr-2 text-gray-400"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              {term}
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default RecentSearches;


--- File: client/src/components/feature/Search/SearchBar.js ---
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { setKeyword, clearResults, searchProducts } from '../../../store/slices/searchSlice';
import { useDebounce } from '../../../hooks/useDebounce';
import { Input } from '../../common/Input';
import { Button } from '../../common/Button';
import RecentSearches from './RecentSearches';
import { useOutsideClick } from '../../../hooks/useOutsideClick';

const SearchBar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const [inputValue, setInputValue] = useState('');
  const [showRecent, setShowRecent] = useState(false);
  const searchRef = useRef(null);
  const { recentSearches } = useSelector((state) => state.search);

  // Debounce input to avoid too many API calls
  const debouncedValue = useDebounce(inputValue, 300);

  // Close dropdown when clicking outside
  useOutsideClick(searchRef, () => {
    setShowRecent(false);
  });

  // Perform search when debounced value changes
  useEffect(() => {
    if (debouncedValue && debouncedValue.length > 2) {
      dispatch(searchProducts(debouncedValue));
    } else {
      dispatch(clearResults());
    }
  }, [debouncedValue, dispatch]);

  // Handle input change
  const handleChange = (e) => {
    const value = e.target.value;
    setInputValue(value);

    // Show recent searches dropdown when typing
    if (value.length > 0) {
      setShowRecent(true);
    } else {
      setShowRecent(false);
      dispatch(clearResults());
    }
  };

  // Handle search submission
  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      dispatch(setKeyword(inputValue));
      navigate(`/search?q=${encodeURIComponent(inputValue)}`);
      setShowRecent(false);
    }
  };

  // Select recent search
  const handleSelectRecent = (term) => {
    setInputValue(term);
    dispatch(setKeyword(term));
    navigate(`/search?q=${encodeURIComponent(term)}`);
    setShowRecent(false);
  };

  return (
    <div ref={searchRef} className="relative">
      <form onSubmit={handleSubmit} className="flex">
        <Input
          type="text"
          placeholder="T√¨m ki·∫øm s·∫£n ph·∫©m..."
          value={inputValue}
          onChange={handleChange}
          onFocus={() => inputValue && setShowRecent(true)}
          className="w-full rounded-r-none"
        />
        <Button type="submit" variant="primary" className="rounded-l-none">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-5 w-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        </Button>
      </form>

      {/* Recent searches dropdown */}
      {showRecent && recentSearches.length > 0 && (
        <RecentSearches searches={recentSearches} onSelect={handleSelectRecent} />
      )}
    </div>
  );
};

export default SearchBar;


--- File: client/src/components/feature/User/OrderDetail.js ---
// src/components/feature/User/OrderDetail.js
import React, { useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { fetchOrderDetail } from '../../../store/slices/orderSlice';
import { formatDate, formatPrice } from '../../../utils/formatters';
import { LoadingSpinner } from '../../common/LoadingSpinner';

const OrderStatus = ({ status, statusHistory }) => {
  const statusSteps = [
    { key: 'pending', label: 'Ch·ªù x√°c nh·∫≠n' },
    { key: 'processing', label: 'ƒêang x·ª≠ l√Ω' },
    { key: 'shipped', label: 'ƒêang giao h√†ng' },
    { key: 'delivered', label: 'ƒê√£ giao h√†ng' },
  ];

  // Find current status index
  const currentIndex = statusSteps.findIndex((step) => step.key === status);

  // Handle cancelled order
  if (status === 'cancelled') {
    return (
      <div className="mb-6">
        <div className="flex items-center">
          <div className="w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white">
            ‚úï
          </div>
          <div className="ml-3">
            <p className="font-medium">ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy</p>
            <p className="text-sm text-gray-500">
              {statusHistory &&
                statusHistory.length > 0 &&
                `Ng√†y h·ªßy: ${formatDate(statusHistory[statusHistory.length - 1].date)}`}
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="mb-6">
      <h3 className="font-medium mb-4">Tr·∫°ng th√°i ƒë∆°n h√†ng</h3>
      <div className="relative">
        {/* Progress line */}
        <div className="absolute top-4 left-4 right-4 h-0.5 bg-gray-200">
          <div
            className="h-0.5 bg-green-500"
            style={{ width: `${(currentIndex * 100) / (statusSteps.length - 1)}%` }}
          ></div>
        </div>

        {/* Status steps */}
        <div className="flex justify-between relative">
          {statusSteps.map((step, index) => {
            const isCompleted = index <= currentIndex;
            const isCurrent = index === currentIndex;

            return (
              <div key={step.key} className="flex flex-col items-center">
                <div
                  className={`w-8 h-8 rounded-full flex items-center justify-center z-10 ${
                    isCompleted ? 'bg-green-500 text-white' : 'bg-gray-200'
                  } ${isCurrent ? 'ring-2 ring-green-300' : ''}`}
                >
                  {isCompleted ? '‚úì' : index + 1}
                </div>
                <p className={`text-sm mt-2 ${isCompleted ? 'font-medium' : 'text-gray-500'}`}>
                  {step.label}
                </p>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
};

const OrderDetail = () => {
  const { orderId } = useParams();
  const dispatch = useDispatch();
  const { currentOrder, loading, error } = useSelector((state) => state.order);

  useEffect(() => {
    if (orderId) {
      dispatch(fetchOrderDetail(orderId));
    }
  }, [dispatch, orderId]);

  if (loading) {
    return (
      <div className="flex justify-center items-center py-8">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (!currentOrder) {
    return <div className="text-center py-4">Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë∆°n h√†ng</div>;
  }

  return (
    <div className="bg-white rounded-lg border p-6">
      <div className="flex justify-between items-start mb-6">
        <div>
          <h2 className="text-xl font-semibold">ƒê∆°n h√†ng #{currentOrder.orderNumber}</h2>
          <p className="text-gray-500">Ng√†y ƒë·∫∑t: {formatDate(currentOrder.createdAt)}</p>
        </div>
        <div className="font-bold text-lg">{formatPrice(currentOrder.totalAmount)}</div>
      </div>

      <OrderStatus status={currentOrder.status} statusHistory={currentOrder.statusHistory} />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <h3 className="font-medium mb-2">Th√¥ng tin giao h√†ng</h3>
          <div className="border rounded-lg p-4">
            <p>{currentOrder.shippingAddress.name}</p>
            <p>{currentOrder.shippingAddress.phone}</p>
            <p>{currentOrder.shippingAddress.street}</p>
            <p>
              {currentOrder.shippingAddress.city}, {currentOrder.shippingAddress.zipCode}
            </p>
          </div>
        </div>

        <div>
          <h3 className="font-medium mb-2">Ph∆∞∆°ng th·ª©c thanh to√°n</h3>
          <div className="border rounded-lg p-4">
            <p>
              {currentOrder.paymentMethod === 'cod'
                ? 'Thanh to√°n khi nh·∫≠n h√†ng (COD)'
                : 'Thanh to√°n qua VNPay'}
            </p>
            <p className="text-sm mt-1">
              Tr·∫°ng th√°i:
              <span
                className={
                  currentOrder.paymentStatus === 'paid' ? 'text-green-600' : 'text-yellow-600'
                }
              >
                {currentOrder.paymentStatus === 'paid' ? ' ƒê√£ thanh to√°n' : ' Ch∆∞a thanh to√°n'}
              </span>
            </p>
          </div>
        </div>
      </div>

      <h3 className="font-medium mb-2">Chi ti·∫øt ƒë∆°n h√†ng</h3>
      <div className="border rounded-lg">
        <div className="divide-y">
          {currentOrder.items.map((item) => (
            <div key={item._id} className="p-4 flex justify-between items-center">
              <div className="flex items-center">
                {item.image && (
                  <img
                    src={item.image}
                    alt={item.name}
                    className="w-12 h-12 object-cover rounded mr-3"
                  />
                )}
                <div>
                  <p className="font-medium">{item.name}</p>
                  <p className="text-sm text-gray-500">
                    S·ªë l∆∞·ª£ng: {item.quantity} x {formatPrice(item.price)}
                  </p>
                </div>
              </div>
              <div className="font-medium">{formatPrice(item.price * item.quantity)}</div>
            </div>
          ))}
        </div>

        <div className="border-t p-4">
          <div className="flex justify-between mb-2">
            <span className="text-gray-600">T·∫°m t√≠nh:</span>
            <span>{formatPrice(currentOrder.subtotal)}</span>
          </div>
          {currentOrder.discount && currentOrder.discount.amount > 0 && (
            <div className="flex justify-between mb-2 text-green-600">
              <span>Gi·∫£m gi√°:</span>
              <span>-{formatPrice(currentOrder.discount.amount)}</span>
            </div>
          )}
          <div className="flex justify-between mb-2">
            <span className="text-gray-600">Ph√≠ v·∫≠n chuy·ªÉn:</span>
            <span>{formatPrice(currentOrder.shippingCost)}</span>
          </div>
          <div className="flex justify-between font-bold text-lg pt-2 border-t mt-2">
            <span>T·ªïng c·ªông:</span>
            <span>{formatPrice(currentOrder.totalAmount)}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default OrderDetail;


--- File: client/src/components/feature/User/ProfileSidebar.js ---
// src/components/feature/User/ProfileSidebar.js
import React from 'react';
import { NavLink, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';

const ProfileSidebar = () => {
  const location = useLocation();
  const { user } = useSelector((state) => state.user);

  const menuItems = [
    {
      path: '/profile',
      label: 'Th√¥ng tin t√†i kho·∫£n',
      icon: 'üë§',
      exact: true,
    },
    {
      path: '/profile/orders',
      label: 'ƒê∆°n h√†ng c·ªßa t√¥i',
      icon: 'üì¶',
      exact: false,
    },
    {
      path: '/profile/reviews',
      label: 'ƒê√°nh gi√° c·ªßa t√¥i',
      icon: '‚≠ê',
      exact: true,
    },
    {
      path: '/profile/wishlist',
      label: 'S·∫£n ph·∫©m y√™u th√≠ch',
      icon: '‚ù§Ô∏è',
      exact: true,
    },
    {
      path: '/profile/settings',
      label: 'C√†i ƒë·∫∑t t√†i kho·∫£n',
      icon: '‚öôÔ∏è',
      exact: true,
    },
  ];

  return (
    <div className="bg-white rounded-lg border overflow-hidden">
      {user && (
        <div className="p-6 border-b">
          <div className="flex items-center">
            <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 font-semibold mr-3">
              {user.name.charAt(0).toUpperCase()}
            </div>
            <div>
              <p className="font-medium">{user.name}</p>
              <p className="text-sm text-gray-500">{user.email}</p>
            </div>
          </div>
        </div>
      )}

      <div className="py-2">
        {menuItems.map((item) => {
          const isActive = item.exact
            ? location.pathname === item.path
            : location.pathname.startsWith(item.path);

          return (
            <NavLink
              key={item.path}
              to={item.path}
              className={`flex items-center px-6 py-3 hover:bg-gray-50 ${
                isActive ? 'text-blue-600 bg-blue-50 font-medium' : 'text-gray-700'
              }`}
            >
              <span className="mr-3">{item.icon}</span>
              {item.label}
            </NavLink>
          );
        })}
      </div>
    </div>
  );
};

export default ProfileSidebar;


--- File: client/src/components/feature/User/UserOrders.js ---
// src/components/feature/User/UserOrders.js
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Link } from 'react-router-dom';
import { fetchUserOrders } from '../../../store/slices/orderSlice';
import { LoadingSpinner } from '../../common/LoadingSpinner';
import { formatDate, formatPrice } from '../../../utils/formatters';
import { Empty } from '../../common/Empty';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Ch·ªù x√°c nh·∫≠n', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'ƒêang x·ª≠ l√Ω', color: 'bg-blue-100 text-blue-800' },
    shipped: { text: 'ƒêang giao h√†ng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'ƒê√£ giao h√†ng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'ƒê√£ h·ªßy', color: 'bg-red-100 text-red-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${config.color}`}>
      {config.text}
    </span>
  );
};

const UserOrders = () => {
  const dispatch = useDispatch();
  const { orders, loading, error } = useSelector((state) => state.order);

  useEffect(() => {
    dispatch(fetchUserOrders());
  }, [dispatch]);

  if (loading) {
    return (
      <div className="flex justify-center items-center py-8">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (!orders || orders.length === 0) {
    return <Empty message="B·∫°n ch∆∞a c√≥ ƒë∆°n h√†ng n√†o" />;
  }

  return (
    <div className="bg-white rounded-lg border">
      <h2 className="text-xl font-semibold p-6 border-b">ƒê∆°n h√†ng c·ªßa t√¥i</h2>

      <div className="divide-y">
        {orders.map((order) => (
          <div key={order._id} className="p-6">
            <div className="flex justify-between items-start mb-4">
              <div>
                <p className="font-medium mb-1">ƒê∆°n h√†ng #{order.orderNumber}</p>
                <p className="text-sm text-gray-500">Ng√†y ƒë·∫∑t: {formatDate(order.createdAt)}</p>
              </div>
              <div className="flex flex-col items-end">
                <OrderStatusBadge status={order.status} />
                <p className="font-bold mt-2">{formatPrice(order.totalAmount)}</p>
              </div>
            </div>

            <div className="space-y-2 mb-4">
              {order.items.map((item) => (
                <div key={item._id} className="flex items-center">
                  <span className="text-gray-500 mr-2">{item.quantity}x</span>
                  <span>{item.name}</span>
                </div>
              ))}
            </div>

            <Link
              to={`/profile/orders/${order._id}`}
              className="text-blue-600 hover:text-blue-800 text-sm font-medium"
            >
              Xem chi ti·∫øt
            </Link>
          </div>
        ))}
      </div>
    </div>
  );
};

export default UserOrders;


--- File: client/src/components/feature/User/UserProfile.js ---
// src/components/feature/User/UserProfile.js
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { updateUserProfile } from '../../../store/slices/userSlice';
import { Button } from '../../common/Button/Button';
import { Input } from '../../common/Input/Input';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object({
  name: yup.string().required('Vui l√≤ng nh·∫≠p h·ªç t√™n'),
  email: yup.string().email('Email kh√¥ng h·ª£p l·ªá').required('Vui l√≤ng nh·∫≠p email'),
  phone: yup.string(),
  address: yup.string(),
});

const UserProfile = () => {
  const dispatch = useDispatch();
  const { user, loading } = useSelector((state) => state.user);
  const [isEditing, setIsEditing] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      name: user?.name || '',
      email: user?.email || '',
      phone: user?.phone || '',
      address: user?.address?.street || '',
    },
  });

  const onSubmit = async (data) => {
    try {
      await dispatch(updateUserProfile(data)).unwrap();
      setIsEditing(false);
    } catch (error) {
      console.error('Failed to update profile:', error);
    }
  };

  if (!user) {
    return <div className="text-center p-4">ƒêang t·∫£i th√¥ng tin...</div>;
  }

  return (
    <div className="bg-white p-6 rounded-lg border">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-semibold">Th√¥ng tin c√° nh√¢n</h2>
        {!isEditing && (
          <Button variant="outline" size="sm" onClick={() => setIsEditing(true)}>
            Ch·ªânh s·ª≠a
          </Button>
        )}
      </div>

      {isEditing ? (
        <form onSubmit={handleSubmit(onSubmit)}>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <Input label="H·ªç t√™n" {...register('name')} error={errors.name?.message} />
            </div>
            <div>
              <Input label="Email" {...register('email')} error={errors.email?.message} disabled />
            </div>
            <div>
              <Input label="S·ªë ƒëi·ªán tho·∫°i" {...register('phone')} error={errors.phone?.message} />
            </div>
            <div>
              <Input label="ƒê·ªãa ch·ªâ" {...register('address')} error={errors.address?.message} />
            </div>
          </div>

          <div className="flex justify-end space-x-3">
            <Button type="button" variant="outline" onClick={() => setIsEditing(false)}>
              H·ªßy
            </Button>
            <Button type="submit" isLoading={loading}>
              L∆∞u thay ƒë·ªïi
            </Button>
          </div>
        </form>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <p className="text-gray-500 mb-1">H·ªç t√™n</p>
            <p className="font-medium">{user.name}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">Email</p>
            <p className="font-medium">{user.email}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">S·ªë ƒëi·ªán tho·∫°i</p>
            <p className="font-medium">{user.phone || 'Ch∆∞a c·∫≠p nh·∫≠t'}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">ƒê·ªãa ch·ªâ</p>
            <p className="font-medium">{user.address?.street || 'Ch∆∞a c·∫≠p nh·∫≠t'}</p>
          </div>
        </div>
      )}
    </div>
  );
};

export default UserProfile;


--- File: client/src/hooks/useDebounce.js ---
import { useState, useEffect } from 'react';

/**
 * Custom hook ƒë·ªÉ debounce m·ªôt gi√° tr·ªã
 * @param {any} value - Gi√° tr·ªã c·∫ßn debounce
 * @param {number} delay - Th·ªùi gian delay (ms)
 * @returns {any} - Gi√° tr·ªã ƒë√£ debounce
 */
const useDebounce = (value, delay) => {
  // State v√† setter cho gi√° tr·ªã debounced
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // C·∫≠p nh·∫≠t gi√° tr·ªã debounced sau m·ªôt kho·∫£ng th·ªùi gian delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // H·ªßy timeout n·∫øu value thay ƒë·ªïi ho·∫∑c unmount
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

export default useDebounce;

--- File: client/src/hooks/useForm.js ---
import { useState } from 'react';

/**
 * Custom hook ƒë·ªÉ qu·∫£n l√Ω form state
 * @param {Object} initialValues - Gi√° tr·ªã ban ƒë·∫ßu c·ªßa form
 * @param {Function} [validate] - H√†m validate form (optional)
 * @param {Function} [onSubmit] - H√†m x·ª≠ l√Ω submit form (optional)
 * @returns {Object} - Form state v√† c√°c h√†m x·ª≠ l√Ω
 */
const useForm = (initialValues, validate, onSubmit) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // X·ª≠ l√Ω thay ƒë·ªïi input
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;

    // X·ª≠ l√Ω gi√° tr·ªã d·ª±a tr√™n lo·∫°i input
    const inputValue = type === 'checkbox' ? checked : value;

    setValues({
      ...values,
      [name]: inputValue,
    });

    // N·∫øu field ƒë√£ ƒë∆∞·ª£c touched, ch·∫°y validate khi thay ƒë·ªïi
    if (touched[name] && validate) {
      const validationErrors = validate({ ...values, [name]: inputValue });
      setErrors(validationErrors);
    }
  };

  // X·ª≠ l√Ω khi blur kh·ªèi field
  const handleBlur = (e) => {
    const { name } = e.target;

    setTouched({
      ...touched,
      [name]: true,
    });

    // Ch·∫°y validate khi blur
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
    }
  };

  // X·ª≠ l√Ω submit form
  const handleSubmit = async (e) => {
    e.preventDefault();

    // ƒê√°nh d·∫•u t·∫•t c·∫£ c√°c field l√† touched
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});

    setTouched(allTouched);

    // Validate form tr∆∞·ªõc khi submit
    let validationErrors = {};
    if (validate) {
      validationErrors = validate(values);
      setErrors(validationErrors);
    }

    // N·∫øu kh√¥ng c√≥ l·ªói v√† c√≥ h√†m onSubmit
    if (Object.keys(validationErrors).length === 0 && onSubmit) {
      setIsSubmitting(true);

      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Form submission error:', error);
      } finally {
        setIsSubmitting(false);
      }
    }
  };

  // Reset form
  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  };

  // C·∫≠p nh·∫≠t gi√° tr·ªã form t·ª´ b√™n ngo√†i
  const setFieldValue = (name, value) => {
    setValues({
      ...values,
      [name]: value,
    });
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setFieldValue,
  };
};

export default useForm;


--- File: client/src/hooks/useLocalStorage.js ---
import { useState, useEffect } from 'react';

/**
 * Custom hook ƒë·ªÉ s·ª≠ d·ª•ng localStorage
 * @param {string} key - Key ƒë·ªÉ l∆∞u trong localStorage
 * @param {any} initialValue - Gi√° tr·ªã ban ƒë·∫ßu
 * @returns {Array} [storedValue, setValue]
 */
const useLocalStorage = (key, initialValue) => {
  // T·∫°o state ban ƒë·∫ßu
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // L·∫•y gi√° tr·ªã t·ª´ localStorage
      const item = window.localStorage.getItem(key);
      // Parse stored json or return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // N·∫øu c√≥ l·ªói, tr·∫£ v·ªÅ gi√° tr·ªã ban ƒë·∫ßu
      console.error(`Error getting localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // H√†m ƒë·ªÉ c·∫≠p nh·∫≠t localStorage v√† state
  const setValue = (value) => {
    try {
      // Cho ph√©p value l√† m·ªôt function
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      // L∆∞u state
      setStoredValue(valueToStore);
      // L∆∞u v√†o localStorage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  // ƒê·ªìng b·ªô v·ªõi c√°c tab kh√°c
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.error(`Error parsing localStorage key "${key}":`, error);
        }
      }
    };

    // L·∫Øng nghe s·ª± ki·ªán storage
    window.addEventListener('storage', handleStorageChange);

    // Cleanup
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [key]);

  return [storedValue, setValue];
};

export default useLocalStorage;

--- File: client/src/hooks/useOutsideClick.js ---
import { useEffect, useRef } from 'react';

/**
 * Custom hook ƒë·ªÉ ph√°t hi·ªán click b√™n ngo√†i m·ªôt element
 * @param {Function} callback - H√†m s·∫Ω ƒë∆∞·ª£c g·ªçi khi click b√™n ngo√†i
 * @returns {React.MutableRefObject} - Ref ƒë·ªÉ g·∫Øn v√†o element c·∫ßn theo d√µi
 */
const useOutsideClick = (callback) => {
  const ref = useRef();

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    };

    // Th√™m event listener
    document.addEventListener('mousedown', handleClickOutside);
    
    // Cleanup
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [callback]);

  return ref;
};

export default useOutsideClick;

--- File: client/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import { QueryClient, QueryClientProvider } from 'react-query';
import { store } from './store';
import App from './App';
import './assets/css/index.css';

// Kh·ªüi t·∫°o React Query client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 ph√∫t
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </QueryClientProvider>
    </Provider>
  </React.StrictMode>
);


--- File: client/src/pages/Admin/Dashboard/index.js ---
// src/pages/Admin/Dashboard/index.js
// V·ªã tr√≠: Trang Dashboard ch√≠nh cho Admin, hi·ªÉn th·ªã th·ªëng k√™, bi·ªÉu ƒë·ªì v√† ƒë∆°n h√†ng g·∫ßn ƒë√¢y

import React, { useEffect, useState, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../../../store/hooks';
import {
  fetchDashboardStats,
  fetchRecentOrders,
  resetDashboardErrors,
} from '../../../store/slices/adminSlice';
import {
  DashboardStats,
  RecentOrders,
  SalesChart,
  TimeFilter,
} from '../../../components/feature/Admin/Dashboard';
import { LoadingSpinner, ErrorAlert, RefreshButton } from '../../../components/common';

const TIME_PERIODS = {
  TODAY: 'today',
  WEEK: 'week',
  MONTH: 'month',
  YEAR: 'year',
};

const AdminDashboardPage = () => {
  const dispatch = useAppDispatch();
  const { stats, recentOrders, isLoading, error } = useAppSelector((state) => state.admin);

  const [timePeriod, setTimePeriod] = useState(TIME_PERIODS.WEEK);

  const fetchDashboardData = useCallback(() => {
    dispatch(fetchDashboardStats(timePeriod));
    dispatch(fetchRecentOrders(timePeriod));
  }, [dispatch, timePeriod]);

  useEffect(() => {
    fetchDashboardData();

    // Cleanup function ƒë·ªÉ reset errors khi unmount
    return () => {
      dispatch(resetDashboardErrors());
    };
  }, [fetchDashboardData, dispatch]);

  const handleRefresh = () => {
    fetchDashboardData();
  };

  const handleTimeFilterChange = (period) => {
    setTimePeriod(period);
  };

  const handleDismissError = () => {
    dispatch(resetDashboardErrors());
  };

  return (
    <div className="space-y-6 px-4 py-6 sm:px-6 lg:px-8">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
        <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>

        <div className="mt-3 sm:mt-0 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
          <TimeFilter
            currentPeriod={timePeriod}
            onChange={handleTimeFilterChange}
            options={TIME_PERIODS}
          />
          <RefreshButton onClick={handleRefresh} isLoading={isLoading} />
        </div>
      </div>

      {error && <ErrorAlert message={error} onDismiss={handleDismissError} />}

      {isLoading ? (
        <div className="flex justify-center items-center h-64">
          <LoadingSpinner size="large" />
        </div>
      ) : (
        <>
          <DashboardStats stats={stats} />

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Doanh s·ªë b√°n h√†ng</h2>
              <SalesChart data={stats?.salesData || []} period={timePeriod} />
            </div>

            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">ƒê∆°n h√†ng g·∫ßn ƒë√¢y</h2>
              <RecentOrders
                orders={recentOrders}
                isLoading={isLoading}
                onViewAllClick={() => {
                  /* Navigate to orders page */
                }}
              />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">S·∫£n ph·∫©m b√°n ch·∫°y</h2>
              {/* Component hi·ªÉn th·ªã s·∫£n ph·∫©m b√°n ch·∫°y */}
            </div>

            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y</h2>
              {/* Component hi·ªÉn th·ªã ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y */}
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default AdminDashboardPage;


--- File: client/src/pages/Auth/Login/index.js ---
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { login, clearError, selectAuth } from '../../../store/slices/authSlice';
import { ROUTES } from '../../../routes/paths';
import Button from '../../../components/common/Button/Button';
import Input from '../../../components/common/Input/Input';
import useForm from '../../../hooks/useForm';

const Login = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { isAuthenticated, error, loading } = useSelector(selectAuth);
  const [showPassword, setShowPassword] = useState(false);

  // L·∫•y redirect path t·ª´ location state ho·∫∑c m·∫∑c ƒë·ªãnh v·ªÅ trang ch·ªß
  const from = location.state?.from?.pathname || ROUTES.HOME;

  // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, chuy·ªÉn h∆∞·ªõng
  useEffect(() => {
    if (isAuthenticated) {
      navigate(from, { replace: true });
    }

    // X√≥a error khi unmount
    return () => {
      dispatch(clearError());
    };
  }, [isAuthenticated, navigate, from, dispatch]);

  // Validate form
  const validateForm = (values) => {
    const errors = {};

    if (!values.email) {
      errors.email = 'Email l√† b·∫Øt bu·ªôc';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email kh√¥ng h·ª£p l·ªá';
    }

    if (!values.password) {
      errors.password = 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc';
    }

    return errors;
  };

  // X·ª≠ l√Ω submit form
  const handleSubmit = async (values) => {
    await dispatch(login(values));
  };

  // Kh·ªüi t·∫°o form v·ªõi useForm hook
  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit: submitForm,
  } = useForm({ email: '', password: '' }, validateForm, handleSubmit);

  return (
    <div className="max-w-md mx-auto">
      <h2 className="text-center text-2xl font-extrabold mb-6">ƒêƒÉng Nh·∫≠p</h2>

      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <form onSubmit={submitForm}>
        <Input
          type="email"
          id="email"
          name="email"
          label="Email"
          placeholder="Nh·∫≠p email c·ªßa b·∫°n"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.email && errors.email}
          leftIcon={
            <svg
              className="h-5 w-5 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
              ></path>
            </svg>
          }
        />

        <Input
          type={showPassword ? 'text' : 'password'}
          id="password"
          name="password"
          label="M·∫≠t kh·∫©u"
          placeholder="Nh·∫≠p m·∫≠t kh·∫©u c·ªßa b·∫°n"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.password && errors.password}
          leftIcon={
            <svg
              className="h-5 w-5 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
              ></path>
            </svg>
          }
          rightIcon={
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="focus:outline-none"
            >
              {showPassword ? (
                <svg
                  className="h-5 w-5 text-gray-400"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"
                  ></path>
                </svg>
              ) : (
                <svg
                  className="h-5 w-5 text-gray-400"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                  ></path>
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                  ></path>
                </svg>
              )}
            </button>
          }
        />

        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center">
            <input
              id="remember-me"
              name="remember-me"
              type="checkbox"
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
              Ghi nh·ªõ ƒëƒÉng nh·∫≠p
            </label>
          </div>

          <div className="text-sm">
            <Link
              to={ROUTES.FORGOT_PASSWORD}
              className="font-medium text-blue-600 hover:text-blue-500"
            >
              Qu√™n m·∫≠t kh·∫©u?
            </Link>
          </div>
        </div>

        <Button type="submit" variant="primary" className="w-full" isLoading={loading}>
          ƒêƒÉng Nh·∫≠p
        </Button>
      </form>

      <div className="text-center mt-6">
        <p className="text-sm text-gray-600">
          Ch∆∞a c√≥ t√†i kho·∫£n?{' '}
          <Link to={ROUTES.REGISTER} className="font-medium text-blue-600 hover:text-blue-500">
            ƒêƒÉng k√Ω ngay
          </Link>
        </p>
      </div>
    </div>
  );
};

export default Login;


--- File: client/src/pages/Auth/Register/index.js ---


--- File: client/src/pages/Cart/index.js ---
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Link } from 'react-router-dom';
import { updateCartItem, removeFromCart, clearCart, fetchCart } from '../../store/slices/cartSlice';
import CartList from '../../components/feature/Cart/CartList';
import CartSummary from '../../components/feature/Cart/CartSummary';
import EmptyState from '../../components/common/Empty';
import Breadcrumb from '../../components/common/Breadcrumb';
import { Button } from '../../components/common/Button';
import { LoadingSpinner } from '../../components/common/LoadingSpinner';
import MainLayout from '../../components/layout/MainLayout';
import { PATHS } from '../../routes/paths';

const CartPage = () => {
  const dispatch = useDispatch();
  const { items, loading, error } = useSelector((state) => state.cart);

  useEffect(() => {
    dispatch(fetchCart());
  }, [dispatch]);

  // Handle quantity change
  const handleQuantityChange = (productId, quantity) => {
    dispatch(updateCartItem({ productId, quantity }));
  };

  // Handle remove item
  const handleRemoveItem = (productId) => {
    dispatch(removeFromCart(productId));
  };

  // Handle clear cart
  const handleClearCart = () => {
    if (window.confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng?')) {
      dispatch(clearCart());
    }
  };

  // Render loading state
  if (loading) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang ch·ªß', path: '/' },
              { label: 'Gi·ªè h√†ng', path: '/cart' },
            ]}
          />
          <div className="flex justify-center items-center h-64">
            <LoadingSpinner />
          </div>
        </div>
      </MainLayout>
    );
  }

  // Render error state
  if (error) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang ch·ªß', path: '/' },
              { label: 'Gi·ªè h√†ng', path: '/cart' },
            ]}
          />
          <div className="text-center text-red-500 mt-8">
            <p>ƒê√£ x·∫£y ra l·ªói: {error}</p>
            <Button variant="primary" className="mt-4" onClick={() => dispatch(fetchCart())}>
              Th·ª≠ l·∫°i
            </Button>
          </div>
        </div>
      </MainLayout>
    );
  }

  // Render empty state if cart is empty
  if (items.length === 0) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang ch·ªß', path: '/' },
              { label: 'Gi·ªè h√†ng', path: '/cart' },
            ]}
          />

          <EmptyState
            message="Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng"
            icon={
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-16 w-16 text-gray-400"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"
                />
              </svg>
            }
            action={
              <Link to={PATHS.PRODUCTS}>
                <Button variant="primary">Ti·∫øp t·ª•c mua s·∫Øm</Button>
              </Link>
            }
          />
        </div>
      </MainLayout>
    );
  }

  // Render cart with items
  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <Breadcrumb
          items={[
            { label: 'Trang ch·ªß', path: '/' },
            { label: 'Gi·ªè h√†ng', path: '/cart' },
          ]}
        />

        <h1 className="text-2xl font-bold mb-6">Gi·ªè h√†ng c·ªßa b·∫°n</h1>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Cart Items */}
          <div className="lg:col-span-2">
            <CartList
              items={items}
              onQuantityChange={handleQuantityChange}
              onRemoveItem={handleRemoveItem}
              loading={loading}
            />

            <div className="mt-4 flex justify-between items-center">
              <Button variant="outline" onClick={handleClearCart} disabled={items.length === 0}>
                X√≥a t·∫•t c·∫£
              </Button>

              <Link to={PATHS.PRODUCTS}>
                <Button variant="link">Ti·∫øp t·ª•c mua s·∫Øm</Button>
              </Link>
            </div>
          </div>

          {/* Cart Summary */}
          <div className="lg:col-span-1">
            <CartSummary items={items} checkoutLink={PATHS.CHECKOUT} />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default CartPage;


--- File: client/src/pages/Home/index.js ---
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Link } from 'react-router-dom';
import { fetchProducts, fetchCategories } from '../../store/slices/productSlice';
import { ROUTES } from '../../routes/paths';
import LoadingSpinner from '../../components/common/LoadingSpiner';
import Card from '../../components/common/Card/Card';
import Button from '../../components/common/Button/Button';
import { formatPrice } from '../../utils/formatters';

const HomePage = () => {
  const dispatch = useDispatch();
  const { products, categories, loading } = useSelector((state) => state.product);

  useEffect(() => {
    // L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t
    dispatch(fetchProducts({ limit: 8, featured: true }));

    // L·∫•y danh m·ª•c
    dispatch(fetchCategories());
  }, [dispatch]);

  if (loading && products.length === 0) {
    return <LoadingSpinner fullScreen />;
  }

  return (
    <div>
      {/* Hero Section */}
      <section className="bg-blue-900 text-white py-16 mb-12 rounded-lg">
        <div className="container mx-auto px-4 text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-6">RunOut-Biliard</h1>
          <p className="text-xl mb-8 max-w-3xl mx-auto">
            Chuy√™n cung c·∫•p c√°c s·∫£n ph·∫©m Bi-a ch·∫•t l∆∞·ª£ng cao, ƒëa d·∫°ng m·∫´u m√£, ph√π h·ª£p v·ªõi m·ªçi nhu
            c·∫ßu t·ª´ ng∆∞·ªùi ch∆°i nghi·ªáp d∆∞ ƒë·∫øn chuy√™n nghi·ªáp.
          </p>
          <div className="flex justify-center space-x-4">
            <Link to={ROUTES.PRODUCTS}>
              <Button variant="primary" size="lg">
                Mua Ngay
              </Button>
            </Link>
            <Link to={ROUTES.ABOUT}>
              <Button variant="outline" size="lg">
                T√¨m Hi·ªÉu Th√™m
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* Categories Section */}
      <section className="mb-16">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold mb-8 text-center">Danh M·ª•c S·∫£n Ph·∫©m</h2>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            {categories.slice(0, 4).map((category) => (
              <Link
                key={category._id}
                to={`${ROUTES.PRODUCTS}?category=${category.slug}`}
                className="block"
              >
                <div className="bg-gray-100 rounded-lg p-6 transition-transform hover:transform hover:scale-105 hover:shadow-lg text-center">
                  {category.image && (
                    <img
                      src={category.image.url}
                      alt={category.name}
                      className="w-16 h-16 mx-auto mb-4"
                    />
                  )}
                  <h3 className="text-xl font-semibold mb-2">{category.name}</h3>
                  <p className="text-gray-600 mb-4">
                    {category.description
                      ? category.description.substring(0, 100)
                      : 'Xem c√°c s·∫£n ph·∫©m'}
                  </p>
                  <span className="text-blue-600 hover:text-blue-800 font-medium">
                    Xem s·∫£n ph·∫©m ‚Üí
                  </span>
                </div>
              </Link>
            ))}
          </div>
        </div>
      </section>

      {/* Featured Products Section */}
      <section className="mb-16">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold mb-8 text-center">S·∫£n Ph·∫©m N·ªïi B·∫≠t</h2>

          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            {products.map((product) => (
              <Link key={product._id} to={`${ROUTES.PRODUCTS}/${product._id}`}>
                <Card className="h-full flex flex-col transition-all hover:shadow-lg">
                  <div className="relative pb-[75%] overflow-hidden rounded-t-lg">
                    <img
                      src={product.images[0]?.url || '/placeholder.png'}
                      alt={product.name}
                      className="absolute top-0 left-0 w-full h-full object-cover"
                    />
                  </div>
                  <div className="p-4 flex-grow flex flex-col">
                    <h3 className="text-lg font-semibold mb-2">{product.name}</h3>
                    <p className="text-gray-600 text-sm mb-4 flex-grow">
                      {product.description?.short?.substring(0, 100) || 'Kh√¥ng c√≥ m√¥ t·∫£'}
                    </p>
                    <div className="flex justify-between items-center">
                      <span className="text-lg font-bold text-blue-700">
                        {formatPrice(product.price)}
                      </span>
                      <span className="text-sm text-gray-500">
                        {product.ratings?.average > 0 ? (
                          <span className="flex items-center">
                            <svg
                              className="w-4 h-4 text-yellow-500 mr-1"
                              fill="currentColor"
                              viewBox="0 0 20 20"
                            >
                              <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                            </svg>
                            {product.ratings.average.toFixed(1)}
                          </span>
                        ) : (
                          'Ch∆∞a c√≥ ƒë√°nh gi√°'
                        )}
                      </span>
                    </div>
                  </div>
                </Card>
              </Link>
            ))}
          </div>

          <div className="text-center mt-10">
            <Link to={ROUTES.PRODUCTS}>
              <Button variant="outline" size="lg">
                Xem T·∫•t C·∫£ S·∫£n Ph·∫©m
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* About Section */}
      <section className="mb-16 bg-gray-100 py-16 rounded-lg">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row items-center">
            <div className="md:w-1/2 mb-8 md:mb-0 md:pr-8">
              <h2 className="text-3xl font-bold mb-6">V·ªÅ RunOut-Biliard</h2>
              <p className="text-lg mb-6">
                RunOut-Biliard l√† nh√† cung c·∫•p h√†ng ƒë·∫ßu c√°c s·∫£n ph·∫©m Bi-a ch·∫•t l∆∞·ª£ng cao t·∫°i Vi·ªát
                Nam. Ch√∫ng t√¥i t·ª± h√†o mang ƒë·∫øn cho kh√°ch h√†ng nh·ªØng s·∫£n ph·∫©m ch√≠nh h√£ng v·ªõi gi√° c·∫£
                h·ª£p l√Ω.
              </p>
              <p className="text-lg mb-6">
                V·ªõi ƒë·ªôi ng≈© nh√¢n vi√™n nhi·ªÅu kinh nghi·ªám v√† am hi·ªÉu v·ªÅ Bi-a, ch√∫ng t√¥i cam k·∫øt mang
                ƒë·∫øn s·ª± t∆∞ v·∫•n t·∫≠n t√¢m v√† chuy√™n nghi·ªáp cho kh√°ch h√†ng.
              </p>
              <Link to={ROUTES.ABOUT}>
                <Button variant="primary">Xem Th√™m</Button>
              </Link>
            </div>
            <div className="md:w-1/2">
              <img
                src="/assets/about.jpg"
                alt="RunOut-Biliard Store"
                className="rounded-lg shadow-lg"
              />
            </div>
          </div>
        </div>
      </section>
    </div>
  );
};

export default HomePage;


--- File: client/src/pages/Info/Contact.js ---


--- File: client/src/pages/Info/FAQ.js ---


--- File: client/src/pages/Info/Privacy.js ---


--- File: client/src/pages/Info/Return.js ---


--- File: client/src/pages/Info/Shipping.js ---


--- File: client/src/pages/Info/Terms.js ---


--- File: client/src/pages/NotFound/index.js ---
import React from 'react';
import { Link } from 'react-router-dom';
import { ROUTES } from '../../routes/paths';
import Button from '../../components/common/Button/Button';

const NotFoundPage = () => {
  return (
    <div className="min-h-[70vh] flex flex-col items-center justify-center text-center px-4">
      <h1 className="text-9xl font-bold text-blue-600 mb-4">404</h1>
      <h2 className="text-3xl font-semibold mb-6">Trang Kh√¥ng T√¨m Th·∫•y</h2>
      <p className="text-lg text-gray-600 max-w-md mb-8">
        Xin l·ªói, trang b·∫°n ƒëang t√¨m ki·∫øm kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c di chuy·ªÉn.
      </p>
      <div className="flex flex-col sm:flex-row gap-4">
        <Link to={ROUTES.HOME}>
          <Button variant="primary" size="lg">
            Quay L·∫°i Trang Ch·ªß
          </Button>
        </Link>
        <Link to={ROUTES.PRODUCTS}>
          <Button variant="outline" size="lg">
            Xem S·∫£n Ph·∫©m
          </Button>
        </Link>
      </div>
    </div>
  );
};

export default NotFoundPage;


--- File: client/src/pages/ProductDetail/index.js ---
// src/pages/ProductDetail/index.js
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { fetchProductById } from '../../store/slices/productSlice';
import { fetchProductReviews, submitProductReview } from '../../store/slices/reviewSlice';
import { addToCart } from '../../store/slices/cartSlice';
import MainLayout from '../../components/layout/MainLayout';
import { Button, LoadingSpinner } from '../../components/common';
import { formatPrice } from '../../utils/formatters';
import ReviewForm from '../../components/feature/Review/ReviewForm';
import ReviewList from '../../components/feature/Review/ReviewList';
import ReviewStats from '../../components/feature/Review/ReviewStats';
import { toast } from 'react-toastify';

const ProductDetailPage = () => {
  const { id } = useParams();
  const dispatch = useDispatch();
  const { product, loading, error } = useSelector((state) => state.products);
  const {
    reviews,
    stats: reviewStats,
    loading: reviewsLoading,
    error: reviewsError,
  } = useSelector((state) => state.review);
  const { isAuthenticated, user } = useSelector((state) => state.auth);
  const [quantity, setQuantity] = useState(1);
  const [selectedImage, setSelectedImage] = useState(0);
  const [isSubmittingReview, setIsSubmittingReview] = useState(false);

  useEffect(() => {
    if (id) {
      dispatch(fetchProductById(id));
      dispatch(fetchProductReviews(id));
    }

    // Scroll to top when component mounts
    window.scrollTo(0, 0);
  }, [dispatch, id]);

  const handleQuantityChange = (e) => {
    const value = parseInt(e.target.value);
    if (!isNaN(value) && value > 0 && value <= (product?.stock || 1)) {
      setQuantity(value);
    }
  };

  const handleAddToCart = () => {
    if (product) {
      dispatch(
        addToCart({
          productId: product.id,
          quantity,
          name: product.name,
          price: product.price,
          image: product.images[0]?.url || '/placeholder.png',
        })
      );
      toast.success('ƒê√£ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng!');
    }
  };

  const handleSubmitReview = async (reviewData) => {
    try {
      setIsSubmittingReview(true);
      await dispatch(submitProductReview({ ...reviewData, productId: id })).unwrap();
      toast.success('ƒê√°nh gi√° c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!');
      // Refresh reviews
      dispatch(fetchProductReviews(id));
    } catch (error) {
      toast.error(error || 'Kh√¥ng th·ªÉ g·ª≠i ƒë√°nh gi√°. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setIsSubmittingReview(false);
    }
  };

  const handleImageClick = (index) => {
    setSelectedImage(index);
  };

  if (loading) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4 flex justify-center">
          <LoadingSpinner />
        </div>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4">
          <div className="text-red-500">L·ªói: {error}</div>
        </div>
      </MainLayout>
    );
  }

  if (!product) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4">
          <div className="text-center">Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m.</div>
        </div>
      </MainLayout>
    );
  }

  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y ch∆∞a
  const hasUserReviewed = isAuthenticated && reviews.some((review) => review.userId === user?.id);

  return (
    <MainLayout>
      <div className="container mx-auto py-8 px-4">
        {/* Breadcrumb */}
        <div className="mb-6 text-sm text-gray-600">
          <a href="/" className="hover:text-blue-600">
            Trang ch·ªß
          </a>{' '}
          &gt;
          <a href="/products" className="hover:text-blue-600">
            {' '}
            S·∫£n ph·∫©m
          </a>{' '}
          &gt;
          <span className="text-gray-800"> {product.name}</span>
        </div>

        <div className="flex flex-col md:flex-row gap-8">
          {/* H√¨nh ·∫£nh s·∫£n ph·∫©m */}
          <div className="w-full md:w-1/2">
            <div className="bg-white rounded-lg overflow-hidden shadow-md">
              <img
                src={product.images[selectedImage]?.url || '/placeholder.png'}
                alt={product.name}
                className="w-full h-auto object-contain"
                style={{ maxHeight: '500px' }}
              />
            </div>

            {/* H√¨nh ·∫£nh ph·ª• */}
            {product.images.length > 1 && (
              <div className="grid grid-cols-5 gap-2 mt-4">
                {product.images.map((image, index) => (
                  <div
                    key={index}
                    className={`border rounded cursor-pointer overflow-hidden ${selectedImage === index ? 'border-blue-500 border-2' : ''}`}
                    onClick={() => handleImageClick(index)}
                  >
                    <img
                      src={image.url}
                      alt={image.alt || `${product.name} - ·∫¢nh ${index + 1}`}
                      className="w-full h-20 object-cover"
                    />
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Th√¥ng tin s·∫£n ph·∫©m */}
          <div className="w-full md:w-1/2">
            <h1 className="text-3xl font-bold mb-2">{product.name}</h1>
            <p className="text-gray-600 mb-2">Th∆∞∆°ng hi·ªáu: {product.brand}</p>

            {/* ƒê√°nh gi√° sao */}
            <div className="flex items-center mb-4">
              <div className="flex text-yellow-400 mr-2">
                {'‚òÖ'.repeat(Math.floor(product.ratings?.average || 0))}
                {'‚òÜ'.repeat(5 - Math.floor(product.ratings?.average || 0))}
              </div>
              <p className="text-gray-600">({product.ratings?.count || 0} ƒë√°nh gi√°)</p>
            </div>

            <div className="text-2xl font-bold text-blue-700 mb-4">
              {formatPrice(product.price)}
              {product.salePrice && product.salePrice < product.price && (
                <span className="text-gray-500 line-through ml-2 text-lg">
                  {formatPrice(product.salePrice)}
                </span>
              )}
            </div>

            {/* T√¨nh tr·∫°ng kho */}
            <div className="mb-4">
              <span className="font-semibold">T√¨nh tr·∫°ng: </span>
              {product.stock > 0 ? (
                <span className="text-green-600">C√≤n h√†ng ({product.stock})</span>
              ) : (
                <span className="text-red-600">H·∫øt h√†ng</span>
              )}
            </div>

            {/* M√¥ t·∫£ ng·∫Øn */}
            <div className="mb-6">
              <p>{product.description.short}</p>
            </div>

            {/* S·ªë l∆∞·ª£ng v√† th√™m v√†o gi·ªè h√†ng */}
            <div className="flex items-center mb-6">
              <div className="mr-4">
                <label htmlFor="quantity" className="block mb-1">
                  S·ªë l∆∞·ª£ng:
                </label>
                <div className="flex items-center border rounded">
                  <button
                    className="px-3 py-2 bg-gray-100 hover:bg-gray-200"
                    onClick={() => quantity > 1 && setQuantity(quantity - 1)}
                    disabled={quantity <= 1}
                  >
                    -
                  </button>
                  <input
                    type="number"
                    id="quantity"
                    min="1"
                    max={product.stock}
                    value={quantity}
                    onChange={handleQuantityChange}
                    className="w-16 border-x p-2 text-center"
                  />
                  <button
                    className="px-3 py-2 bg-gray-100 hover:bg-gray-200"
                    onClick={() => quantity < product.stock && setQuantity(quantity + 1)}
                    disabled={quantity >= product.stock}
                  >
                    +
                  </button>
                </div>
              </div>

              <Button
                variant="primary"
                size="lg"
                onClick={handleAddToCart}
                disabled={product.stock <= 0}
                className="flex-1"
              >
                {product.stock > 0 ? 'Th√™m v√†o gi·ªè h√†ng' : 'H·∫øt h√†ng'}
              </Button>
            </div>

            {/* T√≠nh nƒÉng s·∫£n ph·∫©m */}
            {product.features && product.features.length > 0 && (
              <div className="mb-6">
                <h3 className="text-lg font-semibold mb-2">T√≠nh nƒÉng n·ªïi b·∫≠t:</h3>
                <ul className="list-disc pl-5">
                  {product.features.map((feature, index) => (
                    <li key={index} className="mb-1">
                      {feature}
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* Ch√≠nh s√°ch b√°n h√†ng */}
            <div className="mt-6 bg-gray-50 p-4 rounded-lg">
              <h3 className="font-semibold mb-2">Ch√≠nh s√°ch mua h√†ng:</h3>
              <ul className="space-y-2">
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  Giao h√†ng to√†n qu·ªëc
                </li>
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  ƒê·ªïi tr·∫£ trong v√≤ng 7 ng√†y
                </li>
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  B·∫£o h√†nh ch√≠nh h√£ng 12 th√°ng
                </li>
              </ul>
            </div>
          </div>
        </div>

        {/* Tabs cho m√¥ t·∫£ v√† th√¥ng s·ªë k·ªπ thu·∫≠t */}
        <div className="mt-12">
          <div className="border-b border-gray-200">
            <nav className="-mb-px flex space-x-8">
              <a
                href="#description"
                className="border-b-2 border-blue-500 py-4 px-1 text-sm font-medium text-blue-600"
              >
                M√¥ t·∫£ s·∫£n ph·∫©m
              </a>
              <a
                href="#specifications"
                className="border-b-2 border-transparent py-4 px-1 text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300"
              >
                Th√¥ng s·ªë k·ªπ thu·∫≠t
              </a>
              <a
                href="#reviews"
                className="border-b-2 border-transparent py-4 px-1 text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300"
              >
                ƒê√°nh gi√° ({product.ratings?.count || 0})
              </a>
            </nav>
          </div>

          {/* M√¥ t·∫£ chi ti·∫øt */}
          <div id="description" className="mt-6">
            <div className="bg-white p-6 rounded-lg shadow">
              <p className="whitespace-pre-line">{product.description.long}</p>
            </div>
          </div>

          {/* Th√¥ng s·ªë k·ªπ thu·∫≠t */}
          {product.specifications && Object.keys(product.specifications).length > 0 && (
            <div id="specifications" className="mt-10">
              <h2 className="text-2xl font-bold mb-4">Th√¥ng s·ªë k·ªπ thu·∫≠t</h2>
              <div className="bg-white rounded-lg shadow overflow-hidden">
                <table className="w-full border-collapse">
                  <tbody>
                    {Object.entries(product.specifications).map(([key, value]) => (
                      <tr key={key} className="border-b">
                        <td className="py-3 px-6 bg-gray-50 font-medium capitalize w-1/3">
                          {key.replace(/([A-Z])/g, ' $1').toLowerCase()}
                        </td>
                        <td className="py-3 px-6">{value}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {/* ƒê√°nh gi√° s·∫£n ph·∫©m */}
          <div id="reviews" className="mt-10">
            <h2 className="text-2xl font-bold mb-6">ƒê√°nh gi√° s·∫£n ph·∫©m</h2>

            {/* Th·ªëng k√™ ƒë√°nh gi√° */}
            <ReviewStats stats={reviewStats} />

            {/* Form ƒë√°nh gi√° - ch·ªâ hi·ªÉn th·ªã cho ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p v√† ch∆∞a ƒë√°nh gi√° */}
            {isAuthenticated && !hasUserReviewed && (
              <div className="mb-8 mt-6">
                <h3 className="text-lg font-semibold mb-3">Vi·∫øt ƒë√°nh gi√° c·ªßa b·∫°n</h3>
                <ReviewForm
                  productId={product.id}
                  onSubmit={handleSubmitReview}
                  isSubmitting={isSubmittingReview}
                />
              </div>
            )}

            {/* Danh s√°ch ƒë√°nh gi√° */}
            <ReviewList reviews={reviews} loading={reviewsLoading} error={reviewsError} />
          </div>
        </div>

        {/* S·∫£n ph·∫©m li√™n quan */}
        <div className="mt-16">
          <h2 className="text-2xl font-bold mb-6">S·∫£n ph·∫©m li√™n quan</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {/* Placeholder cho s·∫£n ph·∫©m li√™n quan - s·∫Ω ƒë∆∞·ª£c thay th·∫ø b·∫±ng d·ªØ li·ªáu th·ª±c */}
            {[1, 2, 3, 4].map((item) => (
              <div key={item} className="bg-white rounded-lg shadow overflow-hidden">
                <div className="p-4">
                  <div className="aspect-w-1 aspect-h-1 bg-gray-200 mb-3"></div>
                  <h3 className="font-medium">S·∫£n ph·∫©m li√™n quan {item}</h3>
                  <p className="text-blue-600 font-bold mt-2">1.000.000‚Ç´</p>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProductDetailPage;


--- File: client/src/pages/Products/index.js ---
// src/pages/Products/index.js
// Trang hi·ªÉn th·ªã danh s√°ch s·∫£n ph·∫©m, bao g·ªìm b·ªô l·ªçc v√† breadcrumb

import React, { useEffect, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import { useAppSelector, useAppDispatch } from '../../store/hooks';
import { fetchProducts } from '../../store/slices/productSlice';
import ProductList from '../../components/feature/Product/ProductList';
import ProductFilter from '../../components/feature/Product/ProductFilter';
import CategoryBreadcrumb from '../../components/feature/Category/CategoryBreadcrumb';
import MainLayout from '../../components/layout/MainLayout';
import LoadingSpinner from '../../components/common/LoadingSpiner';

const ProductsPage = () => {
  const { categoryId } = useParams();
  const dispatch = useAppDispatch();
  const { products, isLoading, filters } = useAppSelector((state) => state.products);

  // Fetch s·∫£n ph·∫©m khi component mount ho·∫∑c categoryId thay ƒë·ªïi
  useEffect(() => {
    dispatch(fetchProducts({ categoryId }));
  }, [dispatch, categoryId]);

  // S·ª≠ d·ª•ng useMemo ƒë·ªÉ t·ªëi ∆∞u h√≥a filtering
  const filteredProducts = useMemo(() => {
    if (!products.length) return [];

    return products.filter((product) => {
      // Filter by price range
      if (filters.minPrice && product.price < filters.minPrice) {
        return false;
      }
      if (filters.maxPrice && product.price > filters.maxPrice) {
        return false;
      }

      // Filter by brand
      if (filters.brand && product.brand !== filters.brand) {
        return false;
      }

      // Filter by stock
      if (filters.inStock && !product.inStock) {
        return false;
      }

      return true;
    });
  }, [products, filters]);

  return (
    <MainLayout>
      <div className="container mx-auto py-8 px-4">
        <CategoryBreadcrumb categoryId={categoryId} />
        <h1 className="text-3xl font-bold mb-6">S·∫£n Ph·∫©m Billiard</h1>

        <div className="flex flex-col md:flex-row gap-6">
          <div className="w-full md:w-1/4">
            <ProductFilter />
          </div>

          <div className="w-full md:w-3/4">
            {isLoading ? (
              <div className="flex justify-center py-12">
                <LoadingSpinner />
              </div>
            ) : (
              <ProductList products={filteredProducts} />
            )}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProductsPage;


--- File: client/src/pages/Profile/OrderDetail.js ---
// src/pages/Profile/OrderDetail.js
import React from 'react';
import { Link, useParams } from 'react-router-dom';
import MainLayout from '../../components/layout/MainLayout';
import OrderDetail from '../../components/feature/User/OrderDetail';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const OrderDetailPage = () => {
  const { orderId } = useParams();

  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center mb-6">
          <Link to="/profile/orders" className="text-blue-600 hover:text-blue-800 mr-2">
            ‚Üê Quay l·∫°i
          </Link>
          <h1 className="text-2xl font-bold">Chi ti·∫øt ƒë∆°n h√†ng</h1>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            <OrderDetail />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default OrderDetailPage;


--- File: client/src/pages/Profile/Orders.js ---
// src/pages/Profile/Orders.js
import React from 'react';
import MainLayout from '../../components/layout/MainLayout';
import UserOrders from '../../components/feature/User/UserOrders';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const OrdersPage = () => {
  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">ƒê∆°n h√†ng c·ªßa t√¥i</h1>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            <UserOrders />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default OrdersPage;


--- File: client/src/pages/Profile/index.js ---
// src/pages/Profile/index.js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUserProfile } from '../../store/slices/userSlice';
import MainLayout from '../../components/layout/MainLayout';
import UserProfile from '../../components/feature/User/UserProfile';
import { LoadingSpinner } from '../../components/common/LoadingSpinner';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const ProfilePage = () => {
  const dispatch = useDispatch();
  const { loading, error } = useSelector((state) => state.user);

  useEffect(() => {
    dispatch(fetchUserProfile());
  }, [dispatch]);

  if (loading) {
    return (
      <MainLayout>
        <div className="flex justify-center items-center py-12">
          <LoadingSpinner />
        </div>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">T√†i kho·∫£n c·ªßa t√¥i</h1>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            {error ? (
              <div className="bg-red-100 text-red-700 p-4 rounded">{error}</div>
            ) : (
              <UserProfile />
            )}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProfilePage;


--- File: client/src/pages/Search/index.js ---
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useLocation } from 'react-router-dom';
import { searchProducts, setKeyword } from '../../store/slices/searchSlice';
import ProductCard from '../../components/feature/Product/ProductCard';
import SearchFilters from '../../components/feature/Search/SearchFilters';
import Breadcrumb from '../../components/common/Breadcrumb';
import LoadingSpinner from '../../components/common/LoadingSpinner';
import EmptyState from '../../components/common/Empty';
import ErrorMessage from '../../components/common/ErrorMessage';

const SearchPage = () => {
  const dispatch = useDispatch();
  const location = useLocation();
  const { results, loading, error, keyword } = useSelector((state) => state.search);

  // Extract search query from URL
  useEffect(() => {
    const searchParams = new URLSearchParams(location.search);
    const queryParam = searchParams.get('q');

    if (queryParam) {
      dispatch(setKeyword(queryParam));
      dispatch(searchProducts(queryParam));
    }
  }, [dispatch, location.search]);

  return (
    <div className="container mx-auto px-4 py-8">
      <Breadcrumb
        items={[
          { label: 'Trang ch·ªß', path: '/' },
          { label: 'T√¨m ki·∫øm', path: '/search' },
          { label: keyword, path: `/search?q=${encodeURIComponent(keyword)}` },
        ]}
      />

      <h1 className="text-2xl font-bold mb-6">K·∫øt qu·∫£ t√¨m ki·∫øm cho `{keyword}`</h1>

      <div className="flex flex-col md:flex-row gap-6">
        {/* Sidebar with filters */}
        <div className="w-full md:w-1/4 lg:w-1/5">
          <SearchFilters />
        </div>

        {/* Search results */}
        <div className="w-full md:w-3/4 lg:w-4/5">
          {loading ? (
            <LoadingSpinner />
          ) : error ? (
            <ErrorMessage message={error} />
          ) : results.length === 0 ? (
            <EmptyState message={`Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi "${keyword}"`} />
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {results.map((product) => (
                <ProductCard key={product.id} product={product} />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default SearchPage;


--- File: client/src/services/adminService.js ---
// src/services/adminService.js

import api from './api';

const adminService = {
  // Dashboard Stats
  getDashboardStats: async () => {
    try {
      const response = await api.get('/admin/dashboard/stats');
      return response.data;
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      throw error;
    }
  },

  // Recent Orders
  getRecentOrders: async () => {
    try {
      const response = await api.get('/admin/orders/recent');
      return response.data;
    } catch (error) {
      console.error('Error fetching recent orders:', error);
      throw error;
    }
  },

  // Sales Data
  getSalesData: async (period = 'monthly') => {
    try {
      const response = await api.get(`/admin/dashboard/sales?period=${period}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching sales data:', error);
      throw error;
    }
  },

  // Product Management
  getProducts: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/products?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching products:', error);
      throw error;
    }
  },

  // Order Management
  getOrders: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/orders?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching orders:', error);
      throw error;
    }
  },

  // User Management
  getUsers: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/users?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching users:', error);
      throw error;
    }
  },
};

export default adminService;


--- File: client/src/services/api.js ---
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { refreshToken } from '../utils/authToken';

// URL c∆° s·ªü c·ªßa API
const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Truy v·∫•n c∆° s·ªü t√πy ch·ªânh v·ªõi kh·∫£ nƒÉng l√†m m·ªõi token
const baseQueryWithReauth = async (args, api, extraOptions) => {
  const baseQuery = fetchBaseQuery({
    baseUrl,
    prepareHeaders: (headers, { getState }) => {
      // L·∫•y token t·ª´ state
      const token = getState().auth.token;

      // N·∫øu c√≥ token, th√™m v√†o header
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }

      return headers;
    },
  });

  // Th·ª≠ nghi·ªám ƒë·∫ßu ti√™n v·ªõi token hi·ªán t·∫°i
  let result = await baseQuery(args, api, extraOptions);

  // N·∫øu nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi 401 Unauthorized, th·ª≠ l√†m m·ªõi token
  if (result.error && result.error.status === 401) {
    try {
      // C·ªë g·∫Øng l·∫•y token m·ªõi
      const newToken = await refreshToken();

      // L∆∞u tr·ªØ token m·ªõi
      api.dispatch({
        type: 'auth/tokenRefreshed',
        payload: newToken,
      });

      // Th·ª≠ l·∫°i truy v·∫•n ban ƒë·∫ßu v·ªõi token m·ªõi
      result = await baseQuery(args, api, extraOptions);
    } catch (refreshError) {
      // X·ª≠ l√Ω khi l√†m m·ªõi token th·∫•t b·∫°i - chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p
      window.location.href = '/login';
    }
  }

  return result;
};

// RTK Query API
export const api = createApi({
  reducerPath: 'api',
  baseQuery: baseQueryWithReauth,
  tagTypes: ['Product', 'Category', 'User', 'Cart', 'Order', 'Review'],
  endpoints: () => ({}),
});

export default api;


--- File: client/src/services/authService.js ---
import axios from 'axios';
import { api } from './api';

// API base URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
const AUTH_URL = `${API_URL}/auth`;

// Auth API endpoints
export const authApi = api.injectEndpoints({
  endpoints: (builder) => ({
    login: builder.mutation({
      query: (credentials) => ({
        url: '/auth/login',
        method: 'POST',
        body: credentials,
      }),
    }),
    register: builder.mutation({
      query: (userData) => ({
        url: '/auth/register',
        method: 'POST',
        body: userData,
      }),
    }),
    forgotPassword: builder.mutation({
      query: (email) => ({
        url: '/auth/forgot-password',
        method: 'POST',
        body: { email },
      }),
    }),
    resetPassword: builder.mutation({
      query: ({ token, password }) => ({
        url: '/auth/reset-password',
        method: 'POST',
        body: { token, password },
      }),
    }),
    getCurrentUser: builder.query({
      query: () => '/auth/me',
      providesTags: ['User'],
    }),
  }),
});

// Export hooks
export const {
  useLoginMutation,
  useRegisterMutation,
  useForgotPasswordMutation,
  useResetPasswordMutation,
  useGetCurrentUserQuery,
} = authApi;

// Regular API service for use with Redux Thunk
const authService = {
  // ƒêƒÉng nh·∫≠p
  login: async (credentials) => {
    return await axios.post(`${AUTH_URL}/login`, credentials);
  },

  // ƒêƒÉng k√Ω
  register: async (userData) => {
    return await axios.post(`${AUTH_URL}/register`, userData);
  },

  // Qu√™n m·∫≠t kh·∫©u
  forgotPassword: async (email) => {
    return await axios.post(`${AUTH_URL}/forgot-password`, { email });
  },

  // ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u
  resetPassword: async (token, password) => {
    return await axios.post(`${AUTH_URL}/reset-password`, { token, password });
  },

  // L·∫•y th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i
  getCurrentUser: async () => {
    return await axios.get(`${AUTH_URL}/me`);
  },

  // C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
  updateProfile: async (userData) => {
    return await axios.put(`${API_URL}/users/profile`, userData);
  },

  // ƒê·ªïi m·∫≠t kh·∫©u
  changePassword: async (passwordData) => {
    return await axios.put(`${API_URL}/users/password`, passwordData);
  },
};

export default authService;


--- File: client/src/services/cartService.js ---
import api from './api';
import { isAuthenticated } from '../utils/authToken';

export const cartService = {
  // Get cart (for authenticated users)
  async getCart() {
    if (!isAuthenticated()) {
      // Return local cart for guest users
      return this.getLocalCart();
    }

    try {
      const { data } = await api.get('/carts/me');
      return data;
    } catch (error) {
      console.error('Error fetching cart:', error);
      throw error;
    }
  },

  // Add item to cart
  async addToCart(productId, quantity = 1) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.addToLocalCart(productId, quantity);
    }

    try {
      const { data } = await api.post('/carts/items', { productId, quantity });
      return data;
    } catch (error) {
      console.error('Error adding item to cart:', error);
      throw error;
    }
  },

  // Update cart item
  async updateCartItem(productId, quantity) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.updateLocalCartItem(productId, quantity);
    }

    try {
      const { data } = await api.put(`/carts/items/${productId}`, { quantity });
      return data;
    } catch (error) {
      console.error('Error updating cart item:', error);
      throw error;
    }
  },

  // Remove item from cart
  async removeFromCart(productId) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.removeFromLocalCart(productId);
    }

    try {
      const { data } = await api.delete(`/carts/items/${productId}`);
      return data;
    } catch (error) {
      console.error('Error removing item from cart:', error);
      throw error;
    }
  },

  // Clear cart
  async clearCart() {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.clearLocalCart();
    }

    try {
      const { data } = await api.delete('/carts/items');
      return data;
    } catch (error) {
      console.error('Error clearing cart:', error);
      throw error;
    }
  },

  // Local cart methods (for guest users)
  getLocalCart() {
    const cartJson = localStorage.getItem('guest_cart');
    return cartJson ? JSON.parse(cartJson) : { items: [] };
  },

  saveLocalCart(cart) {
    localStorage.setItem('guest_cart', JSON.stringify(cart));
    return cart;
  },

  async addToLocalCart(productId, quantity) {
    // Fetch product details first
    const { data: product } = await api.get(`/products/${productId}`);

    // Get current cart
    const cart = this.getLocalCart();

    // Check if product already exists in cart
    const existingItemIndex = cart.items.findIndex((item) => item.product.id === productId);

    if (existingItemIndex !== -1) {
      // Update quantity if product already exists
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item to cart
      cart.items.push({
        product,
        quantity,
      });
    }

    // Save updated cart
    return this.saveLocalCart(cart);
  },

  updateLocalCartItem(productId, quantity) {
    // Get current cart
    const cart = this.getLocalCart();

    // Find item in cart
    const itemIndex = cart.items.findIndex((item) => item.product.id === productId);

    if (itemIndex !== -1) {
      // Update quantity
      cart.items[itemIndex].quantity = quantity;

      // Save updated cart
      return this.saveLocalCart(cart);
    }

    return cart;
  },

  removeFromLocalCart(productId) {
    // Get current cart
    const cart = this.getLocalCart();

    // Remove item from cart
    cart.items = cart.items.filter((item) => item.product.id !== productId);

    // Save updated cart
    return this.saveLocalCart(cart);
  },

  clearLocalCart() {
    // Clear cart
    const emptyCart = { items: [] };

    // Save empty cart
    return this.saveLocalCart(emptyCart);
  },
};


--- File: client/src/services/notificationService.js ---
// services/notificationService.js
import api from './api';

/**
 * Service for notification-related API calls
 */
const notificationService = {
  /**
   * Get all notifications for current user
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Object>} Notifications with pagination data
   */
  async getNotifications(params = {}) {
    try {
      const response = await api.get('/notifications', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching notifications:', error);
      throw error;
    }
  },

  /**
   * Get unread notifications count
   * @returns {Promise<number>} Number of unread notifications
   */
  async getUnreadCount() {
    try {
      const response = await api.get('/notifications/unread/count');
      return response.data.count;
    } catch (error) {
      console.error('Error fetching unread count:', error);
      throw error;
    }
  },

  /**
   * Mark notification as read
   * @param {string} notificationId - ID of the notification
   * @returns {Promise<Object>} Updated notification
   */
  async markAsRead(notificationId) {
    try {
      const response = await api.put(`/notifications/${notificationId}/read`);
      return response.data;
    } catch (error) {
      console.error(`Error marking notification ${notificationId} as read:`, error);
      throw error;
    }
  },

  /**
   * Mark all notifications as read
   * @returns {Promise<Object>} Success message
   */
  async markAllAsRead() {
    try {
      const response = await api.put('/notifications/read-all');
      return response.data;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  },

  /**
   * Delete a notification
   * @param {string} notificationId - ID of the notification
   * @returns {Promise<Object>} Success message
   */
  async deleteNotification(notificationId) {
    try {
      const response = await api.delete(`/notifications/${notificationId}`);
      return response.data;
    } catch (error) {
      console.error(`Error deleting notification ${notificationId}:`, error);
      throw error;
    }
  },

  /**
   * Delete all notifications
   * @returns {Promise<Object>} Success message
   */
  async deleteAllNotifications() {
    try {
      const response = await api.delete('/notifications');
      return response.data;
    } catch (error) {
      console.error('Error deleting all notifications:', error);
      throw error;
    }
  },

  /**
   * Update notification preferences
   * @param {Object} preferences - Notification preferences
   * @returns {Promise<Object>} Updated preferences
   */
  async updatePreferences(preferences) {
    try {
      const response = await api.put('/notifications/preferences', preferences);
      return response.data;
    } catch (error) {
      console.error('Error updating notification preferences:', error);
      throw error;
    }
  },

  /**
   * Get notification preferences
   * @returns {Promise<Object>} Current notification preferences
   */
  async getPreferences() {
    try {
      const response = await api.get('/notifications/preferences');
      return response.data;
    } catch (error) {
      console.error('Error fetching notification preferences:', error);
      throw error;
    }
  },

  /**
   * Initialize WebSocket connection for real-time notifications
   * @returns {WebSocket} WebSocket connection
   */
  initializeWebSocket() {
    const token = localStorage.getItem('token');
    if (!token) {
      console.warn('No authentication token available for WebSocket connection');
      return null;
    }

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = process.env.REACT_APP_WS_HOST || window.location.host;
    const wsUrl = `${wsProtocol}//${wsHost}/ws/notifications?token=${token}`;

    try {
      const socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log('WebSocket connection established for notifications');
      };

      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      socket.onclose = (event) => {
        console.log('WebSocket connection closed:', event.code, event.reason);

        // Attempt to reconnect after 5 seconds if connection was closed unexpectedly
        if (event.code !== 1000) {
          setTimeout(() => {
            console.log('Attempting to reconnect WebSocket...');
            this.initializeWebSocket();
          }, 5000);
        }
      };

      return socket;
    } catch (error) {
      console.error('Error initializing WebSocket:', error);
      return null;
    }
  },
};

export default notificationService;


--- File: client/src/services/orderService.js ---
// src/services/orderService.js
import api from './api';

export const orderService = {
  // T·∫°o ƒë∆°n h√†ng m·ªõi
  async createOrder(orderData) {
    try {
      const response = await api.post('/orders', orderData);
      return response.data.data;
    } catch (error) {
      console.error('Error creating order:', error);
      throw error;
    }
  },

  // L·∫•y danh s√°ch ƒë∆°n h√†ng c·ªßa ng∆∞·ªùi d√πng
  async getUserOrders() {
    try {
      const response = await api.get('/orders');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user orders:', error);
      throw error;
    }
  },

  // L·∫•y th√¥ng tin chi ti·∫øt ƒë∆°n h√†ng
  async getOrderById(orderId) {
    try {
      const response = await api.get(`/orders/${orderId}`);
      return response.data.data;
    } catch (error) {
      console.error(`Error fetching order ${orderId}:`, error);
      throw error;
    }
  },

  // H·ªßy ƒë∆°n h√†ng
  async cancelOrder(orderId) {
    try {
      const response = await api.post(`/orders/${orderId}/cancel`);
      return response.data.data;
    } catch (error) {
      console.error(`Error cancelling order ${orderId}:`, error);
      throw error;
    }
  },
};


--- File: client/src/services/paymentService.js ---
// src/services/paymentService.js
// File n√†y ch·ª©a c√°c d·ªãch v·ª• li√™n quan ƒë·∫øn thanh to√°n trong ·ª©ng d·ª•ng
// H·ªó tr·ª£ nhi·ªÅu c·ªïng thanh to√°n nh∆∞ VNPay, Momo, v.v.

import api from './api';

const paymentService = {
  // === VNPay Payment Methods ===

  // T·∫°o URL thanh to√°n VNPay
  createVnpayPaymentUrl: async (orderId, amount, orderInfo) => {
    try {
      const response = await api.post('/payments/vnpay/create-payment-url', {
        orderId,
        amount,
        orderInfo,
      });
      return response.data;
    } catch (error) {
      console.error('Error creating VNPay payment URL:', error);
      throw error;
    }
  },

  // X√°c th·ª±c k·∫øt qu·∫£ thanh to√°n t·ª´ VNPay
  verifyVnpayReturn: async (vnpParams) => {
    try {
      const response = await api.post('/payments/vnpay/verify-return', vnpParams);
      return response.data;
    } catch (error) {
      console.error('Error verifying VNPay return:', error);
      throw error;
    }
  },

  // === Momo Payment Methods ===

  // T·∫°o URL thanh to√°n Momo
  createMomoPaymentUrl: async (orderId, amount, orderInfo) => {
    try {
      const response = await api.post('/payments/momo/create-payment-url', {
        orderId,
        amount,
        orderInfo,
      });
      return response.data;
    } catch (error) {
      console.error('Error creating Momo payment URL:', error);
      throw error;
    }
  },

  // X√°c th·ª±c k·∫øt qu·∫£ thanh to√°n t·ª´ Momo
  verifyMomoReturn: async (momoParams) => {
    try {
      const response = await api.post('/payments/momo/verify-return', momoParams);
      return response.data;
    } catch (error) {
      console.error('Error verifying Momo return:', error);
      throw error;
    }
  },

  // === Generic Payment Methods ===

  // L·∫•y l·ªãch s·ª≠ thanh to√°n c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i
  getPaymentHistory: async () => {
    try {
      const response = await api.get('/payments/history');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching payment history:', error);
      throw error;
    }
  },

  // L·∫•y chi ti·∫øt m·ªôt giao d·ªãch thanh to√°n
  getPaymentDetail: async (paymentId) => {
    try {
      const response = await api.get(`/payments/${paymentId}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching payment detail:', error);
      throw error;
    }
  },

  // H·ªßy m·ªôt giao d·ªãch thanh to√°n
  cancelPayment: async (paymentId, reason) => {
    try {
      const response = await api.post(`/payments/${paymentId}/cancel`, { reason });
      return response.data.data;
    } catch (error) {
      console.error('Error canceling payment:', error);
      throw error;
    }
  },
};

export default paymentService;


--- File: client/src/services/productService.js ---
import axios from 'axios';
import { api } from './api';

// API base URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
const PRODUCTS_URL = `${API_URL}/products`;
const CATEGORIES_URL = `${API_URL}/categories`;

// Products API endpoints
export const productApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: (params) => ({
        url: '/products',
        params,
      }),
      providesTags: (result) =>
        result
          ? [
              ...result.products.map(({ id }) => ({ type: 'Product', id })),
              { type: 'Product', id: 'LIST' },
            ]
          : [{ type: 'Product', id: 'LIST' }],
    }),
    getProductById: builder.query({
      query: (id) => `/products/${id}`,
      providesTags: (result, error, id) => [{ type: 'Product', id }],
    }),
    getCategories: builder.query({
      query: () => '/categories',
      providesTags: [{ type: 'Category', id: 'LIST' }],
    }),
    getProductReviews: builder.query({
      query: (id) => `/products/${id}/reviews`,
      providesTags: (result, error, id) => [{ type: 'Review', id: `product-${id}` }],
    }),
  }),
});

// Export hooks
export const {
  useGetProductsQuery,
  useGetProductByIdQuery,
  useGetCategoriesQuery,
  useGetProductReviewsQuery,
} = productApi;

// Regular API service for use with Redux Thunk
const productService = {
  /**
   * L·∫•y danh s√°ch s·∫£n ph·∫©m
   * @param {Object} params - Tham s·ªë l·ªçc v√† ph√¢n trang
   * @returns {Promise<Object>} Danh s√°ch s·∫£n ph·∫©m v√† th√¥ng tin ph√¢n trang
   */
  getProducts: async (params = {}) => {
    const response = await api.get('/products', { params });
    return response.data;
  },

  /**
   * L·∫•y chi ti·∫øt s·∫£n ph·∫©m theo ID
   * @param {string} id - ID s·∫£n ph·∫©m
   * @returns {Promise<Object>} Th√¥ng tin chi ti·∫øt s·∫£n ph·∫©m
   */
  getProductById: async (id) => {
    const response = await api.get(`/products/${id}`);
    return response.data;
  },

  /**
   * L·∫•y s·∫£n ph·∫©m theo danh m·ª•c
   * @param {string} categoryId - ID danh m·ª•c
   * @param {Object} params - Tham s·ªë l·ªçc v√† ph√¢n trang
   * @returns {Promise<Object>} Danh s√°ch s·∫£n ph·∫©m v√† th√¥ng tin ph√¢n trang
   */
  getProductsByCategory: async (categoryId, params = {}) => {
    const response = await api.get(`/categories/${categoryId}/products`, { params });
    return response.data;
  },

  /**
   * T√¨m ki·∫øm s·∫£n ph·∫©m
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @param {Object} params - Tham s·ªë l·ªçc v√† ph√¢n trang
   * @returns {Promise<Object>} K·∫øt qu·∫£ t√¨m ki·∫øm
   */
  searchProducts: async (query, params = {}) => {
    const response = await api.get('/products/search', {
      params: {
        q: query,
        ...params,
      },
    });
    return response.data;
  },
};

export default productService;


--- File: client/src/services/reviewService.js ---
// src/services/reviewService.js
import api from './api';

export const reviewService = {
  // L·∫•y ƒë√°nh gi√° c·ªßa s·∫£n ph·∫©m
  async getProductReviews(productId) {
    try {
      const response = await api.get(`/products/${productId}/reviews`);
      return response.data.data;
    } catch (error) {
      console.error(`Error fetching reviews for product ${productId}:`, error);
      throw error;
    }
  },

  // T·∫°o ƒë√°nh gi√° m·ªõi
  async createReview(reviewData) {
    try {
      const response = await api.post(`/products/${reviewData.productId}/reviews`, reviewData);
      return response.data.data;
    } catch (error) {
      console.error('Error creating review:', error);
      throw error;
    }
  },

  // L·∫•y ƒë√°nh gi√° c·ªßa ng∆∞·ªùi d√πng
  async getUserReviews() {
    try {
      const response = await api.get('/reviews/user');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user reviews:', error);
      throw error;
    }
  },

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  async updateReview(reviewId, reviewData) {
    try {
      const response = await api.put(`/reviews/${reviewId}`, reviewData);
      return response.data.data;
    } catch (error) {
      console.error(`Error updating review ${reviewId}:`, error);
      throw error;
    }
  },

  // X√≥a ƒë√°nh gi√°
  async deleteReview(reviewId) {
    try {
      const response = await api.delete(`/reviews/${reviewId}`);
      return response.data.data;
    } catch (error) {
      console.error(`Error deleting review ${reviewId}:`, error);
      throw error;
    }
  },
};


--- File: client/src/services/userService.js ---
// services/userService.js
import api from './api';

/**
 * Service for user-related API calls
 */
const userService = {
  /**
   * Get current user profile
   * @returns {Promise<Object>} User profile data
   */
  async getCurrentUser() {
    try {
      const response = await api.get('/users/me');
      return response.data;
    } catch (error) {
      console.error('Error fetching user profile:', error);
      throw error;
    }
  },

  /**
   * Update user profile
   * @param {Object} userData - User data to update
   * @returns {Promise<Object>} Updated user data
   */
  async updateProfile(userData) {
    try {
      const response = await api.put('/users/me', userData);
      return response.data;
    } catch (error) {
      console.error('Error updating user profile:', error);
      throw error;
    }
  },

  /**
   * Change user password
   * @param {Object} passwordData - Contains current and new password
   * @returns {Promise<Object>} Success message
   */
  async changePassword(passwordData) {
    try {
      const response = await api.put('/users/change-password', passwordData);
      return response.data;
    } catch (error) {
      console.error('Error changing password:', error);
      throw error;
    }
  },

  /**
   * Get user order history
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Array>} List of user orders
   */
  async getOrders(params = {}) {
    try {
      const response = await api.get('/users/orders', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching user orders:', error);
      throw error;
    }
  },

  /**
   * Get specific order details
   * @param {string} orderId - ID of the order
   * @returns {Promise<Object>} Order details
   */
  async getOrderDetails(orderId) {
    try {
      const response = await api.get(`/users/orders/${orderId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching order details for order ${orderId}:`, error);
      throw error;
    }
  },

  /**
   * Get user reviews
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Array>} List of user reviews
   */
  async getReviews(params = {}) {
    try {
      const response = await api.get('/users/reviews', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching user reviews:', error);
      throw error;
    }
  },

  /**
   * Upload user avatar
   * @param {FormData} formData - Form data containing the avatar image
   * @returns {Promise<Object>} Updated user data with new avatar URL
   */
  async uploadAvatar(formData) {
    try {
      const response = await api.post('/users/avatar', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading avatar:', error);
      throw error;
    }
  },

  /**
   * Get user shipping addresses
   * @returns {Promise<Array>} List of user addresses
   */
  async getAddresses() {
    try {
      const response = await api.get('/users/addresses');
      return response.data;
    } catch (error) {
      console.error('Error fetching addresses:', error);
      throw error;
    }
  },

  /**
   * Add new shipping address
   * @param {Object} addressData - Address information
   * @returns {Promise<Object>} Created address
   */
  async addAddress(addressData) {
    try {
      const response = await api.post('/users/addresses', addressData);
      return response.data;
    } catch (error) {
      console.error('Error adding address:', error);
      throw error;
    }
  },

  /**
   * Update existing shipping address
   * @param {string} addressId - ID of the address
   * @param {Object} addressData - Updated address information
   * @returns {Promise<Object>} Updated address
   */
  async updateAddress(addressId, addressData) {
    try {
      const response = await api.put(`/users/addresses/${addressId}`, addressData);
      return response.data;
    } catch (error) {
      console.error(`Error updating address ${addressId}:`, error);
      throw error;
    }
  },

  /**
   * Delete shipping address
   * @param {string} addressId - ID of the address
   * @returns {Promise<Object>} Success message
   */
  async deleteAddress(addressId) {
    try {
      const response = await api.delete(`/users/addresses/${addressId}`);
      return response.data;
    } catch (error) {
      console.error(`Error deleting address ${addressId}:`, error);
      throw error;
    }
  },
};

export default userService;


--- File: client/src/services/wishlistService.js ---
// services/wishlistService.js
import api from './api';

/**
 * Service for wishlist-related API calls
 */
const wishlistService = {
  /**
   * Get all wishlist items
   * @returns {Promise<Array>} List of wishlist items
   */
  async getWishlist() {
    try {
      const response = await api.get('/wishlist');
      return response.data;
    } catch (error) {
      console.error('Error fetching wishlist:', error);
      throw error;
    }
  },

  /**
   * Add product to wishlist
   * @param {string} productId - Product ID to add to wishlist
   * @returns {Promise<Object>} Added wishlist item or success message
   */
  async addToWishlist(productId) {
    try {
      const response = await api.post('/wishlist', { productId });
      return response.data;
    } catch (error) {
      console.error('Error adding to wishlist:', error);
      throw error;
    }
  },

  /**
   * Remove product from wishlist
   * @param {string} productId - Product ID to remove from wishlist
   * @returns {Promise<Object>} Success message
   */
  async removeFromWishlist(productId) {
    try {
      const response = await api.delete(`/wishlist/${productId}`);
      return response.data;
    } catch (error) {
      console.error('Error removing from wishlist:', error);
      throw error;
    }
  },

  /**
   * Check if product is in wishlist
   * @param {string} productId - Product ID to check
   * @returns {Promise<boolean>} True if product is in wishlist
   */
  async checkInWishlist(productId) {
    try {
      const response = await api.get(`/wishlist/check/${productId}`);
      return response.data.inWishlist;
    } catch (error) {
      console.error('Error checking wishlist status:', error);
      throw error;
    }
  },

  /**
   * Clear entire wishlist
   * @returns {Promise<Object>} Success message
   */
  async clearWishlist() {
    try {
      const response = await api.delete('/wishlist');
      return response.data;
    } catch (error) {
      console.error('Error clearing wishlist:', error);
      throw error;
    }
  },

  /**
   * Move all wishlist items to cart
   * @returns {Promise<Object>} Success message and cart information
   */
  async moveAllToCart() {
    try {
      const response = await api.post('/wishlist/move-to-cart');
      return response.data;
    } catch (error) {
      console.error('Error moving wishlist to cart:', error);
      throw error;
    }
  },

  /**
   * Move a single wishlist item to cart
   * @param {string} productId - Product ID to move to cart
   * @returns {Promise<Object>} Success message and cart information
   */
  async moveToCart(productId) {
    try {
      const response = await api.post(`/wishlist/move-to-cart/${productId}`);
      return response.data;
    } catch (error) {
      console.error('Error moving item to cart:', error);
      throw error;
    }
  },
};

export default wishlistService;


--- File: client/src/store/hooks.js ---
import { useDispatch, useSelector } from 'react-redux';

// S·ª≠ d·ª•ng hooks n√†y thay v√¨ useDispatch v√† useSelector th√¥ng th∆∞·ªùng
export const useAppDispatch = () => useDispatch();
export const useAppSelector = useSelector;


--- File: client/src/store/index.js ---
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authReducer, { authMiddleware } from './slices/authSlice';
import cartReducer from './slices/cartSlice';
import productReducer from './slices/productSlice';
import uiReducer, { uiMiddleware } from './slices/uiSlice';
import orderReducer from './slices/orderSlice';
import reviewReducer from './slices/reviewSlice';
import checkoutReducer from './slices/checkoutSlice';
import userReducer from './slices/userSlice';
import wishlistReducer from './slices/wishlistSlice';
import notificationReducer from './slices/notificationSlice';
import { api } from '../services/api';

// H√†m ti·ªán √≠ch ƒë·ªÉ thao t√°c v·ªõi localStorage an to√†n
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`L·ªói khi ƒë·ªçc ${key} t·ª´ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`L·ªói khi l∆∞u ${key} v√†o localStorage:`, error);
      return false;
    }
  },
  removeItem: (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`L·ªói khi x√≥a ${key} t·ª´ localStorage:`, error);
      return false;
    }
  },
};

// Middleware t√πy ch·ªânh ƒë·ªÉ ghi log c√°c actions (ch·ªâ trong m√¥i tr∆∞·ªùng development)
const loggerMiddleware = (store) => (next) => (action) => {
  if (process.env.NODE_ENV !== 'production') {
    console.group(action.type);
    console.info('dispatching', action);
    const result = next(action);
    console.log('next state', store.getState());
    console.groupEnd();
    return result;
  }
  return next(action);
};

// Middleware ƒë·ªÉ l∆∞u state v√†o localStorage - ƒë√£ c·∫£i ti·∫øn v·ªõi x·ª≠ l√Ω l·ªói
const persistStateMiddleware = (store) => (next) => (action) => {
  const result = next(action);
  try {
    const stateToPersist = {
      cart: store.getState().cart,
      auth: {
        isAuthenticated: store.getState().auth.isAuthenticated,
        user: store.getState().auth.user,
      },
      wishlist: store.getState().wishlist,
    };
    safeLocalStorage.setItem('reduxState', JSON.stringify(stateToPersist));
  } catch (error) {
    console.error('L·ªói khi l∆∞u state v√†o localStorage:', error);
  }
  return result;
};

// L·∫•y state t·ª´ localStorage khi kh·ªüi ƒë·ªông - ƒë√£ c·∫£i ti·∫øn v·ªõi safeLocalStorage
const loadState = () => {
  try {
    const serializedState = safeLocalStorage.getItem('reduxState');
    if (serializedState === null) {
      return undefined;
    }
    return JSON.parse(serializedState);
  } catch (err) {
    console.error('Kh√¥ng th·ªÉ load state t·ª´ localStorage:', err);
    return undefined;
  }
};

const preloadedState = loadState();

export const store = configureStore({
  reducer: {
    auth: authReducer,
    cart: cartReducer,
    product: productReducer,
    ui: uiReducer,
    order: orderReducer,
    review: reviewReducer,
    checkout: checkoutReducer,
    user: userReducer,
    wishlist: wishlistReducer,
    notification: notificationReducer,
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // B·ªè qua c√°c actions v√† paths kh√¥ng serializable
        ignoredActions: [
          'checkout/createOrder/fulfilled',
          'auth/login/fulfilled',
          'auth/register/fulfilled',
        ],
        ignoredPaths: ['checkout.paymentUrl', 'auth.user.token', 'ui.modalContent'],
      },
    }).concat(
      api.middleware,
      loggerMiddleware,
      persistStateMiddleware,
      uiMiddleware, // Th√™m middleware cho UI
      authMiddleware // Th√™m middleware cho Auth
    ),
  preloadedState,
  devTools: process.env.NODE_ENV !== 'production',
});

// √Åp d·ª•ng theme ban ƒë·∫ßu khi ·ª©ng d·ª•ng kh·ªüi ƒë·ªông
const initialTheme = store.getState().ui.theme;
if (initialTheme) {
  document.documentElement.classList.add(initialTheme);
}

// C·∫•u h√¨nh listeners cho RTK Query
setupListeners(store.dispatch);

// H√†m ti·ªán √≠ch ƒë·ªÉ dispatch nhi·ªÅu actions c√πng l√∫c
export const batchDispatch = (actions) => {
  actions.forEach((action) => store.dispatch(action));
};

// H√†m ti·ªán √≠ch ƒë·ªÉ reset to√†n b·ªô state (v√≠ d·ª•: khi logout)
export const resetStore = () => {
  // Danh s√°ch c√°c actions ƒë·ªÉ reset t·ª´ng ph·∫ßn c·ªßa state
  const resetActions = [
    { type: 'auth/logout' },
    { type: 'cart/clearCart' },
    { type: 'ui/resetUI' },
    { type: 'wishlist/clearWishlist' },
    { type: 'notification/clearAll' },
  ];

  batchDispatch(resetActions);
  safeLocalStorage.removeItem('reduxState');
};

// Hooks typing
export * from './hooks';


--- File: client/src/store/slices/adminSlice.js ---
// src/store/slices/adminSlice.js
// File n√†y n·∫±m trong th∆∞ m·ª•c src/store/slices c·ªßa d·ª± √°n React Redux

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import adminService from '../../services/adminService';

// Async thunk actions
export const fetchDashboardStats = createAsyncThunk(
  'admin/fetchDashboardStats',
  async (_, { rejectWithValue }) => {
    try {
      return await adminService.getDashboardStats();
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y th·ªëng k√™ dashboard');
    }
  }
);

export const fetchRecentOrders = createAsyncThunk(
  'admin/fetchRecentOrders',
  async (_, { rejectWithValue }) => {
    try {
      return await adminService.getRecentOrders();
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y ƒë∆°n h√†ng g·∫ßn ƒë√¢y');
    }
  }
);

export const fetchSalesData = createAsyncThunk(
  'admin/fetchSalesData',
  async (period, { rejectWithValue }) => {
    try {
      return await adminService.getSalesData(period);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y d·ªØ li·ªáu doanh thu');
    }
  }
);

// Th√™m thunk action qu·∫£n l√Ω s·∫£n ph·∫©m
export const fetchProducts = createAsyncThunk(
  'admin/fetchProducts',
  async ({ page = 1, limit = 10, search = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getProducts(page, limit, search);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y danh s√°ch s·∫£n ph·∫©m');
    }
  }
);

export const createProduct = createAsyncThunk(
  'admin/createProduct',
  async (productData, { rejectWithValue, dispatch }) => {
    try {
      const response = await adminService.createProduct(productData);
      // Sau khi t·∫°o s·∫£n ph·∫©m th√†nh c√¥ng, c·∫≠p nh·∫≠t l·∫°i danh s√°ch
      dispatch(fetchProducts({ page: 1 }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi t·∫°o s·∫£n ph·∫©m m·ªõi');
    }
  }
);

export const updateProduct = createAsyncThunk(
  'admin/updateProduct',
  async ({ id, productData }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateProduct(id, productData);
      // Sau khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m th√†nh c√¥ng, c·∫≠p nh·∫≠t l·∫°i danh s√°ch
      const { currentPage } = getState().admin;
      dispatch(fetchProducts({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m');
    }
  }
);

export const deleteProduct = createAsyncThunk(
  'admin/deleteProduct',
  async (id, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.deleteProduct(id);
      // Sau khi x√≥a s·∫£n ph·∫©m th√†nh c√¥ng, c·∫≠p nh·∫≠t l·∫°i danh s√°ch
      const { currentPage } = getState().admin;
      dispatch(fetchProducts({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi x√≥a s·∫£n ph·∫©m');
    }
  }
);

// Th√™m thunk action qu·∫£n l√Ω ƒë∆°n h√†ng
export const fetchOrders = createAsyncThunk(
  'admin/fetchOrders',
  async ({ page = 1, limit = 10, status = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getOrders(page, limit, status);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y danh s√°ch ƒë∆°n h√†ng');
    }
  }
);

export const updateOrderStatus = createAsyncThunk(
  'admin/updateOrderStatus',
  async ({ id, status }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateOrderStatus(id, status);
      // Sau khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng, c·∫≠p nh·∫≠t l·∫°i danh s√°ch
      const { currentPage } = getState().admin;
      dispatch(fetchOrders({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng'
      );
    }
  }
);

// Th√™m thunk action qu·∫£n l√Ω ng∆∞·ªùi d√πng
export const fetchUsers = createAsyncThunk(
  'admin/fetchUsers',
  async ({ page = 1, limit = 10, search = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getUsers(page, limit, search);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'L·ªói khi l·∫•y danh s√°ch ng∆∞·ªùi d√πng');
    }
  }
);

export const updateUserStatus = createAsyncThunk(
  'admin/updateUserStatus',
  async ({ id, status }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateUserStatus(id, status);
      // Sau khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng, c·∫≠p nh·∫≠t l·∫°i danh s√°ch
      const { currentPage } = getState().admin;
      dispatch(fetchUsers({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng'
      );
    }
  }
);

const initialState = {
  stats: null,
  recentOrders: [],
  salesData: [],
  productList: [],
  orderList: [],
  userList: [],
  totalPages: 1,
  currentPage: 1,
  isLoading: false,
  isLoadingSales: false,
  isLoadingProducts: false,
  isLoadingOrders: false,
  isLoadingUsers: false,
  error: null,
};

const adminSlice = createSlice({
  name: 'admin',
  initialState,
  reducers: {
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Dashboard Stats
      .addCase(fetchDashboardStats.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchDashboardStats.fulfilled, (state, action) => {
        state.isLoading = false;
        state.stats = action.payload;
      })
      .addCase(fetchDashboardStats.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      })

      // Recent Orders
      .addCase(fetchRecentOrders.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchRecentOrders.fulfilled, (state, action) => {
        state.isLoading = false;
        state.recentOrders = action.payload;
      })
      .addCase(fetchRecentOrders.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      })

      // Sales Data
      .addCase(fetchSalesData.pending, (state) => {
        state.isLoadingSales = true;
      })
      .addCase(fetchSalesData.fulfilled, (state, action) => {
        state.isLoadingSales = false;
        state.salesData = action.payload;
      })
      .addCase(fetchSalesData.rejected, (state, action) => {
        state.isLoadingSales = false;
        state.error = action.payload;
      })

      // Products
      .addCase(fetchProducts.pending, (state) => {
        state.isLoadingProducts = true;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.isLoadingProducts = false;
        state.productList = action.payload.products;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.isLoadingProducts = false;
        state.error = action.payload;
      })

      // Kh√¥ng c·∫ßn th√™m case cho createProduct, updateProduct, deleteProduct
      // v√¨ ch√∫ng ƒë√£ dispatch fetchProducts ƒë·ªÉ c·∫≠p nh·∫≠t l·∫°i danh s√°ch

      // Orders
      .addCase(fetchOrders.pending, (state) => {
        state.isLoadingOrders = true;
      })
      .addCase(fetchOrders.fulfilled, (state, action) => {
        state.isLoadingOrders = false;
        state.orderList = action.payload.orders;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchOrders.rejected, (state, action) => {
        state.isLoadingOrders = false;
        state.error = action.payload;
      })

      // Users
      .addCase(fetchUsers.pending, (state) => {
        state.isLoadingUsers = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.isLoadingUsers = false;
        state.userList = action.payload.users;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoadingUsers = false;
        state.error = action.payload;
      });
  },
});

export const { setCurrentPage, clearError } = adminSlice.actions;

export default adminSlice.reducer;


--- File: client/src/store/slices/authSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from '../../services/authService';
import { setAuthToken, removeAuthToken } from '../../utils/authToken';

// H√†m ti·ªán √≠ch ƒë·ªÉ thao t√°c v·ªõi localStorage an to√†n
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`L·ªói khi ƒë·ªçc ${key} t·ª´ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`L·ªói khi l∆∞u ${key} v√†o localStorage:`, error);
      return false;
    }
  },
  removeItem: (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`L·ªói khi x√≥a ${key} t·ª´ localStorage:`, error);
      return false;
    }
  },
};

// Async thunks
export const login = createAsyncThunk('auth/login', async (credentials, { rejectWithValue }) => {
  try {
    const response = await authService.login(credentials);
    return response.data;
  } catch (error) {
    return rejectWithValue(error.response?.data?.message || 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i');
  }
});

export const register = createAsyncThunk('auth/register', async (userData, { rejectWithValue }) => {
  try {
    const response = await authService.register(userData);
    return response.data;
  } catch (error) {
    return rejectWithValue(error.response?.data?.message || 'ƒêƒÉng k√Ω th·∫•t b·∫°i');
  }
});

export const fetchCurrentUser = createAsyncThunk(
  'auth/fetchCurrentUser',
  async (_, { rejectWithValue }) => {
    try {
      const response = await authService.getCurrentUser();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng');
    }
  }
);

// Initial state
const initialState = {
  user: null,
  token: safeLocalStorage.getItem('token'),
  isAuthenticated: !!safeLocalStorage.getItem('token'),
  loading: false,
  error: null,
};

// Slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      // Kh√¥ng thao t√°c v·ªõi localStorage v√† removeAuthToken ·ªü ƒë√¢y n·ªØa
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Login
      .addCase(login.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Kh√¥ng thao t√°c v·ªõi localStorage v√† setAuthToken ·ªü ƒë√¢y n·ªØa
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Register
      .addCase(register.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Kh√¥ng thao t√°c v·ªõi localStorage v√† setAuthToken ·ªü ƒë√¢y n·ªØa
      })
      .addCase(register.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch current user
      .addCase(fetchCurrentUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCurrentUser.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(fetchCurrentUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
        // N·∫øu token kh√¥ng h·ª£p l·ªá, ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng
        if (action.payload === 'Unauthorized' || action.payload === 'Invalid token') {
          state.user = null;
          state.token = null;
          state.isAuthenticated = false;
          // Kh√¥ng thao t√°c v·ªõi localStorage v√† removeAuthToken ·ªü ƒë√¢y n·ªØa
        }
      });
  },
});

// Actions
export const { logout, clearError } = authSlice.actions;

// Selectors
export const selectAuth = (state) => state.auth;
export const selectIsAuthenticated = (state) => state.auth.isAuthenticated;
export const selectUser = (state) => state.auth.user;
export const selectAuthLoading = (state) => state.auth.loading;
export const selectAuthError = (state) => state.auth.error;

// Middleware ƒë·ªÉ x·ª≠ l√Ω side effects (nh∆∞ localStorage v√† authToken)
export const authMiddleware = (store) => (next) => (action) => {
  // X·ª≠ l√Ω tr∆∞·ªõc khi action ƒë∆∞·ª£c dispatch
  const result = next(action);

  // X·ª≠ l√Ω sau khi action ƒë√£ ƒë∆∞·ª£c dispatch
  if (login.fulfilled.match(action) || register.fulfilled.match(action)) {
    // L∆∞u token v√†o localStorage v√† thi·∫øt l·∫≠p header cho axios
    safeLocalStorage.setItem('token', action.payload.token);
    setAuthToken(action.payload.token);
  } else if (
    logout.match(action) ||
    (fetchCurrentUser.rejected.match(action) &&
      (action.payload === 'Unauthorized' || action.payload === 'Invalid token'))
  ) {
    // X√≥a token kh·ªèi localStorage v√† header
    safeLocalStorage.removeItem('token');
    removeAuthToken();
  }

  return result;
};

// Reducer
export default authSlice.reducer;


--- File: client/src/store/slices/cartSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { cartService } from '../../services/cartService';

// Async thunks
export const fetchCart = createAsyncThunk('cart/fetchCart', async (_, { rejectWithValue }) => {
  try {
    return await cartService.getCart();
  } catch (error) {
    return rejectWithValue(error.message);
  }
});

export const addToCartAsync = createAsyncThunk(
  'cart/addToCartAsync',
  async ({ productId, quantity }, { rejectWithValue }) => {
    try {
      return await cartService.addToCart(productId, quantity);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateCartItemAsync = createAsyncThunk(
  'cart/updateCartItemAsync',
  async ({ productId, quantity }, { rejectWithValue }) => {
    try {
      return await cartService.updateCartItem(productId, quantity);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const removeFromCartAsync = createAsyncThunk(
  'cart/removeFromCartAsync',
  async (productId, { rejectWithValue }) => {
    try {
      return await cartService.removeFromCart(productId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const clearCartAsync = createAsyncThunk(
  'cart/clearCartAsync',
  async (_, { rejectWithValue }) => {
    try {
      return await cartService.clearCart();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Helper functions
const calculateTotals = (items) => {
  return items.reduce(
    (totals, item) => {
      const itemTotal = item.product.price * item.quantity;
      return {
        itemsCount: totals.itemsCount + item.quantity,
        subtotal: totals.subtotal + itemTotal,
      };
    },
    { itemsCount: 0, subtotal: 0 }
  );
};

// Initial state
const initialState = {
  items: [],
  itemsCount: 0,
  subtotal: 0,
  loading: false,
  error: null,
};

// Slice
const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    // Local cart actions (for guest users)
    addToCart: (state, action) => {
      const { product, quantity = 1 } = action.payload;

      // Check if product already exists in cart
      const existingItem = state.items.find((item) => item.product.id === product.id);

      if (existingItem) {
        // Update quantity if product already exists
        existingItem.quantity += quantity;
      } else {
        // Add new item to cart
        state.items.push({
          product,
          quantity,
        });
      }

      // Update totals
      const { itemsCount, subtotal } = calculateTotals(state.items);
      state.itemsCount = itemsCount;
      state.subtotal = subtotal;
    },

    updateCartItem: (state, action) => {
      const { productId, quantity } = action.payload;

      // Find item in cart
      const item = state.items.find((item) => item.product.id === productId);

      if (item) {
        // Update quantity
        item.quantity = quantity;

        // Update totals
        const { itemsCount, subtotal } = calculateTotals(state.items);
        state.itemsCount = itemsCount;
        state.subtotal = subtotal;
      }
    },

    removeFromCart: (state, action) => {
      const productId = action.payload;

      // Remove item from cart
      state.items = state.items.filter((item) => item.product.id !== productId);

      // Update totals
      const { itemsCount, subtotal } = calculateTotals(state.items);
      state.itemsCount = itemsCount;
      state.subtotal = subtotal;
    },

    clearCart: (state) => {
      // Reset cart
      state.items = [];
      state.itemsCount = 0;
      state.subtotal = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // Handle fetchCart
      .addCase(fetchCart.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCart.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.items;

        // Calculate totals
        const { itemsCount, subtotal } = calculateTotals(action.payload.items);
        state.itemsCount = itemsCount;
        state.subtotal = subtotal;
      })
      .addCase(fetchCart.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });

    // Handle other async actions with similar patterns
    // ...
  },
});

// Export actions and reducer
export const { addToCart, updateCartItem, removeFromCart, clearCart } = cartSlice.actions;
export default cartSlice.reducer;


--- File: client/src/store/slices/notificationSlice.js ---
// src/store/slices/notificationSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import notificationService from '../../services/notificationService';

// Async thunk ƒë·ªÉ l·∫•y danh s√°ch th√¥ng b√°o
export const fetchNotifications = createAsyncThunk(
  'notification/fetchNotifications',
  async (_, { rejectWithValue }) => {
    try {
      const notifications = await notificationService.getNotifications();
      return notifications;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng b√°o');
    }
  }
);

// Async thunk ƒë·ªÉ ƒë√°nh d·∫•u th√¥ng b√°o ƒë√£ ƒë·ªçc
export const markAsRead = createAsyncThunk(
  'notification/markAsRead',
  async (notificationId, { rejectWithValue }) => {
    try {
      await notificationService.markAsRead(notificationId);
      return notificationId;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Kh√¥ng th·ªÉ ƒë√°nh d·∫•u th√¥ng b√°o ƒë√£ ƒë·ªçc'
      );
    }
  }
);

// Async thunk ƒë·ªÉ ƒë√°nh d·∫•u t·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë·ªçc
export const markAllAsRead = createAsyncThunk(
  'notification/markAllAsRead',
  async (_, { rejectWithValue }) => {
    try {
      await notificationService.markAllAsRead();
      return true;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Kh√¥ng th·ªÉ ƒë√°nh d·∫•u t·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë·ªçc'
      );
    }
  }
);

// Async thunk ƒë·ªÉ x√≥a th√¥ng b√°o
export const deleteNotification = createAsyncThunk(
  'notification/deleteNotification',
  async (notificationId, { rejectWithValue }) => {
    try {
      await notificationService.deleteNotification(notificationId);
      return notificationId;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ x√≥a th√¥ng b√°o');
    }
  }
);

// Async thunk ƒë·ªÉ x√≥a t·∫•t c·∫£ th√¥ng b√°o
export const deleteAllNotifications = createAsyncThunk(
  'notification/deleteAllNotifications',
  async (_, { rejectWithValue }) => {
    try {
      await notificationService.deleteAllNotifications();
      return true;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£ th√¥ng b√°o');
    }
  }
);

// Initial state
const initialState = {
  notifications: [],
  unreadCount: 0,
  loading: false,
  error: null,
  operationInProgress: false,
};

// Notification slice
const notificationSlice = createSlice({
  name: 'notification',
  initialState,
  reducers: {
    // Th√™m th√¥ng b√°o m·ªõi (cho realtime notifications)
    addNewNotification: (state, action) => {
      state.notifications.unshift(action.payload);
      state.unreadCount += 1;
    },
    // Reset tr·∫°ng th√°i l·ªói
    resetNotificationError: (state) => {
      state.error = null;
    },
    // Clear notifications khi logout
    clearNotifications: (state) => {
      state.notifications = [];
      state.unreadCount = 0;
      state.loading = false;
      state.error = null;
      state.operationInProgress = false;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchNotifications
      .addCase(fetchNotifications.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchNotifications.fulfilled, (state, action) => {
        state.loading = false;
        state.notifications = action.payload.notifications;
        state.unreadCount = action.payload.unreadCount;
      })
      .addCase(fetchNotifications.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y th√¥ng b√°o';
      })

      // markAsRead
      .addCase(markAsRead.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(markAsRead.fulfilled, (state, action) => {
        state.operationInProgress = false;
        const notification = state.notifications.find((item) => item._id === action.payload);
        if (notification && !notification.isRead) {
          notification.isRead = true;
          state.unreadCount = Math.max(0, state.unreadCount - 1);
        }
      })
      .addCase(markAsRead.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi ƒë√°nh d·∫•u th√¥ng b√°o ƒë√£ ƒë·ªçc';
      })

      // markAllAsRead
      .addCase(markAllAsRead.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(markAllAsRead.fulfilled, (state) => {
        state.operationInProgress = false;
        state.notifications.forEach((notification) => {
          notification.isRead = true;
        });
        state.unreadCount = 0;
      })
      .addCase(markAllAsRead.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi ƒë√°nh d·∫•u t·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë·ªçc';
      })

      // deleteNotification
      .addCase(deleteNotification.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(deleteNotification.fulfilled, (state, action) => {
        state.operationInProgress = false;
        const deletedNotification = state.notifications.find((item) => item._id === action.payload);
        if (deletedNotification && !deletedNotification.isRead) {
          state.unreadCount = Math.max(0, state.unreadCount - 1);
        }
        state.notifications = state.notifications.filter((item) => item._id !== action.payload);
      })
      .addCase(deleteNotification.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi x√≥a th√¥ng b√°o';
      })

      // deleteAllNotifications
      .addCase(deleteAllNotifications.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(deleteAllNotifications.fulfilled, (state) => {
        state.operationInProgress = false;
        state.notifications = [];
        state.unreadCount = 0;
      })
      .addCase(deleteAllNotifications.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi x√≥a t·∫•t c·∫£ th√¥ng b√°o';
      });
  },
});

// Export actions
export const { addNewNotification, resetNotificationError, clearNotifications } =
  notificationSlice.actions;

// Export reducer
export default notificationSlice.reducer;


--- File: client/src/store/slices/orderSlice.js ---
// src/store/slices/orderSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { orderService } from '../../services/orderService';

export const fetchUserOrders = createAsyncThunk(
  'order/fetchUserOrders',
  async (_, { rejectWithValue }) => {
    try {
      const orders = await orderService.getUserOrders();
      return orders;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch ƒë∆°n h√†ng');
    }
  }
);

export const fetchOrderDetail = createAsyncThunk(
  'order/fetchOrderDetail',
  async (orderId, { rejectWithValue }) => {
    try {
      const order = await orderService.getOrderById(orderId);
      return order;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ƒë∆°n h√†ng');
    }
  }
);

const initialState = {
  orders: [],
  currentOrder: null,
  loading: false,
  error: null,
};

const orderSlice = createSlice({
  name: 'order',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // fetchUserOrders
      .addCase(fetchUserOrders.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserOrders.fulfilled, (state, action) => {
        state.loading = false;
        state.orders = action.payload;
      })
      .addCase(fetchUserOrders.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch ƒë∆°n h√†ng';
      })

      // fetchOrderDetail
      .addCase(fetchOrderDetail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchOrderDetail.fulfilled, (state, action) => {
        state.loading = false;
        state.currentOrder = action.payload;
      })
      .addCase(fetchOrderDetail.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'C√≥ l·ªói x·∫£y ra khi l·∫•y th√¥ng tin ƒë∆°n h√†ng';
      });
  },
});

export default orderSlice.reducer;


--- File: client/src/store/slices/productSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import productService from '../../services/productService';

// Async thunk ƒë·ªÉ l·∫•y chi ti·∫øt s·∫£n ph·∫©m
export const fetchProducts = createAsyncThunk(
  'product/fetchProducts',
  async (params, { rejectWithValue }) => {
    try {
      const response = await productService.getProducts(params);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m');
    }
  }
);

export const fetchProductById = createAsyncThunk(
  'product/fetchProductById',
  async (id, { rejectWithValue }) => {
    try {
      const response = await productService.getProductById(id);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin s·∫£n ph·∫©m');
    }
  }
);

export const fetchCategories = createAsyncThunk(
  'product/fetchCategories',
  async (_, { rejectWithValue }) => {
    try {
      const response = await productService.getCategories();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y danh m·ª•c s·∫£n ph·∫©m');
    }
  }
);

// Initial state
const initialState = {
  products: [],
  product: null,
  categories: [],
  filters: {
    category: '',
    priceRange: { min: 0, max: 0 },
    sort: 'newest',
  },
  pagination: {
    page: 1,
    limit: 12,
    total: 0,
    pages: 0,
  },
  loading: false,
  error: null,
};

// Slice
const productSlice = createSlice({
  name: 'product',
  initialState,
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      // Reset trang v·ªÅ 1 khi thay ƒë·ªïi b·ªô l·ªçc
      state.pagination.page = 1;
    },
    setPage: (state, action) => {
      state.pagination.page = action.payload;
    },
    clearProductError: (state) => {
      state.error = null;
    },
    clearSelectedProduct: (state) => {
      state.product = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch products
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.products = action.payload.products;
        state.pagination = {
          page: action.payload.page,
          limit: action.payload.limit,
          total: action.payload.total,
          pages: action.payload.pages,
        };
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch product by id
      .addCase(fetchProductById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductById.fulfilled, (state, action) => {
        state.loading = false;
        state.product = action.payload;
      })
      .addCase(fetchProductById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch categories
      .addCase(fetchCategories.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCategories.fulfilled, (state, action) => {
        state.loading = false;
        state.categories = action.payload;
      })
      .addCase(fetchCategories.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Actions
export const { setFilters, setPage, clearProductError, clearSelectedProduct } =
  productSlice.actions;

// Selectors
export const selectProducts = (state) => state.product.products;
export const selectSelectedProduct = (state) => state.product.product;
export const selectCategories = (state) => state.product.categories;
export const selectFilters = (state) => state.product.filters;
export const selectPagination = (state) => state.product.pagination;
export const selectProductLoading = (state) => state.product.loading;
export const selectProductError = (state) => state.product.error;

// Reducer

export default productSlice.reducer;


--- File: client/src/store/slices/reviewSlice.js ---
// src/store/slices/reviewSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { reviewService } from '../../services/reviewService';

export const fetchProductReviews = createAsyncThunk(
  'review/fetchProductReviews',
  async (productId, { rejectWithValue }) => {
    try {
      const result = await reviewService.getProductReviews(productId);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y ƒë√°nh gi√° s·∫£n ph·∫©m');
    }
  }
);

export const submitProductReview = createAsyncThunk(
  'review/submitProductReview',
  async (reviewData, { rejectWithValue, dispatch }) => {
    try {
      const result = await reviewService.createReview(reviewData);
      // Refetch reviews after submitting
      dispatch(fetchProductReviews(reviewData.productId));
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ g·ª≠i ƒë√°nh gi√°');
    }
  }
);

export const fetchUserReviews = createAsyncThunk(
  'review/fetchUserReviews',
  async (_, { rejectWithValue }) => {
    try {
      const reviews = await reviewService.getUserReviews();
      return reviews;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y ƒë√°nh gi√° c·ªßa b·∫°n');
    }
  }
);

const initialState = {
  reviews: [],
  userReviews: [],
  stats: {
    average: 0,
    count: 0,
    distribution: {},
  },
  loading: false,
  submitting: false,
  error: null,
};

const reviewSlice = createSlice({
  name: 'review',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // fetchProductReviews
      .addCase(fetchProductReviews.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductReviews.fulfilled, (state, action) => {
        state.loading = false;
        state.reviews = action.payload.reviews;
        state.stats = action.payload.stats;
      })
      .addCase(fetchProductReviews.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'C√≥ l·ªói x·∫£y ra khi l·∫•y ƒë√°nh gi√°';
      })

      // submitProductReview
      .addCase(submitProductReview.pending, (state) => {
        state.submitting = true;
        state.error = null;
      })
      .addCase(submitProductReview.fulfilled, (state) => {
        state.submitting = false;
      })
      .addCase(submitProductReview.rejected, (state, action) => {
        state.submitting = false;
        state.error = action.payload || 'C√≥ l·ªói x·∫£y ra khi g·ª≠i ƒë√°nh gi√°';
      })

      // fetchUserReviews
      .addCase(fetchUserReviews.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserReviews.fulfilled, (state, action) => {
        state.loading = false;
        state.userReviews = action.payload;
      })
      .addCase(fetchUserReviews.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'C√≥ l·ªói x·∫£y ra khi l·∫•y ƒë√°nh gi√° c·ªßa b·∫°n';
      });
  },
});

export default reviewSlice.reducer;


--- File: client/src/store/slices/searchSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import productService from '../../services/productService';

// Async thunk for searching products
export const searchProducts = createAsyncThunk(
  'search/searchProducts',
  async (keyword, { rejectWithValue }) => {
    try {
      return await productService.searchProducts(keyword);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Initial state
const initialState = {
  keyword: '',
  results: [],
  loading: false,
  error: null,
  recentSearches: [],
  filters: {
    category: null,
    priceRange: { min: 0, max: 10000000 },
    sortBy: 'relevance',
  },
};

// Slice
const searchSlice = createSlice({
  name: 'search',
  initialState,
  reducers: {
    setKeyword: (state, action) => {
      state.keyword = action.payload;

      // Add to recent searches if not already there
      if (action.payload && !state.recentSearches.includes(action.payload)) {
        state.recentSearches = [
          action.payload,
          ...state.recentSearches.slice(0, 4), // Keep only 5 most recent
        ];
      }
    },
    clearResults: (state) => {
      state.results = [];
    },
    setSearchFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearSearchFilters: (state) => {
      state.filters = initialState.filters;
    },
    clearRecentSearches: (state) => {
      state.recentSearches = [];
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(searchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.results = action.payload;
      })
      .addCase(searchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Export actions and reducer
export const {
  setKeyword,
  clearResults,
  setSearchFilters,
  clearSearchFilters,
  clearRecentSearches,
} = searchSlice.actions;

export default searchSlice.reducer;


--- File: client/src/store/slices/uiSlice.js ---
import { createSlice } from '@reduxjs/toolkit';

// H√†m ti·ªán √≠ch ƒë·ªÉ thao t√°c v·ªõi localStorage an to√†n
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`L·ªói khi ƒë·ªçc ${key} t·ª´ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`L·ªói khi l∆∞u ${key} v√†o localStorage:`, error);
      return false;
    }
  },
};

// Initial state
const initialState = {
  sidebarOpen: false,
  notifications: [],
  theme: safeLocalStorage.getItem('theme', 'light'),
};

// Slice
const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    setSidebarOpen: (state, action) => {
      state.sidebarOpen = action.payload;
    },
    addNotification: (state, action) => {
      const id = Date.now().toString();
      state.notifications.push({
        id,
        type: action.payload.type || 'info',
        message: action.payload.message,
        duration: action.payload.duration || 5000,
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(
        (notification) => notification.id !== action.payload
      );
    },
    clearNotifications: (state) => {
      state.notifications = [];
    },
    setTheme: (state, action) => {
      state.theme = action.payload;
      safeLocalStorage.setItem('theme', action.payload);
    },
  },
});

// Actions
export const {
  toggleSidebar,
  setSidebarOpen,
  addNotification,
  removeNotification,
  clearNotifications,
  setTheme,
} = uiSlice.actions;

// Selectors
export const selectSidebarOpen = (state) => state.ui.sidebarOpen;
export const selectNotifications = (state) => state.ui.notifications;
export const selectTheme = (state) => state.ui.theme;

// Middleware ƒë·ªÉ x·ª≠ l√Ω side effects (nh∆∞ thay ƒë·ªïi DOM)
export const uiMiddleware = (store) => (next) => (action) => {
  // X·ª≠ l√Ω tr∆∞·ªõc khi action ƒë∆∞·ª£c dispatch
  const result = next(action);

  // X·ª≠ l√Ω sau khi action ƒë√£ ƒë∆∞·ª£c dispatch
  if (setTheme.match(action)) {
    // √Åp d·ª•ng theme v√†o document
    document.documentElement.classList.remove('light', 'dark');
    document.documentElement.classList.add(action.payload);
  }

  return result;
};

// Reducer
export default uiSlice.reducer;


--- File: client/src/store/slices/userSlice.js ---
// src/store/slices/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import userService from '../../services/userService';

// Async thunk ƒë·ªÉ l·∫•y th√¥ng tin h·ªì s∆° ng∆∞·ªùi d√πng
export const fetchUserProfile = createAsyncThunk(
  'user/fetchUserProfile',
  async (_, { rejectWithValue }) => {
    try {
      const user = await userService.getUserProfile();
      return user;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng');
    }
  }
);

// Async thunk ƒë·ªÉ c·∫≠p nh·∫≠t th√¥ng tin h·ªì s∆° ng∆∞·ªùi d√πng
export const updateUserProfile = createAsyncThunk(
  'user/updateUserProfile',
  async (userData, { rejectWithValue }) => {
    try {
      const updatedUser = await userService.updateUserProfile(userData);
      return updatedUser;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng'
      );
    }
  }
);

// Async thunk ƒë·ªÉ thay ƒë·ªïi m·∫≠t kh·∫©u
export const changePassword = createAsyncThunk(
  'user/changePassword',
  async (passwordData, { rejectWithValue }) => {
    try {
      const result = await userService.changePassword(passwordData);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ thay ƒë·ªïi m·∫≠t kh·∫©u');
    }
  }
);

// Async thunk ƒë·ªÉ c·∫≠p nh·∫≠t avatar
export const updateAvatar = createAsyncThunk(
  'user/updateAvatar',
  async (formData, { rejectWithValue }) => {
    try {
      const result = await userService.updateAvatar(formData);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán');
    }
  }
);

// Initial state
const initialState = {
  user: null,
  loading: false,
  error: null,
  passwordUpdateStatus: {
    loading: false,
    success: false,
    error: null,
  },
  avatarUpdateStatus: {
    loading: false,
    success: false,
    error: null,
  },
};

// User slice
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // Reset tr·∫°ng th√°i c·∫≠p nh·∫≠t m·∫≠t kh·∫©u
    resetPasswordUpdateStatus: (state) => {
      state.passwordUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
    // Reset tr·∫°ng th√°i c·∫≠p nh·∫≠t avatar
    resetAvatarUpdateStatus: (state) => {
      state.avatarUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
    // Clear user state khi logout
    clearUserState: (state) => {
      state.user = null;
      state.loading = false;
      state.error = null;
      state.passwordUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
      state.avatarUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchUserProfile
      .addCase(fetchUserProfile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng';
      })

      // updateUserProfile
      .addCase(updateUserProfile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng';
      })

      // changePassword
      .addCase(changePassword.pending, (state) => {
        state.passwordUpdateStatus.loading = true;
        state.passwordUpdateStatus.success = false;
        state.passwordUpdateStatus.error = null;
      })
      .addCase(changePassword.fulfilled, (state) => {
        state.passwordUpdateStatus.loading = false;
        state.passwordUpdateStatus.success = true;
      })
      .addCase(changePassword.rejected, (state, action) => {
        state.passwordUpdateStatus.loading = false;
        state.passwordUpdateStatus.success = false;
        state.passwordUpdateStatus.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi thay ƒë·ªïi m·∫≠t kh·∫©u';
      })

      // updateAvatar
      .addCase(updateAvatar.pending, (state) => {
        state.avatarUpdateStatus.loading = true;
        state.avatarUpdateStatus.success = false;
        state.avatarUpdateStatus.error = null;
      })
      .addCase(updateAvatar.fulfilled, (state, action) => {
        state.avatarUpdateStatus.loading = false;
        state.avatarUpdateStatus.success = true;
        if (state.user) {
          state.user.avatar = action.payload.avatar;
        }
      })
      .addCase(updateAvatar.rejected, (state, action) => {
        state.avatarUpdateStatus.loading = false;
        state.avatarUpdateStatus.success = false;
        state.avatarUpdateStatus.error =
          action.payload || 'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán';
      });
  },
});

// Export actions
export const { resetPasswordUpdateStatus, resetAvatarUpdateStatus, clearUserState } =
  userSlice.actions;

// Export reducer
export default userSlice.reducer;


--- File: client/src/store/slices/wishlistSlice.js ---
// src/store/slices/wishlistSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import wishlistService from '../../services/wishlistService';

// Async thunk ƒë·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m y√™u th√≠ch
export const fetchWishlist = createAsyncThunk(
  'wishlist/fetchWishlist',
  async (_, { rejectWithValue }) => {
    try {
      const wishlist = await wishlistService.getWishlist();
      return wishlist;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch y√™u th√≠ch');
    }
  }
);

// Async thunk ƒë·ªÉ th√™m s·∫£n ph·∫©m v√†o danh s√°ch y√™u th√≠ch
export const addToWishlist = createAsyncThunk(
  'wishlist/addToWishlist',
  async (productId, { rejectWithValue }) => {
    try {
      const result = await wishlistService.addToWishlist(productId);
      return result;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Kh√¥ng th·ªÉ th√™m v√†o danh s√°ch y√™u th√≠ch'
      );
    }
  }
);

// Async thunk ƒë·ªÉ x√≥a s·∫£n ph·∫©m kh·ªèi danh s√°ch y√™u th√≠ch
export const removeFromWishlist = createAsyncThunk(
  'wishlist/removeFromWishlist',
  async (productId, { rejectWithValue }) => {
    try {
      await wishlistService.removeFromWishlist(productId);
      return productId;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Kh√¥ng th·ªÉ x√≥a kh·ªèi danh s√°ch y√™u th√≠ch'
      );
    }
  }
);

// Initial state
const initialState = {
  items: [],
  loading: false,
  error: null,
  addingItem: null,
  removingItem: null,
};

// Wishlist slice
const wishlistSlice = createSlice({
  name: 'wishlist',
  initialState,
  reducers: {
    // Reset tr·∫°ng th√°i l·ªói
    resetWishlistError: (state) => {
      state.error = null;
    },
    // Clear to√†n b·ªô danh s√°ch y√™u th√≠ch khi logout
    clearWishlist: (state) => {
      state.items = [];
      state.loading = false;
      state.error = null;
      state.addingItem = null;
      state.removingItem = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchWishlist
      .addCase(fetchWishlist.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchWishlist.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchWishlist.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y danh s√°ch y√™u th√≠ch';
      })

      // addToWishlist
      .addCase(addToWishlist.pending, (state, action) => {
        state.addingItem = action.meta.arg; // productId
      })
      .addCase(addToWishlist.fulfilled, (state, action) => {
        state.addingItem = null;
        // Ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√£ c√≥ trong danh s√°ch ch∆∞a
        const exists = state.items.some((item) => item._id === action.payload._id);
        if (!exists) {
          state.items.push(action.payload);
        }
      })
      .addCase(addToWishlist.rejected, (state, action) => {
        state.addingItem = null;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi th√™m v√†o danh s√°ch y√™u th√≠ch';
      })

      // removeFromWishlist
      .addCase(removeFromWishlist.pending, (state, action) => {
        state.removingItem = action.meta.arg; // productId
      })
      .addCase(removeFromWishlist.fulfilled, (state, action) => {
        state.removingItem = null;
        state.items = state.items.filter((item) => item._id !== action.payload);
      })
      .addCase(removeFromWishlist.rejected, (state, action) => {
        state.removingItem = null;
        state.error = action.payload || 'ƒê√£ x·∫£y ra l·ªói khi x√≥a kh·ªèi danh s√°ch y√™u th√≠ch';
      });
  },
});

// Export actions
export const { resetWishlistError, clearWishlist } = wishlistSlice.actions;

// Export reducer
export default wishlistSlice.reducer;


--- File: client/src/utils/authToken.js ---
import axios from 'axios';
// client/src/utils/authToken.js
const TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';

export const setAuthToken = (token) => {
  localStorage.setItem(TOKEN_KEY, token);
};

export const getAuthToken = () => {
  return localStorage.getItem(TOKEN_KEY);
};

export const removeAuthToken = () => {
  localStorage.removeItem(TOKEN_KEY);
};

export const setRefreshToken = (token) => {
  localStorage.setItem(REFRESH_TOKEN_KEY, token);
};

export const getRefreshToken = () => {
  return localStorage.getItem(REFRESH_TOKEN_KEY);
};

export const removeRefreshToken = () => {
  localStorage.removeItem(REFRESH_TOKEN_KEY);
};

export const refreshToken = async () => {
  try {
    const refreshToken = getRefreshToken();

    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await fetch(`${process.env.REACT_APP_API_URL}/auth/refresh-token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error('Failed to refresh token');
    }

    const data = await response.json();
    setAuthToken(data.token);

    if (data.refreshToken) {
      setRefreshToken(data.refreshToken);
    }

    return data.token;
  } catch (error) {
    removeAuthToken();
    removeRefreshToken();
    throw error;
  }
};

export const isAuthenticated = () => {
  return !!getAuthToken();
};
/**
 * Thi·∫øt l·∫≠p token v√†o header c·ªßa Axios
 * @param {string} token - JWT token
 */
// export const setAuthToken = (token) => {
//   if (token) {
//     // √Åp d·ª•ng token cho t·∫•t c·∫£ c√°c request
//     axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
//   } else {
//     // X√≥a header n·∫øu kh√¥ng c√≥ token
//     delete axios.defaults.headers.common['Authorization'];
//   }
// };

// /**
//  * X√≥a token kh·ªèi header c·ªßa Axios
//  */
// export const removeAuthToken = () => {
//   delete axios.defaults.headers.common['Authorization'];
// };


--- File: client/src/utils/formatters.js ---
/**
 * ƒê·ªãnh d·∫°ng gi√° ti·ªÅn theo lo·∫°i ti·ªÅn t·ªá
 * @param {number} price - S·ªë ti·ªÅn c·∫ßn ƒë·ªãnh d·∫°ng
 * @param {string} locale - Ng√¥n ng·ªØ hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh: 'vi-VN')
 * @param {string} currency - Lo·∫°i ti·ªÅn t·ªá (m·∫∑c ƒë·ªãnh: 'VND')
 * @returns {string} Gi√° ti·ªÅn ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatPrice = (price, locale = 'vi-VN', currency = 'VND') => {
  if (price === null || price === undefined) return '';

  try {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency,
    }).format(price);
  } catch (error) {
    console.error('L·ªói khi ƒë·ªãnh d·∫°ng gi√° ti·ªÅn:', error);
    return `${price} ${currency}`;
  }
};

/**
 * ƒê·ªãnh d·∫°ng ng√†y theo ƒë·ªãnh d·∫°ng chu·∫©n
 * @param {string|Date} date - Ng√†y c·∫ßn ƒë·ªãnh d·∫°ng
 * @param {string} locale - Ng√¥n ng·ªØ hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh: 'vi-VN')
 * @param {object} options - T√πy ch·ªçn ƒë·ªãnh d·∫°ng (m·∫∑c ƒë·ªãnh: hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß ng√†y th√°ng)
 * @returns {string} Ng√†y ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatDate = (date, locale = 'vi-VN', options = null) => {
  if (!date) return '';

  try {
    const dateObj = typeof date === 'string' ? new Date(date) : date;

    // Ki·ªÉm tra ng√†y h·ª£p l·ªá
    if (isNaN(dateObj.getTime())) {
      return '';
    }

    const defaultOptions = options || {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    };

    return dateObj.toLocaleDateString(locale, defaultOptions);
  } catch (error) {
    console.error('L·ªói khi ƒë·ªãnh d·∫°ng ng√†y:', error);
    return String(date);
  }
};

/**
 * ƒê·ªãnh d·∫°ng th·ªùi gian
 * @param {string|Date} date - Th·ªùi gian c·∫ßn ƒë·ªãnh d·∫°ng
 * @param {string} locale - Ng√¥n ng·ªØ hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh: 'vi-VN')
 * @returns {string} Th·ªùi gian ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatTime = (date, locale = 'vi-VN') => {
  if (!date) return '';

  try {
    const dateObj = typeof date === 'string' ? new Date(date) : date;

    // Ki·ªÉm tra ng√†y h·ª£p l·ªá
    if (isNaN(dateObj.getTime())) {
      return '';
    }

    return dateObj.toLocaleTimeString(locale, {
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch (error) {
    console.error('L·ªói khi ƒë·ªãnh d·∫°ng th·ªùi gian:', error);
    return '';
  }
};

/**
 * ƒê·ªãnh d·∫°ng ng√†y gi·ªù ƒë·∫ßy ƒë·ªß
 * @param {string|Date} datetime - Ng√†y gi·ªù c·∫ßn ƒë·ªãnh d·∫°ng
 * @param {string} locale - Ng√¥n ng·ªØ hi·ªÉn th·ªã (m·∫∑c ƒë·ªãnh: 'vi-VN')
 * @returns {string} Ng√†y gi·ªù ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatDateTime = (datetime, locale = 'vi-VN') => {
  if (!datetime) return '';

  try {
    return `${formatDate(datetime, locale)}, ${formatTime(datetime, locale)}`;
  } catch (error) {
    console.error('L·ªói khi ƒë·ªãnh d·∫°ng ng√†y gi·ªù:', error);
    return String(datetime);
  }
};

/**
 * R√∫t g·ªçn vƒÉn b·∫£n n·∫øu qu√° d√†i
 * @param {string} text - VƒÉn b·∫£n c·∫ßn r√∫t g·ªçn
 * @param {number} maxLength - ƒê·ªô d√†i t·ªëi ƒëa (m·∫∑c ƒë·ªãnh: 100)
 * @returns {string} VƒÉn b·∫£n ƒë√£ r√∫t g·ªçn
 */
export const truncateText = (text, maxLength = 100) => {
  if (!text) return '';
  if (text.length <= maxLength) return text;

  return text.slice(0, maxLength) + '...';
};

/**
 * T·∫°o slug t·ª´ text
 * @param {string} text - Text c·∫ßn chuy·ªÉn ƒë·ªïi
 * @returns {string} Slug
 */
export const createSlug = (text) => {
  if (!text) return '';

  try {
    return text
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  } catch (error) {
    console.error('L·ªói khi t·∫°o slug:', error);
    return '';
  }
};

/**
 * ƒê·ªãnh d·∫°ng s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam
 * @param {string} phone - S·ªë ƒëi·ªán tho·∫°i c·∫ßn ƒë·ªãnh d·∫°ng
 * @returns {string} S·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatPhoneNumber = (phone) => {
  if (!phone) return '';

  // Lo·∫°i b·ªè t·∫•t c·∫£ k√Ω t·ª± kh√¥ng ph·∫£i s·ªë
  const cleaned = phone.replace(/\D/g, '');

  // Ki·ªÉm tra ƒë·ªô d√†i s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam
  if (cleaned.length !== 10) {
    return phone;
  }

  // ƒê·ªãnh d·∫°ng: 0xx xxxx xxx
  return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 7)} ${cleaned.slice(7)}`;
};

/**
 * ƒê·ªãnh d·∫°ng s·ªë l∆∞·ª£ng l·ªõn (v√≠ d·ª•: 1.5k thay v√¨ 1500)
 * @param {number} number - S·ªë c·∫ßn ƒë·ªãnh d·∫°ng
 * @returns {string} S·ªë ƒë√£ ƒë·ªãnh d·∫°ng
 */
export const formatCompactNumber = (number) => {
  if (number === null || number === undefined) return '';

  const formatter = new Intl.NumberFormat('vi-VN', {
    notation: 'compact',
    compactDisplay: 'short',
  });

  return formatter.format(number);
};


--- File: client/tailwind.config.js ---
module.exports = {
    content: [
      './src/**/*.{js,jsx,ts,tsx}',
      './public/index.html',
    ],
    theme: {
      extend: {
        colors: {
          primary: {
            50: '#e6f1fe',
            100: '#cce3fd',
            200: '#99c7fb',
            300: '#66aaf9',
            400: '#338ef7',
            500: '#0072f5', // Primary color
            600: '#005bc4',
            700: '#004493',
            800: '#002e62',
            900: '#001731',
          },
        },
        fontFamily: {
          sans: ['Roboto', 'Arial', 'sans-serif'],
          heading: ['Montserrat', 'Arial', 'sans-serif'],
        },
        spacing: {
          '72': '18rem',
          '84': '21rem',
          '96': '24rem',
        },
        borderRadius: {
          'xl': '0.75rem',
          '2xl': '1rem',
        },
        boxShadow: {
          'outline-blue': '0 0 0 3px rgba(0, 114, 245, 0.3)',
        },
        transitionProperty: {
          'height': 'height',
          'spacing': 'margin, padding',
        },
      },
    },
    plugins: [
      require('@tailwindcss/forms'),
    ],
  };

--- File: client/webpack.config.md ---
// File: webpack.config.js - ƒê·∫∑t ·ªü th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n (c√πng c·∫•p v·ªõi package.json)
// C·∫•u h√¨nh Webpack ƒë·∫ßy ƒë·ªß cho d·ª± √°n React/JavaScript

const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const CompressionPlugin = require('compression-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

// X√°c ƒë·ªãnh m√¥i tr∆∞·ªùng
const isDevelopment = process.env.NODE_ENV !== 'production';

module.exports = {
  // Ch·∫ø ƒë·ªô: development ho·∫∑c production
  mode: isDevelopment ? 'development' : 'production',

  // ƒêi·ªÉm v√†o c·ªßa ·ª©ng d·ª•ng
  entry: './src/index.js', // ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n t·ªõi file entry point c·ªßa b·∫°n

  // C·∫•u h√¨nh ƒë·∫ßu ra
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: isDevelopment ? '[name].js' : '[name].[contenthash].js',
    publicPath: '/',
    clean: true, // X√≥a th∆∞ m·ª•c dist tr∆∞·ªõc m·ªói l·∫ßn build
  },

  // Source maps cho development
  devtool: isDevelopment ? 'eval-source-map' : false,

  // C·∫•u h√¨nh dev server
  devServer: {
    static: {
      directory: path.join(__dirname, 'public'),
    },
    port: 3000,
    hot: true,
    historyApiFallback: true, // H·ªó tr·ª£ cho React Router
    open: true,
  },

  // C·∫•u h√¨nh module rules
  module: {
    rules: [
      // JavaScript/React
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react'],
          },
        },
      },
      // CSS/SCSS
      {
        test: /\.(css|scss)$/,
        use: [
          isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,
          'css-loader',
          'postcss-loader',
          'sass-loader',
        ],
      },
      // Images
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },
      // Fonts
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
      },
    ],
  },

  // C·∫•u h√¨nh resolve
  resolve: {
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'), // Cho ph√©p import t·ª´ '@/components/...'
    },
  },

  // T·ªëi ∆∞u h√≥a bundle size
  optimization: {
    minimize: !isDevelopment,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: !isDevelopment,
          },
        },
      }),
    ],
    splitChunks: {
      chunks: 'all',
      maxInitialRequests: 10,
      minSize: 0,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
            return `vendor.${packageName.replace('@', '')}`;
          },
        },
      },
    },
  },

  // Plugins
  plugins: [
    // T·∫°o file HTML
    new HtmlWebpackPlugin({
      template: './public/index.html', // ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n t·ªõi template HTML c·ªßa b·∫°n
      favicon: './public/favicon.ico', // N·∫øu c√≥ favicon
    }),

    // Extract CSS th√†nh file ri√™ng trong production
    !isDevelopment &&
      new MiniCssExtractPlugin({
        filename: '[name].[contenthash].css',
      }),

    // N√©n file JS v√† CSS
    !isDevelopment &&
      new CompressionPlugin({
        algorithm: 'gzip',
        test: /\.(js|css|html|svg)$/,
        threshold: 10240,
        minRatio: 0.8,
      }),

    // Ph√¢n t√≠ch bundle size (ch·ªâ ch·∫°y khi c·∫ßn ph√¢n t√≠ch)
    process.env.ANALYZE === 'true' && new BundleAnalyzerPlugin(),
  ].filter(Boolean),
};


--- File: docker/Dockerfile.client ---
# S·ª≠ d·ª•ng multi-stage build ƒë·ªÉ t·ªëi ∆∞u image size

# Stage 1: Build stage
FROM node:18-alpine AS build

# T·∫°o th∆∞ m·ª•c l√†m vi·ªác
WORKDIR /app

# Sao ch√©p package.json v√† package-lock.json
COPY package*.json ./

# C√†i ƒë·∫∑t dependencies
RUN npm ci

# Sao ch√©p source code c·ªßa ·ª©ng d·ª•ng
COPY . .

# Build ·ª©ng d·ª•ng React
RUN npm run build

# Stage 2: Production stage
FROM nginx:alpine

# Sao ch√©p build files t·ª´ build stage v√†o th∆∞ m·ª•c root c·ªßa Nginx
COPY --from=build /app/build /usr/share/nginx/html

# Sao ch√©p c·∫•u h√¨nh Nginx t√πy ch·ªânh (n·∫øu c√≥)
# COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80
EXPOSE 80

# Kh·ªüi ch·∫°y Nginx
CMD ["nginx", "-g", "daemon off;"]

--- File: docker/Dockerfile.server ---
# S·ª≠ d·ª•ng Node.js 18 v·ªõi Alpine Linux cho nh·∫π v√† b·∫£o m·∫≠t
FROM node:18-alpine

# T·∫°o th∆∞ m·ª•c l√†m vi·ªác
WORKDIR /app

# Sao ch√©p package.json v√† package-lock.json tr∆∞·ªõc ƒë·ªÉ t·∫≠n d·ª•ng Docker caching
COPY package*.json ./

# C√†i ƒë·∫∑t dependencies
RUN npm ci --only=production

# Sao ch√©p source code c·ªßa ·ª©ng d·ª•ng
COPY . .

# T·∫°o th∆∞ m·ª•c logs
RUN mkdir -p logs

# Set node user cho b·∫£o m·∫≠t t·ªët h∆°n (kh√¥ng ch·∫°y ·ª©ng d·ª•ng v·ªõi quy·ªÅn root)
USER node

# Expose port
EXPOSE 5000

# Bi·∫øn m√¥i tr∆∞·ªùng
ENV NODE_ENV=production

# Kh·ªüi ch·∫°y ·ª©ng d·ª•ng
CMD ["node", "src/server.js"] 

--- File: docker/docker-compose.yml ---
version: '3.8'

services:
  # MongoDB Service
  mongodb:
    image: mongo:6
    container_name: runout_mongodb_prod
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
      MONGO_INITDB_DATABASE: runout_biliard
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init/:/docker-entrypoint-initdb.d/
      - ./mongodb_backup:/backup
    networks:
      - runout_network
    # Kh√¥ng expose port ra ngo√†i trong m√¥i tr∆∞·ªùng production
    ports:
      - "127.0.0.1:27017:27017"
    command: ["--auth", "--wiredTigerCacheSizeGB", "1"]
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
  
  # MongoDB Backup Service
  mongo-backup:
    image: mongo:6
    container_name: runout_mongodb_backup
    restart: always
    depends_on:
      - mongodb
    volumes:
      - ./mongodb_backup:/backup
      - ./scripts:/scripts
    entrypoint: ["sh", "/scripts/mongodb-backup.sh"]
    networks:
      - runout_network
    environment:
      - MONGO_HOST=mongodb
      - MONGO_PORT=27017
      - MONGO_USERNAME=${MONGO_USERNAME}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_DATABASE=runout_biliard
      - BACKUP_CRON="0 2 * * *" # Ch·∫°y l√∫c 2 gi·ªù s√°ng h√†ng ng√†y

  # Backend Service
  backend:
    image: ${DOCKER_HUB_USERNAME}/runout-biliard-server:latest
    container_name: runout_backend_prod
    restart: always
    depends_on:
      - mongodb
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/runout_biliard?authSource=admin
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN}
      - JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
      - JWT_REFRESH_EXPIRES_IN=${JWT_REFRESH_EXPIRES_IN}
      - CORS_ORIGIN=${CORS_ORIGIN}
      - APP_NAME=RunOut-Biliard
      - SIGNATURE=${SIGNATURE}
      - LOG_LEVEL=${LOG_LEVEL:-info}
    volumes:
      - backend_logs:/app/logs
    networks:
      - runout_network
    # S·ª≠ d·ª•ng Nginx l√†m reverse proxy, ch·ªâ expose trong internal network
    expose:
      - "5000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5000/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 512M

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: runout_nginx
    restart: always
    depends_on:
      - backend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
      - ./nginx/www:/var/www/html
    networks:
      - runout_network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  # Prometheus for monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: runout_prometheus
    restart: always
    volumes:
      - ./prometheus:/etc/prometheus
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=15d'
      - '--web.enable-lifecycle'
    networks:
      - runout_network
    expose:
      - "9090"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # Grafana for visualization
  grafana:
    image: grafana/grafana:latest
    container_name: runout_grafana
    restart: always
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    networks:
      - runout_network
    expose:
      - "3000"
    depends_on:
      - prometheus
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # Node Exporter for system metrics
  node-exporter:
    image: prom/node-exporter:latest
    container_name: runout_node_exporter
    restart: always
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.rootfs=/rootfs'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($|/)'
    networks:
      - runout_network
    expose:
      - "9100"

  # Watchtower for automatic container updates
  watchtower:
    image: containrrr/watchtower
    container_name: runout_watchtower
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command: --interval 86400 --cleanup
    environment:
      - WATCHTOWER_NOTIFICATIONS=slack
      - WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL=${SLACK_WEBHOOK_URL}
      - WATCHTOWER_NOTIFICATION_SLACK_IDENTIFIER=watchtower
      - WATCHTOWER_NOTIFICATION_SLACK_CHANNEL=${SLACK_CHANNEL:-deployments}
    networks:
      - runout_network

networks:
  runout_network:
    driver: bridge

volumes:
  mongodb_data:
  backend_logs:
  prometheus_data:
  grafana_data:

--- File: docker-compose.prod.yml ---
version: '3.8'

services:
  # MongoDB Service
  mongodb:
    image: mongo:6
    container_name: runout_mongodb_prod
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
    volumes:
      - mongodb_data:/data/db
    networks:
      - runout_network
    # Kh√¥ng expose port ra ngo√†i trong m√¥i tr∆∞·ªùng production
    ports:
      - "127.0.0.1:27017:27017"
    healthcheck:
      test: ["CMD", "mongo", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Backend Service
  backend:
    image: ${DOCKER_HUB_USERNAME}/runout-biliard-server:latest
    container_name: runout_backend_prod
    restart: always
    depends_on:
      - mongodb
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/runout_biliard?authSource=admin
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN}
      - CORS_ORIGIN=${CORS_ORIGIN}
      - APP_NAME=RunOut-Biliard
      - SIGNATURE=${SIGNATURE}
    volumes:
      - backend_logs:/app/logs
    networks:
      - runout_network
    # S·ª≠ d·ª•ng Nginx l√†m reverse proxy, ch·ªâ expose trong internal network
    expose:
      - "5000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5000/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: runout_nginx
    restart: always
    depends_on:
      - backend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
    networks:
      - runout_network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  runout_network:
    driver: bridge

volumes:
  mongodb_data:
  backend_logs:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/logs
      o: bind
  nginx_logs:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/nginx/logs
      o: bind
  nginx_ssl:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/nginx/ssl
      o: bind
  # Ch√∫ √Ω: ƒê·∫£m b·∫£o r·∫±ng c√°c th∆∞ m·ª•c /opt/runout-biliard/logs, /opt/runout-biliard/nginx/logs v√† /opt/runout-biliard/nginx/ssl ƒë√£ t·ªìn t·∫°i tr√™n server tr∆∞·ªõc khi ch·∫°y docker-compose.
  # N·∫øu ch∆∞a t·ªìn t·∫°i, b·∫°n c√≥ th·ªÉ t·∫°o ch√∫ng b·∫±ng l·ªánh sau:
  # mkdir -p /opt/runout-biliard/logs /opt/runout-biliard/nginx/logs /opt/runout-biliard/nginx/ssl
  # Ho·∫∑c b·∫°n c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n trong driver_opts ƒë·ªÉ ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c c·ªßa b·∫°n.
  # N·∫øu b·∫°n mu·ªën s·ª≠ d·ª•ng volume m·∫∑c ƒë·ªãnh c·ªßa Docker, b·∫°n c√≥ th·ªÉ b·ªè qua ph·∫ßn n√†y v√† ch·ªâ c·∫ßn ƒë·ªãnh nghƒ©a mongodb_data.
  # Tuy nhi√™n, vi·ªác s·ª≠ d·ª•ng volume bind mount nh∆∞ tr√™n s·∫Ω gi√∫p b·∫°n d·ªÖ d√†ng truy c·∫≠p v√† qu·∫£n l√Ω c√°c file log v√† ssl certificate t·ª´ b√™n ngo√†i container.

--- File: docs/CI-CD-Guide.md ---
# H∆∞·ªõng D·∫´n CI/CD cho D·ª± √Ån RunOut-Biliard

## T·ªïng Quan

RunOut-Biliard s·ª≠ d·ª•ng GitHub Actions ƒë·ªÉ t·ª± ƒë·ªông h√≥a quy tr√¨nh Continuous Integration (CI) v√† Continuous Deployment (CD). T√†i li·ªáu n√†y m√¥ t·∫£ c√°ch th·ª©c ho·∫°t ƒë·ªông c·ªßa c√°c pipeline CI/CD v√† c√°ch c√°c developer c√≥ th·ªÉ l√†m vi·ªác v·ªõi ch√∫ng.

## Quy Tr√¨nh L√†m Vi·ªác (Workflow)

### 1. Quy Tr√¨nh Ph√°t Tri·ªÉn

1. **T·∫°o Branch M·ªõi**: B·∫Øt ƒë·∫ßu t·ª´ nh√°nh `develop`, t·∫°o m·ªôt branch m·ªõi cho t√≠nh nƒÉng ho·∫∑c s·ª≠a l·ªói c·ªßa b·∫°n:
   ```bash
   git checkout develop
   git pull
   git checkout -b feature/your-feature-name
   ```

2. **Ph√°t Tri·ªÉn**: Vi·∫øt code, tests v√† commit th∆∞·ªùng xuy√™n:
   ```bash
   git add .
   git commit -m "feat: implement xyz feature"
   ```

3. **Push Branch**: ƒê·∫©y branch l√™n GitHub:
   ```bash
   git push -u origin feature/your-feature-name
   ```

4. **T·∫°o Pull Request**: T·∫°o Pull Request (PR) t·ª´ branch c·ªßa b·∫°n v√†o nh√°nh `develop`.
   - ƒêi·ªÅn th√¥ng tin theo template PR
   - Ch·ªâ ƒë·ªãnh reviewer th√≠ch h·ª£p

5. **CI T·ª± ƒê·ªông Ch·∫°y**: Khi PR ƒë∆∞·ª£c t·∫°o, workflow CI s·∫Ω t·ª± ƒë·ªông ch·∫°y.

6. **Merge**: Sau khi PR ƒë∆∞·ª£c approve v√† t·∫•t c·∫£ checks ƒë√£ th√†nh c√¥ng, b·∫°n c√≥ th·ªÉ merge PR v√†o nh√°nh `develop`.

### 2. Quy Tr√¨nh Release

1. **T·∫°o Release Branch**: Khi chu·∫©n b·ªã release, t·∫°o branch t·ª´ `develop`:
   ```bash
   git checkout develop
   git checkout -b release/v1.0.0
   ```

2. **C·∫≠p Nh·∫≠t Version**: C·∫≠p nh·∫≠t version trong package.json v√† c√°c t√†i li·ªáu kh√°c.

3. **T·∫°o PR v√†o Main**: T·∫°o Pull Request t·ª´ branch release v√†o nh√°nh `main`.

4. **Ch·∫°y Tests**: ƒê·∫£m b·∫£o CI ho√†n th√†nh th√†nh c√¥ng.

5. **Merge v√†o Main**: Sau khi PR ƒë∆∞·ª£c approve, merge v√†o `main`.

6. **T·∫°o Tag**: T·∫°o tag cho version m·ªõi:
   ```bash
   git checkout main
   git pull
   git tag -a v1.0.0 -m "Version 1.0.0"
   git push origin v1.0.0
   ```

7. **ƒê·ªìng B·ªô v·ªÅ Develop**: T·∫°o PR ƒë·ªÉ merge `main` tr·ªü l·∫°i `develop`.

## Chi Ti·∫øt v·ªÅ CI Pipeline

Pipeline CI s·∫Ω t·ª± ƒë·ªông ch·∫°y khi:
- Push v√†o nh√°nh `main` ho·∫∑c `develop`
- T·∫°o Pull Request v√†o `main` ho·∫∑c `develop`

### C√°c b∆∞·ªõc trong CI Pipeline

1. **Backend Tests**:
   - Kh·ªüi t·∫°o m√¥i tr∆∞·ªùng v·ªõi Node.js v√† MongoDB
   - C√†i ƒë·∫∑t dependencies
   - Ki·ªÉm tra linting
   - Ch·∫°y unit tests v√† integration tests
   - T·∫°o coverage report

2. **Frontend Tests**:
   - C√†i ƒë·∫∑t dependencies
   - Ki·ªÉm tra linting
   - Ch·∫°y unit tests
   - Build ·ª©ng d·ª•ng

3. **Security Scan**:
   - Ch·∫°y npm audit ƒë·ªÉ ki·ªÉm tra c√°c dependencies c√≥ v·∫•n ƒë·ªÅ b·∫£o m·∫≠t kh√¥ng

## Chi Ti·∫øt v·ªÅ CD Pipeline

Pipeline CD s·∫Ω t·ª± ƒë·ªông ch·∫°y khi:
- Push v√†o nh√°nh `main`
- K√≠ch ho·∫°t th·ªß c√¥ng qua GitHub

### C√°c b∆∞·ªõc trong CD Pipeline

1. **Deploy Backend**:
   - Build Docker image
   - Push image l√™n Docker Hub
   - SSH v√†o production server v√† c·∫≠p nh·∫≠t container

2. **Deploy Frontend**:
   - Build ·ª©ng d·ª•ng React v·ªõi bi·∫øn m√¥i tr∆∞·ªùng production
   - Deploy l√™n service hosting (Netlify/Vercel)

3. **Notify**:
   - G·ª≠i th√¥ng b√°o t·ªõi Slack v·ªÅ status c·ªßa deployment

## Bi·∫øn M√¥i Tr∆∞·ªùng trong GitHub Secrets

C√°c GitHub Secrets sau c·∫ßn ƒë∆∞·ª£c c·∫•u h√¨nh:

- `DOCKER_HUB_USERNAME`: Username Docker Hub
- `DOCKER_HUB_TOKEN`: Token ƒë·ªÉ authenticate v·ªõi Docker Hub
- `PRODUCTION_HOST`: Hostname ho·∫∑c IP c·ªßa production server
- `PRODUCTION_USERNAME`: Username SSH cho server
- `PRODUCTION_SSH_KEY`: Private key SSH
- `PRODUCTION_API_URL`: URL c·ªßa API production
- `NETLIFY_AUTH_TOKEN`: Token Netlify (n·∫øu s·ª≠ d·ª•ng)
- `NETLIFY_SITE_ID`: ID site Netlify (n·∫øu s·ª≠ d·ª•ng)
- `SLACK_WEBHOOK`: Webhook URL cho th√¥ng b√°o Slack

## Troubleshooting

### Pipeline CI Failed

1. Ki·ªÉm tra build logs trong tab Actions c·ªßa GitHub
2. S·ª≠a c√°c l·ªói ƒë∆∞·ª£c b√°o c√°o trong logs
3. Push changes v√†o PR branch
4. CI pipeline s·∫Ω t·ª± ƒë·ªông ch·∫°y l·∫°i

### Pipeline CD Failed

1. Ki·ªÉm tra logs v√† errors
2. ƒê·∫£m b·∫£o t·∫•t c·∫£ secrets ƒë∆∞·ª£c c·∫•u h√¨nh ƒë√∫ng
3. Ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn production server
4. Th·ª≠ deploy l·∫°i th·ªß c√¥ng b·∫±ng c√°ch k√≠ch ho·∫°t workflow CD trong tab Actions

## Quy ∆Ø·ªõc Commit

D·ª± √°n n√†y s·ª≠ d·ª•ng quy ∆∞·ªõc [Conventional Commits](https://www.conventionalcommits.org/):

- `feat`: Th√™m t√≠nh nƒÉng m·ªõi
- `fix`: S·ª≠a l·ªói
- `docs`: Thay ƒë·ªïi documentation
- `style`: Thay ƒë·ªïi kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn code (format, spaces, etc.)
- `refactor`: Thay ƒë·ªïi code kh√¥ng th√™m t√≠nh nƒÉng ho·∫∑c s·ª≠a l·ªói
- `perf`: C·∫£i thi·ªán hi·ªáu su·∫•t
- `test`: Th√™m ho·∫∑c s·ª≠a tests
- `chore`: Thay ƒë·ªïi build process, tools, etc.

V√≠ d·ª•:
```
feat: add user authentication
fix: correct product pagination
docs: update deployment instructions
```

---

¬© 2025 RunOut-Biliard. T·∫•t c·∫£ c√°c quy·ªÅn thu·ªôc v·ªÅ Steve.

--- File: nginx/conf.d/default.conf ---
server {
    listen 80;
    server_name example.com www.example.com;
    
    # Redirect t·∫•t c·∫£ c√°c request HTTP sang HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name example.com www.example.com;
    
    # SSL Configuration
    ssl_certificate /etc/nginx/ssl/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:10m;
    ssl_session_tickets off;
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'; frame-ancestors 'self';" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    # Logs
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
    
    # API Endpoints
    location /api {
        proxy_pass http://backend:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeout settings
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Cache settings
        proxy_cache_bypass $http_upgrade;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
    
    # Root location - Serve SPA frontend
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
        
        # Caching static assets
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 30d;
            add_header Cache-Control "public, no-transform";
        }
        
        # No cache for HTML files
        location ~* \.html$ {
            expires -1;
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        }
    }
    
    # Custom error pages
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    # Favicon
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }
    
    # Robots.txt
    location = /robots.txt {
        log_not_found off;
        access_log off;
    }
    
    # Deny access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Custom header to identify website owner
    add_header X-Owner "RunOut-Biliard - Steve" always;
}

--- File: prometheus/prometheus.yml ---
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  scrape_timeout: 10s

# Alertmanager configuration
alerting:
  alertmanagers:
    - static_configs:
        - targets: []

# Rule files to load
rule_files:
  - "rules/*.yml"

# Scrape configurations
scrape_configs:
  # Prometheus itself
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Node Exporter for system metrics
  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']

  # MongoDB Exporter
  - job_name: 'mongodb'
    static_configs:
      - targets: ['mongodb-exporter:9216']

  # Backend Service
  - job_name: 'backend'
    metrics_path: '/api/metrics'
    static_configs:
      - targets: ['backend:5000']

  # Nginx Exporter
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']

--- File: scripts/init-structure.sh ---
#!/bin/bash

# T·∫°o th∆∞ m·ª•c g·ªëc
mkdir -p runout-biliard

# Server (Backend Node.js/Express)
mkdir -p runout-biliard/server/src/{api,services,data,common,config}
touch runout-biliard/server/src/{app.js,server.js}
mkdir -p runout-biliard/server/tests
touch runout-biliard/server/{.eslintrc.js,.prettierrc,jest.config.js,package.json,README.md}

# Client (Frontend React)
mkdir -p runout-biliard/client/public
mkdir -p runout-biliard/client/src/{assets,components,hooks,pages,services,store,utils,routes}
touch runout-biliard/client/src/{App.js,index.js}
touch runout-biliard/client/{.eslintrc.js,.prettierrc,package.json,README.md}

# Docker files
mkdir -p runout-biliard/docker
touch runout-biliard/docker/{docker-compose.yml,Dockerfile.server,Dockerfile.client}

# GitHub Actions
mkdir -p runout-biliard/.github/workflows
touch runout-biliard/.github/workflows/{ci.yml,deploy.yml}

# Root files
touch runout-biliard/.gitignore
touch runout-biliard/README.md

echo "‚úÖ C·∫•u tr√∫c th∆∞ m·ª•c d·ª± √°n runout-biliard ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng."


--- File: scripts/mongodb-backup.sh ---
#!/bin/sh

# Script th·ª±c hi·ªán sao l∆∞u MongoDB
# T√°c gi·∫£: Steve
# D·ª± √°n: RunOut-Biliard

# Bi·∫øn m√¥i tr∆∞·ªùng
MONGO_HOST=${MONGO_HOST:-mongodb}
MONGO_PORT=${MONGO_PORT:-27017}
MONGO_USERNAME=${MONGO_USERNAME:-root}
MONGO_PASSWORD=${MONGO_PASSWORD:-example}
MONGO_DATABASE=${MONGO_DATABASE:-runout_biliard}
BACKUP_DIR=${BACKUP_DIR:-/backup}
BACKUP_CRON=${BACKUP_CRON:-"0 2 * * *"} # M·∫∑c ƒë·ªãnh: 2 gi·ªù s√°ng h√†ng ng√†y
BACKUP_RETENTION=${BACKUP_RETENTION:-7} # Gi·ªØ l·∫°i backup trong 7 ng√†y

# ƒê·∫£m b·∫£o th∆∞ m·ª•c backup t·ªìn t·∫°i
mkdir -p ${BACKUP_DIR}

# H√†m th·ª±c hi·ªán backup
perform_backup() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILENAME="${MONGO_DATABASE}_${TIMESTAMP}.gz"
    BACKUP_PATH="${BACKUP_DIR}/${BACKUP_FILENAME}"
    
    echo "$(date): B·∫Øt ƒë·∫ßu sao l∆∞u ${MONGO_DATABASE} v√†o ${BACKUP_PATH}..."
    
    # Th·ª±c hi·ªán backup v·ªõi mongodump
    mongodump \
        --host=${MONGO_HOST} \
        --port=${MONGO_PORT} \
        --username=${MONGO_USERNAME} \
        --password=${MONGO_PASSWORD} \
        --authenticationDatabase=admin \
        --db=${MONGO_DATABASE} \
        --gzip \
        --archive=${BACKUP_PATH}
    
    # Ki·ªÉm tra k·∫øt qu·∫£
    if [ $? -eq 0 ]; then
        echo "$(date): Sao l∆∞u th√†nh c√¥ng: ${BACKUP_PATH}"
        
        # C·∫≠p nh·∫≠t ch·ªß s·ªü h·ªØu file
        chmod 600 ${BACKUP_PATH}
        
        # L∆∞u th√¥ng tin meta
        echo "Database: ${MONGO_DATABASE}" > "${BACKUP_PATH}.meta"
        echo "Created at: $(date)" >> "${BACKUP_PATH}.meta"
        echo "Server: ${MONGO_HOST}:${MONGO_PORT}" >> "${BACKUP_PATH}.meta"
        echo "Signature: RunOut-Biliard - Steve" >> "${BACKUP_PATH}.meta"
    else
        echo "$(date): Sao l∆∞u th·∫•t b·∫°i: ${BACKUP_PATH}"
    fi
}

# H√†m x√≥a backup c≈©
cleanup_old_backups() {
    echo "$(date): X√≥a c√°c b·∫£n sao l∆∞u c≈© h∆°n ${BACKUP_RETENTION} ng√†y..."
    find ${BACKUP_DIR} -name "${MONGO_DATABASE}_*.gz" -type f -mtime +${BACKUP_RETENTION} -delete
    find ${BACKUP_DIR} -name "${MONGO_DATABASE}_*.gz.meta" -type f -mtime +${BACKUP_RETENTION} -delete
    echo "$(date): ƒê√£ x√≥a c√°c b·∫£n sao l∆∞u c≈©."
}

# Th·ª±c hi·ªán backup ngay l·∫≠p t·ª©c
perform_backup
cleanup_old_backups

# N·∫øu ƒë∆∞·ª£c ch·∫°y nh∆∞ m·ªôt container ƒë·ªôc l·∫≠p, thi·∫øt l·∫≠p cron job
if [ "$1" = "schedule" ]; then
    echo "Thi·∫øt l·∫≠p cron job: ${BACKUP_CRON}"
    echo "${BACKUP_CRON} /scripts/mongodb-backup.sh backup" > /etc/crontabs/root
    crond -f -d 8
else
    echo "Backup th·ªß c√¥ng ho√†n t·∫•t. Tho√°t..."
fi

--- File: scripts/setup-directory-structure.sh ---
#!/bin/bash

# Script t·∫°o c·∫•u tr√∫c th∆∞ m·ª•c cho d·ª± √°n RunOut-Biliard
# T√°c gi·∫£: Steve
# Ng√†y: $(date +"%d/%m/%Y")

# Colors for terminal output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Th∆∞ m·ª•c g·ªëc
ROOT_DIR="server"

# T·∫°o th∆∞ m·ª•c g·ªëc n·∫øu ch∆∞a t·ªìn t·∫°i
mkdir -p ${ROOT_DIR}

echo -e "${GREEN}B·∫Øt ƒë·∫ßu t·∫°o c·∫•u tr√∫c th∆∞ m·ª•c cho d·ª± √°n RunOut-Biliard...${NC}"

# T·∫°o c√°c file c·∫•u h√¨nh c∆° b·∫£n
touch ${ROOT_DIR}/.env.example
touch ${ROOT_DIR}/.eslintrc.js
touch ${ROOT_DIR}/.prettierrc
touch ${ROOT_DIR}/README.md
touch ${ROOT_DIR}/jest.config.js
touch ${ROOT_DIR}/jsconfig.json
touch ${ROOT_DIR}/package.json

# T·∫°o th∆∞ m·ª•c logs v√† tests
mkdir -p ${ROOT_DIR}/logs
mkdir -p ${ROOT_DIR}/tests/unit/services
mkdir -p ${ROOT_DIR}/tests/unit/repositories
mkdir -p ${ROOT_DIR}/tests/unit/controllers
mkdir -p ${ROOT_DIR}/tests/integration/api
mkdir -p ${ROOT_DIR}/tests/integration/repositories
touch ${ROOT_DIR}/tests/setup.js

# T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c src
mkdir -p ${ROOT_DIR}/src

# 1. API Layer
mkdir -p ${ROOT_DIR}/src/api/controllers
mkdir -p ${ROOT_DIR}/src/api/routes
mkdir -p ${ROOT_DIR}/src/api/middleware

# T·∫°o controllers
for controller in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/api/controllers/${controller}Controller.js
done

# T·∫°o routes
for route in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/api/routes/${route}Routes.js
done

# T·∫°o middleware API c·ª• th·ªÉ
touch ${ROOT_DIR}/src/api/middleware/errorMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/loggingMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/validationMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/authMiddleware.js

# 2. Common Layer
mkdir -p ${ROOT_DIR}/src/common/errors
mkdir -p ${ROOT_DIR}/src/common/middleware
mkdir -p ${ROOT_DIR}/src/common/utils
mkdir -p ${ROOT_DIR}/src/common/validators
mkdir -p ${ROOT_DIR}/src/common/types

# T·∫°o errors
touch ${ROOT_DIR}/src/common/errors/apiError.js

# T·∫°o middleware chung
touch ${ROOT_DIR}/src/common/middleware/errorHandler.js
touch ${ROOT_DIR}/src/common/middleware/validate.js
touch ${ROOT_DIR}/src/common/middleware/requestLogger.js

# T·∫°o utils chung
touch ${ROOT_DIR}/src/common/utils/apiFeatures.js
touch ${ROOT_DIR}/src/common/utils/catchAsync.js
touch ${ROOT_DIR}/src/common/utils/responseHandler.js
touch ${ROOT_DIR}/src/common/utils/validatorUtils.js

# T·∫°o validators
for validator in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/common/validators/${validator}Validator.js
done

# 3. Config Layer
mkdir -p ${ROOT_DIR}/src/config
touch ${ROOT_DIR}/src/config/database.js
touch ${ROOT_DIR}/src/config/environment.js
touch ${ROOT_DIR}/src/config/indexes.js
touch ${ROOT_DIR}/src/config/logger.js
touch ${ROOT_DIR}/src/config/middleware.js
touch ${ROOT_DIR}/src/config/monitoring.js

# 4. Data Layer
mkdir -p ${ROOT_DIR}/src/data/models
mkdir -p ${ROOT_DIR}/src/data/repositories
mkdir -p ${ROOT_DIR}/src/data/dto

# T·∫°o models
touch ${ROOT_DIR}/src/data/models/user.model.js
touch ${ROOT_DIR}/src/data/models/product.model.js
touch ${ROOT_DIR}/src/data/models/category.model.js
touch ${ROOT_DIR}/src/data/models/order.model.js
touch ${ROOT_DIR}/src/data/models/cart.model.js
touch ${ROOT_DIR}/src/data/models/review.model.js

# T·∫°o repositories
touch ${ROOT_DIR}/src/data/repositories/userRepository.js
touch ${ROOT_DIR}/src/data/repositories/productRepository.js
touch ${ROOT_DIR}/src/data/repositories/categoryRepository.js
touch ${ROOT_DIR}/src/data/repositories/orderRepository.js
touch ${ROOT_DIR}/src/data/repositories/cartRepository.js
touch ${ROOT_DIR}/src/data/repositories/reviewRepository.js

# T·∫°o DTOs
touch ${ROOT_DIR}/src/data/dto/userDTO.js
touch ${ROOT_DIR}/src/data/dto/productDTO.js
touch ${ROOT_DIR}/src/data/dto/categoryDTO.js
touch ${ROOT_DIR}/src/data/dto/orderDTO.js
touch ${ROOT_DIR}/src/data/dto/cartDTO.js
touch ${ROOT_DIR}/src/data/dto/reviewDTO.js

# 5. Migrations
mkdir -p ${ROOT_DIR}/src/migrations/scripts
touch ${ROOT_DIR}/src/migrations/config.js
touch ${ROOT_DIR}/src/migrations/index.js
touch ${ROOT_DIR}/src/migrations/migrationRunner.js
touch ${ROOT_DIR}/src/migrations/scripts/001-initial-categories.js
touch ${ROOT_DIR}/src/migrations/scripts/002-add-indexes.js

# 6. Seeds
mkdir -p ${ROOT_DIR}/src/seeds/data
mkdir -p ${ROOT_DIR}/src/seeds/scripts
touch ${ROOT_DIR}/src/seeds/index.js
touch ${ROOT_DIR}/src/seeds/runner.js

# T·∫°o seed data
touch ${ROOT_DIR}/src/seeds/data/categories.js
touch ${ROOT_DIR}/src/seeds/data/products.js
touch ${ROOT_DIR}/src/seeds/data/users.js
touch ${ROOT_DIR}/src/seeds/data/orders.js
touch ${ROOT_DIR}/src/seeds/data/carts.js
touch ${ROOT_DIR}/src/seeds/data/reviews.js

# T·∫°o seed scripts
touch ${ROOT_DIR}/src/seeds/scripts/categorySeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/productSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/userSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/orderSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/cartSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/reviewSeeder.js

# 7. Services
mkdir -p ${ROOT_DIR}/src/services/auth
mkdir -p ${ROOT_DIR}/src/services/base
mkdir -p ${ROOT_DIR}/src/services/cache
mkdir -p ${ROOT_DIR}/src/services/email/templates
mkdir -p ${ROOT_DIR}/src/services/product
mkdir -p ${ROOT_DIR}/src/services/category
mkdir -p ${ROOT_DIR}/src/services/user
mkdir -p ${ROOT_DIR}/src/services/order
mkdir -p ${ROOT_DIR}/src/services/cart
mkdir -p ${ROOT_DIR}/src/services/review

# T·∫°o services
touch ${ROOT_DIR}/src/services/auth/authService.js
touch ${ROOT_DIR}/src/services/base/baseService.js
touch ${ROOT_DIR}/src/services/cache/redisCache.js
touch ${ROOT_DIR}/src/services/email/emailService.js
touch ${ROOT_DIR}/src/services/email/templates/resetPassword.hbs
touch ${ROOT_DIR}/src/services/email/templates/verification.hbs
touch ${ROOT_DIR}/src/services/product/productService.js
touch ${ROOT_DIR}/src/services/category/categoryService.js
touch ${ROOT_DIR}/src/services/user/userService.js
touch ${ROOT_DIR}/src/services/order/orderService.js
touch ${ROOT_DIR}/src/services/cart/cartService.js
touch ${ROOT_DIR}/src/services/review/reviewService.js

# 8. Utils v√† Types
mkdir -p ${ROOT_DIR}/src/utils
mkdir -p ${ROOT_DIR}/src/types
touch ${ROOT_DIR}/src/utils/queryAnalyzer.js
touch ${ROOT_DIR}/src/types/express.d.ts

# 9. App v√† Server
touch ${ROOT_DIR}/src/app.js
touch ${ROOT_DIR}/src/server.js

echo -e "${GREEN}ƒê√£ t·∫°o xong c·∫•u tr√∫c th∆∞ m·ª•c!${NC}"
echo -e "${BLUE}T·ªïng s·ªë file ƒë√£ t·∫°o: $(find ${ROOT_DIR} -type f | wc -l)${NC}"
echo -e "${BLUE}T·ªïng s·ªë th∆∞ m·ª•c ƒë√£ t·∫°o: $(find ${ROOT_DIR} -type d | wc -l)${NC}"
echo -e "${YELLOW}C·∫•u tr√∫c th∆∞ m·ª•c ƒë√£ ƒë∆∞·ª£c t·∫°o t·∫°i th∆∞ m·ª•c: $(pwd)/${ROOT_DIR}${NC}"

# Hi·ªÉn th·ªã c·∫•u tr√∫c th∆∞ m·ª•c (n·∫øu c√≥ l·ªánh tree)
if command -v tree &> /dev/null; then
    tree ${ROOT_DIR} -L 3
else
    echo -e "${YELLOW}ƒê·ªÉ xem c·∫•u tr√∫c th∆∞ m·ª•c ƒë·∫ßy ƒë·ªß, h√£y c√†i ƒë·∫∑t l·ªánh 'tree' v√† ch·∫°y: tree ${ROOT_DIR}${NC}"
fi

echo -e "${GREEN}Ho√†n t·∫•t!${NC}"

--- File: server/.eslintrc.js ---
module.exports = {
  env: {
    node: true,
    commonjs: true,
    es2021: true,
    jest: true,
  },
  extends: ['eslint:recommended', 'plugin:node/recommended', 'plugin:jest/recommended', 'prettier'],
  parserOptions: {
    ecmaVersion: 'latest',
  },
  plugins: ['prettier', 'jest'],
  rules: {
    'prettier/prettier': 'error',
    'no-console': 'warn',
    'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'node/exports-style': ['error', 'module.exports'],
    'node/file-extension-in-import': ['error', 'always'],
    'node/prefer-global/buffer': ['error', 'always'],
    'node/prefer-global/console': ['error', 'always'],
    'node/prefer-global/process': ['error', 'always'],
    'node/prefer-global/url-search-params': ['error', 'always'],
    'node/prefer-global/url': ['error', 'always'],
    'node/prefer-promises/dns': 'error',
    'node/prefer-promises/fs': 'error',
    'jest/no-disabled-tests': 'warn',
    'jest/no-focused-tests': 'error',
    'jest/no-identical-title': 'error',
    'jest/valid-expect': 'error',
  },
};


--- File: server/.prettierrc ---
{
    "semi": true,
    "singleQuote": true,
    "trailingComma": "es5",
    "printWidth": 100,
    "tabWidth": 2,
    "useTabs": false,
    "bracketSpacing": true,
    "arrowParens": "always",
    "endOfLine": "lf"
    
  }

--- File: server/README.md ---
# RunOut-Biliard Backend

## Gi·ªõi Thi·ªáu

Backend cho h·ªá th·ªëng RunOut-Biliard, x√¢y d·ª±ng tr√™n n·ªÅn t·∫£ng Node.js, Express v√† MongoDB. H·ªá th·ªëng ƒë∆∞·ª£c thi·∫øt k·∫ø v·ªõi ki·∫øn tr√∫c ph√¢n l·ªõp, t√°ch bi·ªát r√µ r√†ng c√°c th√†nh ph·∫ßn v√† d·ªÖ d√†ng m·ªü r·ªông.

## C·∫•u Tr√∫c D·ª± √Ån

server/
‚îú‚îÄ‚îÄ .env                      # Ch·ª©a c√°c bi·∫øn m√¥i tr∆∞·ªùng (API keys, database connection strings, ports, etc.)
‚îú‚îÄ‚îÄ .eslintrc.js              # C·∫•u h√¨nh ESLint - c√¥ng c·ª• ki·ªÉm tra l·ªói v√† format code JavaScript
‚îú‚îÄ‚îÄ .prettierrc               # C·∫•u h√¨nh Prettier - c√¥ng c·ª• t·ª± ƒë·ªông format code
‚îú‚îÄ‚îÄ README.md                 # T√†i li·ªáu m√¥ t·∫£ t·ªïng quan v·ªÅ d·ª± √°n, h∆∞·ªõng d·∫´n c√†i ƒë·∫∑t v√† s·ª≠ d·ª•ng
‚îú‚îÄ‚îÄ jest.config.js            # C·∫•u h√¨nh Jest - framework testing cho JavaScript
‚îú‚îÄ‚îÄ jsconfig.json             # C·∫•u h√¨nh cho JavaScript trong VS Code (intellisense, path aliases)
‚îú‚îÄ‚îÄ package.json              # Qu·∫£n l√Ω dependencies v√† scripts c·ªßa d·ª± √°n
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ api/                       # API Layer - x·ª≠ l√Ω t·∫•t c·∫£ c√°c HTTP request/response
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/           # X·ª≠ l√Ω logic nh·∫≠n request t·ª´ routes v√† g·ªçi services t∆∞∆°ng ·ª©ng
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.js       # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn x√°c th·ª±c
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productController.js    # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn s·∫£n ph·∫©m
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ userController.js       # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn ng∆∞·ªùi d√πng
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ categoryController.js   # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn danh m·ª•c
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderController.js      # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn ƒë∆°n h√†ng
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cartController.js       # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn gi·ªè h√†ng
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reviewController.js     # X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn ƒë√°nh gi√°
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/            # Middleware c·ª• th·ªÉ cho API endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorMiddleware.js      # X·ª≠ l√Ω c√°c l·ªói t·ª´ API routes
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loggingMiddleware.js    # Ghi log c√°c request/response API
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validationMiddleware.js # X√°c th·ª±c d·ªØ li·ªáu tr∆∞·ªõc khi x·ª≠ l√Ω requests
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authMiddleware.js       # X√°c th·ª±c JWT v√† x√°c minh quy·ªÅn ng∆∞·ªùi d√πng
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes/                # ƒê·ªãnh nghƒ©a API endpoints v√† mapping t·ªõi controllers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ authRoutes.js           # Endpoints x√°c th·ª±c (ƒëƒÉng nh·∫≠p, ƒëƒÉng k√Ω, ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ productRoutes.js        # Endpoints qu·∫£n l√Ω s·∫£n ph·∫©m (CRUD)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ userRoutes.js           # Endpoints qu·∫£n l√Ω ng∆∞·ªùi d√πng (CRUD)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ categoryRoutes.js       # Endpoints qu·∫£n l√Ω danh m·ª•c (CRUD)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ orderRoutes.js          # Endpoints qu·∫£n l√Ω ƒë∆°n h√†ng (CRUD)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cartRoutes.js           # Endpoints qu·∫£n l√Ω gi·ªè h√†ng (CRUD)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reviewRoutes.js         # Endpoints qu·∫£n l√Ω ƒë√°nh gi√° (CRUD)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ app.js                     # Setup Express application, c·∫•u h√¨nh middleware v√† routes
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ common/                    # Shared code d√πng chung trong to√†n b·ªô ·ª©ng d·ª•ng
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors/                # Custom error classes
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ apiError.js             # Class ƒë·ªãnh nghƒ©a c√°c lo·∫°i l·ªói API
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/            # Middleware d√πng chung
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.js         # Middleware x·ª≠ l√Ω l·ªói chung
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validate.js             # Middleware validation chung
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requestLogger.js        # Middleware ghi log request/response
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/                 # Type definitions v√† interfaces
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/                 # C√°c utility functions d√πng trong nhi·ªÅu modules
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ apiFeatures.js          # X·ª≠ l√Ω filtering, sorting, pagination
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ catchAsync.js           # Wrapper function ƒë·ªÉ x·ª≠ l√Ω async errors
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ responseHandler.js      # Format response tr·∫£ v·ªÅ t·ª´ API
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validatorUtils.js       # C√°c helper functions cho validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validators/            # ƒê·ªãnh nghƒ©a validation schema v√† rules
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ authValidator.js        # Validation rules cho auth requests
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ userValidator.js        # Validation rules cho user requests
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ productValidator.js     # Validation rules cho product requests
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ categoryValidator.js    # Validation rules cho category requests
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ orderValidator.js       # Validation rules cho order requests
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cartValidator.js        # Validation rules cho cart requests
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reviewValidator.js      # Validation rules cho review requests
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/                    # C·∫•u h√¨nh ·ª©ng d·ª•ng
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.js                 # C·∫•u h√¨nh k·∫øt n·ªëi MongoDB
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ environment.js              # Qu·∫£n l√Ω bi·∫øn m√¥i tr∆∞·ªùng
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ indexes.js                  # C·∫•u h√¨nh indexes cho database
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js                   # C·∫•u h√¨nh logging
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware.js               # C·∫•u h√¨nh middleware ·ª©ng d·ª•ng
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ monitoring.js               # C·∫•u h√¨nh health checks v√† monitoring
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ data/                      # Data Layer - t∆∞∆°ng t√°c v·ªõi database
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/                   # Data Transfer Objects - chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu gi·ªØa service v√† controller
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cartDTO.js              # DTO cho cart data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ categoryDTO.js          # DTO cho category data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderDTO.js             # DTO cho order data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productDTO.js           # DTO cho product data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reviewDTO.js            # DTO cho review data
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userDTO.js              # DTO cho user data
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/                # Mongoose Models - ƒë·ªãnh nghƒ©a schema v√† validation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart.model.js           # Model cho collection carts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.model.js       # Model cho collection categories
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.model.js          # Model cho collection orders
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.model.js        # Model cho collection products
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ review.model.js         # Model cho collection reviews
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.model.js           # Model cho collection users
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/          # Repository Pattern - truy v·∫•n database v√† x·ª≠ l√Ω d·ªØ li·ªáu
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cartRepository.js       # Repository cho cart data
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ categoryRepository.js   # Repository cho category data
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ orderRepository.js      # Repository cho order data
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ productRepository.js    # Repository cho product data
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ reviewRepository.js     # Repository cho review data
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ userRepository.js       # Repository cho user data
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ migrations/                # Database migrations - qu·∫£n l√Ω thay ƒë·ªïi schema
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.js                   # C·∫•u h√¨nh migration framework
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/                    # Scripts migration c·ª• th·ªÉ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001-initial-categories.js  # Migration ƒë·∫ßu ti√™n t·∫°o categories
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 002-add-indexes.js        # Migration th√™m indexes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js                    # Entry point cho migrations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrationRunner.js          # Logic ch·∫°y migrations
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ seeds/                     # Database seeds - t·∫°o d·ªØ li·ªáu m·∫´u ban ƒë·∫ßu
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/                  # D·ªØ li·ªáu m·∫´u d√πng cho seeding
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ categories.js           # D·ªØ li·ªáu m·∫´u cho categories
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.js             # D·ªØ li·ªáu m·∫´u cho products
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.js                # D·ªØ li·ªáu m·∫´u cho users
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.js               # D·ªØ li·ªáu m·∫´u cho orders
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ carts.js                # D·ªØ li·ªáu m·∫´u cho carts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reviews.js              # D·ªØ li·ªáu m·∫´u cho reviews
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/               # Scripts ch·∫°y seed data
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ categorySeeder.js       # Seeder cho categories
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ productSeeder.js        # Seeder cho products
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ userSeeder.js           # Seeder cho users
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderSeeder.js          # Seeder cho orders
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cartSeeder.js           # Seeder cho carts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reviewSeeder.js         # Seeder cho reviews
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js                    # Entry point cho seeds
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ runner.js                   # Logic ch·∫°y seeds
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ server.js                  # Entry point c·ªßa ·ª©ng d·ª•ng, kh·ªüi ƒë·ªông server
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/                  # Service Layer - ch·ª©a business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/                  # Auth services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authService.js          # Logic x√°c th·ª±c v√† ph√¢n quy·ªÅn
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base/                  # Base services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ baseService.js          # Service c∆° s·ªü ƒë·ªÉ extend
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache/                 # Caching services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ redisCache.js           # Service qu·∫£n l√Ω cache v·ªõi Redis
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email/                 # Email services
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emailService.js         # Service g·ª≠i email
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ templates/              # Templates email
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ resetPassword.hbs   # Template email ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ verification.hbs    # Template email x√°c minh t√†i kho·∫£n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product/               # Product services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ productService.js       # Logic x·ª≠ l√Ω s·∫£n ph·∫©m
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category/              # Category services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ categoryService.js      # Logic x·ª≠ l√Ω danh m·ª•c
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user/                  # User services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userService.js          # Logic x·ª≠ l√Ω ng∆∞·ªùi d√πng
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order/                 # Order services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orderService.js         # Logic x·ª≠ l√Ω ƒë∆°n h√†ng
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart/                  # Cart services
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cartService.js          # Logic x·ª≠ l√Ω gi·ªè h√†ng
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ review/                # Review services
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reviewService.js        # Logic x·ª≠ l√Ω ƒë√°nh gi√°
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/                     # Utilities chung √≠t d√πng h∆°n
‚îÇ       ‚îî‚îÄ‚îÄ queryAnalyzer.js            # Ph√¢n t√≠ch hi·ªáu su·∫•t truy v·∫•n
‚îÇ
‚îú‚îÄ‚îÄ tests/                         # Test files
‚îÇ   ‚îú‚îÄ‚îÄ unit/                      # Unit tests - ki·ªÉm th·ª≠ t·ª´ng th√†nh ph·∫ßn ri√™ng l·∫ª
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/                   # Tests cho services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/               # Tests cho repositories
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ controllers/                # Tests cho controllers
‚îÇ   ‚îú‚îÄ‚îÄ integration/               # Integration tests - ki·ªÉm th·ª≠ nhi·ªÅu th√†nh ph·∫ßn k·∫øt h·ª£p
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/                        # Tests cho API endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/               # Tests cho t∆∞∆°ng t√°c repositories v·ªõi database
‚îÇ   ‚îî‚îÄ‚îÄ setup.js                   # C·∫•u h√¨nh m√¥i tr∆∞·ªùng test
‚îÇ
‚îî‚îÄ‚îÄ logs/                          # Th∆∞ m·ª•c ch·ª©a c√°c file log

```

## Ki·∫øn Tr√∫c Ph·∫ßn M·ªÅm

Backend ƒë∆∞·ª£c x√¢y d·ª±ng theo ki·∫øn tr√∫c ph√¢n l·ªõp:

1. **API Layer**: X·ª≠ l√Ω HTTP requests v√† responses, ƒë·ªãnh tuy·∫øn v√† c√°c middleware.
2. **Service Layer**: Ch·ª©a business logic, ƒëi·ªÅu ph·ªëi d·ªØ li·ªáu v√† x·ª≠ l√Ω c√°c quy tr√¨nh.
3. **Data Access Layer**: T∆∞∆°ng t√°c v·ªõi database, truy xu·∫•t v√† c·∫≠p nh·∫≠t d·ªØ li·ªáu.
4. **Common Layer**: Ch·ª©a c√°c code d√πng chung trong to√†n ·ª©ng d·ª•ng.

## C√†i ƒê·∫∑t v√† Ch·∫°y

### Y√™u C·∫ßu

- Node.js >= 18.x
- MongoDB >= 6.0
- npm ho·∫∑c yarn

### C√†i ƒê·∫∑t Ph·ª• Thu·ªôc

```bash
# C√†i ƒë·∫∑t dependencies
npm install

# Ho·∫∑c s·ª≠ d·ª•ng yarn
yarn install
```

### C·∫•u H√¨nh M√¥i Tr∆∞·ªùng

```bash
# Sao ch√©p file .env.example th√†nh .env
cp .env.example .env

# Ch·ªânh s·ª≠a file .env v·ªõi c·∫•u h√¨nh c·ªßa b·∫°n
nano .env
```

### Ch·∫°y ·ª®ng D·ª•ng

```bash
# Ch·∫°y trong m√¥i tr∆∞·ªùng development
npm run dev

# Ch·∫°y trong m√¥i tr∆∞·ªùng production
npm start
```

### Ch·∫°y Tests

```bash
# Ch·∫°y t·∫•t c·∫£ tests
npm test

# Ch·∫°y tests v√† theo d√µi thay ƒë·ªïi
npm run test:watch
```

## API Endpoints

API c·ªßa RunOut-Biliard tu√¢n theo chu·∫©n RESTful v√† c√≥ c√°c endpoints ch√≠nh sau:

- **Authentication**: `/api/auth/*`
- **Users**: `/api/users/*`
- **Products**: `/api/products/*`
- **Categories**: `/api/categories/*`
- **Carts**: `/api/carts/*`
- **Orders**: `/api/orders/*`
- **Reviews**: `/api/reviews/*`

Chi ti·∫øt v·ªÅ c√°c API endpoints c√≥ th·ªÉ ƒë∆∞·ª£c t√¨m th·∫•y trong API documentation.

## Docker

D·ª± √°n ƒë∆∞·ª£c containerized v·ªõi Docker:

```bash
# Build image
docker build -t runout-biliard-server .

# Ch·∫°y container
docker run -p 5000:5000 runout-biliard-server
```

Ho·∫∑c s·ª≠ d·ª•ng Docker Compose:

```bash
# Kh·ªüi ƒë·ªông t·∫•t c·∫£ services
docker-compose up

# Ch·∫°y trong background
docker-compose up -d
```

## T√≠nh NƒÉng

- **Authentication & Authorization**: JWT-based authentication v√† role-based authorization.
- **User Management**: ƒêƒÉng k√Ω, ƒëƒÉng nh·∫≠p, qu·∫£n l√Ω profile.
- **Email Service**: G·ª≠i email x√°c th·ª±c v√† ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u.
- **Product Management**: CRUD cho s·∫£n ph·∫©m, danh m·ª•c, v√† ƒë√°nh gi√°.
- **Cart & Order**: Qu·∫£n l√Ω gi·ªè h√†ng v√† ƒë∆°n h√†ng.
- **Payment Integration**: T√≠ch h·ª£p c·ªïng thanh to√°n VNPay.
- **Error Handling**: X·ª≠ l√Ω l·ªói th·ªëng nh·∫•t.
- **Logging**: Logging ƒë·∫ßy ƒë·ªß cho debugging v√† monitoring.
- **Validation**: Validation d·ªØ li·ªáu ƒë·∫ßu v√†o.

## ƒê√≥ng G√≥p

1. Fork repository
2. T·∫°o branch m·ªõi (`git checkout -b feature/amazing-feature`)
3. Commit thay ƒë·ªïi c·ªßa b·∫°n (`git commit -m 'feat: add some amazing feature'`)
4. Push l√™n branch (`git push origin feature/amazing-feature`)
5. T·∫°o Pull Request

## Gi·∫•y Ph√©p

¬© 2025 RunOut-Biliard. T·∫•t c·∫£ c√°c quy·ªÅn thu·ªôc v·ªÅ Steve.


--- File: server/jest.config.js ---
module.exports = {
  testEnvironment: 'node',
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: ['src/**/*.js', '!src/server.js', '!**/node_modules/**', '!**/vendor/**'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  testPathIgnorePatterns: ['/node_modules/'],
  // Setup file tr∆∞·ªõc khi ch·∫°y tests
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  // T√πy ch·ªçn ƒë·ªëi v·ªõi m√¥i tr∆∞·ªùng test
  testEnvironmentOptions: {
    NODE_ENV: 'test',
  },
  verbose: true,
  // T·ª± ƒë·ªông x√≥a c√°c mocks gi·ªØa c√°c tests
  clearMocks: true,
  // Timeout cho tests
  testTimeout: 10000,
};


--- File: server/jsconfig.json ---
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "baseUrl": ".",
      "paths": {
        "*": ["src/*"]
      },
      "checkJs": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "moduleResolution": "node"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "**/node_modules/*", "dist", "build"]
  }

--- File: server/package.json ---
{
    "name": "runout-biliard-server",
    "version": "1.0.0",
    "description": "Backend server cho h·ªá th·ªëng RunOut-Biliard",
    "main": "src/server.js",
    "scripts": {
        "start": "node src/server.js",
        "dev": "nodemon src/server.js",
        "test": "jest --coverage",
        "test:watch": "jest --watch",
        "lint": "eslint --ext .js src/",
        "lint:fix": "eslint --ext .js src/ --fix",
        "format": "prettier --write \"src/**/*.js\"",
        "migrate": "node src/migrations migrate",
        "migrate:rollback": "node src/migrations rollback",
        "seed": "node src/seeds/index.js",
        "prepare": "husky install"
    },
    "author": "Steve",
    "license": "UNLICENSED",
    "private": true,
    "dependencies": {
        "bcrypt": "^5.1.1",
        "compression": "^1.7.4",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "csurf": "^1.10.0",
        "dotenv": "^16.3.1",
        "express": "^4.21.2",
        "express-mongo-sanitize": "^2.2.0",
        "express-rate-limit": "^7.5.0",
        "handlebars": "^4.7.8",
        "helmet": "^7.1.0",
        "hpp": "^0.2.3",
        "joi": "^17.11.0",
        "jsonwebtoken": "^9.0.2",
        "mongodb-memory-server": "^10.1.4",
        "mongoose": "^8.0.3",
        "morgan": "^1.10.0",
        "nodemailer": "^7.0.2",
        "redis": "^5.0.1",
        "winston": "^3.11.0",
        "xss-clean": "^0.1.4"
    },
    "devDependencies": {
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-jest": "^27.6.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "husky": "^8.0.3",
        "jest": "^29.7.0",
        "lint-staged": "^15.2.0",
        "nodemon": "^3.0.2",
        "prettier": "^3.1.1",
        "supertest": "^6.3.3"
    },
    "engines": {
        "node": ">=18.0.0"
    },
    "lint-staged": {
        "*.js": [
            "eslint --fix",
            "prettier --write"
        ]
    }
}


--- File: server/src/api/controllers/authController.js ---
// @ts-nocheck
/**
 * Controller cho x√°c th·ª±c ng∆∞·ªùi d√πng
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { ApiError } = require('../../middleware/errorHandler');
const User = require('../../data/models/user.model');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../../services/email/emailService');

/**
 * T·∫°o JWT token
 * @param {Object} user - User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, role: user.role },
    environment.auth.jwtSecret,
    { expiresIn: environment.auth.jwtExpiresIn }
  );
};

/**
 * T·∫°o refresh token
 * @param {Object} user - User object
 * @returns {String} Refresh token
 */
const generateRefreshToken = (user) => {
  return jwt.sign(
    { id: user._id },
    environment.auth.jwtRefreshSecret,
    { expiresIn: environment.auth.jwtRefreshExpiresIn }
  );
};

/**
 * ƒêƒÉng k√Ω ng∆∞·ªùi d√πng m·ªõi
 */
exports.register = catchAsync(async (req, res, next) => {
  const { name, email, password, phone } = req.body;
  
  // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng'));
  }
  
  // T·∫°o verification token
  const verificationToken = crypto.randomBytes(32).toString('hex');
  const verificationTokenExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 gi·ªù
  
  // T·∫°o user m·ªõi
  const newUser = await User.create({
    name,
    email,
    password,
    phone,
    emailVerificationToken: crypto
      .createHash('sha256')
      .update(verificationToken)
      .digest('hex'),
    emailVerificationExpires: verificationTokenExpires,
  });
  
  try {
    // G·ª≠i email x√°c th·ª±c
    const verifyURL = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    await sendEmail({
      to: email,
      subject: 'X√°c th·ª±c t√†i kho·∫£n RunOut-Biliard',
      template: 'verification',
      context: {
        name,
        verifyURL,
      },
    });
    
    res.status(201).json({
      status: 'success',
      message: 'Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c t·∫°o. Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ x√°c th·ª±c t√†i kho·∫£n.',
    });
  } catch (error) {
    // X·ª≠ l√Ω l·ªói g·ª≠i email
    logger.error(`Kh√¥ng th·ªÉ g·ª≠i email x√°c th·ª±c: ${error.message}`);
    
    // X√≥a user trong tr∆∞·ªùng h·ª£p email kh√¥ng g·ª≠i ƒë∆∞·ª£c
    await User.findByIdAndDelete(newUser._id);
    
    return next(new ApiError(
      500,
      'ƒê√£ x·∫£y ra l·ªói khi g·ª≠i email x√°c th·ª±c. Vui l√≤ng th·ª≠ l·∫°i sau.'
    ));
  }
});

/**
 * ƒêƒÉng nh·∫≠p
 */
exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  
  // Ki·ªÉm tra email v√† password
  if (!email || !password) {
    return next(new ApiError(400, 'Vui l√≤ng cung c·∫•p email v√† m·∫≠t kh·∫©u'));
  }
  
  // T√¨m user trong database
  const user = await User.findOne({ email }).select('+password');
  
  // Ki·ªÉm tra user t·ªìn t·∫°i v√† password ƒë√∫ng
  if (!user || !(await user.correctPassword(password, user.password))) {
    return next(new ApiError(401, 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng'));
  }
  
  // Ki·ªÉm tra email ƒë√£ x√°c th·ª±c ch∆∞a
  if (!user.emailVerified) {
    return next(new ApiError(401, 'Vui l√≤ng x√°c th·ª±c email tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p'));
  }
  
  // Ki·ªÉm tra user c√≥ active kh√¥ng
  if (!user.isActive) {
    return next(new ApiError(401, 'T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a'));
  }
  
  // T·∫°o token
  const token = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  // C·∫≠p nh·∫≠t th√¥ng tin ƒëƒÉng nh·∫≠p
  user.lastLogin = Date.now();
  user.loginCount += 1;
  await user.save({ validateBeforeSave: false });
  
  // Kh√¥ng g·ª≠i password trong response
  user.password = undefined;
  
  res.status(200).json({
    status: 'success',
    data: {
      user,
      token,
      refreshToken,
    },
  });
});

/**
 * ƒêƒÉng xu·∫•t
 */
exports.logout = catchAsync(async (req, res, next) => {
  // ƒê·ªëi v·ªõi JWT, kh√¥ng c·∫ßn l√†m g√¨ ·ªü ph√≠a server
  // Client c·∫ßn x√≥a token
  
  res.status(200).json({
    status: 'success',
    message: 'ƒêƒÉng xu·∫•t th√†nh c√¥ng',
  });
});

/**
 * L√†m m·ªõi access token b·∫±ng refresh token
 */
exports.refreshToken = catchAsync(async (req, res, next) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return next(new ApiError(400, 'Refresh token kh√¥ng ƒë∆∞·ª£c cung c·∫•p'));
  }
  
  try {
    // X√°c th·ª±c refresh token
    const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);
    
    // T√¨m user
    const user = await User.findById(decoded.id);
    
    if (!user || !user.isActive) {
      return next(new ApiError(401, 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã v√¥ hi·ªáu h√≥a'));
    }
    
    // T·∫°o token m·ªõi
    const newToken = generateToken(user);
    
    res.status(200).json({
      status: 'success',
      data: {
        token: newToken,
      },
    });
  } catch (error) {
    return next(new ApiError(401, 'Refresh token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n'));
  }
});

/**
 * Qu√™n m·∫≠t kh·∫©u
 */
exports.forgotPassword = catchAsync(async (req, res, next) => {
  const { email } = req.body;
  
  // T√¨m user theo email
  const user = await User.findOne({ email });
  
  if (!user) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi email n√†y'));
  }
  
  // T·∫°o reset token
  const resetToken = user.createPasswordResetToken();
  await user.save({ validateBeforeSave: false });
  
  try {
    // T·∫°o URL reset password
    const resetURL = `${req.protocol}://${req.get('host')}/reset-password/${resetToken}`;
    
    // G·ª≠i email
    await sendEmail({
      to: user.email,
      subject: 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u (c√≥ hi·ªáu l·ª±c trong 10 ph√∫t)',
      template: 'resetPassword',
      context: {
        name: user.name,
        resetURL,
      },
    });
    
    res.status(200).json({
      status: 'success',
      message: 'Token ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email',
    });
  } catch (error) {
    // X·ª≠ l√Ω l·ªói g·ª≠i email
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save({ validateBeforeSave: false });
    
    logger.error(`Kh√¥ng th·ªÉ g·ª≠i email ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u: ${error.message}`);
    
    return next(new ApiError(
      500,
      'C√≥ l·ªói x·∫£y ra khi g·ª≠i email. Vui l√≤ng th·ª≠ l·∫°i sau!'
    ));
  }
});

/**
 * ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u
 */
exports.resetPassword = catchAsync(async (req, res, next) => {
  const { token, password } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // T√¨m user v·ªõi token v√† ki·ªÉm tra th·ªùi h·∫°n
  const user = await User.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpires: { $gt: Date.now() },
  });
  
  // Ki·ªÉm tra n·∫øu token h·ª£p l·ªá
  if (!user) {
    return next(new ApiError(400, 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n'));
  }
  
  // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
  user.password = password;
  user.resetPasswordToken = undefined;
  user.resetPasswordExpires = undefined;
  await user.save();
  
  // ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng
  const jwtToken = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  res.status(200).json({
    status: 'success',
    message: 'M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t',
    data: {
      token: jwtToken,
      refreshToken,
    },
  });
});

/**
 * X√°c th·ª±c email
 */
exports.verifyEmail = catchAsync(async (req, res, next) => {
  const { token } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // T√¨m user v√† ki·ªÉm tra th·ªùi h·∫°n
  const user = await User.findOne({
    emailVerificationToken: hashedToken,
    emailVerificationExpires: { $gt: Date.now() },
  });
  
  // Ki·ªÉm tra n·∫øu token h·ª£p l·ªá
  if (!user) {
    return next(new ApiError(400, 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n'));
  }
  
  // C·∫≠p nh·∫≠t tr·∫°ng th√°i x√°c th·ª±c
  user.emailVerified = true;
  user.emailVerificationToken = undefined;
  user.emailVerificationExpires = undefined;
  await user.save({ validateBeforeSave: false });
  
  res.status(200).json({
    status: 'success',
    message: 'Email ƒë√£ ƒë∆∞·ª£c x√°c th·ª±c th√†nh c√¥ng',
  });
});

--- File: server/src/api/controllers/cartController.js ---
/**
 * Cart Controller
 * X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn gi·ªè h√†ng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const cartService = require('../../services/cart/cartService');

/**
 * L·∫•y gi·ªè h√†ng hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p ho·∫∑c kh√°ch
 * @route GET /api/carts/mycart
 * @access Public
 */
const getMyCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p, l·∫•y gi·ªè h√†ng theo userId
  if (req.user) {
    userId = req.user.id;
  } else {
    // N·∫øu ch∆∞a ƒëƒÉng nh·∫≠p, l·∫•y gi·ªè h√†ng theo sessionId
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    // N·∫øu ch∆∞a c√≥ sessionId, t·∫°o m·ªõi
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 ng√†y
        httpOnly: true
      });
    }
  }
  
  const cart = await cartService.getActiveCart(userId, sessionId);
  return responseHandler.success(res, cart);
});

/**
 * Th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng
 * @route POST /api/carts/items
 * @access Public
 */
const addItemToCart = catchAsync(async (req, res) => {
  const { productId, quantity, attributes } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000,
        httpOnly: true
      });
    }
  }
  
  const updatedCart = await cartService.addItemToCart(
    userId,
    sessionId,
    productId,
    quantity,
    attributes
  );
  
  return responseHandler.success(res, updatedCart);
});

/**
 * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m trong gi·ªè h√†ng
 * @route PATCH /api/carts/items/:itemId
 * @access Public
 */
const updateCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  const { quantity } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.updateCartItem(userId, sessionId, itemId, quantity);
  return responseHandler.success(res, updatedCart);
});

/**
 * X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng
 * @route DELETE /api/carts/items/:itemId
 * @access Public
 */
const removeCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeItemFromCart(userId, sessionId, itemId);
  return responseHandler.success(res, updatedCart);
});

/**
 * X√≥a to√†n b·ªô gi·ªè h√†ng
 * @route DELETE /api/carts/mycart
 * @access Public
 */
const clearCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  await cartService.clearCart(userId, sessionId);
  return responseHandler.success(res, { message: 'Cart cleared successfully' });
});

/**
 * √Åp d·ª•ng m√£ gi·∫£m gi√° v√†o gi·ªè h√†ng
 * @route POST /api/carts/apply-coupon
 * @access Public
 */
const applyCoupon = catchAsync(async (req, res) => {
  const { code } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.applyCoupon(userId, sessionId, code);
  return responseHandler.success(res, updatedCart);
});

/**
 * X√≥a m√£ gi·∫£m gi√° kh·ªèi gi·ªè h√†ng
 * @route DELETE /api/carts/remove-coupon
 * @access Public
 */
const removeCoupon = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeCoupon(userId, sessionId);
  return responseHandler.success(res, updatedCart);
});

/**
 * H·ª£p nh·∫•t gi·ªè h√†ng t·ª´ session v·ªõi gi·ªè h√†ng ng∆∞·ªùi d√πng khi ƒëƒÉng nh·∫≠p
 * @route POST /api/carts/merge
 * @access Private
 */
const mergeCart = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const { sessionId } = req.body;
  
  if (!sessionId) {
    return responseHandler.badRequest(res, 'Session ID is required');
  }
  
  const mergedCart = await cartService.mergeCartsOnLogin(userId, sessionId);
  
  // X√≥a cookie gi·ªè h√†ng c·ªßa session
  res.clearCookie('cartSessionId');
  
  return responseHandler.success(res, mergedCart);
});

module.exports = {
  getMyCart,
  addItemToCart,
  updateCartItem,
  removeCartItem,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCart
};

--- File: server/src/api/controllers/categoryController.js ---
/**
 * Category Controller
 * X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn danh m·ª•c s·∫£n ph·∫©m
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const categoryService = require('../../services/category/categoryService');

/**
 * L·∫•y t·∫•t c·∫£ danh m·ª•c
 * @route GET /api/categories
 * @access Public
 */
const getAllCategories = catchAsync(async (req, res) => {
  const features = req.query;
  const categories = await categoryService.getAllCategories(features);
  return responseHandler.success(res, categories);
});

/**
 * L·∫•y danh m·ª•c theo ID
 * @route GET /api/categories/:id
 * @access Public
 */
const getCategoryById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const category = await categoryService.getCategoryById(id);
  return responseHandler.success(res, category);
});

/**
 * L·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m trong danh m·ª•c
 * @route GET /api/categories/:id/products
 * @access Public
 */
const getCategoryProducts = catchAsync(async (req, res) => {
  const { id } = req.params;
  const features = req.query;
  const products = await categoryService.getCategoryProducts(id, features);
  return responseHandler.success(res, products);
});

/**
 * T·∫°o danh m·ª•c m·ªõi
 * @route POST /api/categories
 * @access Private (Admin only)
 */
const createCategory = catchAsync(async (req, res) => {
  const categoryData = req.body;
  const newCategory = await categoryService.createCategory(categoryData);
  return responseHandler.created(res, newCategory);
});

/**
 * C·∫≠p nh·∫≠t danh m·ª•c
 * @route PUT /api/categories/:id
 * @access Private (Admin only)
 */
const updateCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  const categoryData = req.body;
  const updatedCategory = await categoryService.updateCategory(id, categoryData);
  return responseHandler.success(res, updatedCategory);
});

/**
 * X√≥a danh m·ª•c
 * @route DELETE /api/categories/:id
 * @access Private (Admin only)
 */
const deleteCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  await categoryService.deleteCategory(id);
  return responseHandler.success(res, { message: 'Danh m·ª•c ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng' });
});

/**
 * L·∫•y t·∫•t c·∫£ danh m·ª•c con
 * @route GET /api/categories/:id/subcategories
 * @access Public
 */
const getSubcategories = catchAsync(async (req, res) => {
  const { id } = req.params;
  const subcategories = await categoryService.getSubcategories(id);
  return responseHandler.success(res, subcategories);
});

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getSubcategories
};

--- File: server/src/api/controllers/orderController.js ---
/**
 * Order Controller
 * X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn ƒë∆°n h√†ng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const orderService = require('../../services/order/orderService');

/**
 * L·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng (Admin)
 * @route GET /api/orders
 * @access Private (Admin only)
 */
const getAllOrders = catchAsync(async (req, res) => {
  const features = req.query;
  const orders = await orderService.getAllOrders(features);
  return responseHandler.success(res, orders);
});

/**
 * L·∫•y ƒë∆°n h√†ng theo ID
 * @route GET /api/orders/:id
 * @access Private (Admin ho·∫∑c ng∆∞·ªùi d√πng s·ªü h·ªØu ƒë∆°n h√†ng)
 */
const getOrderById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  const order = await orderService.getOrderById(id, userId, isAdmin);
  return responseHandler.success(res, order);
});

/**
 * L·∫•y ƒë∆°n h√†ng c·ªßa ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p
 * @route GET /api/orders/myorders
 * @access Private
 */
const getMyOrders = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const features = req.query;
  
  const orders = await orderService.getOrdersByUserId(userId, features);
  return responseHandler.success(res, orders);
});

/**
 * T·∫°o ƒë∆°n h√†ng m·ªõi
 * @route POST /api/orders
 * @access Private
 */
const createOrder = catchAsync(async (req, res) => {
  const orderData = req.body;
  const userId = req.user.id;
  
  const newOrder = await orderService.createOrder(orderData, userId);
  return responseHandler.created(res, newOrder);
});

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
 * @route PATCH /api/orders/:id/status
 * @access Private (Admin only)
 */
const updateOrderStatus = catchAsync(async (req, res) => {
  const { id } = req.params;
  const { status, note } = req.body;
  const adminId = req.user.id;
  
  const updatedOrder = await orderService.updateOrderStatus(id, status, note, adminId);
  return responseHandler.success(res, updatedOrder);
});

/**
 * H·ªßy ƒë∆°n h√†ng
 * @route PATCH /api/orders/:id/cancel
 * @access Private (Admin ho·∫∑c ng∆∞·ªùi d√πng s·ªü h·ªØu ƒë∆°n h√†ng)
 */
const cancelOrder = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { reason } = req.body;
  
  const cancelledOrder = await orderService.cancelOrder(id, userId, isAdmin, reason);
  return responseHandler.success(res, cancelledOrder);
});

/**
 * X·ª≠ l√Ω webhook thanh to√°n t·ª´ VNPay
 * @route POST /api/orders/payment/vnpay-webhook
 * @access Public
 */
const processVnPayWebhook = catchAsync(async (req, res) => {
  const paymentData = req.body;
  await orderService.processPaymentWebhook(paymentData);
  return responseHandler.success(res, { message: 'Payment processed successfully' });
});

/**
 * X·ª≠ l√Ω callback t·ª´ VNPay
 * @route GET /api/orders/payment/vnpay-return
 * @access Private
 */
const processVnPayReturn = catchAsync(async (req, res) => {
  const paymentData = req.query;
  const result = await orderService.processPaymentReturn(paymentData);
  return responseHandler.success(res, result);
});

module.exports = {
  getAllOrders,
  getOrderById,
  getMyOrders,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processVnPayWebhook,
  processVnPayReturn
};

--- File: server/src/api/controllers/productController.js ---
/**
 * ProductController
 * X·ª≠ l√Ω c√°c request API li√™n quan ƒë·∫øn s·∫£n ph·∫©m
 */

const productService = require('../../services/product/productService');
const catchAsync = require('../../common/utils/catchAsync');
const responseHandler = require('../../common/utils/responseHandler');
const AppError = require('../../common/errors/apiError');

// T·∫°o ƒë·ªëi t∆∞·ª£ng controller
const productController = {
  /**
   * L·∫•y danh s√°ch s·∫£n ph·∫©m
   * @route GET /api/products
   * @access Public
   */
  getProducts: catchAsync(async (req, res) => {
    const result = await productService.getProducts(req.query);
    responseHandler.success(res, {
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * L·∫•y chi ti·∫øt s·∫£n ph·∫©m
   * @route GET /api/products/:id
   * @access Public
   */
  getProductById: catchAsync(async (req, res) => {
    const product = await productService.getProductById(req.params.id);
    responseHandler.success(res, { product });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m theo slug
   * @route GET /api/products/by-slug/:slug
   * @access Public
   */
  getProductBySlug: catchAsync(async (req, res) => {
    // S·ª≠ d·ª•ng getProducts v·ªõi filter theo slug
    const result = await productService.getProducts({
      slug: req.params.slug,
      limit: 1,
    });

    if (!result.products || result.products.length === 0) {
      throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
    }

    // L·∫•y s·∫£n ph·∫©m ƒë·∫ßu ti√™n t·ª´ k·∫øt qu·∫£
    const product = result.products[0];

    // L·∫•y th√™m th√¥ng tin chi ti·∫øt n·∫øu c·∫ßn
    const detailedProduct = await productService.getProductById(product.id);

    responseHandler.success(res, { product: detailedProduct });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m theo danh m·ª•c
   * @route GET /api/categories/:categoryId/products
   * @access Public
   */
  getProductsByCategory: catchAsync(async (req, res) => {
    const { categoryId } = req.params;
    const result = await productService.getProductsByCategory(categoryId, req.query);
    responseHandler.success(res, {
      category: result.category,
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t
   * @route GET /api/products/trending
   * @access Public
   */
  getTrendingProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;
    const products = await productService.getTrendingProducts(limit);
    responseHandler.success(res, { products });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m m·ªõi
   * @route GET /api/products/new
   * @access Public
   */
  getNewProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // S·ª≠ d·ª•ng getProducts v·ªõi s·∫Øp x·∫øp theo ng√†y t·∫°o m·ªõi nh·∫•t
    const result = await productService.getProducts({
      limit,
      sort: { createdAt: -1 },
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m gi·∫£m gi√°
   * @route GET /api/products/sale
   * @access Public
   */
  getSaleProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // S·ª≠ d·ª•ng getProducts v·ªõi b·ªô l·ªçc cho s·∫£n ph·∫©m c√≥ gi√° khuy·∫øn m√£i
    const result = await productService.getProducts({
      limit,
      filters: { salePrice: { $gt: 0 } },
      sort: { salePrice: 1 }, // S·∫Øp x·∫øp theo gi√° khuy·∫øn m√£i tƒÉng d·∫ßn
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * T√¨m ki·∫øm s·∫£n ph·∫©m
   * @route GET /api/products/search
   * @access Public
   */
  searchProducts: catchAsync(async (req, res) => {
    const { q } = req.query;
    if (!q) {
      throw new AppError(400, 'Vui l√≤ng cung c·∫•p t·ª´ kh√≥a t√¨m ki·∫øm');
    }

    const options = {
      limit: parseInt(req.query.limit) || 10,
      page: parseInt(req.query.page) || 1,
      sort: req.query.sort ? JSON.parse(req.query.sort) : { newest: -1 },
      filters: req.query.filters ? JSON.parse(req.query.filters) : {},
    };

    const result = await productService.searchProducts(q, options);
    responseHandler.success(res, result);
  }),

  /**
   * T·∫°o s·∫£n ph·∫©m m·ªõi (Admin)
   * @route POST /api/admin/products
   * @access Private/Admin
   */
  createProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const product = await productService.createProduct(req.body, userId);
    responseHandler.created(res, { product });
  }),

  /**
   * C·∫≠p nh·∫≠t s·∫£n ph·∫©m (Admin)
   * @route PUT /api/admin/products/:id
   * @access Private/Admin
   */
  updateProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;
    const product = await productService.updateProduct(id, req.body, userId);
    responseHandler.success(res, { product });
  }),

  /**
   * X√≥a s·∫£n ph·∫©m (Admin)
   * @route DELETE /api/admin/products/:id
   * @access Private/Admin
   */
  deleteProduct: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.deleteProduct(id);
    responseHandler.success(res, { message: 'S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng' });
  }),

  /**
   * C·∫≠p nh·∫≠t t·ªìn kho (Admin)
   * @route PATCH /api/admin/products/:id/stock
   * @access Private/Admin
   */
  updateStock: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { quantity } = req.body;

    if (quantity === undefined) {
      throw new AppError(400, 'Vui l√≤ng cung c·∫•p s·ªë l∆∞·ª£ng t·ªìn kho');
    }

    const result = await productService.updateStock(id, parseInt(quantity));
    responseHandler.success(res, result);
  }),

  /**
   * C·∫≠p nh·∫≠t tr·∫°ng th√°i s·∫£n ph·∫©m (Admin)
   * @route PATCH /api/admin/products/:id/status
   * @access Private/Admin
   */
  updateStatus: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
      throw new AppError(400, 'Vui l√≤ng cung c·∫•p tr·∫°ng th√°i');
    }

    const allowedStatuses = ['active', 'draft', 'discontinued'];
    if (!allowedStatuses.includes(status)) {
      throw new AppError(
        400,
        `Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá. C√°c tr·∫°ng th√°i h·ª£p l·ªá: ${allowedStatuses.join(', ')}`
      );
    }

    const product = await productService.updateProduct(id, { status }, req.user.id);
    responseHandler.success(res, { product });
  }),

  /**
   * L·∫•y th·ªëng k√™ s·∫£n ph·∫©m (Admin)
   * @route GET /api/admin/products/stats
   * @access Private/Admin
   */
  getProductStats: catchAsync(async (req, res) => {
    const stats = await productService.getProductStats();
    responseHandler.success(res, { stats });
  }),

  /**
   * L·∫•y s·∫£n ph·∫©m li√™n quan
   * @route GET /api/products/:id/related
   * @access Public
   */
  getRelatedProducts: catchAsync(async (req, res) => {
    const { id } = req.params;
    const limit = parseInt(req.query.limit) || 5;

    const products = await productService.getRelatedProducts(id, limit);
    responseHandler.success(res, { products });
  }),

  /**
   * TƒÉng s·ªë l∆∞·ª£t xem s·∫£n ph·∫©m
   * @route POST /api/products/:id/view
   * @access Public
   */
  incrementProductView: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.incrementViewCount(id);
    responseHandler.success(res, { message: 'ƒê√£ c·∫≠p nh·∫≠t l∆∞·ª£t xem' });
  }),
};

// Xu·∫•t controller
module.exports = productController;


--- File: server/src/api/controllers/reviewController.js ---
/**
 * Review Controller
 * X·ª≠ l√Ω c√°c request li√™n quan ƒë·∫øn ƒë√°nh gi√° s·∫£n ph·∫©m
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const reviewService = require('../../services/review/reviewService');

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° (c√≥ ph√¢n trang, l·ªçc)
 * @route GET /api/reviews
 * @access Public
 */
const getAllReviews = catchAsync(async (req, res) => {
  const features = req.query;
  const reviews = await reviewService.getAllReviews(features);
  return responseHandler.success(res, reviews);
});

/**
 * L·∫•y ƒë√°nh gi√° theo ID
 * @route GET /api/reviews/:id
 * @access Public
 */
const getReviewById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const review = await reviewService.getReviewById(id);
  return responseHandler.success(res, review);
});

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° cho m·ªôt s·∫£n ph·∫©m
 * @route GET /api/products/:productId/reviews
 * @access Public
 */
const getProductReviews = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const features = req.query;
  const reviews = await reviewService.getProductReviews(productId, features);
  return responseHandler.success(res, reviews);
});

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° c·ªßa m·ªôt ng∆∞·ªùi d√πng
 * @route GET /api/users/:userId/reviews
 * @access Private (Admin ho·∫∑c ng∆∞·ªùi d√πng s·ªü h·ªØu ƒë√°nh gi√°)
 */
const getUserReviews = catchAsync(async (req, res) => {
  const { userId } = req.params;
  
  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
  const requestUserId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  if (userId !== requestUserId && !isAdmin) {
    return responseHandler.forbidden(res, 'B·∫°n kh√¥ng c√≥ quy·ªÅn xem ƒë√°nh gi√° c·ªßa ng∆∞·ªùi d√πng kh√°c');
  }
  
  const features = req.query;
  const reviews = await reviewService.getUserReviews(userId, features);
  return responseHandler.success(res, reviews);
});

/**
 * T·∫°o ƒë√°nh gi√° m·ªõi
 * @route POST /api/products/:productId/reviews
 * @access Private
 */
const createReview = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const userId = req.user.id;
  const reviewData = req.body;
  
  const newReview = await reviewService.createReview(productId, userId, reviewData);
  return responseHandler.created(res, newReview);
});

/**
 * C·∫≠p nh·∫≠t ƒë√°nh gi√°
 * @route PUT /api/reviews/:id
 * @access Private (Ng∆∞·ªùi d√πng s·ªü h·ªØu ƒë√°nh gi√°)
 */
const updateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const reviewData = req.body;
  
  const updatedReview = await reviewService.updateReview(id, userId, reviewData, isAdmin);
  return responseHandler.success(res, updatedReview);
});

/**
 * X√≥a ƒë√°nh gi√°
 * @route DELETE /api/reviews/:id
 * @access Private (Admin ho·∫∑c ng∆∞·ªùi d√πng s·ªü h·ªØu ƒë√°nh gi√°)
 */
const deleteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  await reviewService.deleteReview(id, userId, isAdmin);
  return responseHandler.success(res, { message: 'ƒê√°nh gi√° ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng' });
});

/**
 * Upvote ho·∫∑c downvote ƒë√°nh gi√°
 * @route POST /api/reviews/:id/vote
 * @access Private
 */
const voteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { vote } = req.body; // 1 for upvote, -1 for downvote
  
  const updatedReview = await reviewService.voteReview(id, userId, vote);
  return responseHandler.success(res, updatedReview);
});

/**
 * Ki·ªÉm duy·ªát ƒë√°nh gi√° (duy·ªát ho·∫∑c t·ª´ ch·ªëi)
 * @route PATCH /api/reviews/:id/moderate
 * @access Private (Admin only)
 */
const moderateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const adminId = req.user.id;
  const { action, reason } = req.body; // 'approve' or 'reject'
  
  const moderatedReview = await reviewService.moderateReview(id, action, reason, adminId);
  return responseHandler.success(res, moderatedReview);
});

/**
 * B√°o c√°o ƒë√°nh gi√°
 * @route POST /api/reviews/:id/report
 * @access Private
 */
const reportReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { reason, description } = req.body;
  
  const reportedReview = await reviewService.reportReview(id, userId, reason, description);
  return responseHandler.success(res, reportedReview);
});

/**
 * Th√™m ph·∫£n h·ªìi cho ƒë√°nh gi√°
 * @route POST /api/reviews/:id/responses
 * @access Private (Admin ho·∫∑c ng∆∞·ªùi d√πng s·ªü h·ªØu s·∫£n ph·∫©m)
 */
const addReviewResponse = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { content } = req.body;
  
  const updatedReview = await reviewService.addReviewResponse(id, userId, content, isAdmin);
  return responseHandler.success(res, updatedReview);
});

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse
};

--- File: server/src/api/controllers/userController.js ---
/**
 * Controller cho qu·∫£n l√Ω ng∆∞·ªùi d√πng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const { ApiError, isOwnerOrAdmin } = require('../middleware/authMiddleware');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const responseHandler = require('../../utils/responseHandler');

/**
 * L·∫•y danh s√°ch ng∆∞·ªùi d√πng (v·ªõi ph√¢n trang v√† filter)
 */
exports.getUsers = catchAsync(async (req, res, next) => {
  // X·ª≠ l√Ω query params
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;
  const sort = req.query.sort || '-createdAt';

  // X√¢y d·ª±ng filter
  const filter = {};

  // L·ªçc theo role n·∫øu c√≥
  if (req.query.role) {
    filter.role = req.query.role;
  }

  // L·ªçc theo tr·∫°ng th√°i active
  if (req.query.isActive) {
    filter.isActive = req.query.isActive === 'true';
  }

  // T√¨m ki·∫øm theo t√™n ho·∫∑c email
  if (req.query.search) {
    const searchRegex = new RegExp(req.query.search, 'i');
    filter.$or = [{ name: searchRegex }, { email: searchRegex }];
  }

  // Th·ª±c hi·ªán query
  const users = await User.find(filter).sort(sort).skip(skip).limit(limit).select('-password');

  // ƒê·∫øm t·ªïng s·ªë users ph√π h·ª£p v·ªõi filter
  const total = await User.countDocuments(filter);

  // T√≠nh to√°n th√¥ng tin ph√¢n trang
  const totalPages = Math.ceil(total / limit);
  const hasNext = page < totalPages;
  const hasPrev = page > 1;

  responseHandler.success(res, {
    results: users.length,
    pagination: {
      total,
      page,
      limit,
      totalPages,
      hasNext,
      hasPrev,
    },
    data: users,
  });
});

/**
 * L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
 * Middleware isOwnerOrAdmin ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.getUserById = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // T√¨m user
  const user = await User.findById(userId).select('-password');

  if (!user) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'));
  }

  responseHandler.success(res, { data: user });
});

/**
 * T·∫°o ng∆∞·ªùi d√πng m·ªõi (ch·ªâ admin)
 * Middleware restrictTo('admin') ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.createUser = catchAsync(async (req, res, next) => {
  const { name, email, password, role, phone } = req.body;

  // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng'));
  }

  // T·∫°o user m·ªõi
  const newUser = await User.create({
    name,
    email,
    password,
    role,
    phone,
    // Admin t·∫°o user th√¨ m·∫∑c ƒë·ªãnh ƒë√£ x√°c th·ª±c email
    emailVerified: true,
  });

  // Kh√¥ng g·ª≠i password trong response
  newUser.password = undefined;

  // Ghi log
  logger.info(`User ${newUser.email} ƒë√£ ƒë∆∞·ª£c t·∫°o b·ªüi ${req.user.email}`);

  responseHandler.created(res, { data: newUser });
});

/**
 * C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
 * Middleware isOwnerOrAdmin ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.updateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Lo·∫°i b·ªè c√°c tr∆∞·ªùng kh√¥ng ƒë∆∞·ª£c ph√©p c·∫≠p nh·∫≠t
  const { password, emailVerified, loginCount, lastLogin, ...updateData } = req.body;

  // Admin c√≥ th·ªÉ c·∫≠p nh·∫≠t role
  if (req.user.role !== 'admin') {
    delete updateData.role;
  }

  // T√¨m v√† c·∫≠p nh·∫≠t user
  const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
    new: true,
    runValidators: true,
  }).select('-password');

  if (!updatedUser) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'));
  }

  // Ghi log
  logger.info(`User ${updatedUser.email} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi ${req.user.email}`);

  responseHandler.success(res, { data: updatedUser });
});

/**
 * X√≥a ng∆∞·ªùi d√πng
 * Middleware restrictTo('admin') ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.deleteUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // X√≥a user
  const user = await User.findByIdAndDelete(userId);

  if (!user) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'));
  }

  logger.info(`User ${user.email} ƒë√£ b·ªã x√≥a b·ªüi ${req.user.email}`);

  responseHandler.success(res, { message: 'Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng' });
});

/**
 * L·∫•y th√¥ng tin profile ng∆∞·ªùi d√πng hi·ªán t·∫°i
 * Middleware authenticate ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.getProfile = catchAsync(async (req, res, next) => {
  // Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c l∆∞u trong req.user t·ª´ middleware authenticate
  const user = req.user;

  responseHandler.success(res, { data: user });
});

/**
 * Thay ƒë·ªïi m·∫≠t kh·∫©u
 * Middleware authenticate ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next function
 */
exports.changePassword = catchAsync(async (req, res, next) => {
  const { currentPassword, newPassword } = req.body;

  // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
  if (!currentPassword || !newPassword) {
    return next(new ApiError(400, 'Vui l√≤ng cung c·∫•p m·∫≠t kh·∫©u hi·ªán t·∫°i v√† m·∫≠t kh·∫©u m·ªõi'));
  }

  // L·∫•y user hi·ªán t·∫°i v·ªõi password
  /**
   * @type {import('mongoose').Document & {
   *   password: string,
   *   correctPassword: (candidatePassword: string, userPassword: string) => Promise<boolean>
   * }}
   */
  const user = await User.findById(req.user.id).select('+password');

  // Ki·ªÉm tra m·∫≠t kh·∫©u hi·ªán t·∫°i
  if (!(await user.correctPassword(currentPassword, user.password))) {
    return next(new ApiError(401, 'M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng'));
  }

  // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
  user.password = newPassword;
  await user.save();

  // Kh√¥ng g·ª≠i password trong response
  user.password = undefined;

  // Ghi log
  logger.info(`User ${user.email} ƒë√£ thay ƒë·ªïi m·∫≠t kh·∫©u`);

  responseHandler.success(res, { message: 'M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng' });
});

/**
 * V√¥ hi·ªáu h√≥a t√†i kho·∫£n ng∆∞·ªùi d√πng
 * Middleware restrictTo('admin') ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.deactivateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: false }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'));
  }

  logger.info(`User ${user.email} ƒë√£ b·ªã v√¥ hi·ªáu h√≥a b·ªüi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'T√†i kho·∫£n ng∆∞·ªùi d√πng ƒë√£ b·ªã v√¥ hi·ªáu h√≥a',
    data: user,
  });
});

/**
 * K√≠ch ho·∫°t l·∫°i t√†i kho·∫£n ng∆∞·ªùi d√πng
 * Middleware restrictTo('admin') ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng ·ªü route
 */
exports.activateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: true }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'));
  }

  logger.info(`User ${user.email} ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i b·ªüi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'T√†i kho·∫£n ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i',
    data: user,
  });
});


--- File: server/src/api/middleware/authMiddleware.js ---
/**
 * Authentication Middleware
 * X·ª≠ l√Ω x√°c th·ª±c v√† ph√¢n quy·ªÅn cho API endpoints
 */

const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const catchAsync = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const userService = require('../../services/user/userService');
const config = require('../../config/environment');

const authMiddleware = {
  /**
   * X√°c th·ª±c ng∆∞·ªùi d√πng qua JWT token
   * Token ƒë∆∞·ª£c cung c·∫•p qua header Authorization
   */
  authenticate: catchAsync(async (req, res, next) => {
    // 1) L·∫•y token v√† ki·ªÉm tra n·∫øu t·ªìn t·∫°i
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies && req.cookies.jwt) {
      token = req.cookies.jwt;
    }

    if (!token) {
      return responseHandler.unauthorized(res, 'Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ truy c·∫≠p');
    }

    // 2) X√°c th·ª±c token
    const decoded = await promisify(jwt.verify)(token, config.jwt.secret);

    // 3) Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng v·∫´n t·ªìn t·∫°i
    const user = await userService.getUserById(decoded.id);
    if (!user) {
      return responseHandler.unauthorized(res, 'Ng∆∞·ªùi d√πng kh√¥ng c√≤n t·ªìn t·∫°i');
    }

    // 4) Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng ƒë√£ thay ƒë·ªïi m·∫≠t kh·∫©u sau khi token ƒë∆∞·ª£c c·∫•p
    if (user.changedPasswordAfter(decoded.iat)) {
      return responseHandler.unauthorized(res, 'M·∫≠t kh·∫©u ƒë√£ thay ƒë·ªïi, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i');
    }

    // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√†o request
    req.user = user;
    next();
  }),

  /**
   * Gi·ªõi h·∫°n quy·ªÅn truy c·∫≠p d·ª±a tr√™n vai tr√≤ ng∆∞·ªùi d√πng
   * @param {...string} roles - C√°c vai tr√≤ ƒë∆∞·ª£c ph√©p truy c·∫≠p
   */
  restrictTo: (...roles) => {
    return (req, res, next) => {
      // Ki·ªÉm tra n·∫øu vai tr√≤ c·ªßa ng∆∞·ªùi d√πng n·∫±m trong danh s√°ch ƒë∆∞·ª£c ph√©p
      if (!roles.includes(req.user.role)) {
        return responseHandler.forbidden(res, 'B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y');
      }
      next();
    };
  },

  /**
   * Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ x√°c th·ª±c email ch∆∞a
   */
  isEmailVerified: (req, res, next) => {
    if (!req.user.emailVerified) {
      return responseHandler.forbidden(res, 'Vui l√≤ng x√°c th·ª±c email c·ªßa b·∫°n tr∆∞·ªõc');
    }
    next();
  },

  /**
   * Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng ƒëang truy c·∫≠p d·ªØ li·ªáu c·ªßa ch√≠nh h·ªç
   * ho·∫∑c l√† admin
   */
  isOwnerOrAdmin: (userIdPath) => {
    return (req, res, next) => {
      const userId = userIdPath.split('.').reduce((obj, prop) => obj[prop], req);

      // Cho ph√©p n·∫øu l√† admin ho·∫∑c ch·ªß s·ªü h·ªØu
      if (req.user.role === 'admin' || req.user.id === userId) {
        return next();
      }

      return responseHandler.forbidden(res, 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p d·ªØ li·ªáu n√†y');
    };
  },
};

module.exports = {
  authenticate: authMiddleware.authenticate,
  restrictTo: authMiddleware.restrictTo,
  isEmailVerified: authMiddleware.isEmailVerified,
  isOwnerOrAdmin: authMiddleware.isOwnerOrAdmin,
};


--- File: server/src/api/middleware/errorHandler.js ---
/**
 * Error Handler Middleware
 * X·ª≠ l√Ω c√°c l·ªói trong API v√† tr·∫£ v·ªÅ response ph√π h·ª£p
 * @author Steve
 * @project RunOut-Biliard
 */

const logger = require('../../config/logger');

/**
 * Class ApiError - ƒê·ªãnh nghƒ©a c·∫•u tr√∫c l·ªói API
 */
class ApiError extends Error {
  /**
   * Kh·ªüi t·∫°o l·ªói API
   * @param {number} statusCode - M√£ HTTP status
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {Array} errors - Danh s√°ch l·ªói chi ti·∫øt (optional)
   * @param {boolean} isOperational - X√°c ƒë·ªãnh l·ªói l√† operational hay programming
   * @param {string} stack - Stack trace
   */
  constructor(statusCode, message, errors = [], isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;

    // Th√™m timestamp
    this.timestamp = new Date();

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  /**
   * T·∫°o l·ªói 404 Not Found
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static notFound(message = 'Kh√¥ng t√¨m th·∫•y t√†i nguy√™n') {
    return new ApiError(404, message);
  }

  /**
   * T·∫°o l·ªói 400 Bad Request
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {Array} errors - Danh s√°ch l·ªói chi ti·∫øt
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static badRequest(message = 'Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá', errors = []) {
    return new ApiError(400, message, errors);
  }

  /**
   * T·∫°o l·ªói 401 Unauthorized
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static unauthorized(message = 'Kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p') {
    return new ApiError(401, message);
  }

  /**
   * T·∫°o l·ªói 403 Forbidden
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static forbidden(message = 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p t√†i nguy√™n n√†y') {
    return new ApiError(403, message);
  }

  /**
   * T·∫°o l·ªói 500 Internal Server Error
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {boolean} isOperational - X√°c ƒë·ªãnh l·ªói l√† operational hay programming
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static internal(message = 'L·ªói m√°y ch·ªß n·ªôi b·ªô', isOperational = true) {
    return new ApiError(500, message, [], isOperational);
  }

  /**
   * T·∫°o l·ªói 422 Unprocessable Entity
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {Array} errors - Danh s√°ch l·ªói chi ti·∫øt
   * @returns {ApiError} - ƒê·ªëi t∆∞·ª£ng ApiError
   */
  static validationError(message = 'L·ªói x√°c th·ª±c d·ªØ li·ªáu', errors = []) {
    return new ApiError(422, message, errors);
  }
}

/**
 * Middleware x·ª≠ l√Ω l·ªói
 * @param {Error} err - ƒê·ªëi t∆∞·ª£ng l·ªói
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // N·∫øu l·ªói kh√¥ng ph·∫£i l√† ApiError, chuy·ªÉn ƒë·ªïi th√†nh ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'L·ªói m√°y ch·ªß n·ªôi b·ªô';
    error = new ApiError(statusCode, message, [], false, err.stack);
  }

  // Log l·ªói
  if (error.statusCode >= 500) {
    logger.error(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
    logger.error(error.stack);
  } else {
    logger.warn(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
  }

  // Chu·∫©n b·ªã response
  const response = {
    success: false,
    status: error.statusCode,
    message: error.message,
    errors: error.errors.length > 0 ? error.errors : undefined,
    timestamp: error.timestamp,
    path: req.path,
  };

  // Trong m√¥i tr∆∞·ªùng development, th√™m stack trace
  if (process.env.NODE_ENV === 'development') {
    response.stack = error.stack;
  }

  // G·ª≠i response
  res.status(error.statusCode).json(response);
};

/**
 * Middleware b·∫Øt l·ªói 404 cho c√°c routes kh√¥ng t·ªìn t·∫°i
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const notFoundHandler = (req, res, next) => {
  const error = ApiError.notFound(`Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng d·∫´n: ${req.originalUrl}`);
  next(error);
};

/**
 * Middleware b·∫Øt l·ªói validation t·ª´ express-validator
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const validationErrorHandler = (req, res, next) => {
  const { validationErrors } = req;

  if (validationErrors && validationErrors.length > 0) {
    const errors = validationErrors.map((error) => ({
      field: error.param,
      message: error.msg,
      value: error.value,
    }));

    const error = ApiError.validationError('D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá', errors);
    return next(error);
  }

  next();
};

/**
 * X·ª≠ l√Ω l·ªói kh√¥ng ƒë∆∞·ª£c b·∫Øt trong promise
 */
const setupUnhandledRejectionHandler = () => {
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // Trong m√¥i tr∆∞·ªùng production, c√≥ th·ªÉ c√¢n nh·∫Øc t·∫Øt server ho·∫∑c x·ª≠ l√Ω graceful shutdown
    // process.exit(1);
  });
};

/**
 * X·ª≠ l√Ω l·ªói kh√¥ng ƒë∆∞·ª£c b·∫Øt
 */
const setupUncaughtExceptionHandler = () => {
  process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception:', error);
    // Trong m√¥i tr∆∞·ªùng production, n√™n t·∫Øt server v√¨ tr·∫°ng th√°i c√≥ th·ªÉ kh√¥ng ·ªïn ƒë·ªãnh
    // process.exit(1);
  });
};

module.exports = {
  ApiError,
  errorHandler,
  notFoundHandler,
  validationErrorHandler,
  setupUnhandledRejectionHandler,
  setupUncaughtExceptionHandler,
};


--- File: server/src/api/middleware/errorMiddleware.js ---
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'Internal Server Error',
  });
};

module.exports = { errorHandler };


--- File: server/src/api/middleware/loggingMiddleware.js ---
const loggingMiddleware = (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  next();
};

module.exports = { loggingMiddleware };


--- File: server/src/api/middleware/validationMiddleware.js ---
/**
 * Middleware x√°c th·ª±c d·ªØ li·ªáu s·ª≠ d·ª•ng Joi v√† c√°c ti·ªán √≠ch kh√°c
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 */

const Joi = require('joi');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;

/**
 * Middleware ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa MongoDB ObjectId
 * @returns {function} Express middleware
 */
const validateMongoId = () => (req, res, next) => {
  const idParam = req.params.id;

  if (!idParam) {
    return res.status(400).json({
      success: false,
      message: 'ID kh√¥ng ƒë∆∞·ª£c cung c·∫•p',
    });
  }

  if (!ObjectId.isValid(idParam)) {
    return res.status(400).json({
      success: false,
      message: 'ID kh√¥ng h·ª£p l·ªá',
    });
  }

  next();
};

/**
 * Middleware t·∫°o b·ªô x√°c th·ª±c d·ªØ li·ªáu t·ª´ schema Joi
 * @param {Joi.Schema} schema - Joi schema s·ª≠ d·ª•ng ƒë·ªÉ x√°c th·ª±c
 * @returns {function} Express middleware
 */
const validate = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body, {
    abortEarly: false, // Tr·∫£ v·ªÅ t·∫•t c·∫£ l·ªói thay v√¨ ch·ªâ l·ªói ƒë·∫ßu ti√™n
    stripUnknown: true, // Lo·∫°i b·ªè c√°c tr∆∞·ªùng kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong schema
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá',
      errors: errorMessages,
    });
  }

  next();
};

/**
 * Middleware t·∫°o b·ªô x√°c th·ª±c d·ªØ li·ªáu t·ª´ schema Joi cho query params
 * @param {Joi.Schema} schema - Joi schema s·ª≠ d·ª•ng ƒë·ªÉ x√°c th·ª±c
 * @returns {function} Express middleware
 */
const validateQuery = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.query, {
    abortEarly: false,
    stripUnknown: true,
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'Tham s·ªë truy v·∫•n kh√¥ng h·ª£p l·ªá',
      errors: errorMessages,
    });
  }

  next();
};

// Schema m·∫´u cho s·∫£n ph·∫©m (gi·ªØ l·∫°i t·ª´ file g·ªëc)
const productSchema = Joi.object({
  name: Joi.string().min(3).max(100).required(),
  price: Joi.number().min(0).required(),
  description: Joi.string().max(500).required(),
});

/**
 * Middleware x√°c th·ª±c d·ªØ li·ªáu s·∫£n ph·∫©m (gi·ªØ l·∫°i t·ª´ file g·ªëc ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c)
 * @deprecated S·ª≠ d·ª•ng h√†m validate v·ªõi schema t∆∞∆°ng ·ª©ng thay th·∫ø
 */
const validateProduct = (req, res, next) => {
  const { error } = productSchema.validate(req.body);
  if (error) {
    return res.status(400).json({
      success: false,
      error: error.details[0].message,
    });
  }
  next();
};

/**
 * C√°c helpers h·ªØu √≠ch cho x√°c th·ª±c d·ªØ li·ªáu
 */
const validationHelpers = {
  /**
   * T·∫°o m·ªôt custom validator ƒë·ªÉ x√°c th·ª±c m·∫≠t kh·∫©u m·∫°nh
   */
  strongPassword: () =>
    Joi.string()
      .min(8)
      .max(30)
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .message(
        'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 8 k√Ω t·ª±, bao g·ªìm ch·ªØ hoa, ch·ªØ th∆∞·ªùng, s·ªë v√† k√Ω t·ª± ƒë·∫∑c bi·ªát'
      ),

  /**
   * T·∫°o custom validator cho s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam
   */
  vietnamesePhone: () =>
    Joi.string()
      .pattern(/^(0|\+84)([0-9]{9,10})$/)
      .message('S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá, ph·∫£i l√† s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam'),
};

module.exports = {
  validateMongoId,
  validate,
  validateQuery,
  validateProduct, // Gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
  validationHelpers,
};


--- File: server/src/app.js ---
/**
 * T·ªáp c·∫•u h√¨nh Express ch√≠nh cho ·ª©ng d·ª•ng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const dotenv = require('dotenv');
const path = require('path');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');

const { connectToDatabase } = require('./config/database');
const config = require('./config/environment');
const logger = require('./config/logger');

// Routes
const productRoutes = require('./api/routes/productRoutes');
const authRoutes = require('./api/routes/authRoutes');
const userRoutes = require('./api/routes/userRoutes');
// const bookingRoutes = require('./api/routes/bookingRoutes');
// const paymentRoutes = require('./api/routes/paymentRoutes');

// Middleware
const { loggingMiddleware } = require('./api/middleware/loggingMiddleware');
const { errorHandler } = require('./api/middleware/errorMiddleware');
// S·ª≠a c√°ch import authMiddleware - kh√¥ng c·∫ßn import ·ªü ƒë√¢y v√¨ ƒë√£ import trong routes

// Kh·ªüi t·∫°o app Express
const app = express();

// C·∫•u h√¨nh bi·∫øn m√¥i tr∆∞·ªùng
dotenv.config();

// K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu
connectToDatabase();

// C·∫•u h√¨nh b·∫£o m·∫≠t
app.use(helmet()); // Thi·∫øt l·∫≠p c√°c HTTP header b·∫£o m·∫≠t
app.use(mongoSanitize()); // B·∫£o v·ªá kh·ªèi SQL injection
app.use(xss()); // B·∫£o v·ªá kh·ªèi XSS attacks
app.use(hpp({ whitelist: ['price', 'date', 'rating'] })); // B·∫£o v·ªá kh·ªèi HTTP Parameter Pollution

// Rate limiting ƒë·ªÉ ch·ªëng DDOS v√† brute force
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 ph√∫t
  max: 100, // 100 y√™u c·∫ßu m·ªói IP
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Qu√° nhi·ªÅu y√™u c·∫ßu t·ª´ IP n√†y, vui l√≤ng th·ª≠ l·∫°i sau 15 ph√∫t',
});

// √Åp d·ª•ng rate limiting cho t·∫•t c·∫£ c√°c request API
app.use('/api', limiter);

// CORS config t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
app.use(
  cors({
    origin: config.cors.origin.split(','),
    methods: config.cors.methods,
    credentials: true,
    optionsSuccessStatus: 204,
  })
);

// Middleware n√©n response
app.use(compression());

// Body parsers
app.use(express.json({ limit: '10kb' })); // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc body
app.use(express.urlencoded({ extended: true, limit: '10kb' }));
app.use(cookieParser()); // X·ª≠ l√Ω cookies

// Ghi log cho requests trong m√¥i tr∆∞·ªùng ph√°t tri·ªÉn
if (config.app.environment === 'development') {
  app.use(morgan('dev'));
}

// Middleware ghi log t√πy ch·ªânh
app.use(loggingMiddleware);

// Th∆∞ m·ª•c tƒ©nh cho uploads v√† t√†i nguy√™n c√¥ng khai
app.use('/uploads', express.static(path.join(__dirname, '..', config.paths.uploads)));
app.use(express.static(path.join(__dirname, '..', 'public')));

// Routes API
app.use('/api/products', productRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes); // Kh√¥ng c·∫ßn th√™m middleware ·ªü ƒë√¢y v√¨ ƒë√£ c√≥ trong routes
// app.use('/api/bookings', bookingRoutes);
// app.use('/api/payments', paymentRoutes);

// Route s·ª©c kh·ªèe h·ªá th·ªëng
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'H·ªá th·ªëng ƒëang ho·∫°t ƒë·ªông',
    environment: config.app.environment,
    timestamp: new Date().toISOString(),
  });
});

// Route trang ch·ªß API
app.get('/', (req, res) => {
  res.json({
    message: 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi API RunOut-Biliard!',
    version: '1.0.0',
    docs: '/api/docs',
  });
});

// API Documentation route
app.get('/api/docs', (req, res) => {
  res.redirect('/api-docs'); // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn Swagger ho·∫∑c trang t√†i li·ªáu
});

// X·ª≠ l√Ω route kh√¥ng t√¨m th·∫•y
app.all('*', (req, res, next) => {
  const err = new Error(`Kh√¥ng th·ªÉ t√¨m th·∫•y ${req.originalUrl} tr√™n server n√†y!`);
  err.status = 'fail';
  err.statusCode = 404;
  next(err);
});

// Middleware x·ª≠ l√Ω l·ªói to√†n c·ª•c
app.use(errorHandler);

// X·ª≠ l√Ω s·ª± ki·ªán process
process.on('SIGTERM', () => {
  logger.info('SIGTERM nh·∫≠n ƒë∆∞·ª£c. ƒêang chu·∫©n b·ªã ƒë√≥ng ·ª©ng d·ª•ng Express...');
});

// Export app cho server.js s·ª≠ d·ª•ng
module.exports = app;


--- File: server/src/common/errors/apiError.js ---
/**
 * L·ªõp ApiError m·ªü r·ªông t·ª´ Error ƒë·ªÉ x·ª≠ l√Ω c√°c l·ªói API v·ªõi m√£ tr·∫°ng th√°i
 * @extends Error
 */
class ApiError extends Error {
  /**
   * T·∫°o m·ªôt ApiError
   * @param {number} statusCode - M√£ tr·∫°ng th√°i HTTP
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {object} [errors] - C√°c l·ªói chi ti·∫øt (t√πy ch·ªçn)
   */
  constructor(statusCode, message, errors = {}) {
    super(message);
    this.statusCode = statusCode;
    this.errors = errors;
    this.name = this.constructor.name;

    // Ghi l·∫°i stack trace
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Chuy·ªÉn ƒë·ªïi l·ªói th√†nh ƒë·ªãnh d·∫°ng JSON
   * @returns {object} - ƒê·ªëi t∆∞·ª£ng l·ªói d·∫°ng JSON
   */
  toJSON() {
    return {
      status: 'error',
      statusCode: this.statusCode,
      message: this.message,
      errors: Object.keys(this.errors).length > 0 ? this.errors : undefined,
    };
  }

  /**
   * T·∫°o m·ªôt l·ªói BadRequest (400)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @param {object} [errors] - C√°c l·ªói chi ti·∫øt (t√πy ch·ªçn)
   * @returns {ApiError} - L·ªói BadRequest
   */
  static badRequest(message = 'Bad Request', errors = {}) {
    return new ApiError(400, message, errors);
  }

  /**
   * T·∫°o m·ªôt l·ªói Unauthorized (401)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - L·ªói Unauthorized
   */
  static unauthorized(message = 'Unauthorized') {
    return new ApiError(401, message);
  }

  /**
   * T·∫°o m·ªôt l·ªói Forbidden (403)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - L·ªói Forbidden
   */
  static forbidden(message = 'Forbidden') {
    return new ApiError(403, message);
  }

  /**
   * T·∫°o m·ªôt l·ªói NotFound (404)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - L·ªói NotFound
   */
  static notFound(message = 'Resource not found') {
    return new ApiError(404, message);
  }

  /**
   * T·∫°o m·ªôt l·ªói Conflict (409)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - L·ªói Conflict
   */
  static conflict(message = 'Resource already exists') {
    return new ApiError(409, message);
  }

  /**
   * T·∫°o m·ªôt l·ªói InternalServer (500)
   * @param {string} message - Th√¥ng b√°o l·ªói
   * @returns {ApiError} - L·ªói InternalServer
   */
  static internal(message = 'Internal Server Error') {
    return new ApiError(500, message);
  }
}

module.exports = ApiError;


--- File: server/src/common/middleware/errorHandler.js ---
const ApiError = require('../errors/apiError');
const logger = require('../../config/logger');

/**
 * Middleware x·ª≠ l√Ω l·ªói to√†n c·ª•c
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // N·∫øu l·ªói kh√¥ng ph·∫£i l√† instance c·ªßa ApiError, chuy·ªÉn ƒë·ªïi th√†nh ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Something went wrong';
    error = new ApiError(statusCode, message, false, err.stack);
  }

  // Ghi log l·ªói
  if (error.statusCode >= 500) {
    logger.error(error);
  } else {
    logger.warn(`${error.statusCode} - ${error.message}`);
  }

  // Ph·∫£n h·ªìi cho client
  const response = {
    status: error.status,
    message: error.message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack }),
  };

  // Th√™m errors v√†o response n·∫øu l√† ValidationError
  if (error.errors) {
    response.errors = error.errors;
  }

  res.status(error.statusCode).json(response);
  next();
};

module.exports = errorHandler;


--- File: server/src/common/middleware/rateLimiter.js ---
const rateLimit = require('express-rate-limit');
const BusinessError = require('../errors/apiError');

/**
 * Middleware gi·ªõi h·∫°n s·ªë request trong m·ªôt kho·∫£ng th·ªùi gian
 * @param {Object} options - T√πy ch·ªçn c·∫•u h√¨nh
 */
const rateLimiter = (options = {}) => {
  const defaultOptions = {
    windowMs: 15 * 60 * 1000, // 15 ph√∫t
    max: 100, // Gi·ªõi h·∫°n 100 request m·ªói IP trong 15 ph√∫t
    message: 'Too many requests from this IP, please try again later',
  };

  const limiterOptions = { ...defaultOptions, ...options };

  return rateLimit({
    windowMs: limiterOptions.windowMs,
    max: limiterOptions.max,
    handler: (req, res, next) => {
      next(new BusinessError(limiterOptions.message, 429));
    },
  });
};

module.exports = rateLimiter;


--- File: server/src/common/middleware/requestLogger.js ---
const logger = require('../../config/logger');

/**
 * Middleware ghi log request v√† response
 */
const requestLogger = (req, res, next) => {
  // L∆∞u th·ªùi gian b·∫Øt ƒë·∫ßu request
  req.startTime = Date.now();

  // Ghi log request
  logger.info({
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userId: req.user ? req.user.id : 'anonymous',
  });

  // B·∫Øt s·ª± ki·ªán 'finish' ƒë·ªÉ ghi log sau khi request ho√†n th√†nh
  res.on('finish', () => {
    const duration = Date.now() - req.startTime;
    logger.info({
      method: req.method,
      url: req.originalUrl,
      status: res.statusCode,
      duration: `${duration}ms`,
    });
  });

  next();
};

module.exports = requestLogger;


--- File: server/src/common/middleware/validate.js ---
const { ValidationError } = require('../errors/apiError');

/**
 * Middleware validation d·ª±a tr√™n schema
 * @param {Object} schema - Joi schema ho·∫∑c validation schema
 * @param {String} source - Ngu·ªìn d·ªØ li·ªáu c·∫ßn validate ('body', 'query', 'params')
 */
const validate = (schema, source = 'body') => {
  return (req, res, next) => {
    const data = req[source];
    const { error, value } = schema.validate(data, { abortEarly: false });

    if (error) {
      const validationErrors = {};

      error.details.forEach((detail) => {
        const path = detail.path.join('.');
        validationErrors[path] = detail.message;
      });

      return next(new ValidationError('Validation failed', validationErrors));
    }

    // G√°n l·∫°i d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c validate v√†o request
    req[source] = value;
    return next();
  };
};

module.exports = validate;


--- File: server/src/common/readme.md ---
```
server/
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ common/                    # Shared code d√πng chung trong to√†n b·ªô ·ª©ng d·ª•ng
        ‚îú‚îÄ‚îÄ errors/                # Custom error classes
        ‚îÇ   ‚îú‚îÄ‚îÄ apiError.js             # Class ƒë·ªãnh nghƒ©a c√°c lo·∫°i l·ªói API chung
        ‚îÇ   ‚îú‚îÄ‚îÄ authError.js            # L·ªói li√™n quan ƒë·∫øn x√°c th·ª±c
        ‚îÇ   ‚îú‚îÄ‚îÄ validationError.js      # L·ªói li√™n quan ƒë·∫øn validation
        ‚îÇ   ‚îú‚îÄ‚îÄ notFoundError.js        # L·ªói khi kh√¥ng t√¨m th·∫•y t√†i nguy√™n
        ‚îÇ   ‚îú‚îÄ‚îÄ forbiddenError.js       # L·ªói v·ªÅ quy·ªÅn truy c·∫≠p
        ‚îÇ   ‚îî‚îÄ‚îÄ businessError.js        # L·ªói li√™n quan ƒë·∫øn business logic
        ‚îÇ
        ‚îú‚îÄ‚îÄ middleware/            # Middleware d√πng chung
        ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.js         # Middleware x·ª≠ l√Ω l·ªói chung
        ‚îÇ   ‚îú‚îÄ‚îÄ validate.js             # Middleware validation chung
        ‚îÇ   ‚îú‚îÄ‚îÄ requestLogger.js        # Middleware ghi log request/response
        ‚îÇ   ‚îî‚îÄ‚îÄ rateLimiter.js          # Gi·ªõi h·∫°n s·ªë request trong m·ªôt kho·∫£ng th·ªùi gian
        ‚îÇ
        ‚îú‚îÄ‚îÄ types/                 # Type definitions v√† interfaces
        ‚îÇ   ‚îú‚îÄ‚îÄ express.d.ts            # Type definitions m·ªü r·ªông cho Express
        ‚îÇ   ‚îú‚îÄ‚îÄ auth.types.js           # Types li√™n quan ƒë·∫øn authentication
        ‚îÇ   ‚îú‚îÄ‚îÄ product.types.js        # Types li√™n quan ƒë·∫øn product
        ‚îÇ   ‚îú‚îÄ‚îÄ order.types.js          # Types li√™n quan ƒë·∫øn order
        ‚îÇ   ‚îî‚îÄ‚îÄ common.types.js         # Types d√πng chung
        ‚îÇ
        ‚îú‚îÄ‚îÄ utils/                 # C√°c utility functions d√πng trong nhi·ªÅu modules
        ‚îÇ   ‚îú‚îÄ‚îÄ apiFeatures.js          # X·ª≠ l√Ω filtering, sorting, pagination
        ‚îÇ   ‚îú‚îÄ‚îÄ catchAsync.js           # Wrapper function ƒë·ªÉ x·ª≠ l√Ω async errors
        ‚îÇ   ‚îú‚îÄ‚îÄ responseHandler.js      # Format response tr·∫£ v·ªÅ t·ª´ API
        ‚îÇ   ‚îú‚îÄ‚îÄ validatorUtils.js       # C√°c helper functions cho validation
        ‚îÇ   ‚îú‚îÄ‚îÄ dateUtils.js            # C√°c utility function x·ª≠ l√Ω datetime
        ‚îÇ   ‚îú‚îÄ‚îÄ fileUtils.js            # X·ª≠ l√Ω file upload, manipulation
        ‚îÇ   ‚îú‚îÄ‚îÄ securityUtils.js        # C√°c utility cho hash, token, encrypt
        ‚îÇ   ‚îî‚îÄ‚îÄ formatters.js           # C√°c h√†m format data (currency, phone, etc.)
        ‚îÇ
        ‚îî‚îÄ‚îÄ validators/            # ƒê·ªãnh nghƒ©a validation schema v√† rules
            ‚îú‚îÄ‚îÄ authValidator.js        # Validation rules cho auth requests
            ‚îú‚îÄ‚îÄ userValidator.js        # Validation rules cho user requests
            ‚îú‚îÄ‚îÄ productValidator.js     # Validation rules cho product requests
            ‚îú‚îÄ‚îÄ categoryValidator.js    # Validation rules cho category requests
            ‚îú‚îÄ‚îÄ orderValidator.js       # Validation rules cho order requests
            ‚îú‚îÄ‚îÄ cartValidator.js        # Validation rules cho cart requests
            ‚îú‚îÄ‚îÄ reviewValidator.js      # Validation rules cho review requests
            ‚îî‚îÄ‚îÄ commonValidator.js      # Validation rules d√πng chung

        ‚îî‚îÄ‚îÄ readme.md                 # README file for common package

```
1. errors/
Th∆∞ m·ª•c n√†y ch·ª©a c√°c class ƒë·ªãnh nghƒ©a l·ªói t√πy ch·ªânh ƒë·ªÉ x·ª≠ l√Ω l·ªói m·ªôt c√°ch nh·∫•t qu√°n trong to√†n b·ªô ·ª©ng d·ª•ng.

apiError.js: Class c∆° s·ªü cho t·∫•t c·∫£ c√°c lo·∫°i l·ªói API. ƒê·ªãnh nghƒ©a c·∫•u tr√∫c l·ªói v·ªõi statusCode, message, v√† c√°c th√¥ng tin b·ªï sung.
authError.js: L·ªói x√°c th·ª±c nh∆∞ token kh√¥ng h·ª£p l·ªá, h·∫øt h·∫°n, kh√¥ng c√≥ quy·ªÅn, v.v.
validationError.js: L·ªói x·∫£y ra khi d·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng ƒë·∫°t y√™u c·∫ßu validation.
notFoundError.js: L·ªói khi t√†i nguy√™n kh√¥ng t·ªìn t·∫°i (404).
forbiddenError.js: L·ªói khi ng∆∞·ªùi d√πng kh√¥ng c√≥ quy·ªÅn truy c·∫≠p t√†i nguy√™n (403).
businessError.js: L·ªói li√™n quan ƒë·∫øn logic nghi·ªáp v·ª•, v√≠ d·ª•: s·∫£n ph·∫©m h·∫øt h√†ng, ƒë∆°n h√†ng ƒë√£ b·ªã h·ªßy, v.v.

2. middleware/
Ch·ª©a c√°c middleware d√πng chung c√≥ th·ªÉ √°p d·ª•ng ·ªü nhi·ªÅu n∆°i trong ·ª©ng d·ª•ng.

errorHandler.js: Middleware x·ª≠ l√Ω t·∫•t c·∫£ c√°c l·ªói, chuy·ªÉn ƒë·ªïi ch√∫ng th√†nh response chu·∫©n.
validate.js: Middleware x√°c th·ª±c d·ªØ li·ªáu ƒë·∫ßu v√†o d·ª±a tr√™n schema ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a.
requestLogger.js: Ghi log t·∫•t c·∫£ c√°c requests v√† responses ƒë·ªÉ debugging v√† monitoring.
rateLimiter.js: Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng request trong m·ªôt kho·∫£ng th·ªùi gian ƒë·ªÉ ngƒÉn ch·∫∑n DoS.

3. types/
ƒê·ªãnh nghƒ©a c√°c ki·ªÉu d·ªØ li·ªáu v√† interfaces ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n trong to√†n b·ªô ·ª©ng d·ª•ng.

express.d.ts: M·ªü r·ªông ki·ªÉu d·ªØ li·ªáu cho Express, v√≠ d·ª•: th√™m thu·ªôc t√≠nh user v√†o Request.
auth.types.js: ƒê·ªãnh nghƒ©a c√°c ki·ªÉu li√™n quan ƒë·∫øn x√°c th·ª±c nh∆∞ UserRole, TokenPayload.
product.types.js: ƒê·ªãnh nghƒ©a c√°c ki·ªÉu d·ªØ li·ªáu cho s·∫£n ph·∫©m nh∆∞ ProductStatus, ProductVariant.
order.types.js: ƒê·ªãnh nghƒ©a c√°c ki·ªÉu d·ªØ li·ªáu cho ƒë∆°n h√†ng nh∆∞ OrderStatus, PaymentStatus.
common.types.js: C√°c ki·ªÉu d·ªØ li·ªáu d√πng chung nh∆∞ PaginationParams, SortDirection.

4. utils/
C√°c h√†m ti·ªán √≠ch d√πng chung trong ·ª©ng d·ª•ng.

apiFeatures.js: X·ª≠ l√Ω c√°c t√≠nh nƒÉng API nh∆∞ filtering, sorting, pagination m·ªôt c√°ch nh·∫•t qu√°n.
catchAsync.js: Wrapper function ƒë·ªÉ b·∫Øt l·ªói trong c√°c h√†m async m√† kh√¥ng c·∫ßn try/catch l·∫∑p l·∫°i.
responseHandler.js: Chu·∫©n h√≥a c·∫•u tr√∫c response t·ª´ API (success, error, data, message).
validatorUtils.js: C√°c h√†m h·ªó tr·ª£ cho validation nh∆∞ isValidEmail, isStrongPassword.
dateUtils.js: X·ª≠ l√Ω c√°c operations li√™n quan ƒë·∫øn datetime nh∆∞ format, compare, diff.
fileUtils.js: X·ª≠ l√Ω file upload, manipulation, validation.
securityUtils.js: C√°c h√†m li√™n quan ƒë·∫øn b·∫£o m·∫≠t nh∆∞ hash password, generate token.
formatters.js: ƒê·ªãnh d·∫°ng data nh∆∞ formatCurrency, formatPhoneNumber, formatAddress.

5. validators/
Ch·ª©a c√°c schema v√† rules validation cho d·ªØ li·ªáu ƒë·∫ßu v√†o.

authValidator.js: Validation cho request ƒëƒÉng nh·∫≠p, ƒëƒÉng k√Ω, ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u.
userValidator.js: Validation cho th√¥ng tin ng∆∞·ªùi d√πng, c·∫≠p nh·∫≠t profile.
productValidator.js: Validation cho th√¥ng tin s·∫£n ph·∫©m, th√™m/s·ª≠a s·∫£n ph·∫©m.
categoryValidator.js: Validation cho th√¥ng tin danh m·ª•c.
orderValidator.js: Validation cho th√¥ng tin ƒë∆°n h√†ng, c·∫≠p nh·∫≠t tr·∫°ng th√°i.
cartValidator.js: Validation cho th√¥ng tin gi·ªè h√†ng, th√™m/s·ª≠a s·∫£n ph·∫©m trong gi·ªè.
reviewValidator.js: Validation cho ƒë√°nh gi√° s·∫£n ph·∫©m.
commonValidator.js: C√°c rules validation d√πng chung nh∆∞ validateObjectId, validatePagination.
```


--- File: server/src/common/types/auth.types.js ---
/**
 * C√°c ki·ªÉu d·ªØ li·ªáu li√™n quan ƒë·∫øn authentication
 */

// Enum vai tr√≤ ng∆∞·ªùi d√πng
const UserRole = {
  ADMIN: 'admin',
  STAFF: 'staff',
  USER: 'user',
};

// C·∫•u tr√∫c payload trong JWT token
const TokenPayload = {
  id: String, // ID ng∆∞·ªùi d√πng
  email: String, // Email ng∆∞·ªùi d√πng
  role: String, // Vai tr√≤ ng∆∞·ªùi d√πng
  iat: Number, // Issued at - th·ªùi ƒëi·ªÉm token ƒë∆∞·ª£c t·∫°o
  exp: Number, // Expiration - th·ªùi ƒëi·ªÉm token h·∫øt h·∫°n
};

// C·∫•u tr√∫c response khi ƒëƒÉng nh·∫≠p
const AuthResponse = {
  user: Object, // Th√¥ng tin ng∆∞·ªùi d√πng
  token: String, // Access token
  refreshToken: String, // Refresh token
};

module.exports = {
  UserRole,
  TokenPayload,
  AuthResponse,
};


--- File: server/src/common/types/common.types.js ---
/**
 * C√°c ki·ªÉu d·ªØ li·ªáu d√πng chung trong ·ª©ng d·ª•ng
 */

// Tham s·ªë ph√¢n trang
const PaginationParams = {
  page: Number, // Trang hi·ªán t·∫°i
  limit: Number, // S·ªë l∆∞·ª£ng item m·ªói trang
  total: Number, // T·ªïng s·ªë item
  totalPages: Number, // T·ªïng s·ªë trang
};

// H∆∞·ªõng s·∫Øp x·∫øp
const SortDirection = {
  ASC: 'asc',
  DESC: 'desc',
};

// ƒêi·ªÅu ki·ªán l·ªçc
const FilterOperator = {
  EQ: 'eq', // B·∫±ng
  NE: 'ne', // Kh√¥ng b·∫±ng
  GT: 'gt', // L·ªõn h∆°n
  GTE: 'gte', // L·ªõn h∆°n ho·∫∑c b·∫±ng
  LT: 'lt', // Nh·ªè h∆°n
  LTE: 'lte', // Nh·ªè h∆°n ho·∫∑c b·∫±ng
  IN: 'in', // Trong t·∫≠p gi√° tr·ªã
  NIN: 'nin', // Kh√¥ng trong t·∫≠p gi√° tr·ªã
  REGEX: 'regex', // Kh·ªõp v·ªõi bi·ªÉu th·ª©c ch√≠nh quy
};

module.exports = {
  PaginationParams,
  SortDirection,
  FilterOperator,
};


--- File: server/src/common/types/express.d.ts ---
// M·ªü r·ªông ki·ªÉu Request t·ª´ Express
declare namespace Express {
    export interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
        permissions?: string[];
      };
      startTime?: number;
      correlationId?: string;
    }
  }

--- File: server/src/common/types/order.types.js ---
/**
 * C√°c ki·ªÉu d·ªØ li·ªáu li√™n quan ƒë·∫øn ƒë∆°n h√†ng
 */

// Enum tr·∫°ng th√°i ƒë∆°n h√†ng
const OrderStatus = {
  PENDING: 'pending', // Ch·ªù x√°c nh·∫≠n
  PROCESSING: 'processing', // ƒêang x·ª≠ l√Ω
  PACKED: 'packed', // ƒê√£ ƒë√≥ng g√≥i
  SHIPPED: 'shipped', // ƒêang giao h√†ng
  DELIVERED: 'delivered', // ƒê√£ giao h√†ng
  CANCELLED: 'cancelled', // ƒê√£ h·ªßy
  RETURNED: 'returned', // ƒê√£ tr·∫£ h√†ng
};

// Enum tr·∫°ng th√°i thanh to√°n
const PaymentStatus = {
  PENDING: 'pending', // Ch·ªù thanh to√°n
  AUTHORIZED: 'authorized', // ƒê√£ ·ªßy quy·ªÅn
  PAID: 'paid', // ƒê√£ thanh to√°n
  FAILED: 'failed', // Thanh to√°n th·∫•t b·∫°i
  REFUNDED: 'refunded', // ƒê√£ ho√†n ti·ªÅn
  PARTIALLY_REFUNDED: 'partially_refunded', // Ho√†n ti·ªÅn m·ªôt ph·∫ßn
};

// Enum ph∆∞∆°ng th·ª©c thanh to√°n
const PaymentMethod = {
  COD: 'cod', // Thanh to√°n khi nh·∫≠n h√†ng
  CREDIT_CARD: 'credit_card', // Th·∫ª t√≠n d·ª•ng
  VNPAY: 'vnpay', // VNPay
  BANK_TRANSFER: 'bank_transfer', // Chuy·ªÉn kho·∫£n ng√¢n h√†ng
  MOMO: 'momo', // V√≠ MoMo
};

module.exports = {
  OrderStatus,
  PaymentStatus,
  PaymentMethod,
};


--- File: server/src/common/types/product.types.js ---
/**
 * C√°c ki·ªÉu d·ªØ li·ªáu li√™n quan ƒë·∫øn s·∫£n ph·∫©m
 */

// Enum tr·∫°ng th√°i s·∫£n ph·∫©m
const ProductStatus = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  OUT_OF_STOCK: 'out_of_stock',
  COMING_SOON: 'coming_soon',
  DISCONTINUED: 'discontinued',
};

// Enum lo·∫°i s·∫£n ph·∫©m
const ProductType = {
  CUE: 'cue', // G·∫≠y billiard
  BALL: 'ball', // Bi
  ACCESSORIES: 'accessories', // Ph·ª• ki·ªán
  TABLE: 'table', // B√†n billiard
  CHALK: 'chalk', // Ph·∫•n
};

module.exports = {
  ProductStatus,
  ProductType,
};


--- File: server/src/common/utils/apiFeatures.js ---
/**
 * Class x·ª≠ l√Ω c√°c t√≠nh nƒÉng API nh∆∞ filtering, sorting, pagination
 */
class APIFeatures {
  /**
   * @param {Object} query - Mongoose query object
   * @param {Object} queryString - Query string t·ª´ Express request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * Filter query d·ª±a tr√™n c√°c tham s·ªë
   * H·ªó tr·ª£ c√°c operators: gt, gte, lt, lte, in
   */
  filter() {
    const queryObj = { ...this.queryString };
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'q', 'populate'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // Advanced filtering v·ªõi gte, gt, lte, lt
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in)\b/g, (match) => `$${match}`);

    this.query = this.query.find(JSON.parse(queryStr));
    return this;
  }

  /**
   * S·∫Øp x·∫øp k·∫øt qu·∫£
   * Format: sort=field,direction (v√≠ d·ª•: sort=price,-createdAt)
   */
  sort() {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // Default sort theo createdAt gi·∫£m d·∫ßn (m·ªõi nh·∫•t tr∆∞·ªõc)
      this.query = this.query.sort('-createdAt');
    }
    return this;
  }

  /**
   * Gi·ªõi h·∫°n c√°c tr∆∞·ªùng ƒë∆∞·ª£c tr·∫£ v·ªÅ
   * Format: fields=field1,field2,-field3
   */
  limitFields() {
    if (this.queryString.fields) {
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // M·∫∑c ƒë·ªãnh b·ªè tr∆∞·ªùng __v
      this.query = this.query.select('-__v');
    }
    return this;
  }

  /**
   * Ph√¢n trang k·∫øt qu·∫£
   * page: S·ªë trang (default: 1)
   * limit: S·ªë items m·ªói trang (default: 10)
   */
  paginate() {
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    this.query = this.query.skip(skip).limit(limit);
    return this;
  }

  /**
   * Populate c√°c tr∆∞·ªùng reference
   * Format: populate=field1,field2
   */
  populate() {
    if (this.queryString.populate) {
      const fields = this.queryString.populate.split(',');
      fields.forEach((field) => {
        this.query = this.query.populate(field);
      });
    }
    return this;
  }

  /**
   * Search d·ª±a tr√™n text index
   * Format: q=search term
   */
  search() {
    if (this.queryString.q) {
      this.query = this.query.find({ $text: { $search: this.queryString.q } });
    }
    return this;
  }
}

module.exports = APIFeatures;


--- File: server/src/common/utils/catchAsync.js ---
/**
 * Wrapper function ƒë·ªÉ b·∫Øt l·ªói trong c√°c h√†m async
 * Tr√°nh vi·ªác ph·∫£i s·ª≠ d·ª•ng try/catch nhi·ªÅu l·∫ßn
 *
 * @param {Function} fn - Async function c·∫ßn b·ªçc
 * @returns {Function} Middleware function v·ªõi l·ªói ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

module.exports = catchAsync;


--- File: server/src/common/utils/dateUtils.js ---
/**
 * C√°c h√†m ti·ªán √≠ch x·ª≠ l√Ω datetime
 */
/**
 * no-type
 * @module dateUtils
 * @description C√°c h√†m ti·ªán √≠ch x·ª≠ l√Ω datetime
 * @example
 * const dateUtils = require('./dateUtils');
 * const formattedDate = dateUtils.formatDate(new Date());
 */
const dateUtils = {
  /**
   * Format date theo ƒë·ªãnh d·∫°ng DD/MM/YYYY
   *
   * @param {Date} date - Date object c·∫ßn format
   * @returns {String} Chu·ªói ƒë√£ format
   */
  formatDate: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();

    return `${day}/${month}/${year}`;
  },

  /**
   * Format datetime theo ƒë·ªãnh d·∫°ng DD/MM/YYYY HH:MM
   *
   * @param {Date} date - Date object c·∫ßn format
   * @returns {String} Chu·ªói ƒë√£ format
   */
  formatDateTime: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');

    return `${day}/${month}/${year} ${hours}:${minutes}`;
  },

  /**
   * T√≠nh s·ªë ng√†y gi·ªØa hai ng√†y
   *
   * @param {Date} startDate - Ng√†y b·∫Øt ƒë·∫ßu
   * @param {Date} endDate - Ng√†y k·∫øt th√∫c
   * @returns {Number} S·ªë ng√†y
   */
  daysBetween: (startDate, endDate) => {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end.getTime() - start.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    return diffDays;
  },

  /**
   * Th√™m s·ªë ng√†y v√†o m·ªôt ng√†y
   *
   * @param {Date} date - Ng√†y g·ªëc
   * @param {Number} days - S·ªë ng√†y c·∫ßn th√™m
   * @returns {Date} Ng√†y m·ªõi
   */
  addDays: (date, days) => {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  },

  /**
   * L·∫•y ng√†y ƒë·∫ßu ti√™n c·ªßa th√°ng
   *
   * @param {Date} date - Ng√†y b·∫•t k·ª≥ trong th√°ng
   * @returns {Date} Ng√†y ƒë·∫ßu ti√™n c·ªßa th√°ng
   */
  firstDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth(), 1);
  },

  /**
   * L·∫•y ng√†y cu·ªëi c√πng c·ªßa th√°ng
   *
   * @param {Date} date - Ng√†y b·∫•t k·ª≥ trong th√°ng
   * @returns {Date} Ng√†y cu·ªëi c√πng c·ªßa th√°ng
   */
  lastDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0);
  },

  /**
   * Ki·ªÉm tra ng√†y c√≥ ph·∫£i l√† ng√†y hi·ªán t·∫°i
   *
   * @param {Date} date - Ng√†y c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isToday: (date) => {
    const today = new Date();
    const d = new Date(date);

    return (
      d.getDate() === today.getDate() &&
      d.getMonth() === today.getMonth() &&
      d.getFullYear() === today.getFullYear()
    );
  },
};

module.exports = dateUtils;


--- File: server/src/common/utils/fileUtils.js ---
const fs = require('fs');
const path = require('path');
const util = require('util');
const crypto = require('crypto');

// Promisify fs functions
const unlinkAsync = util.promisify(fs.unlink);
const mkdirAsync = util.promisify(fs.mkdir);
const statAsync = util.promisify(fs.stat);

/**
 * C√°c h√†m ti·ªán √≠ch x·ª≠ l√Ω file
 */
const fileUtils = {
  /**
   * Ki·ªÉm tra m·ªôt file c√≥ t·ªìn t·∫°i
   *
   * @param {String} filePath - ƒê∆∞·ªùng d·∫´n file
   * @returns {Promise<Boolean>} K·∫øt qu·∫£ ki·ªÉm tra
   */
  fileExists: async (filePath) => {
    try {
      await statAsync(filePath);
      return true;
    } catch (error) {
      return false;
    }
  },

  /**
   * T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i
   *
   * @param {String} dirPath - ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c
   * @returns {Promise<void>}
   */
  ensureDirectoryExists: async (dirPath) => {
    if (!fs.existsSync(dirPath)) {
      await mkdirAsync(dirPath, { recursive: true });
    }
  },

  /**
   * X√≥a m·ªôt file
   *
   * @param {String} filePath - ƒê∆∞·ªùng d·∫´n file
   * @returns {Promise<void>}
   */
  removeFile: async (filePath) => {
    if (await fileUtils.fileExists(filePath)) {
      await unlinkAsync(filePath);
    }
  },

  /**
   * L·∫•y extension c·ªßa file
   *
   * @param {String} filename - T√™n file
   * @returns {String} Extension c·ªßa file
   */
  getFileExtension: (filename) => {
    return path.extname(filename).toLowerCase();
  },

  /**
   * Ki·ªÉm tra file c√≥ ph·∫£i l√† h√¨nh ·∫£nh
   *
   * @param {String} filename - T√™n file
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isImageFile: (filename) => {
    const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
    const extension = fileUtils.getFileExtension(filename);
    return validExtensions.includes(extension);
  },

  /**
   * T·∫°o t√™n file ng·∫´u nhi√™n
   *
   * @param {String} originalname - T√™n file g·ªëc
   * @returns {String} T√™n file m·ªõi
   */
  generateUniqueFilename: (originalname) => {
    const extension = fileUtils.getFileExtension(originalname);
    const randomName = crypto.randomBytes(16).toString('hex');
    return `${randomName}${extension}`;
  },

  /**
   * T√≠nh k√≠ch th∆∞·ªõc file theo ƒë·ªãnh d·∫°ng readable
   *
   * @param {Number} bytes - K√≠ch th∆∞·ªõc file t√≠nh b·∫±ng bytes
   * @returns {String} K√≠ch th∆∞·ªõc file d·∫°ng readable
   */
  formatFileSize: (bytes) => {
    if (bytes === 0) return '0 Bytes';

    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));

    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
  },
};

module.exports = fileUtils;


--- File: server/src/common/utils/formatters.js ---
/**
 * C√°c h√†m ti·ªán √≠ch ƒë·ªãnh d·∫°ng d·ªØ li·ªáu
 */
const formatters = {
  /**
   * ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn
   *
   * @param {Number} amount - S·ªë ti·ªÅn c·∫ßn ƒë·ªãnh d·∫°ng
   * @param {String} currency - ƒê∆°n v·ªã ti·ªÅn t·ªá (m·∫∑c ƒë·ªãnh: VND)
   * @returns {String} Chu·ªói ƒë√£ ƒë·ªãnh d·∫°ng
   */
  formatCurrency: (amount, currency = 'VND') => {
    const formatter = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
    });

    return formatter.format(amount);
  },

  /**
   * ƒê·ªãnh d·∫°ng s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam
   *
   * @param {String} phone - S·ªë ƒëi·ªán tho·∫°i c·∫ßn ƒë·ªãnh d·∫°ng
   * @returns {String} S·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë·ªãnh d·∫°ng
   */
  formatPhoneNumber: (phone) => {
    if (!phone) return '';

    // Lo·∫°i b·ªè t·∫•t c·∫£ k√Ω t·ª± kh√¥ng ph·∫£i s·ªë
    const cleaned = phone.replace(/\D/g, '');

    // Ki·ªÉm tra ƒë·ªô d√†i
    if (cleaned.length !== 10) return phone;

    // ƒê·ªãnh d·∫°ng: XXX XXX XXXX
    return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)} ${cleaned.slice(6)}`;
  },

  /**
   * ƒê·ªãnh d·∫°ng ƒë·ªãa ch·ªâ
   *
   * @param {Object} address - Object ch·ª©a th√¥ng tin ƒë·ªãa ch·ªâ
   * @returns {String} ƒê·ªãa ch·ªâ ƒë√£ ƒë·ªãnh d·∫°ng
   */
  formatAddress: (address) => {
    if (!address) return '';

    const parts = [];

    if (address.street) parts.push(address.street);
    if (address.city) parts.push(address.city);
    if (address.state) parts.push(address.state);
    if (address.zipCode) parts.push(address.zipCode);
    if (address.country) parts.push(address.country);

    return parts.join(', ');
  },

  /**
   * R√∫t g·ªçn chu·ªói n·∫øu qu√° d√†i
   *
   * @param {String} text - Chu·ªói c·∫ßn r√∫t g·ªçn
   * @param {Number} maxLength - ƒê·ªô d√†i t·ªëi ƒëa
   * @returns {String} Chu·ªói ƒë√£ r√∫t g·ªçn
   */
  truncateText: (text, maxLength = 100) => {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.slice(0, maxLength) + '...';
  },

  /**
   * Chuy·ªÉn ƒë·ªïi chu·ªói th√†nh slug URL
   *
   * @param {String} text - Chu·ªói c·∫ßn chuy·ªÉn ƒë·ªïi
   * @returns {String} Slug URL
   */
  slugify: (text) => {
    if (!text) return '';

    // Chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng v√† thay th·∫ø d·∫•u ti·∫øng Vi·ªát
    const slug = text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[ƒëƒê]/g, 'd')
      .replace(/[^a-z0-9\s-]/g, '') // Lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
      .replace(/\s+/g, '-') // Thay space b·∫±ng d·∫•u g·∫°ch ngang
      .replace(/-+/g, '-') // Lo·∫°i b·ªè d·∫•u g·∫°ch ngang li√™n ti·∫øp
      .trim();

    return slug;
  },

  /**
   * ƒê·ªãnh d·∫°ng t√™n ng∆∞·ªùi
   *
   * @param {String} firstName - T√™n
   * @param {String} lastName - H·ªç
   * @returns {String} T√™n ƒë·∫ßy ƒë·ªß
   */
  formatName: (firstName, lastName) => {
    if (!firstName && !lastName) return '';
    if (!firstName) return lastName;
    if (!lastName) return firstName;

    return `${lastName} ${firstName}`;
  },

  /**
   * ƒê·ªãnh d·∫°ng d·ªØ li·ªáu s·∫£n ph·∫©m tr∆∞·ªõc khi tr·∫£ v·ªÅ client
   *
   * @param {Object} product - D·ªØ li·ªáu s·∫£n ph·∫©m c·∫ßn ƒë·ªãnh d·∫°ng
   * @returns {Object} - D·ªØ li·ªáu s·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng
   */
  formatProductResponse: (product) => {
    if (!product) return null;

    // T·∫°o b·∫£n sao ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn d·ªØ li·ªáu g·ªëc
    const formattedProduct = { ...product };

    // ƒê·ªãnh d·∫°ng gi√° ti·ªÅn
    if (formattedProduct.pricing) {
      if (formattedProduct.pricing.regular) {
        formattedProduct.pricing.formattedRegularPrice = formatters.formatCurrency(
          formattedProduct.pricing.regular,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.sale) {
        formattedProduct.pricing.formattedSalePrice = formatters.formatCurrency(
          formattedProduct.pricing.sale,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.finalPrice) {
        formattedProduct.pricing.formattedFinalPrice = formatters.formatCurrency(
          formattedProduct.pricing.finalPrice,
          formattedProduct.pricing.currency || 'VND'
        );
      }
    }

    // ƒê·ªãnh d·∫°ng m√¥ t·∫£ ng·∫Øn g·ªçn
    if (formattedProduct.description) {
      formattedProduct.shortDescription = formatters.truncateText(
        formattedProduct.description,
        150
      );
    }

    // ƒê·ªãnh d·∫°ng ng√†y th√°ng
    if (formattedProduct.dates) {
      if (formattedProduct.dates.created) {
        formattedProduct.dates.formattedCreatedDate = new Date(
          formattedProduct.dates.created
        ).toLocaleDateString('vi-VN');
      }
      if (formattedProduct.dates.updated) {
        formattedProduct.dates.formattedUpdatedDate = new Date(
          formattedProduct.dates.updated
        ).toLocaleDateString('vi-VN');
      }
    }

    // ƒê·ªãnh d·∫°ng tr·∫°ng th√°i t·ªìn kho
    if (formattedProduct.inventory) {
      formattedProduct.inventory.statusText = formattedProduct.inventory.inStock
        ? 'C√≤n h√†ng'
        : 'H·∫øt h√†ng';
    }

    // ƒê·ªãnh d·∫°ng ƒë√°nh gi√° trung b√¨nh
    if (formattedProduct.averageRating !== undefined) {
      formattedProduct.formattedRating = formattedProduct.averageRating.toFixed(1);
    }

    return formattedProduct;
  },
};

module.exports = formatters;


--- File: server/src/common/utils/responseHandler.js ---
/**
 * Ti·ªán √≠ch x·ª≠ l√Ω response chu·∫©n h√≥a
 */
const responseHandler = {
  /**
   * Tr·∫£ v·ªÅ response th√†nh c√¥ng
   *
   * @param {Object} res - Express response object
   * @param {Object} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
   * @param {String} message - Th√¥ng b√°o th√†nh c√¥ng
   * @param {Number} statusCode - HTTP status code
   */
  success: (res, data = null, message = 'Success', statusCode = 200) => {
    return res.status(statusCode).json({
      status: 'success',
      message,
      data,
    });
  },

  /**
   * Tr·∫£ v·ªÅ response l·ªói
   *
   * @param {Object} res - Express response object
   * @param {String} message - Th√¥ng b√°o l·ªói
   * @param {Number} statusCode - HTTP status code
   * @param {Object} errors - Chi ti·∫øt l·ªói
   */
  error: (res, message = 'Error occurred', statusCode = 400, errors = null) => {
    const response = {
      status: 'error',
      message,
    };

    if (errors) {
      response.errors = errors;
    }

    return res.status(statusCode).json(response);
  },

  /**
   * Tr·∫£ v·ªÅ response khi t·∫°o th√†nh c√¥ng
   *
   * @param {Object} res - Express response object
   * @param {Object} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
   * @param {String} message - Th√¥ng b√°o th√†nh c√¥ng
   */
  created: (res, data = null, message = 'Resource created successfully') => {
    return responseHandler.success(res, data, message, 201);
  },

  /**
   * Tr·∫£ v·ªÅ response kh√¥ng c√≥ n·ªôi dung
   *
   * @param {Object} res - Express response object
   */
  noContent: (res) => {
    return res.status(204).end();
  },

  /**
   * Tr·∫£ v·ªÅ response v·ªõi d·ªØ li·ªáu ƒë∆∞·ª£c ph√¢n trang
   *
   * @param {Object} res - Express response object
   * @param {Array} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
   * @param {Number} page - Trang hi·ªán t·∫°i
   * @param {Number} limit - S·ªë l∆∞·ª£ng items m·ªói trang
   * @param {Number} total - T·ªïng s·ªë items
   */
  paginated: (res, data, page, limit, total) => {
    const totalPages = Math.ceil(total / limit);

    return res.status(200).json({
      status: 'success',
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
      },
    });
  },
};

module.exports = responseHandler;


--- File: server/src/common/utils/securityUtils.js ---
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

/**
 * C√°c h√†m ti·ªán √≠ch li√™n quan ƒë·∫øn b·∫£o m·∫≠t
 */
const securityUtils = {
  /**
   * Hash m·∫≠t kh·∫©u s·ª≠ d·ª•ng bcrypt
   *
   * @param {String} password - M·∫≠t kh·∫©u c·∫ßn hash
   * @returns {Promise<String>} M·∫≠t kh·∫©u ƒë√£ hash
   */
  hashPassword: async (password) => {
    const saltRounds = 10;
    return await bcrypt.hash(password, saltRounds);
  },

  /**
   * So s√°nh m·∫≠t kh·∫©u v·ªõi hash
   *
   * @param {String} password - M·∫≠t kh·∫©u c·∫ßn ki·ªÉm tra
   * @param {String} hash - Hash ƒë√£ l∆∞u
   * @returns {Promise<Boolean>} K·∫øt qu·∫£ so s√°nh
   */
  comparePassword: async (password, hash) => {
    return await bcrypt.compare(password, hash);
  },

  /**
   * T·∫°o JWT token
   *
   * @param {Object} payload - D·ªØ li·ªáu c·∫ßn l∆∞u trong token
   * @param {String} secret - Secret key
   * @param {Object} options - T√πy ch·ªçn cho token
   * @returns {String} JWT token
   */
  generateToken: (payload, secret, options = {}) => {
    return jwt.sign(payload, secret, options);
  },

  /**
   * X√°c th·ª±c v√† decode JWT token
   *
   * @param {String} token - JWT token
   * @param {String} secret - Secret key
   * @returns {Object} Payload ƒë√£ decode
   */
  verifyToken: (token, secret) => {
    return jwt.verify(token, secret);
  },

  /**
   * T·∫°o chu·ªói random ƒë·ªÉ l√†m reset token, verification token...
   *
   * @param {Number} length - ƒê·ªô d√†i chu·ªói (m·∫∑c ƒë·ªãnh: 32)
   * @returns {String} Chu·ªói random
   */
  generateRandomToken: (length = 32) => {
    return crypto.randomBytes(length).toString('hex');
  },

  /**
   * Hash m·ªôt chu·ªói s·ª≠ d·ª•ng SHA-256
   *
   * @param {String} data - Chu·ªói c·∫ßn hash
   * @returns {String} Chu·ªói ƒë√£ hash
   */
  hashData: (data) => {
    return crypto.createHash('sha256').update(data).digest('hex');
  },

  /**
   * M√£ h√≥a d·ªØ li·ªáu
   *
   * @param {String} data - D·ªØ li·ªáu c·∫ßn m√£ h√≥a
   * @param {String} secret - Secret key
   * @returns {String} D·ªØ li·ªáu ƒë√£ m√£ h√≥a
   */
  encrypt: (data, secret) => {
    const algorithm = 'aes-256-ctr';
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, secret, iv);

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return `${iv.toString('hex')}:${encrypted}`;
  },

  /**
   * Gi·∫£i m√£ d·ªØ li·ªáu
   *
   * @param {String} encryptedData - D·ªØ li·ªáu ƒë√£ m√£ h√≥a
   * @param {String} secret - Secret key
   * @returns {String} D·ªØ li·ªáu ƒë√£ gi·∫£i m√£
   */
  decrypt: (encryptedData, secret) => {
    const algorithm = 'aes-256-ctr';
    const [ivHex, encrypted] = encryptedData.split(':');

    const iv = Buffer.from(ivHex, 'hex');
    const decipher = crypto.createDecipheriv(algorithm, secret, iv);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  },
};

module.exports = securityUtils;


--- File: server/src/common/utils/validatorUtils.js ---
const mongoose = require('mongoose');

/**
 * C√°c h√†m ti·ªán √≠ch cho validation
 */
const validatorUtils = {
  /**
   * Ki·ªÉm tra chu·ªói c√≥ ph·∫£i l√† email h·ª£p l·ªá
   *
   * @param {String} email - Chu·ªói c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isValidEmail: (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  /**
   * Ki·ªÉm tra chu·ªói c√≥ ph·∫£i l√† s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam h·ª£p l·ªá
   *
   * @param {String} phone - Chu·ªói c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isValidVietnamesePhone: (phone) => {
    const phoneRegex = /(84|0[3|5|7|8|9])+([0-9]{8})\b/;
    return phoneRegex.test(phone);
  },

  /**
   * Ki·ªÉm tra chu·ªói c√≥ ph·∫£i l√† m·∫≠t kh·∫©u m·∫°nh
   * Y√™u c·∫ßu: √≠t nh·∫•t 8 k√Ω t·ª±, ch·ª©a ch·ªØ hoa, ch·ªØ th∆∞·ªùng, s·ªë v√† k√Ω t·ª± ƒë·∫∑c bi·ªát
   *
   * @param {String} password - Chu·ªói c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isStrongPassword: (password) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  },

  /**
   * Ki·ªÉm tra chu·ªói c√≥ ph·∫£i l√† MongoDB ObjectId h·ª£p l·ªá
   *
   * @param {String} id - Chu·ªói c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isValidObjectId: (id) => {
    return mongoose.Types.ObjectId.isValid(id);
  },

  /**
   * Ki·ªÉm tra gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë nguy√™n d∆∞∆°ng
   *
   * @param {Number} value - Gi√° tr·ªã c·∫ßn ki·ªÉm tra
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isPositiveInteger: (value) => {
    return Number.isInteger(value) && value > 0;
  },

  /**
   * Ki·ªÉm tra gi√° tr·ªã c√≥ n·∫±m trong kho·∫£ng
   *
   * @param {Number} value - Gi√° tr·ªã c·∫ßn ki·ªÉm tra
   * @param {Number} min - Gi√° tr·ªã t·ªëi thi·ªÉu
   * @param {Number} max - Gi√° tr·ªã t·ªëi ƒëa
   * @returns {Boolean} K·∫øt qu·∫£ ki·ªÉm tra
   */
  isInRange: (value, min, max) => {
    return value >= min && value <= max;
  },
};

module.exports = validatorUtils;


--- File: server/src/common/validators/authValidator.js ---
/**
 * Auth Validator - ƒê·ªãnh nghƒ©a c√°c schema validation cho authentication
 * @author Steve
 * @project RunOut-Biliard
 */

const Joi = require('joi');

// Schema ƒëƒÉng k√Ω
const registerSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().messages({
    'string.min': 'T√™n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
    'string.max': 'T√™n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    'string.empty': 'T√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'T√™n l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),

  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'Email l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
    }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.pattern.base': 'M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t m·ªôt ch·ªØ hoa, m·ªôt ch·ªØ th∆∞·ªùng v√† m·ªôt ch·ªØ s·ªë',
      'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'M·∫≠t kh·∫©u l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'X√°c nh·∫≠n m·∫≠t kh·∫©u ph·∫£i kh·ªõp v·ªõi m·∫≠t kh·∫©u',
    'string.empty': 'X√°c nh·∫≠n m·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'X√°c nh·∫≠n m·∫≠t kh·∫©u l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),

  phone: Joi.string()
    .pattern(/^(0|\+84)[3|5|7|8|9][0-9]{8}$/)
    .allow('', null)
    .messages({
      'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá',
    }),
});

// Schema ƒëƒÉng nh·∫≠p
const loginSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'Email l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
    }),

  password: Joi.string().required().messages({
    'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'M·∫≠t kh·∫©u l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),

  rememberMe: Joi.boolean().default(false),
});

// Schema refresh token
const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().required().messages({
    'string.empty': 'Refresh token kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Refresh token l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),
});

// Schema qu√™n m·∫≠t kh·∫©u
const forgotPasswordSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'Email l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
    }),
});

// Schema ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
const resetPasswordSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Token l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.pattern.base': 'M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t m·ªôt ch·ªØ hoa, m·ªôt ch·ªØ th∆∞·ªùng v√† m·ªôt ch·ªØ s·ªë',
      'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'M·∫≠t kh·∫©u l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'X√°c nh·∫≠n m·∫≠t kh·∫©u ph·∫£i kh·ªõp v·ªõi m·∫≠t kh·∫©u',
    'string.empty': 'X√°c nh·∫≠n m·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'X√°c nh·∫≠n m·∫≠t kh·∫©u l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),
});

// Schema x√°c th·ª±c email
const verifyEmailSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Token l√† tr∆∞·ªùng b·∫Øt bu·ªôc',
  }),
});

module.exports = {
  register: registerSchema,
  login: loginSchema,
  refreshToken: refreshTokenSchema,
  forgotPassword: forgotPasswordSchema,
  resetPassword: resetPasswordSchema,
  verifyEmail: verifyEmailSchema,
};


--- File: server/src/common/validators/cartValidator.js ---
// server/src/common/validators/cartValidator.js

const Joi = require('joi');

const createCartValidator = Joi.object({
  user: Joi.string().allow(null).messages({
    'string.base': 'User ID ph·∫£i l√† m·ªôt chu·ªói',
  }),

  sessionId: Joi.string().allow(null).messages({
    'string.base': 'Session ID ph·∫£i l√† m·ªôt chu·ªói',
  }),

  items: Joi.array()
    .items(
      Joi.object({
        product: Joi.string().required().messages({
          'string.base': 'Product ID ph·∫£i l√† m·ªôt chu·ªói',
          'string.empty': 'Product ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
          'any.required': 'Product ID l√† b·∫Øt bu·ªôc',
        }),
        quantity: Joi.number().integer().min(1).required().messages({
          'number.base': 'S·ªë l∆∞·ª£ng ph·∫£i l√† m·ªôt s·ªë',
          'number.integer': 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë nguy√™n',
          'number.min': 'S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0',
          'any.required': 'S·ªë l∆∞·ª£ng l√† b·∫Øt bu·ªôc',
        }),
        attributes: Joi.object().allow(null).default({}),
      })
    )
    .default([]),
})
  .or('user', 'sessionId')
  .messages({
    'object.missing': 'Ph·∫£i c√≥ √≠t nh·∫•t m·ªôt trong hai tr∆∞·ªùng user ho·∫∑c sessionId',
  });

const addItemValidator = Joi.object({
  product: Joi.string().required().messages({
    'string.base': 'Product ID ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Product ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Product ID l√† b·∫Øt bu·ªôc',
  }),
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'S·ªë l∆∞·ª£ng ph·∫£i l√† m·ªôt s·ªë',
    'number.integer': 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë nguy√™n',
    'number.min': 'S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0',
    'any.required': 'S·ªë l∆∞·ª£ng l√† b·∫Øt bu·ªôc',
  }),
  attributes: Joi.object().allow(null).default({}),
});

const updateItemValidator = Joi.object({
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'S·ªë l∆∞·ª£ng ph·∫£i l√† m·ªôt s·ªë',
    'number.integer': 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë nguy√™n',
    'number.min': 'S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0',
    'any.required': 'S·ªë l∆∞·ª£ng l√† b·∫Øt bu·ªôc',
  }),
});

const applyCouponValidator = Joi.object({
  code: Joi.string().required().messages({
    'string.base': 'M√£ gi·∫£m gi√° ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'M√£ gi·∫£m gi√° kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'M√£ gi·∫£m gi√° l√† b·∫Øt bu·ªôc',
  }),
});

const shippingAddressValidator = Joi.object({
  name: Joi.string().required().messages({
    'string.base': 'T√™n ng∆∞·ªùi nh·∫≠n ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'T√™n ng∆∞·ªùi nh·∫≠n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'T√™n ng∆∞·ªùi nh·∫≠n l√† b·∫Øt bu·ªôc',
  }),
  phone: Joi.string()
    .required()
    .pattern(/^(0|\+84)([0-9]{9,10})$/)
    .messages({
      'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá (ph·∫£i l√† s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam)',
      'any.required': 'S·ªë ƒëi·ªán tho·∫°i l√† b·∫Øt bu·ªôc',
    }),
  street: Joi.string().required().messages({
    'string.base': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë l√† b·∫Øt bu·ªôc',
  }),
  city: Joi.string().required().messages({
    'string.base': 'Th√†nh ph·ªë ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Th√†nh ph·ªë kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Th√†nh ph·ªë l√† b·∫Øt bu·ªôc',
  }),
  state: Joi.string().allow('', null).messages({
    'string.base': 'T·ªânh/Bang ph·∫£i l√† m·ªôt chu·ªói',
  }),
  zipCode: Joi.string().required().messages({
    'string.base': 'M√£ b∆∞u ƒëi·ªán ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'M√£ b∆∞u ƒëi·ªán kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'M√£ b∆∞u ƒëi·ªán l√† b·∫Øt bu·ªôc',
  }),
  country: Joi.string().required().messages({
    'string.base': 'Qu·ªëc gia ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Qu·ªëc gia kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Qu·ªëc gia l√† b·∫Øt bu·ªôc',
  }),
  notes: Joi.string().allow('', null).messages({
    'string.base': 'Ghi ch√∫ ph·∫£i l√† m·ªôt chu·ªói',
  }),
});

const shippingMethodValidator = Joi.object({
  type: Joi.string().valid('standard', 'express').required().messages({
    'string.base': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.only': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn ph·∫£i l√† m·ªôt trong c√°c gi√° tr·ªã: standard, express',
    'any.required': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn l√† b·∫Øt bu·ªôc',
  }),
});

const checkoutValidator = Joi.object({
  cartId: Joi.string().required().messages({
    'string.base': 'Cart ID ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Cart ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Cart ID l√† b·∫Øt bu·ªôc',
  }),
  shippingAddress: shippingAddressValidator.required().messages({
    'any.required': 'ƒê·ªãa ch·ªâ giao h√†ng l√† b·∫Øt bu·ªôc',
  }),
  shippingMethod: shippingMethodValidator.required().messages({
    'any.required': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn l√† b·∫Øt bu·ªôc',
  }),
  paymentMethod: Joi.string()
    .valid('cod', 'bank_transfer', 'vnpay', 'credit_card')
    .required()
    .messages({
      'string.base': 'Ph∆∞∆°ng th·ª©c thanh to√°n ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.only':
        'Ph∆∞∆°ng th·ª©c thanh to√°n ph·∫£i l√† m·ªôt trong c√°c gi√° tr·ªã: cod, bank_transfer, vnpay, credit_card',
      'any.required': 'Ph∆∞∆°ng th·ª©c thanh to√°n l√† b·∫Øt bu·ªôc',
    }),
  customerNotes: Joi.string().allow('', null).max(500).messages({
    'string.base': 'Ghi ch√∫ ph·∫£i l√† m·ªôt chu·ªói',
    'string.max': 'Ghi ch√∫ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
  }),
});

const mergeCartsValidator = Joi.object({
  sourceCartId: Joi.string().required().messages({
    'string.base': 'Source Cart ID ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Source Cart ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Source Cart ID l√† b·∫Øt bu·ªôc',
  }),
  destinationCartId: Joi.string().required().messages({
    'string.base': 'Destination Cart ID ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Destination Cart ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Destination Cart ID l√† b·∫Øt bu·ªôc',
  }),
});

module.exports = {
  createCartValidator,
  addItemValidator,
  updateItemValidator,
  applyCouponValidator,
  shippingAddressValidator,
  shippingMethodValidator,
  checkoutValidator,
  mergeCartsValidator,
};


--- File: server/src/common/validators/categoryValidator.js ---
/**
 * Category Validator
 * ƒê·ªãnh nghƒ©a c√°c validation rules cho category API
 */

const Joi = require('joi');

const categoryValidator = {
  /**
   * Validate khi t·∫°o danh m·ª•c m·ªõi
   */
  createCategory: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'T√™n danh m·ª•c ph·∫£i l√† chu·ªói',
      'string.empty': 'T√™n danh m·ª•c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'T√™n danh m·ª•c ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n danh m·ª•c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'T√™n danh m·ª•c l√† b·∫Øt bu·ªôc',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug ph·∫£i l√† chu·ªói',
      'string.empty': 'Slug kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'Slug ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'Slug kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'M√¥ t·∫£ ph·∫£i l√† chu·ªói',
      'string.max': 'M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh m·ª•c cha ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'ID danh m·ª•c cha kh√¥ng h·ª£p l·ªá',
      }),

    image: Joi.object({
      url: Joi.string().uri().required().messages({
        'string.base': 'URL h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
        'string.empty': 'URL h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.uri': 'URL h√¨nh ·∫£nh kh√¥ng h·ª£p l·ªá',
        'any.required': 'URL h√¨nh ·∫£nh l√† b·∫Øt bu·ªôc',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text ph·∫£i l√† chu·ªói',
        'string.max': 'Alt text kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon ph·∫£i l√† chu·ªói',
      'string.max': 'Icon kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'M√£ m√†u ph·∫£i l√† chu·ªói',
      'string.max': 'M√£ m√†u kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Th·ª© t·ª± ph·∫£i l√† s·ªë',
      'number.integer': 'Th·ª© t·ª± ph·∫£i l√† s·ªë nguy√™n',
      'number.min': 'Th·ª© t·ª± kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive ph·∫£i l√† boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible ph·∫£i l√† boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured ph·∫£i l√† boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),

  /**
   * Validate khi c·∫≠p nh·∫≠t danh m·ª•c
   */
  updateCategory: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'T√™n danh m·ª•c ph·∫£i l√† chu·ªói',
      'string.empty': 'T√™n danh m·ª•c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'T√™n danh m·ª•c ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n danh m·ª•c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug ph·∫£i l√† chu·ªói',
      'string.empty': 'Slug kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'Slug ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'Slug kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'M√¥ t·∫£ ph·∫£i l√† chu·ªói',
      'string.max': 'M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh m·ª•c cha ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'ID danh m·ª•c cha kh√¥ng h·ª£p l·ªá',
      }),

    image: Joi.object({
      url: Joi.string().uri().messages({
        'string.base': 'URL h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
        'string.empty': 'URL h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.uri': 'URL h√¨nh ·∫£nh kh√¥ng h·ª£p l·ªá',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text ph·∫£i l√† chu·ªói',
        'string.max': 'Alt text kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon ph·∫£i l√† chu·ªói',
      'string.max': 'Icon kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'M√£ m√†u ph·∫£i l√† chu·ªói',
      'string.max': 'M√£ m√†u kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Th·ª© t·ª± ph·∫£i l√† s·ªë',
      'number.integer': 'Th·ª© t·ª± ph·∫£i l√† s·ªë nguy√™n',
      'number.min': 'Th·ª© t·ª± kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive ph·∫£i l√† boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible ph·∫£i l√† boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured ph·∫£i l√† boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),
};

module.exports = { categoryValidator };


--- File: server/src/common/validators/orderValidator.js ---
/**
 * Order Validator
 * ƒê·ªãnh nghƒ©a c√°c validation rules cho order API
 */

const Joi = require('joi');

const orderValidator = {
  /**
   * Validate khi t·∫°o ƒë∆°n h√†ng m·ªõi
   */
  createOrder: Joi.object({
    // Th√¥ng tin li√™n h·ªá
    customerInfo: Joi.object({
      name: Joi.string().min(2).max(100).required().messages({
        'string.base': 'T√™n kh√°ch h√†ng ph·∫£i l√† chu·ªói',
        'string.empty': 'T√™n kh√°ch h√†ng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.min': 'T√™n kh√°ch h√†ng ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
        'string.max': 'T√™n kh√°ch h√†ng kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'any.required': 'T√™n kh√°ch h√†ng l√† b·∫Øt bu·ªôc',
      }),
      email: Joi.string().email().required().messages({
        'string.base': 'Email ph·∫£i l√† chu·ªói',
        'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.email': 'Email kh√¥ng h·ª£p l·ªá',
        'any.required': 'Email l√† b·∫Øt bu·ªôc',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .required()
        .messages({
          'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† chu·ªói',
          'string.empty': 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
          'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-11 ch·ªØ s·ªë',
          'any.required': 'S·ªë ƒëi·ªán tho·∫°i l√† b·∫Øt bu·ªôc',
        }),
    })
      .required()
      .messages({
        'object.base': 'Th√¥ng tin kh√°ch h√†ng ph·∫£i l√† ƒë·ªëi t∆∞·ª£ng',
        'any.required': 'Th√¥ng tin kh√°ch h√†ng l√† b·∫Øt bu·ªôc',
      }),

    // Th√¥ng tin v·∫≠n chuy·ªÉn
    shippingAddress: Joi.object({
      name: Joi.string().min(2).max(100).messages({
        'string.base': 'T√™n ng∆∞·ªùi nh·∫≠n ph·∫£i l√† chu·ªói',
        'string.min': 'T√™n ng∆∞·ªùi nh·∫≠n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
        'string.max': 'T√™n ng∆∞·ªùi nh·∫≠n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .messages({
          'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† chu·ªói',
          'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-11 ch·ªØ s·ªë',
        }),
      street: Joi.string().required().messages({
        'string.base': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë ph·∫£i l√† chu·ªói',
        'string.empty': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.required': 'ƒê·ªãa ch·ªâ ƒë∆∞·ªùng ph·ªë l√† b·∫Øt bu·ªôc',
      }),
      city: Joi.string().required().messages({
        'string.base': 'Th√†nh ph·ªë ph·∫£i l√† chu·ªói',
        'string.empty': 'Th√†nh ph·ªë kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.required': 'Th√†nh ph·ªë l√† b·∫Øt bu·ªôc',
      }),
      state: Joi.string().allow('').messages({
        'string.base': 'T·ªânh/Bang ph·∫£i l√† chu·ªói',
      }),
      zipCode: Joi.string().required().messages({
        'string.base': 'M√£ b∆∞u ƒëi·ªán ph·∫£i l√† chu·ªói',
        'string.empty': 'M√£ b∆∞u ƒëi·ªán kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.required': 'M√£ b∆∞u ƒëi·ªán l√† b·∫Øt bu·ªôc',
      }),
      country: Joi.string().required().messages({
        'string.base': 'Qu·ªëc gia ph·∫£i l√† chu·ªói',
        'string.empty': 'Qu·ªëc gia kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.required': 'Qu·ªëc gia l√† b·∫Øt bu·ªôc',
      }),
      notes: Joi.string().max(500).messages({
        'string.base': 'Ghi ch√∫ ph·∫£i l√† chu·ªói',
        'string.max': 'Ghi ch√∫ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      }),
    })
      .required()
      .messages({
        'object.base': 'ƒê·ªãa ch·ªâ giao h√†ng ph·∫£i l√† ƒë·ªëi t∆∞·ª£ng',
        'any.required': 'ƒê·ªãa ch·ªâ giao h√†ng l√† b·∫Øt bu·ªôc',
      }),

    // Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn v√† thanh to√°n
    shippingMethod: Joi.string().valid('standard', 'express').required().messages({
      'string.base': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn ph·∫£i l√† chu·ªói',
      'string.empty': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.only': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn kh√¥ng h·ª£p l·ªá',
      'any.required': 'Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn l√† b·∫Øt bu·ªôc',
    }),

    paymentMethod: Joi.string().valid('cod', 'credit_card', 'paypal', 'vnpay').required().messages({
      'string.base': 'Ph∆∞∆°ng th·ª©c thanh to√°n ph·∫£i l√† chu·ªói',
      'string.empty': 'Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.only': 'Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ª£p l·ªá',
      'any.required': 'Ph∆∞∆°ng th·ª©c thanh to√°n l√† b·∫Øt bu·ªôc',
    }),

    // Ghi ch√∫ ƒë∆°n h√†ng
    customerNotes: Joi.string().max(500).messages({
      'string.base': 'Ghi ch√∫ ph·∫£i l√† chu·ªói',
      'string.max': 'Ghi ch√∫ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    // M√£ gi·∫£m gi√°
    couponCode: Joi.string().max(50).messages({
      'string.base': 'M√£ gi·∫£m gi√° ph·∫£i l√† chu·ªói',
      'string.max': 'M√£ gi·∫£m gi√° kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    // ID gi·ªè h√†ng (n·∫øu t·∫°o ƒë∆°n h√†ng t·ª´ gi·ªè h√†ng)
    cartId: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID gi·ªè h√†ng ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'ID gi·ªè h√†ng kh√¥ng h·ª£p l·ªá',
      }),

    // C√°c m·∫∑t h√†ng trong ƒë∆°n h√†ng (b·∫Øt bu·ªôc n·∫øu kh√¥ng c√≥ cartId)
    items: Joi.when('cartId', {
      is: Joi.exist(),
      then: Joi.array(),
      otherwise: Joi.array()
        .items(
          Joi.object({
            product: Joi.string()
              .regex(/^[0-9a-fA-F]{24}$/)
              .required()
              .messages({
                'string.base': 'ID s·∫£n ph·∫©m ph·∫£i l√† chu·ªói',
                'string.pattern.base': 'ID s·∫£n ph·∫©m kh√¥ng h·ª£p l·ªá',
                'any.required': 'ID s·∫£n ph·∫©m l√† b·∫Øt bu·ªôc',
              }),
            quantity: Joi.number().integer().min(1).required().messages({
              'number.base': 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë',
              'number.integer': 'S·ªë l∆∞·ª£ng ph·∫£i l√† s·ªë nguy√™n',
              'number.min': 'S·ªë l∆∞·ª£ng ph·∫£i √≠t nh·∫•t l√† {#limit}',
              'any.required': 'S·ªë l∆∞·ª£ng l√† b·∫Øt bu·ªôc',
            }),
            attributes: Joi.object().default({}),
          })
        )
        .min(1)
        .required()
        .messages({
          'array.base': 'C√°c m·∫∑t h√†ng ph·∫£i l√† m·∫£ng',
          'array.min': 'Ph·∫£i c√≥ √≠t nh·∫•t m·ªôt m·∫∑t h√†ng',
          'any.required': 'C√°c m·∫∑t h√†ng l√† b·∫Øt bu·ªôc',
        }),
    }),
  }),

  /**
   * Validate khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
   */
  updateOrderStatus: Joi.object({
    status: Joi.string()
      .valid('pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned')
      .required()
      .messages({
        'string.base': 'Tr·∫°ng th√°i ph·∫£i l√† chu·ªói',
        'string.empty': 'Tr·∫°ng th√°i kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.only': 'Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá',
        'any.required': 'Tr·∫°ng th√°i l√† b·∫Øt bu·ªôc',
      }),

    note: Joi.string().max(500).messages({
      'string.base': 'Ghi ch√∫ ph·∫£i l√† chu·ªói',
      'string.max': 'Ghi ch√∫ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),
  }),

  /**
   * Validate khi h·ªßy ƒë∆°n h√†ng
   */
  cancelOrder: Joi.object({
    reason: Joi.string().max(500).required().messages({
      'string.base': 'L√Ω do h·ªßy ph·∫£i l√† chu·ªói',
      'string.empty': 'L√Ω do h·ªßy kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'L√Ω do h·ªßy kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'L√Ω do h·ªßy l√† b·∫Øt bu·ªôc',
    }),
  }),
};
module.exports = orderValidator;
//     'any.required': 'Vai tr√≤ l√† b·∫Øt bu·ªôc'


--- File: server/src/common/validators/productValidator.js ---
// server/src/common/validators/productValidator.js

const Joi = require('joi');

// const priceRegex = /^\d+(\.\d{1,2})?$/; // ƒê·ªãnh d·∫°ng gi√° (s·ªë nguy√™n ho·∫∑c t·ªëi ƒëa 2 ch·ªØ s·ªë th·∫≠p ph√¢n)
const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/; // ƒê·ªãnh d·∫°ng slug

const createProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).required().messages({
    'string.base': 'T√™n s·∫£n ph·∫©m ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'string.min': 'T√™n s·∫£n ph·∫©m ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
    'string.max': 'T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    'any.required': 'T√™n s·∫£n ph·∫©m l√† b·∫Øt bu·ªôc',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).required().messages({
    'string.base': 'Slug ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Slug kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'string.min': 'Slug ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
    'string.max': 'Slug kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    'string.pattern.base': 'Slug ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ c√°i th∆∞·ªùng, s·ªë v√† d·∫•u g·∫°ch ngang',
    'any.required': 'Slug l√† b·∫Øt bu·ªôc',
  }),

  description: Joi.object({
    short: Joi.string().max(200).required().messages({
      'string.base': 'M√¥ t·∫£ ng·∫Øn ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'M√¥ t·∫£ ng·∫Øn l√† b·∫Øt bu·ªôc',
    }),
    long: Joi.string().max(2000).required().messages({
      'string.base': 'M√¥ t·∫£ chi ti·∫øt ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'M√¥ t·∫£ chi ti·∫øt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'M√¥ t·∫£ chi ti·∫øt kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'M√¥ t·∫£ chi ti·∫øt l√† b·∫Øt bu·ªôc',
    }),
  }).required(),

  category: Joi.string().required().messages({
    'string.base': 'Danh m·ª•c ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Danh m·ª•c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Danh m·ª•c l√† b·∫Øt bu·ªôc',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh m·ª•c ph·ª• ph·∫£i l√† m·ªôt chu·ªói',
  }),

  brand: Joi.string().required().messages({
    'string.base': 'Th∆∞∆°ng hi·ªáu ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Th∆∞∆°ng hi·ªáu kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'any.required': 'Th∆∞∆°ng hi·ªáu l√† b·∫Øt bu·ªôc',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nh√† s·∫£n xu·∫•t ph·∫£i l√† m·ªôt chu·ªói',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Qu·ªëc gia xu·∫•t x·ª© ph·∫£i l√† m·ªôt chu·ªói',
  }),

  price: Joi.number().min(0).required().messages({
    'number.base': 'Gi√° ph·∫£i l√† m·ªôt s·ªë',
    'number.min': 'Gi√° kh√¥ng ƒë∆∞·ª£c √¢m',
    'any.required': 'Gi√° l√† b·∫Øt bu·ªôc',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Gi√° khuy·∫øn m√£i ph·∫£i l√† m·ªôt s·ªë',
    'number.min': 'Gi√° khuy·∫øn m√£i kh√¥ng ƒë∆∞·ª£c √¢m',
  }),

  stock: Joi.number().integer().min(0).required().messages({
    'number.base': 'S·ªë l∆∞·ª£ng t·ªìn kho ph·∫£i l√† m·ªôt s·ªë',
    'number.integer': 'S·ªë l∆∞·ª£ng t·ªìn kho ph·∫£i l√† s·ªë nguy√™n',
    'number.min': 'S·ªë l∆∞·ª£ng t·ªìn kho kh√¥ng ƒë∆∞·ª£c √¢m',
    'any.required': 'S·ªë l∆∞·ª£ng t·ªìn kho l√† b·∫Øt bu·ªôc',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU ph·∫£i l√† m·ªôt chu·ªói',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean().default(false),
      })
    )
    .min(1)
    .required()
    .messages({
      'array.base': 'H√¨nh ·∫£nh ph·∫£i l√† m·ªôt m·∫£ng',
      'array.min': 'Ph·∫£i c√≥ √≠t nh·∫•t {#limit} h√¨nh ·∫£nh',
      'any.required': 'H√¨nh ·∫£nh l√† b·∫Øt bu·ªôc',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'T√≠nh nƒÉng ph·∫£i l√† m·ªôt m·∫£ng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean().default(true),
  isPromoted: Joi.boolean().default(false),
  isFeatured: Joi.boolean().default(false),
});

const updateProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).messages({
    'string.base': 'T√™n s·∫£n ph·∫©m ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'string.min': 'T√™n s·∫£n ph·∫©m ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
    'string.max': 'T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).messages({
    'string.base': 'Slug ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Slug kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
    'string.min': 'Slug ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
    'string.max': 'Slug kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    'string.pattern.base': 'Slug ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ c√°i th∆∞·ªùng, s·ªë v√† d·∫•u g·∫°ch ngang',
  }),

  description: Joi.object({
    short: Joi.string().max(200).messages({
      'string.base': 'M√¥ t·∫£ ng·∫Øn ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),
    long: Joi.string().max(2000).messages({
      'string.base': 'M√¥ t·∫£ chi ti·∫øt ph·∫£i l√† m·ªôt chu·ªói',
      'string.empty': 'M√¥ t·∫£ chi ti·∫øt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'M√¥ t·∫£ chi ti·∫øt kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),
  }),

  category: Joi.string().messages({
    'string.base': 'Danh m·ª•c ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Danh m·ª•c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh m·ª•c ph·ª• ph·∫£i l√† m·ªôt chu·ªói',
  }),

  brand: Joi.string().messages({
    'string.base': 'Th∆∞∆°ng hi·ªáu ph·∫£i l√† m·ªôt chu·ªói',
    'string.empty': 'Th∆∞∆°ng hi·ªáu kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nh√† s·∫£n xu·∫•t ph·∫£i l√† m·ªôt chu·ªói',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Qu·ªëc gia xu·∫•t x·ª© ph·∫£i l√† m·ªôt chu·ªói',
  }),

  price: Joi.number().min(0).messages({
    'number.base': 'Gi√° ph·∫£i l√† m·ªôt s·ªë',
    'number.min': 'Gi√° kh√¥ng ƒë∆∞·ª£c √¢m',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Gi√° khuy·∫øn m√£i ph·∫£i l√† m·ªôt s·ªë',
    'number.min': 'Gi√° khuy·∫øn m√£i kh√¥ng ƒë∆∞·ª£c √¢m',
  }),

  stock: Joi.number().integer().min(0).messages({
    'number.base': 'S·ªë l∆∞·ª£ng t·ªìn kho ph·∫£i l√† m·ªôt s·ªë',
    'number.integer': 'S·ªë l∆∞·ª£ng t·ªìn kho ph·∫£i l√† s·ªë nguy√™n',
    'number.min': 'S·ªë l∆∞·ª£ng t·ªìn kho kh√¥ng ƒë∆∞·ª£c √¢m',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU ph·∫£i l√† m·ªôt chu·ªói',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean(),
      })
    )
    .min(1)
    .messages({
      'array.base': 'H√¨nh ·∫£nh ph·∫£i l√† m·ªôt m·∫£ng',
      'array.min': 'Ph·∫£i c√≥ √≠t nh·∫•t {#limit} h√¨nh ·∫£nh',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'T√≠nh nƒÉng ph·∫£i l√† m·ªôt m·∫£ng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean(),
  isPromoted: Joi.boolean(),
  isFeatured: Joi.boolean(),
});
/**
/**
 * X√°c th·ª±c d·ªØ li·ªáu s·∫£n ph·∫©m v·ªõi nhi·ªÅu t√πy ch·ªçn n√¢ng cao
 * @param {Object} data - D·ªØ li·ªáu s·∫£n ph·∫©m c·∫ßn x√°c th·ª±c
 * @param {Object|Boolean} options - C√°c t√πy ch·ªçn x√°c th·ª±c ho·∫∑c boolean cho isUpdate
 * @property {Boolean} options.isUpdate - C√≥ ph·∫£i ƒëang c·∫≠p nh·∫≠t kh√¥ng (true) hay ƒëang t·∫°o m·ªõi (false)
 * @property {Array<string>} options.fields - Danh s√°ch c√°c tr∆∞·ªùng c·∫ßn x√°c th·ª±c (n·∫øu ch·ªâ mu·ªën x√°c th·ª±c m·ªôt s·ªë tr∆∞·ªùng)
 * @property {Boolean} options.formatErrors - C√≥ ƒë·ªãnh d·∫°ng l·ªói th√†nh d·∫°ng d·ªÖ ƒë·ªçc kh√¥ng
 * @property {Boolean} options.checkBusinessRules - C√≥ ki·ªÉm tra c√°c quy t·∫Øc nghi·ªáp v·ª• kh√¥ng
 * @returns {Object} - K·∫øt qu·∫£ x√°c th·ª±c { error, value, isValid, errorDetails }
 */
const validateProductData = (data, options = {}) => {
  // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p options l√† boolean (t∆∞∆°ng th√≠ch ng∆∞·ª£c)
  let isUpdate = false;
  let fields = null;
  let formatErrors = false;
  let checkBusinessRules = false;

  // Ki·ªÉm tra ki·ªÉu d·ªØ li·ªáu c·ªßa options
  if (typeof options === 'boolean') {
    isUpdate = options;
  } else if (options && typeof options === 'object') {
    // Ch·ªâ l·∫•y c√°c thu·ªôc t√≠nh n·∫øu options l√† object
    isUpdate = options.isUpdate === true;
    fields = Array.isArray(options.fields) ? options.fields : null;
    formatErrors = options.formatErrors === true;
    checkBusinessRules = options.checkBusinessRules === true;
  }

  // Ch·ªçn schema ph√π h·ª£p
  let schema = isUpdate ? updateProductValidator : createProductValidator;

  // N·∫øu ch·ªâ x√°c th·ª±c m·ªôt s·ªë tr∆∞·ªùng c·ª• th·ªÉ
  if (fields && Array.isArray(fields) && fields.length > 0) {
    const schemaToUse = isUpdate ? updateProductValidator : createProductValidator;
    const filteredSchema = Joi.object(
      fields.reduce((acc, field) => {
        if (
          schemaToUse.$_terms &&
          schemaToUse.$_terms.keys &&
          schemaToUse.$_terms.keys.some((k) => k.key === field)
        ) {
          acc[field] = schemaToUse.$_terms.keys.find((k) => k.key === field).schema;
        }
        return acc;
      }, {})
    );
    schema = filteredSchema;
  }

  // Th·ª±c hi·ªán x√°c th·ª±c c∆° b·∫£n
  const validationResult = schema.validate(data, { abortEarly: false });

  // N·∫øu kh√¥ng c·∫ßn x·ª≠ l√Ω th√™m, tr·∫£ v·ªÅ k·∫øt qu·∫£ ngay
  if (!formatErrors && !checkBusinessRules) {
    return {
      ...validationResult,
      isValid: !validationResult.error,
    };
  }

  // X·ª≠ l√Ω k·∫øt qu·∫£
  let result = {
    value: validationResult.value,
    isValid: !validationResult.error,
    errorDetails: null,
  };

  // ƒê·ªãnh d·∫°ng l·ªói th√†nh d·∫°ng d·ªÖ ƒë·ªçc n·∫øu c·∫ßn
  if (validationResult.error && formatErrors) {
    const errorDetails = {};

    validationResult.error.details.forEach((err) => {
      const field = err.path.join('.');
      if (!errorDetails[field]) {
        errorDetails[field] = [];
      }
      errorDetails[field].push(err.message);
    });

    result.error = validationResult.error;
    result.errorDetails = errorDetails;
  } else {
    result.error = validationResult.error;
  }

  // Ki·ªÉm tra c√°c quy t·∫Øc nghi·ªáp v·ª• n·∫øu c·∫ßn
  if (checkBusinessRules && !result.error) {
    const businessErrors = validateBusinessRules(data, isUpdate);

    if (businessErrors.length > 0) {
      result.isValid = false;
      result.businessErrors = businessErrors;

      if (formatErrors) {
        const errorDetails = result.errorDetails || {};

        businessErrors.forEach((err) => {
          const field = err.field;
          if (!errorDetails[field]) {
            errorDetails[field] = [];
          }
          errorDetails[field].push(err.message);
        });

        result.errorDetails = errorDetails;
      }
    }
  }

  return result;
};
/**
 * Ki·ªÉm tra c√°c quy t·∫Øc nghi·ªáp v·ª• ph·ª©c t·∫°p kh√¥ng th·ªÉ x√°c th·ª±c b·∫±ng Joi
 * @param {Object} data - D·ªØ li·ªáu s·∫£n ph·∫©m
 * @param {Boolean} isUpdate - C√≥ ph·∫£i ƒëang c·∫≠p nh·∫≠t kh√¥ng
 * @returns {Array} - Danh s√°ch l·ªói nghi·ªáp v·ª•
 */
function validateBusinessRules(data, isUpdate) {
  const errors = [];

  // Ki·ªÉm tra gi√° khuy·∫øn m√£i ph·∫£i nh·ªè h∆°n gi√° g·ªëc
  if (data.price && data.salePrice && data.salePrice >= data.price) {
    errors.push({
      field: 'salePrice',
      message: 'Gi√° khuy·∫øn m√£i ph·∫£i nh·ªè h∆°n gi√° g·ªëc',
    });
  }

  // Ki·ªÉm tra n·∫øu c√≥ discount th√¨ ph·∫£i c√≥ c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
  if (data.discount && data.discount.percentage) {
    if (!data.discount.startDate) {
      errors.push({
        field: 'discount.startDate',
        message: 'Ng√†y b·∫Øt ƒë·∫ßu khuy·∫øn m√£i l√† b·∫Øt bu·ªôc khi c√≥ ph·∫ßn trƒÉm gi·∫£m gi√°',
      });
    }

    if (!data.discount.endDate) {
      errors.push({
        field: 'discount.endDate',
        message: 'Ng√†y k·∫øt th√∫c khuy·∫øn m√£i l√† b·∫Øt bu·ªôc khi c√≥ ph·∫ßn trƒÉm gi·∫£m gi√°',
      });
    }
  }

  // Ki·ªÉm tra √≠t nh·∫•t m·ªôt h√¨nh ·∫£nh ph·∫£i l√† h√¨nh ch√≠nh
  if (data.images && data.images.length > 0) {
    const hasPrimaryImage = data.images.some((img) => img.isPrimary);
    if (!hasPrimaryImage) {
      errors.push({
        field: 'images',
        message: 'Ph·∫£i c√≥ √≠t nh·∫•t m·ªôt h√¨nh ·∫£nh ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† h√¨nh ch√≠nh (isPrimary)',
      });
    }
  }

  return errors;
}
module.exports = {
  createProductValidator,
  updateProductValidator,
  validateProductData,
};


--- File: server/src/common/validators/reviewValidator.js ---
/**
 * Review Validator
 * ƒê·ªãnh nghƒ©a c√°c validation rules cho review API
 */

const Joi = require('joi');

const reviewValidator = {
  /**
   * Validate khi t·∫°o ƒë√°nh gi√° m·ªõi
   */
  createReview: Joi.object({
    rating: Joi.number().min(1).max(5).required().messages({
      'number.base': 'ƒê√°nh gi√° sao ph·∫£i l√† s·ªë',
      'number.min': 'ƒê√°nh gi√° sao kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n {#limit}',
      'number.max': 'ƒê√°nh gi√° sao kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n {#limit}',
      'any.required': 'ƒê√°nh gi√° sao l√† b·∫Øt bu·ªôc',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Ti√™u ƒë·ªÅ ph·∫£i l√† chu·ªói',
      'string.max': 'Ti√™u ƒë·ªÅ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    review: Joi.string().max(2000).required().messages({
      'string.base': 'N·ªôi dung ƒë√°nh gi√° ph·∫£i l√† chu·ªói',
      'string.empty': 'N·ªôi dung ƒë√°nh gi√° kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.max': 'N·ªôi dung ƒë√°nh gi√° kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'N·ªôi dung ƒë√°nh gi√° l√† b·∫Øt bu·ªôc',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
            'string.empty': 'URL h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
            'string.uri': 'URL h√¨nh ·∫£nh kh√¥ng h·ª£p l·ªá',
            'any.required': 'URL h√¨nh ·∫£nh l√† b·∫Øt bu·ªôc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail ph·∫£i l√† chu·ªói',
            'string.uri': 'URL thumbnail kh√¥ng h·ª£p l·ªá',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Ch√∫ th√≠ch h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
            'string.max': 'Ch√∫ th√≠ch h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'H√¨nh ·∫£nh ph·∫£i l√† m·∫£ng',
        'array.max': 'Kh√¥ng ƒë∆∞·ª£c ƒëƒÉng t·∫£i qu√° {#limit} h√¨nh ·∫£nh',
      }),

    order: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID ƒë∆°n h√†ng ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'ID ƒë∆°n h√†ng kh√¥ng h·ª£p l·ªá',
      }),
  }),

  /**
   * Validate khi c·∫≠p nh·∫≠t ƒë√°nh gi√°
   */
  updateReview: Joi.object({
    rating: Joi.number().min(1).max(5).messages({
      'number.base': 'ƒê√°nh gi√° sao ph·∫£i l√† s·ªë',
      'number.min': 'ƒê√°nh gi√° sao kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n {#limit}',
      'number.max': 'ƒê√°nh gi√° sao kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n {#limit}',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Ti√™u ƒë·ªÅ ph·∫£i l√† chu·ªói',
      'string.max': 'Ti√™u ƒë·ªÅ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    review: Joi.string().max(2000).messages({
      'string.base': 'N·ªôi dung ƒë√°nh gi√° ph·∫£i l√† chu·ªói',
      'string.max': 'N·ªôi dung ƒë√°nh gi√° kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
            'string.empty': 'URL h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
            'string.uri': 'URL h√¨nh ·∫£nh kh√¥ng h·ª£p l·ªá',
            'any.required': 'URL h√¨nh ·∫£nh l√† b·∫Øt bu·ªôc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail ph·∫£i l√† chu·ªói',
            'string.uri': 'URL thumbnail kh√¥ng h·ª£p l·ªá',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Ch√∫ th√≠ch h√¨nh ·∫£nh ph·∫£i l√† chu·ªói',
            'string.max': 'Ch√∫ th√≠ch h√¨nh ·∫£nh kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'H√¨nh ·∫£nh ph·∫£i l√† m·∫£ng',
        'array.max': 'Kh√¥ng ƒë∆∞·ª£c ƒëƒÉng t·∫£i qu√° {#limit} h√¨nh ·∫£nh',
      }),
  }),

  /**
   * Validate khi upvote/downvote ƒë√°nh gi√°
   */
  voteReview: Joi.object({
    vote: Joi.number().valid(1, -1).required().messages({
      'number.base': 'Vote ph·∫£i l√† s·ªë',
      'any.only': 'Vote ch·ªâ c√≥ th·ªÉ l√† 1 (upvote) ho·∫∑c -1 (downvote)',
      'any.required': 'Vote l√† b·∫Øt bu·ªôc',
    }),
  }),

  /**
   * Validate khi b√°o c√°o ƒë√°nh gi√°
   */
  reportReview: Joi.object({
    reason: Joi.string()
      .valid('spam', 'offensive', 'inappropriate', 'misleading', 'other')
      .required()
      .messages({
        'string.base': 'L√Ω do ph·∫£i l√† chu·ªói',
        'string.empty': 'L√Ω do kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'any.only': 'L√Ω do kh√¥ng h·ª£p l·ªá',
        'any.required': 'L√Ω do l√† b·∫Øt bu·ªôc',
      }),

    description: Joi.string()
      .max(500)
      .when('reason', {
        is: 'other',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'M√¥ t·∫£ ph·∫£i l√† chu·ªói',
        'string.empty': 'M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.max': 'M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'any.required': 'M√¥ t·∫£ l√† b·∫Øt bu·ªôc khi l√Ω do l√† "other"',
      }),
  }),

  /**
   * Validate khi ki·ªÉm duy·ªát ƒë√°nh gi√°
   */
  moderateReview: Joi.object({
    action: Joi.string().valid('approve', 'reject').required().messages({
      'string.base': 'H√†nh ƒë·ªông ph·∫£i l√† chu·ªói',
      'string.empty': 'H√†nh ƒë·ªông kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.only': 'H√†nh ƒë·ªông ph·∫£i l√† "approve" ho·∫∑c "reject"',
      'any.required': 'H√†nh ƒë·ªông l√† b·∫Øt bu·ªôc',
    }),

    reason: Joi.string()
      .max(500)
      .when('action', {
        is: 'reject',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'L√Ω do ph·∫£i l√† chu·ªói',
        'string.empty': 'L√Ω do kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.max': 'L√Ω do kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'any.required': 'L√Ω do l√† b·∫Øt bu·ªôc khi t·ª´ ch·ªëi ƒë√°nh gi√°',
      }),
  }),

  /**
   * Validate khi th√™m ph·∫£n h·ªìi cho ƒë√°nh gi√°
   */
  addReviewResponse: Joi.object({
    content: Joi.string().min(2).max(1000).required().messages({
      'string.base': 'N·ªôi dung ph·∫£n h·ªìi ph·∫£i l√† chu·ªói',
      'string.empty': 'N·ªôi dung ph·∫£n h·ªìi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'N·ªôi dung ph·∫£n h·ªìi ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'N·ªôi dung ph·∫£n h·ªìi kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'N·ªôi dung ph·∫£n h·ªìi l√† b·∫Øt bu·ªôc',
    }),
  }),
};

module.exports = { reviewValidator };


--- File: server/src/common/validators/userValidator.js ---
/**
 * User Validator
 * ƒê·ªãnh nghƒ©a c√°c validation rules cho user API
 */

const Joi = require('joi');

const userValidator = {
  /**
   * Validate khi ƒëƒÉng k√Ω ng∆∞·ªùi d√πng m·ªõi
   */
  register: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'T√™n ph·∫£i l√† chu·ªói',
      'string.empty': 'T√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'T√™n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'T√™n l√† b·∫Øt bu·ªôc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email ph·∫£i l√† chu·ªói',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'any.required': 'Email l√† b·∫Øt bu·ªôc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'M·∫≠t kh·∫©u ph·∫£i l√† chu·ªói',
        'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.min': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
        'string.max': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'string.pattern.base':
          'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t m·ªôt ch·ªØ th∆∞·ªùng, m·ªôt ch·ªØ hoa, m·ªôt s·ªë v√† m·ªôt k√Ω t·ª± ƒë·∫∑c bi·ªát',
        'any.required': 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'X√°c nh·∫≠n m·∫≠t kh·∫©u ph·∫£i kh·ªõp v·ªõi m·∫≠t kh·∫©u',
      'any.required': 'X√°c nh·∫≠n m·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-11 ch·ªØ s·ªë',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar ph·∫£i l√† chu·ªói',
      'string.uri': 'Avatar ph·∫£i l√† m·ªôt URL h·ª£p l·ªá',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en').default('vi'),
      notifications: Joi.object({
        email: Joi.boolean().default(true),
        marketing: Joi.boolean().default(true),
      }).default({
        email: true,
        marketing: true,
      }),
    })
      .optional()
      .default({
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      }),
  }),

  /**
   * Validate khi ƒëƒÉng nh·∫≠p
   */
  login: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email ph·∫£i l√† chu·ªói',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'any.required': 'Email l√† b·∫Øt bu·ªôc',
    }),

    password: Joi.string().required().messages({
      'string.base': 'M·∫≠t kh·∫©u ph·∫£i l√† chu·ªói',
      'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
    }),

    rememberMe: Joi.boolean().default(false),
  }),

  /**
   * Validate khi y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
   */
  forgotPassword: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email ph·∫£i l√† chu·ªói',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'any.required': 'Email l√† b·∫Øt bu·ªôc',
    }),
  }),

  /**
   * Validate khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
   */
  resetPassword: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token ph·∫£i l√† chu·ªói',
      'string.empty': 'Token kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'Token l√† b·∫Øt bu·ªôc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'M·∫≠t kh·∫©u ph·∫£i l√† chu·ªói',
        'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.min': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
        'string.max': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'string.pattern.base':
          'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t m·ªôt ch·ªØ th∆∞·ªùng, m·ªôt ch·ªØ hoa, m·ªôt s·ªë v√† m·ªôt k√Ω t·ª± ƒë·∫∑c bi·ªát',
        'any.required': 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'X√°c nh·∫≠n m·∫≠t kh·∫©u ph·∫£i kh·ªõp v·ªõi m·∫≠t kh·∫©u',
      'any.required': 'X√°c nh·∫≠n m·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
    }),
  }),

  /**
   * Validate khi c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
   */
  updateProfile: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'T√™n ph·∫£i l√† chu·ªói',
      'string.min': 'T√™n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-11 ch·ªØ s·ªë',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar ph·∫£i l√† chu·ªói',
      'string.uri': 'Avatar ph·∫£i l√† m·ªôt URL h·ª£p l·ªá',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en'),
      notifications: Joi.object({
        email: Joi.boolean(),
        marketing: Joi.boolean(),
      }),
    }).optional(),
  }),

  /**
   * Validate khi thay ƒë·ªïi m·∫≠t kh·∫©u
   */
  changePassword: Joi.object({
    currentPassword: Joi.string().required().messages({
      'string.base': 'M·∫≠t kh·∫©u hi·ªán t·∫°i ph·∫£i l√† chu·ªói',
      'string.empty': 'M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'M·∫≠t kh·∫©u hi·ªán t·∫°i l√† b·∫Øt bu·ªôc',
    }),

    newPassword: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'M·∫≠t kh·∫©u m·ªõi ph·∫£i l√† chu·ªói',
        'string.empty': 'M·∫≠t kh·∫©u m·ªõi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
        'string.min': 'M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
        'string.max': 'M·∫≠t kh·∫©u m·ªõi kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
        'string.pattern.base':
          'M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t m·ªôt ch·ªØ th∆∞·ªùng, m·ªôt ch·ªØ hoa, m·ªôt s·ªë v√† m·ªôt k√Ω t·ª± ƒë·∫∑c bi·ªát',
        'any.required': 'M·∫≠t kh·∫©u m·ªõi l√† b·∫Øt bu·ªôc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('newPassword')).required().messages({
      'any.only': 'X√°c nh·∫≠n m·∫≠t kh·∫©u ph·∫£i kh·ªõp v·ªõi m·∫≠t kh·∫©u m·ªõi',
      'any.required': 'X√°c nh·∫≠n m·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
    }),
  }),

  /**
   * Validate khi x√°c th·ª±c email
   */
  verifyEmail: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token ph·∫£i l√† chu·ªói',
      'string.empty': 'Token kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'any.required': 'Token l√† b·∫Øt bu·ªôc',
    }),
  }),

  /**
   * Validate khi admin c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng
   */
  adminUpdateUser: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'T√™n ph·∫£i l√† chu·ªói',
      'string.min': 'T√™n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
    }),

    email: Joi.string().email().messages({
      'string.base': 'Email ph·∫£i l√† chu·ªói',
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').messages({
      'string.base': 'Vai tr√≤ ph·∫£i l√† chu·ªói',
      'any.only': 'Vai tr√≤ kh√¥ng h·ª£p l·ªá',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'Tr·∫°ng th√°i ho·∫°t ƒë·ªông ph·∫£i l√† boolean',
    }),

    emailVerified: Joi.boolean().messages({
      'boolean.base': 'Tr·∫°ng th√°i x√°c th·ª±c email ph·∫£i l√† boolean',
    }),
  }),

  /**
   * Validate khi t·∫°o ng∆∞·ªùi d√πng m·ªõi (b·ªüi admin)
   */
  adminCreateUser: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'T√™n ph·∫£i l√† chu·ªói',
      'string.empty': 'T√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'T√™n ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'T√™n kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'T√™n l√† b·∫Øt bu·ªôc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email ph·∫£i l√† chu·ªói',
      'string.empty': 'Email kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.email': 'Email kh√¥ng h·ª£p l·ªá',
      'any.required': 'Email l√† b·∫Øt bu·ªôc',
    }),

    password: Joi.string().min(8).max(64).required().messages({
      'string.base': 'M·∫≠t kh·∫©u ph·∫£i l√† chu·ªói',
      'string.empty': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng',
      'string.min': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t {#limit} k√Ω t·ª±',
      'string.max': 'M·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° {#limit} k√Ω t·ª±',
      'any.required': 'M·∫≠t kh·∫©u l√† b·∫Øt bu·ªôc',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').default('user').messages({
      'string.base': 'Vai tr√≤ ph·∫£i l√† chu·ªói',
      'any.only': 'Vai tr√≤ kh√¥ng h·ª£p l·ªá',
    }),

    isActive: Joi.boolean().default(true).messages({
      'boolean.base': 'Tr·∫°ng th√°i ho·∫°t ƒë·ªông ph·∫£i l√† boolean',
    }),

    emailVerified: Joi.boolean().default(false).messages({
      'boolean.base': 'Tr·∫°ng th√°i x√°c th·ª±c email ph·∫£i l√† boolean',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i l√† chu·ªói',
        'string.pattern.base': 'S·ªë ƒëi·ªán tho·∫°i ph·∫£i c√≥ 10-11 ch·ªØ s·ªë',
      }),
  }),
};

module.exports =  userValidator ;


--- File: server/src/config/database.js ---
const mongoose = require('mongoose');
const logger = require('./logger');
const { setupIndexes } = require('./indexes');
// T√πy ch·ªçn k·∫øt n·ªëi Mongoose
const options = {
  autoIndex: process.env.NODE_ENV !== 'production', // T·ª± ƒë·ªông t·∫°o index trong m√¥i tr∆∞·ªùng dev
  serverSelectionTimeoutMS: 5000, // Timeout cho vi·ªác l·ª±a ch·ªçn server
  socketTimeoutMS: 45000, // ƒê√≥ng socket sau 45 gi√¢y kh√¥ng ho·∫°t ƒë·ªông
  family: 4, // S·ª≠ d·ª•ng IPv4, b·ªè qua IPv6
};

// K·∫øt n·ªëi ƒë·∫øn MongoDB
const connectToDatabase = async () => {
  try {
    // X√°c ƒë·ªãnh URI d·ª±a v√†o m√¥i tr∆∞·ªùng
    const uri =
      process.env.NODE_ENV === 'test' ? process.env.MONGODB_URI_TEST : process.env.MONGODB_URI;

    await mongoose.connect(uri, options);

    logger.info('K·∫øt n·ªëi th√†nh c√¥ng ƒë·∫øn MongoDB');
    setupIndexes();
    // X·ª≠ l√Ω s·ª± ki·ªán khi k·∫øt n·ªëi b·ªã ng·∫Øt
    mongoose.connection.on('disconnected', () => {
      logger.warn('M·∫•t k·∫øt n·ªëi MongoDB, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...');
      setTimeout(connectToDatabase, 5000);
    });

    // X·ª≠ l√Ω s·ª± ki·ªán khi c√≥ l·ªói
    mongoose.connection.on('error', (err) => {
      logger.error(`L·ªói k·∫øt n·ªëi MongoDB: ${err.message}`);
    });

    return mongoose.connection;
  } catch (error) {
    logger.error(`Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn MongoDB: ${error.message}`);
    process.exit(1);
  }
};

// Ng·∫Øt k·∫øt n·ªëi t·ª´ MongoDB
const disconnectFromDatabase = async () => {
  try {
    await mongoose.disconnect();
    logger.info('ƒê√£ ng·∫Øt k·∫øt n·ªëi t·ª´ MongoDB');
  } catch (error) {
    logger.error(`L·ªói khi ng·∫Øt k·∫øt n·ªëi t·ª´ MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = {
  connectToDatabase,
  disconnectFromDatabase,
};


--- File: server/src/config/environment.js ---
/**
 * C·∫•u h√¨nh bi·∫øn m√¥i tr∆∞·ªùng
 * @author Steve
 * @project RunOut-Biliard
 */

// Load bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
require('dotenv').config();

// L·∫•y bi·∫øn m√¥i tr∆∞·ªùng ho·∫∑c gi√° tr·ªã m·∫∑c ƒë·ªãnh
const getEnv = (key, defaultValue = undefined) => {
  return process.env[key] || defaultValue;
};

// Bi·∫øn m√¥i tr∆∞·ªùng
const environment = {
  // Th√¥ng tin ·ª©ng d·ª•ng
  app: {
    name: getEnv('APP_NAME', 'RunOut-Biliard'),
    signature: getEnv('SIGNATURE', 'Steve'),
    environment: getEnv('NODE_ENV', 'development'),
    port: parseInt(getEnv('PORT', '5000'), 10),
    host: getEnv('HOST', 'localhost'),
  },

  // C∆° s·ªü d·ªØ li·ªáu
  db: {
    uri: getEnv('MONGODB_URI', 'mongodb://localhost:27017/runout_biliard'),
    uriTest: getEnv('MONGODB_URI_TEST', 'mongodb://localhost:27017/runout_biliard_test'),
  },

  // X√°c th·ª±c
  auth: {
    jwtSecret: getEnv('JWT_SECRET', 'your_jwt_secret_key_here'),
    jwtExpiresIn: getEnv('JWT_EXPIRES_IN', '7d'),
    jwtRefreshSecret: getEnv('JWT_REFRESH_SECRET', 'your_refresh_secret_key_here'),
    jwtRefreshExpiresIn: getEnv('JWT_REFRESH_EXPIRES_IN', '30d'),
  },

  // CORS
  cors: {
    origin: getEnv('CORS_ORIGIN', 'http://localhost:3000'),
    methods: getEnv('CORS_METHODS', 'GET,HEAD,PUT,PATCH,POST,DELETE'),
  },

  // Logging
  logging: {
    level: getEnv('LOG_LEVEL', 'info'),
    colorize: getEnv('NODE_ENV', 'development') === 'development',
  },

  // ƒê∆∞·ªùng d·∫´n tƒ©nh
  paths: {
    uploads: getEnv('UPLOAD_PATH', 'uploads'),
  },

  // Thanh to√°n
  payment: {
    vnpay: {
      tmnCode: getEnv('VNPAY_TMN_CODE', ''),
      secretKey: getEnv('VNPAY_SECRET_KEY', ''),
      returnUrl: getEnv('VNPAY_RETURN_URL', 'http://localhost:5000/api/payments/vnpay-return'),
      ipnUrl: getEnv('VNPAY_IPN_URL', 'http://localhost:5000/api/payments/vnpay-ipn'),
    },
  },

  // Redis
  redis: {
    url: getEnv('REDIS_URL', 'redis://localhost:6379'),
  },
  // Email
  email: {
    host: getEnv('EMAIL_HOST', 'smtp.example.com'),
    port: parseInt(getEnv('EMAIL_PORT', '587'), 10),
    secure: getEnv('EMAIL_SECURE', 'false') === 'true',
    user: getEnv('EMAIL_USER', 'example@example.com'),
    pass: getEnv('EMAIL_PASS', 'password'),
  },
};

// Validate c√°c bi·∫øn m√¥i tr∆∞·ªùng quan tr·ªçng
const validateEnvironment = () => {
  // Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng quan tr·ªçng
  if (environment.app.environment === 'production') {
    if (!process.env.JWT_SECRET) {
      throw new Error('JWT_SECRET kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh cho m√¥i tr∆∞·ªùng production');
    }

    if (!process.env.MONGODB_URI) {
      throw new Error('MONGODB_URI kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh cho m√¥i tr∆∞·ªùng production');
    }
  }
};

// N·∫øu ·ªü m√¥i tr∆∞·ªùng production, validate c√°c bi·∫øn m√¥i tr∆∞·ªùng
if (environment.app.environment === 'production') {
  validateEnvironment();
}

module.exports = environment;


--- File: server/src/config/fix-indexes.js ---
/**
 * Script ƒë·ªÉ s·ª≠a l·ªói ch·ªâ m·ª•c tr√πng l·∫∑p trong MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');
require('dotenv').config();

async function dropIndexes() {
  try {
    logger.info('K·∫øt n·ªëi ƒë·∫øn MongoDB ƒë·ªÉ s·ª≠a l·ªói ch·ªâ m·ª•c...');
    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('K·∫øt n·ªëi th√†nh c√¥ng!');

    // L·∫•y danh s√°ch t·∫•t c·∫£ c√°c collection trong database
    const collections = await mongoose.connection.db.listCollections().toArray();
    const collectionNames = collections.map((c) => c.name);

    logger.info(`T√¨m th·∫•y ${collectionNames.length} collection: ${collectionNames.join(', ')}`);

    // X·ª≠ l√Ω t·ª´ng collection
    for (const collectionName of collectionNames) {
      // B·ªè qua c√°c collection h·ªá th·ªëng
      if (collectionName.startsWith('system.')) {
        logger.info(`B·ªè qua collection h·ªá th·ªëng: ${collectionName}`);
        continue;
      }

      try {
        const collection = mongoose.connection.collection(collectionName);

        // L·∫•y danh s√°ch t·∫•t c·∫£ ch·ªâ m·ª•c
        const indexes = await collection.indexes();
        logger.info(`Collection ${collectionName}: T√¨m th·∫•y ${indexes.length} ch·ªâ m·ª•c`);

        // Log t·∫•t c·∫£ c√°c ch·ªâ m·ª•c ƒë·ªÉ tham kh·∫£o
        indexes.forEach((index) => {
          logger.info(
            `- Ch·ªâ m·ª•c: ${index.name}, Key: ${JSON.stringify(index.key)}, Options: ${JSON.stringify(index)}`
          );
        });

        // X√≥a t·∫•t c·∫£ c√°c ch·ªâ m·ª•c tr·ª´ _id
        const dropPromises = indexes
          .filter((index) => index.name !== '_id_') // Gi·ªØ l·∫°i ch·ªâ m·ª•c _id
          .map((index) => {
            logger.info(`ƒêang x√≥a ch·ªâ m·ª•c: ${index.name} trong collection ${collectionName}`);
            return collection
              .dropIndex(index.name)
              .then(() => logger.info(`ƒê√£ x√≥a th√†nh c√¥ng ch·ªâ m·ª•c ${index.name}`))
              .catch((err) => logger.error(`Kh√¥ng th·ªÉ x√≥a ch·ªâ m·ª•c ${index.name}: ${err.message}`));
          });

        await Promise.all(dropPromises);
        logger.info(`ƒê√£ x√≥a t·∫•t c·∫£ ch·ªâ m·ª•c tr·ª´ _id trong collection ${collectionName}`);
      } catch (collectionError) {
        logger.error(`L·ªói khi x·ª≠ l√Ω collection ${collectionName}: ${collectionError.message}`);
      }
    }

    logger.info('Ho√†n t·∫•t x√≥a ch·ªâ m·ª•c. H√£y kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng ƒë·ªÉ t·∫°o l·∫°i ch·ªâ m·ª•c h·ª£p l·ªá.');
    await mongoose.disconnect();
    logger.info('ƒê√£ ng·∫Øt k·∫øt n·ªëi MongoDB');
  } catch (error) {
    logger.error(`L·ªói khi x√≥a ch·ªâ m·ª•c: ${error.message}`);
    throw error;
  }
}

// Ch·∫°y script
dropIndexes();


--- File: server/src/config/indexes.js ---
/**
 * C·∫•u h√¨nh thi·∫øt l·∫≠p ch·ªâ m·ª•c cho MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');

/**
 * Ki·ªÉm tra xem ch·ªâ m·ª•c c√≥ t·ªìn t·∫°i ch∆∞a
 * @param {Object} collection - Collection MongoDB
 * @param {Object} indexSpec - Ch·ªâ m·ª•c c·∫ßn ki·ªÉm tra
 * @returns {Promise<boolean>} - true n·∫øu ch·ªâ m·ª•c ƒë√£ t·ªìn t·∫°i
 */
async function indexExists(collection, indexSpec) {
  try {
    const indexes = await collection.indexes();

    // So s√°nh c·∫•u tr√∫c ch·ªâ m·ª•c (ch·ªâ d·ª±a tr√™n c√°c tr∆∞·ªùng)
    const keyString = JSON.stringify(Object.keys(indexSpec).sort());

    for (const index of indexes) {
      const existingKeyString = JSON.stringify(Object.keys(index.key).sort());
      if (existingKeyString === keyString) {
        return true;
      }
    }

    return false;
  } catch (error) {
    logger.error(`L·ªói khi ki·ªÉm tra ch·ªâ m·ª•c: ${error.message}`);
    return false;
  }
}

/**
 * Thi·∫øt l·∫≠p ch·ªâ m·ª•c cho c√°c collection
 */
async function setupIndexes() {
  try {
    logger.info('Thi·∫øt l·∫≠p ch·ªâ m·ª•c c∆° s·ªü d·ªØ li·ªáu...');

    // Ch·ªâ m·ª•c ƒë·∫∑c bi·ªát cho Product (text search)
    try {
      const Product = mongoose.model('Product');
      const productCollection = Product.collection;

      const textIndexSpec = {
        name: 'text',
        'description.short': 'text',
        'description.long': 'text',
        brand: 'text',
      };

      // Ki·ªÉm tra xem ch·ªâ m·ª•c text ƒë√£ t·ªìn t·∫°i ch∆∞a
      const productIndexes = await productCollection.indexes();
      const hasTextIndex = productIndexes.some((idx) => idx.textIndexVersion);

      if (!hasTextIndex) {
        logger.info('T·∫°o ch·ªâ m·ª•c text cho collection Product');
        await Product.collection.createIndex(textIndexSpec, {
          weights: {
            name: 10,
            'description.short': 5,
            'description.long': 3,
            brand: 3,
          },
          name: 'product_text_search',
        });
      } else {
        logger.info('Ch·ªâ m·ª•c text cho collection Product ƒë√£ t·ªìn t·∫°i, b·ªè qua t·∫°o m·ªõi');
      }
    } catch (productError) {
      logger.error(`Kh√¥ng th·ªÉ thi·∫øt l·∫≠p ch·ªâ m·ª•c text cho Product: ${productError.message}`);
    }

    // KH√îNG T·∫†O TH√äM CH·ªà M·ª§C T·∫†I ƒê√ÇY
    // ƒê·ªÉ c√°c model t·ª± t·∫°o ch·ªâ m·ª•c c·ªßa m√¨nh khi kh·ªüi ƒë·ªông

    logger.info('Ho√†n t·∫•t thi·∫øt l·∫≠p ch·ªâ m·ª•c');
    return true;
  } catch (error) {
    logger.error(`L·ªói khi thi·∫øt l·∫≠p ch·ªâ m·ª•c: ${error.message}`);
    throw error;
  }
}

module.exports = { setupIndexes };


--- File: server/src/config/logger.js ---
const winston = require('winston');
const path = require('path');

// ƒê·ªãnh nghƒ©a c√°c levels c·ªßa logger
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Ch·ªçn level d·ª±a tr√™n m√¥i tr∆∞·ªùng
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  const isDevelopment = env === 'development';
  return isDevelopment ? 'debug' : 'warn';
};

// T√πy ch·ªânh format cho logs
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf((info) => `${info.timestamp} ${info.level}: ${info.message}`)
);

// ƒê·ªãnh nghƒ©a c√°c transports cho logger
const transports = [
  // Ghi log ƒë·∫øn console
  new winston.transports.Console(),

  // Ghi log errors v√†o file
  new winston.transports.File({
    filename: path.join('logs', 'error.log'),
    level: 'error',
  }),

  // Ghi t·∫•t c·∫£ logs v√†o file
  new winston.transports.File({
    filename: path.join('logs', 'all.log'),
  }),
];

// T·∫°o logger v·ªõi c√°c t√πy ch·ªçn ƒë√£ ƒë·ªãnh nghƒ©a
const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
  // Th√™m metadata custom ƒë·ªÉ nh·∫≠n di·ªán ·ª©ng d·ª•ng
  defaultMeta: {
    service: process.env.APP_NAME || 'runout-biliard',
    signature: process.env.SIGNATURE || 'Steve',
  },
});

module.exports = logger;


--- File: server/src/config/middleware.js ---
/**
 * C·∫•u h√¨nh middleware
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const { rateLimit } = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const csrf = require('csurf');
const environment = require('./environment');
const logger = require('./logger');

/**
 * C·∫•u h√¨nh v√† √°p d·ª•ng c√°c middleware c∆° b·∫£n cho ·ª©ng d·ª•ng Express
 * @param {express.Application} app - ·ª®ng d·ª•ng Express
 */
const setupCommonMiddleware = (app) => {
  // Security middleware
  app.use(
    helmet({
      contentSecurityPolicy: environment.app.environment === 'production',
      crossOriginEmbedderPolicy: environment.app.environment === 'production',
      crossOriginOpenerPolicy: environment.app.environment === 'production',
      crossOriginResourcePolicy: environment.app.environment === 'production',
    })
  ); // B·∫£o m·∫≠t HTTP headers

  // CORS middleware
  app.use(
    cors({
      origin: environment.cors.origin,
      methods: environment.cors.methods.split(','),
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'CSRF-Token'],
      exposedHeaders: ['Content-Disposition', 'CSRF-Token'],
      credentials: true,
      maxAge: 86400, // 24 gi·ªù
    })
  );

  // Body parsing middleware
  app.use(express.json({ limit: '10kb' })); // Limit JSON body size
  app.use(express.urlencoded({ extended: true, limit: '10kb' }));

  // Cookie parsing middleware
  app.use(cookieParser(environment.app.cookieSecret));

  // Compression middleware
  app.use(compression());

  // Logger middleware
  if (environment.app.environment === 'development') {
    app.use(morgan('dev'));
  } else {
    // S·ª≠ d·ª•ng winston cho production
    app.use(
      morgan('combined', {
        stream: {
          write: (message) => logger.http(message.trim()),
        },
      })
    );
  }
};

/**
 * C·∫•u h√¨nh middleware b·∫£o m·∫≠t b·ªï sung
 * @param {express.Application} app - ·ª®ng d·ª•ng Express
 */
const setupSecurityMiddleware = (app) => {
  // Rate limiting middleware
  const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 ph√∫t
    max: 100, // Limit m·ªói IP 100 requests m·ªói windowMs
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Qu√° nhi·ªÅu y√™u c·∫ßu t·ª´ IP n√†y, vui l√≤ng th·ª≠ l·∫°i sau 15 ph√∫t',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // √Åp d·ª•ng rate limit cho t·∫•t c·∫£ c√°c routes /api
  app.use('/api', apiLimiter);

  // Middleware ch·ªëng brute force cho authentication
  const authLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 gi·ªù
    max: 5, // Gi·ªõi h·∫°n 5 l·∫ßn th·ª≠ trong 1 gi·ªù
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Qu√° nhi·ªÅu l·∫ßn th·ª≠ ƒëƒÉng nh·∫≠p, vui l√≤ng th·ª≠ l·∫°i sau 1 gi·ªù',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Auth rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // √Åp d·ª•ng auth limiter cho routes ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
  app.use('/api/auth/login', authLimiter);
  app.use('/api/auth/register', authLimiter);

  // CSRF protection middleware
  if (environment.app.environment === 'production') {
    const csrfProtection = csrf({ cookie: true });

    // √Åp d·ª•ng CSRF protection cho c√°c routes kh√¥ng ph·∫£i API public
    app.use('/api/admin', csrfProtection);
    app.use('/api/user', csrfProtection);

    // Middleware ƒë·ªÉ cung c·∫•p CSRF token
    app.get('/api/csrf-token', csrfProtection, (req, res) => {
      res.json({ csrfToken: req.csrfToken() });
    });
  }
};

/**
 * Setup middleware x·ª≠ l√Ω l·ªói
 * @param {express.Application} app - ·ª®ng d·ª•ng Express
 */
const setupErrorHandlingMiddleware = (app) => {
  // Middleware x·ª≠ l√Ω 404 - Ph·∫£i ƒë·∫∑t sau t·∫•t c·∫£ c√°c routes
  app.use((req, res, next) => {
    res.status(404).json({
      status: 'error',
      message: 'Kh√¥ng t√¨m th·∫•y t√†i nguy√™n y√™u c·∫ßu',
    });
    next(); // G·ªçi next() ƒë·ªÉ chuy·ªÉn sang middleware ti·∫øp theo
  });

  // Middleware x·ª≠ l√Ω l·ªói to√†n c·ª•c
  app.use((err, req, res, next) => {
    // X·ª≠ l√Ω l·ªói CSRF
    if (err.code === 'EBADCSRFTOKEN') {
      logger.error(`CSRF attack detected from IP: ${req.ip}`);
      return res.status(403).json({
        status: 'error',
        message: 'Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá, vui l√≤ng th·ª≠ l·∫°i',
      });
    }

    // Log l·ªói
    logger.error(`Error: ${err.message}`, {
      stack: err.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
    });

    // Tr·∫£ v·ªÅ l·ªói cho client
    const statusCode = err.statusCode || 500;
    const message =
      environment.app.environment === 'production' && statusCode === 500
        ? 'ƒê√£ x·∫£y ra l·ªói, vui l√≤ng th·ª≠ l·∫°i sau'
        : err.message;

    res.status(statusCode).json({
      status: 'error',
      message,
      ...(environment.app.environment !== 'production' && { stack: err.stack }),
    });

    next(); // Th√™m c√¢u l·ªánh g·ªçi next() sau khi x·ª≠ l√Ω l·ªói to√†n c·ª•c
  });
};

/**
 * Setup t·∫•t c·∫£ middleware
 * @param {express.Application} app - ·ª®ng d·ª•ng Express
 */
const setupAllMiddleware = (app) => {
  setupCommonMiddleware(app);
  setupSecurityMiddleware(app);

  // Middleware cho static files
  app.use('/uploads', express.static(environment.paths.uploads));

  // Middleware th√™m signature cho t·∫•t c·∫£ c√°c responses
  app.use((req, res, next) => {
    res.setHeader('X-Powered-By', `RunOut-Biliard - ${environment.app.signature}`);
    next();
  });

  // Middleware x·ª≠ l√Ω l·ªói ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t cu·ªëi c√πng
  // L∆∞u √Ω: Ph·∫£i g·ªçi sau khi ƒë√£ thi·∫øt l·∫≠p t·∫•t c·∫£ c√°c routes
};

module.exports = {
  setupCommonMiddleware,
  setupSecurityMiddleware,
  setupErrorHandlingMiddleware,
  setupAllMiddleware,
};


--- File: server/src/config/monitoring.js ---
// server/src/config/monitoring.js (m·∫´u)
const mongoose = require('mongoose');
const logger = require('./logger');

function setupMongoMonitoring() {
  // Monitor connection events
  mongoose.connection.on('connected', () => {
    logger.info('MongoDB connected');
  });

  mongoose.connection.on('error', (err) => {
    logger.error('MongoDB connection error:', err);
  });

  mongoose.connection.on('disconnected', () => {
    logger.warn('MongoDB disconnected');
  });

  // Monitor DB operations in development
  if (process.env.NODE_ENV === 'development') {
    mongoose.set('debug', (collection, method, query, doc) => {
      logger.debug(`MongoDB ${collection}.${method}`, { query, doc });
    });
  }
}

module.exports = { setupMongoMonitoring };


--- File: server/src/data/dto/cartDTO.js ---
// server/src/data/dto/cartDTO.js
class CartDTO {
  constructor(cart) {
    this.id = cart._id;
    this.items = cart.items.map((item) => ({
      id: item._id,
      product: item.product,
      quantity: item.quantity,
      price: item.price,
      attributes: item.attributes,
      addedAt: item.addedAt,
      updatedAt: item.updatedAt,
      totalPrice: item.price * item.quantity,
    }));

    this.subtotal = cart.subtotal;
    this.coupon = cart.coupon;
    this.totalItems = cart.items.reduce((sum, item) => sum + item.quantity, 0);
    this.lastActivity = cart.lastActivity;
    this.updatedAt = cart.updatedAt;
  }

  static fromEntity(cart) {
    return new CartDTO(cart);
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    delete entity.totalItems;

    if (entity.items) {
      entity.items = entity.items.map((item) => {
        const itemEntity = { ...item };
        delete itemEntity.id;
        delete itemEntity.totalPrice;
        return itemEntity;
      });
    }

    return entity;
  }
}

module.exports = CartDTO;


--- File: server/src/data/dto/categoryDTO.js ---
// server/src/data/dto/categoryDTO.js
class CategoryDTO {
  constructor(category) {
    this.id = category._id;
    this.name = category.name;
    this.slug = category.slug;
    this.description = category.description;
    this.parent = category.parent;
    this.ancestors = category.ancestors;
    this.level = category.level;
    this.image = category.image;
    this.icon = category.icon;
    this.order = category.order;
    this.isActive = category.isActive;
    this.isVisible = category.isVisible;
    this.createdAt = category.createdAt;
    this.updatedAt = category.updatedAt;
    this.children = category.children || [];
    this.meta = category.meta || {};
    this.meta.title = category.meta?.title || '';
    this.meta.description = category.meta?.description || '';
    this.meta.keywords = category.meta?.keywords || '';
    this.meta.robots = category.meta?.robots || '';
    this.meta.canonical = category.meta?.canonical || '';
  }

  static fromEntity(category) {
    return new CategoryDTO(category);
  }

  static fromEntities(categories) {
    return categories.map((category) => CategoryDTO.fromEntity(category));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  static fromTree(categoryTree) {
    return categoryTree.map((category) => {
      const dto = CategoryDTO.fromEntity(category);
      if (category.children && category.children.length > 0) {
        dto.children = CategoryDTO.fromTree(category.children);
      }
      return dto;
    });
  }
}

module.exports = CategoryDTO;


--- File: server/src/data/dto/orderDTO.js ---
// server/src/data/dto/orderDTO.js
class OrderDTO {
  constructor(order) {
    this.id = order._id;
    this.orderNumber = order.orderNumber;
    this.customerInfo = order.customerInfo;
    this.items = order.items;
    this.subtotal = order.subtotal;
    this.shippingCost = order.shippingCost;
    this.tax = order.tax;
    this.discount = order.discount;
    this.totalAmount = order.totalAmount;
    this.shippingAddress = order.shippingAddress;
    this.shippingMethod = order.shippingMethod;
    this.trackingNumber = order.trackingNumber;
    this.paymentMethod = order.paymentMethod;
    this.paymentStatus = order.paymentStatus;
    this.paymentDetails = order.paymentDetails;
    this.status = order.status;
    this.statusHistory = order.statusHistory;
    this.customerNotes = order.customerNotes;
    this.createdAt = order.createdAt;
    this.updatedAt = order.updatedAt;
    this.completedAt = order.completedAt;
    this.cancelledAt = order.cancelledAt;
  }

  static fromEntity(order) {
    return new OrderDTO(order);
  }

  static fromEntities(orders) {
    return orders.map((order) => OrderDTO.fromEntity(order));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }
}

module.exports = OrderDTO;


--- File: server/src/data/dto/productDTO.js ---
// server/src/data/dto/productDTO.js

/**
 * ProductDTO
 * ƒê·ªëi t∆∞·ª£ng chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu cho s·∫£n ph·∫©m
 */
class ProductDTO {
  /**
   * Kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng ProductDTO
   * @param {Object} product - ƒê·ªëi t∆∞·ª£ng s·∫£n ph·∫©m t·ª´ database
   */
  constructor(product) {
    this.product = product;

    if (product) {
      this.id = product._id;
      this.name = product.name;
      this.slug = product.slug;
      this.description = product.description;
      this.detailedDescription = product.detailedDescription;
      this.price = product.price;
      this.salePrice = product.salePrice;
      this.currency = product.currency || 'VND';
      this.stock = product.stock;
      this.categories = product.categories;
      this.images = product.images;
      this.attributes = product.attributes;
      this.status = product.status;
      this.featured = product.featured;
      this.sku = product.sku;
      this.brand = product.brand;
      this.createdAt = product.createdAt;
      this.updatedAt = product.updatedAt;
    }
  }

  /**
   * T·∫°o DTO t·ª´ entity
   * @param {Object} product - Entity s·∫£n ph·∫©m
   * @returns {ProductDTO} - ƒê·ªëi t∆∞·ª£ng DTO
   */
  static fromEntity(product) {
    return new ProductDTO(product);
  }

  /**
   * T·∫°o danh s√°ch DTO t·ª´ danh s√°ch entity
   * @param {Array} products - Danh s√°ch entity s·∫£n ph·∫©m
   * @returns {Array} - Danh s√°ch DTO
   */
  static fromEntities(products) {
    return products.map((product) => ProductDTO.fromEntity(product));
  }

  /**
   * Chuy·ªÉn ƒë·ªïi DTO th√†nh entity
   * @param {ProductDTO} dto - ƒê·ªëi t∆∞·ª£ng DTO
   * @returns {Object} - Entity s·∫£n ph·∫©m
   */
  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  /**
   * Chuy·ªÉn ƒë·ªïi ƒë·ªëi t∆∞·ª£ng s·∫£n ph·∫©m th√†nh JSON
   * @returns {Object} - ƒê·ªëi t∆∞·ª£ng JSON ch·ª©a th√¥ng tin s·∫£n ph·∫©m
   */
  toJSON() {
    if (!this.product) return null;

    // L·∫•y d·ªØ li·ªáu t·ª´ ƒë·ªëi t∆∞·ª£ng s·∫£n ph·∫©m
    const {
      _id,
      name,
      slug,
      description,
      detailedDescription,
      price,
      salePrice,
      currency,
      stock,
      categories,
      images,
      attributes,
      status,
      featured,
      sku,
      brand,
      weight,
      dimensions,
      tags,
      warranty,
      soldCount,
      viewCount,
      createdAt,
      updatedAt,
    } = this.product;

    // Bi·∫øn ƒë·ªïi d·ªØ li·ªáu
    return {
      id: _id.toString(),
      name,
      slug,
      description,
      detailedDescription,
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        currency: currency || 'VND',
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inventory: {
        stock,
        inStock: stock > 0,
        status: stock > 0 ? 'C√≤n h√†ng' : 'H·∫øt h√†ng',
      },
      categories: Array.isArray(categories)
        ? categories.map((cat) =>
            typeof cat === 'object' && cat._id ? cat._id.toString() : cat.toString()
          )
        : [],
      images: this._formatImages(images),
      mainImage: this._getMainImage(images),
      attributes: attributes || [],
      status,
      featured,
      sku,
      brand,
      specifications: {
        weight: weight || null,
        dimensions: dimensions || null,
      },
      tags: tags || [],
      warranty: warranty || null,
      stats: {
        soldCount: soldCount || 0,
        viewCount: viewCount || 0,
      },
      dates: {
        created: createdAt,
        updated: updatedAt,
      },
    };
  }

  /**
   * T·∫°o DTO cho danh s√°ch s·∫£n ph·∫©m
   * @param {Array} products - Danh s√°ch s·∫£n ph·∫©m
   * @returns {Array} - Danh s√°ch DTO
   */
  static toJSONList(products) {
    if (!Array.isArray(products)) return [];
    return products.map((product) => new ProductDTO(product).toJSON());
  }

  /**
   * T·∫°o phi√™n b·∫£n r√∫t g·ªçn c·ªßa DTO cho hi·ªÉn th·ªã trong danh s√°ch
   * @returns {Object} - ƒê·ªëi t∆∞·ª£ng JSON r√∫t g·ªçn
   */
  toSummaryJSON() {
    if (!this.product) return null;

    const {
      _id,
      name,
      slug,
      description,
      price,
      salePrice,
      stock,
      images,
      status,
      featured,
      soldCount,
      createdAt,
    } = this.product;

    return {
      id: _id.toString(),
      name,
      slug,
      shortDescription: this._truncateText(description, 100),
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inStock: stock > 0,
      mainImage: this._getMainImage(images),
      status,
      featured,
      soldCount: soldCount || 0,
      createdAt,
    };
  }

  /**
   * T·∫°o phi√™n b·∫£n chi ti·∫øt ƒë·∫ßy ƒë·ªß, bao g·ªìm c·∫£ ƒë√°nh gi√° v√† danh m·ª•c
   * @param {Array} reviews - Danh s√°ch ƒë√°nh gi√°
   * @param {Array} categoryDetails - Th√¥ng tin chi ti·∫øt danh m·ª•c
   * @returns {Object} - ƒê·ªëi t∆∞·ª£ng JSON chi ti·∫øt
   */
  toDetailedJSON(reviews = [], categoryDetails = []) {
    const baseDTO = this.toJSON();

    // Th√™m th√¥ng tin ƒë√°nh gi√°
    baseDTO.reviews = reviews;
    baseDTO.averageRating =
      reviews.length > 0
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
        : 0;

    // Th√™m th√¥ng tin chi ti·∫øt danh m·ª•c
    baseDTO.categoryDetails = categoryDetails;

    // Th√™m s·∫£n ph·∫©m li√™n quan n·∫øu c√≥
    if (this.relatedProducts) {
      baseDTO.relatedProducts = this.relatedProducts;
    }

    return baseDTO;
  }

  /**
   * Thi·∫øt l·∫≠p s·∫£n ph·∫©m li√™n quan
   * @param {Array} relatedProducts - Danh s√°ch s·∫£n ph·∫©m li√™n quan
   */
  setRelatedProducts(relatedProducts) {
    this.relatedProducts = ProductDTO.toJSONList(relatedProducts);
    return this;
  }

  /**
   * T√≠nh ph·∫ßn trƒÉm gi·∫£m gi√°
   * @param {Number} price - Gi√° g·ªëc
   * @param {Number} salePrice - Gi√° khuy·∫øn m√£i
   * @returns {Number} - Ph·∫ßn trƒÉm gi·∫£m gi√°
   * @private
   */
  _calculateDiscount(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return Math.round(((price - salePrice) / price) * 100);
    }
    return 0;
  }

  /**
   * L·∫•y gi√° cu·ªëi c√πng (sau gi·∫£m gi√° n·∫øu c√≥)
   * @param {Number} price - Gi√° g·ªëc
   * @param {Number} salePrice - Gi√° khuy·∫øn m√£i
   * @returns {Number} - Gi√° cu·ªëi c√πng
   * @private
   */
  _getFinalPrice(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return salePrice;
    }
    return price;
  }

  /**
   * ƒê·ªãnh d·∫°ng danh s√°ch h√¨nh ·∫£nh
   * @param {Array} images - Danh s√°ch h√¨nh ·∫£nh
   * @returns {Array} - Danh s√°ch h√¨nh ·∫£nh ƒë√£ ƒë·ªãnh d·∫°ng
   * @private
   */
  _formatImages(images) {
    if (!images || !Array.isArray(images)) return [];

    return images.map((image) => {
      // N·∫øu image l√† string (url)
      if (typeof image === 'string') {
        return {
          url: image,
          alt: this.product.name,
          isMain: false,
        };
      }

      // N·∫øu image l√† object
      return {
        url: image.url,
        alt: image.alt || this.product.name,
        isMain: !!image.isMain,
      };
    });
  }

  /**
   * L·∫•y h√¨nh ·∫£nh ch√≠nh c·ªßa s·∫£n ph·∫©m
   * @param {Array} images - Danh s√°ch h√¨nh ·∫£nh
   * @returns {String} - URL h√¨nh ·∫£nh ch√≠nh
   * @private
   */
  _getMainImage(images) {
    if (!images || !Array.isArray(images) || images.length === 0) {
      return null;
    }

    // T√¨m h√¨nh ·∫£nh ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† ch√≠nh
    const mainImage = images.find((img) => {
      if (typeof img === 'object' && img.isMain) {
        return true;
      }
      return false;
    });

    // N·∫øu c√≥ h√¨nh ·∫£nh ch√≠nh, tr·∫£ v·ªÅ URL
    if (mainImage) {
      return typeof mainImage === 'string' ? mainImage : mainImage.url;
    }

    // N·∫øu kh√¥ng c√≥ h√¨nh ·∫£nh ch√≠nh, l·∫•y h√¨nh ·∫£nh ƒë·∫ßu ti√™n
    const firstImage = images[0];
    return typeof firstImage === 'string' ? firstImage : firstImage.url;
  }

  /**
   * C·∫Øt ng·∫Øn vƒÉn b·∫£n
   * @param {String} text - VƒÉn b·∫£n
   * @param {Number} maxLength - ƒê·ªô d√†i t·ªëi ƒëa
   * @returns {String} - VƒÉn b·∫£n ƒë√£ c·∫Øt ng·∫Øn
   * @private
   */
  _truncateText(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.substring(0, maxLength) + '...';
  }
}

module.exports = ProductDTO;


--- File: server/src/data/dto/reviewDTO.js ---
// server/src/data/dto/reviewDTO.js
class ReviewDTO {
  constructor(review) {
    this.id = review._id;
    this.product = review.product;
    this.user = review.user;
    this.rating = review.rating;
    this.title = review.title;
    this.review = review.review;
    this.images = review.images;
    this.isVerifiedPurchase = review.isVerifiedPurchase;
    this.helpfulness = {
      upvotes: review.helpfulness.upvotes,
      downvotes: review.helpfulness.downvotes,
    };
    this.responses = review.responses.map((response) => ({
      id: response._id,
      user: response.user,
      isAdmin: response.isAdmin,
      content: response.content,
      createdAt: response.createdAt,
      updatedAt: response.updatedAt,
    }));
    this.createdAt = review.createdAt;
  }

  static fromEntity(review) {
    return new ReviewDTO(review);
  }

  static fromEntities(reviews) {
    return reviews.map((review) => ReviewDTO.fromEntity(review));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;

    if (entity.responses) {
      entity.responses = entity.responses.map((response) => {
        const responseEntity = { ...response };
        delete responseEntity.id;
        return responseEntity;
      });
    }

    return entity;
  }
}

module.exports = ReviewDTO;


--- File: server/src/data/dto/userDTO.js ---
/**
 * DTO cho User - chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu gi·ªØa service layer v√† client
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Class UserDTO - chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu User cho response
 */
class UserDTO {
  /**
   * Chuy·ªÉn ƒë·ªïi t·ª´ model User sang DTO
   * @param {Object} user - User model
   * @returns {Object} - User DTO
   */
  static toDTO(user) {
    if (!user) return null;

    // Chuy·ªÉn ƒë·ªïi user model th√†nh plain object n·∫øu ch∆∞a ph·∫£i
    const userObj = user.toObject ? user.toObject() : user;

    return {
      id: userObj._id.toString(),
      name: userObj.name,
      email: userObj.email,
      role: userObj.role,
      avatar: userObj.avatar,
      phone: userObj.phone || '',
      address: userObj.address || {},
      isActive: userObj.isActive,
      emailVerified: userObj.emailVerified,
      lastLogin: userObj.lastLogin,
      loginCount: userObj.loginCount,
      preferences: userObj.preferences || {
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      },
      createdAt: userObj.createdAt,
      updatedAt: userObj.updatedAt,
    };
  }

  /**
   * Chuy·ªÉn ƒë·ªïi m·ªôt m·∫£ng User models sang DTO
   * @param {Array} users - M·∫£ng User models
   * @returns {Array} - M·∫£ng User DTOs
   */
  static toList(users) {
    if (!users || !Array.isArray(users)) return [];
    return users.map((user) => UserDTO.toDTO(user));
  }

  /**
   * Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ph√¢n trang t·ª´ service
   * @param {Object} paginatedResult - K·∫øt qu·∫£ ph√¢n trang t·ª´ service
   * @returns {Object} - K·∫øt qu·∫£ ph√¢n trang ƒë√£ chuy·ªÉn ƒë·ªïi
   */
  static toPagination(paginatedResult) {
    return {
      data: UserDTO.toList(paginatedResult.data || paginatedResult.users),
      pagination: {
        total: paginatedResult.totalCount || paginatedResult.pagination.total,
        page: paginatedResult.page || paginatedResult.pagination.page,
        limit: paginatedResult.limit || paginatedResult.pagination.limit,
        totalPages: paginatedResult.totalPages || paginatedResult.pagination.totalPages,
        hasNext: paginatedResult.hasNext || paginatedResult.pagination.hasNext,
        hasPrev: paginatedResult.hasPrev || paginatedResult.pagination.hasPrev,
      },
    };
  }

  /**
   * Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu cho profile
   * @param {Object} user - User model
   * @returns {Object} - User profile DTO
   */
  static toProfile(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Th√™m c√°c th√¥ng tin b·ªï sung cho profile n·∫øu c·∫ßn
    return {
      ...dto,
      // C√≥ th·ªÉ th√™m c√°c tr∆∞·ªùng kh√°c ·ªü ƒë√¢y
    };
  }

  /**
   * Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu cho admin (bao g·ªìm th√¥ng tin nh·∫°y c·∫£m h∆°n)
   * @param {Object} user - User model
   * @returns {Object} - Admin User DTO
   */
  static toAdminDTO(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Th√™m c√°c th√¥ng tin admin c·∫ßn
    return {
      ...dto,
      emailVerified: user.emailVerified,
      isActive: user.isActive,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      lastLogin: user.lastLogin,
      loginCount: user.loginCount,
    };
  }
}

module.exports = UserDTO;


--- File: server/src/data/models/cart.model.js ---
// server/src/data/models/cart.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CartSchema = new Schema(
  {
    // Th√¥ng tin ch·ªß s·ªü h·ªØu
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // B·ªè sparse: true ·ªü ƒë√¢y, ch·ªâ ƒë·ªÉ l·∫°i trong khai b√°o index
    },
    sessionId: {
      type: String,
      // B·ªè sparse: true ·ªü ƒë√¢y, ch·ªâ ƒë·ªÉ l·∫°i trong khai b√°o index
    },

    // Danh s√°ch s·∫£n ph·∫©m
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        addedAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // T√≠nh to√°n gi√°
    subtotal: {
      type: Number,
      default: 0,
    },

    // M√£ gi·∫£m gi√°
    coupon: {
      code: String,
      discount: Number,
      appliedAt: Date,
    },

    // Tr·∫°ng th√°i
    status: {
      type: String,
      enum: ['active', 'converted', 'abandoned', 'merged'],
      default: 'active',
    },

    // Th·ªùi gian ho·∫°t ƒë·ªông v√† h·∫øt h·∫°n
    lastActivity: {
      type: Date,
      default: Date.now,
    },
    expiresAt: {
      type: Date,
      // B·ªè sparse: true ·ªü ƒë√¢y, ch·ªâ ƒë·ªÉ l·∫°i trong khai b√°o index
    },
  },
  {
    timestamps: true,
  }
);

// Indexes - Gi·ªØ l·∫°i c√°c khai b√°o ch·ªâ m·ª•c r√µ r√†ng v√† th√™m t√™n
CartSchema.index({ user: 1 }, { sparse: true, name: 'cart_user_idx' });
CartSchema.index({ sessionId: 1 }, { sparse: true, name: 'cart_sessionId_idx' });
CartSchema.index({ status: 1 }, { name: 'cart_status_idx' });
CartSchema.index({ user: 1, status: 1 }, { name: 'cart_user_status_idx' });
CartSchema.index({ sessionId: 1, status: 1 }, { sparse: true, name: 'cart_sessionId_status_idx' });
CartSchema.index(
  { expiresAt: 1 },
  { expireAfterSeconds: 0, sparse: true, name: 'cart_expiresAt_ttl_idx' }
);
CartSchema.index({ 'items.product': 1 }, { name: 'cart_items_product_idx' });

module.exports = mongoose.model('Cart', CartSchema);


--- File: server/src/data/models/category.model.js ---
// server/src/data/models/category.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CategorySchema = new Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
    },
    description: String,

    // C·∫•u tr√∫c ph√¢n c·∫•p
    parent: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      default: null,
    },
    ancestors: [
      {
        _id: {
          type: Schema.Types.ObjectId,
          ref: 'Category',
        },
        name: String,
        slug: String,
      },
    ],
    level: {
      type: Number,
      default: 0,
    },

    // Hi·ªÉn th·ªã
    image: {
      url: String,
      alt: String,
    },
    icon: String,

    // Th·ª© t·ª± v√† tr·∫°ng th√°i
    order: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    isVisible: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes v·ªõi t√™n r√µ r√†ng
CategorySchema.index({ name: 1 }, { name: 'category_name_idx' });
CategorySchema.index({ slug: 1 }, { unique: true, name: 'category_slug_unique_idx' });
CategorySchema.index({ parent: 1 }, { name: 'category_parent_idx' });
CategorySchema.index({ 'ancestors._id': 1 }, { name: 'category_ancestors_idx' });
CategorySchema.index({ level: 1 }, { name: 'category_level_idx' });
CategorySchema.index({ order: 1 }, { name: 'category_order_idx' });
CategorySchema.index({ isActive: 1, isVisible: 1 }, { name: 'category_active_visible_idx' });
CategorySchema.index({ name: 'text', description: 'text' }, { name: 'category_text_search_idx' });

module.exports = mongoose.model('Category', CategorySchema);


--- File: server/src/data/models/order.model.js ---
// server/src/data/models/order.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const OrderSchema = new Schema(
  {
    // Th√¥ng tin c∆° b·∫£n
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      // Kh√¥ng c·∫ßn khai b√°o index: true ·ªü ƒë√¢y v√¨ ƒë√£ c√≥ trong schema.index()
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // Kh√¥ng c·∫ßn khai b√°o index: true ·ªü ƒë√¢y v√¨ ƒë√£ c√≥ trong schema.index()
    },

    // Th√¥ng tin li√™n h·ªá
    customerInfo: {
      name: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
    },

    // Chi ti·∫øt s·∫£n ph·∫©m
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        name: {
          type: String,
          required: true,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        totalPrice: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        sku: String,
        image: String,
      },
    ],

    // T·ªïng ti·ªÅn
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    shippingCost: {
      type: Number,
      required: true,
      default: 0,
    },
    tax: {
      type: Number,
      required: true,
      default: 0,
    },
    discount: {
      amount: {
        type: Number,
        default: 0,
      },
      code: String,
    },
    totalAmount: {
      type: Number,
      required: true,
      min: 0,
    },

    // Th√¥ng tin v·∫≠n chuy·ªÉn
    shippingAddress: {
      name: String,
      phone: String,
      street: {
        type: String,
        required: true,
      },
      city: {
        type: String,
        required: true,
      },
      state: String,
      zipCode: {
        type: String,
        required: true,
      },
      country: {
        type: String,
        required: true,
      },
      notes: String,
    },
    shippingMethod: {
      type: String,
      required: true,
    },
    trackingNumber: String,

    // Th√¥ng tin thanh to√°n
    paymentMethod: {
      type: String,
      required: true,
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'authorized', 'paid', 'failed', 'refunded', 'partially_refunded'],
      default: 'pending',
    },
    paymentDetails: {
      provider: String,
      transactionId: String,
      paymentDate: Date,
    },

    // Tr·∫°ng th√°i ƒë∆°n h√†ng
    status: {
      type: String,
      enum: ['pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned'],
      default: 'pending',
    },

    // L·ªãch s·ª≠ tr·∫°ng th√°i
    statusHistory: [
      {
        status: {
          type: String,
          enum: [
            'pending',
            'processing',
            'packed',
            'shipped',
            'delivered',
            'cancelled',
            'returned',
          ],
        },
        date: {
          type: Date,
          default: Date.now,
        },
        note: String,
        updatedBy: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
      },
    ],

    // Ghi ch√∫
    customerNotes: String,
    adminNotes: String,

    // Th·ªùi gian ho√†n th√†nh ho·∫∑c h·ªßy
    completedAt: Date,
    cancelledAt: Date,
  },
  {
    timestamps: true,
  }
);

// Indexes
// Ch·ªâ hi·ªÉn th·ªã ph·∫ßn khai b√°o ch·ªâ m·ª•c ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian
// Indexes v·ªõi t√™n r√µ r√†ng
OrderSchema.index({ orderNumber: 1 }, { unique: true, name: 'order_number_unique_idx' });
OrderSchema.index({ user: 1 }, { name: 'order_user_idx' });
OrderSchema.index({ 'customerInfo.email': 1 }, { name: 'order_customer_email_idx' });
OrderSchema.index({ 'customerInfo.phone': 1 }, { name: 'order_customer_phone_idx' });
OrderSchema.index({ status: 1 }, { name: 'order_status_idx' });
OrderSchema.index({ paymentStatus: 1 }, { name: 'order_payment_status_idx' });
OrderSchema.index({ createdAt: -1 }, { name: 'order_created_desc_idx' });
OrderSchema.index({ completedAt: -1 }, { name: 'order_completed_desc_idx' });
OrderSchema.index({ user: 1, createdAt: -1 }, { name: 'order_user_created_idx' });
OrderSchema.index({ status: 1, createdAt: -1 }, { name: 'order_status_created_idx' });
OrderSchema.index({ 'items.product': 1 }, { name: 'order_items_product_idx' });
module.exports = mongoose.model('Order', OrderSchema);


--- File: server/src/data/models/product.model.js ---
// server/src/data/models/product.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

/**
 * Product Model
 * Schema MongoDB cho ƒë·ªëi t∆∞·ª£ng s·∫£n ph·∫©m
 */
const ProductSchema = new Schema(
  {
    // Th√¥ng tin c∆° b·∫£n
    name: {
      type: String,
      required: [true, 'T√™n s·∫£n ph·∫©m l√† b·∫Øt bu·ªôc'],
      trim: true,
      maxlength: [200, 'T√™n s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 200 k√Ω t·ª±'],
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      // Lo·∫°i b·ªè index: true t·∫°i ƒë√¢y
    },
    description: {
      short: {
        type: String,
        required: [true, 'M√¥ t·∫£ ng·∫Øn s·∫£n ph·∫©m l√† b·∫Øt bu·ªôc'],
        trim: true,
        maxlength: [500, 'M√¥ t·∫£ ng·∫Øn kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 500 k√Ω t·ª±'],
      },
      long: {
        type: String,
        trim: true,
      },
    },

    // Danh m·ª•c v√† ph√¢n lo·∫°i
    categories: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Category',
        required: [true, 'S·∫£n ph·∫©m ph·∫£i thu·ªôc √≠t nh·∫•t m·ªôt danh m·ª•c'],
      },
    ],
    tags: [String],

    // Th∆∞∆°ng hi·ªáu v√† ngu·ªìn g·ªëc
    brand: {
      type: String,
      required: true,
      trim: true,
    },

    // Gi√° v√† t·ªìn kho
    price: {
      type: Number,
      required: [true, 'Gi√° s·∫£n ph·∫©m l√† b·∫Øt bu·ªôc'],
      min: [0, 'Gi√° s·∫£n ph·∫©m kh√¥ng ƒë∆∞·ª£c √¢m'],
    },
    salePrice: {
      type: Number,
      default: 0,
      min: [0, 'Gi√° khuy·∫øn m√£i kh√¥ng ƒë∆∞·ª£c √¢m'],
    },
    currency: {
      type: String,
      default: 'VND',
    },
    stock: {
      type: Number,
      required: [true, 'S·ªë l∆∞·ª£ng t·ªìn kho l√† b·∫Øt bu·ªôc'],
      min: [0, 'S·ªë l∆∞·ª£ng t·ªìn kho kh√¥ng ƒë∆∞·ª£c √¢m'],
      default: 0,
    },
    sku: {
      type: String,
      trim: true,
      unique: true,
      sparse: true,
      // Lo·∫°i b·ªè index: true t·∫°i ƒë√¢y n·∫øu c√≥
    },

    // H√¨nh ·∫£nh s·∫£n ph·∫©m
    images: [
      {
        url: {
          type: String,
          required: true,
        },
        alt: String,
        isMain: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Thu·ªôc t√≠nh s·∫£n ph·∫©m
    attributes: [
      {
        name: {
          type: String,
          required: true,
        },
        value: {
          type: String,
          required: true,
        },
      },
    ],

    // ƒê·∫∑c ƒëi·ªÉm s·∫£n ph·∫©m
    features: [String],

    // Th√¥ng s·ªë k·ªπ thu·∫≠t
    specifications: {
      weight: Number,
      length: Number,
      diameter: Number,
      material: String,
      tipSize: String,
      wrap: String,
    },

    // K√≠ch th∆∞·ªõc v√† tr·ªçng l∆∞·ª£ng
    weight: {
      value: Number,
      unit: {
        type: String,
        default: 'g',
      },
    },
    dimensions: {
      length: Number,
      width: Number,
      height: Number,
      unit: {
        type: String,
        default: 'cm',
      },
    },

    // B·∫£o h√†nh
    warranty: {
      type: String,
      trim: true,
    },

    // ƒê√°nh gi√°
    ratings: {
      average: {
        type: Number,
        default: 0,
        min: 0,
        max: 5,
      },
      count: {
        type: Number,
        default: 0,
      },
    },

    // Th·ªëng k√™
    soldCount: {
      type: Number,
      default: 0,
    },
    viewCount: {
      type: Number,
      default: 0,
    },

    // Tr·∫°ng th√°i
    status: {
      type: String,
      enum: {
        values: ['active', 'draft', 'discontinued'],
        message: 'Tr·∫°ng th√°i ph·∫£i l√†: active, draft ho·∫∑c discontinued',
      },
      default: 'draft',
    },
    featured: {
      type: Boolean,
      default: false,
    },
    isPromoted: {
      type: Boolean,
      default: false,
    },

    // Th√¥ng tin qu·∫£n l√Ω
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    updatedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Index cho t√¨m ki·∫øm - gi·ªØ l·∫°i m·ªôt ch·ªâ m·ª•c text duy nh·∫•t
ProductSchema.index(
  {
    name: 'text',
    'description.short': 'text',
    'description.long': 'text',
    brand: 'text',
    'attributes.value': 'text',
  },
  {
    weights: {
      name: 10,
      'description.short': 5,
      'description.long': 3,
      brand: 3,
      'attributes.value': 2,
    },
    name: 'product_text_search_index', // ƒê·∫∑t t√™n r√µ r√†ng ƒë·ªÉ tr√°nh xung ƒë·ªôt
  }
);

// T·∫°o c√°c index kh√°c ƒë·ªÉ t·ªëi ∆∞u truy v·∫•n
// Ch·ªâ hi·ªÉn th·ªã ph·∫ßn khai b√°o ch·ªâ m·ª•c ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian
// T·∫°o c√°c index kh√°c ƒë·ªÉ t·ªëi ∆∞u truy v·∫•n
ProductSchema.index({ slug: 1 }, { unique: true, name: 'product_slug_unique_idx' });
ProductSchema.index({ sku: 1 }, { unique: true, sparse: true, name: 'product_sku_unique_idx' });
ProductSchema.index({ status: 1, categories: 1 }, { name: 'product_status_categories_idx' });
ProductSchema.index({ status: 1, price: 1 }, { name: 'product_status_price_idx' });
ProductSchema.index({ status: 1, createdAt: -1 }, { name: 'product_status_created_idx' });
ProductSchema.index({ categories: 1 }, { name: 'product_categories_idx' });
ProductSchema.index({ brand: 1 }, { name: 'product_brand_idx' });
ProductSchema.index({ featured: 1 }, { name: 'product_featured_idx' });
ProductSchema.index({ isPromoted: 1 }, { name: 'product_promoted_idx' });
ProductSchema.index({ 'ratings.average': -1, status: 1 }, { name: 'product_ratings_status_idx' });
ProductSchema.index(
  { status: 1, categories: 1, price: 1 },
  { name: 'product_status_categories_price_idx' }
);

// Virtual ƒë·ªÉ l·∫•y ƒë√°nh gi√°
ProductSchema.virtual('reviews', {
  ref: 'Review',
  foreignField: 'productId',
  localField: '_id',
});

// Ph∆∞∆°ng th·ª©c ƒë·ªÉ ki·ªÉm tra c√≤n h√†ng
ProductSchema.methods.isInStock = function () {
  return this.stock > 0;
};

// Ph∆∞∆°ng th·ª©c ƒë·ªÉ t√≠nh gi√° sau gi·∫£m gi√°
ProductSchema.methods.getFinalPrice = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return this.salePrice;
  }
  return this.price;
};

// Ph∆∞∆°ng th·ª©c ƒë·ªÉ t√≠nh ph·∫ßn trƒÉm gi·∫£m gi√°
ProductSchema.methods.getDiscountPercentage = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return Math.round(((this.price - this.salePrice) / this.price) * 100);
  }
  return 0;
};

// Middleware tr∆∞·ªõc khi l∆∞u
ProductSchema.pre('save', function (next) {
  // C·∫≠p nh·∫≠t ng√†y s·ª≠a ƒë·ªïi
  this.updatedAt = Date.now();
  next();
});

// Middleware sau khi t√¨m ki·∫øm
ProductSchema.post('find', function (docs) {
  if (docs) {
    console.log(`T√¨m th·∫•y ${docs.length} s·∫£n ph·∫©m`);
  }
});

const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;


--- File: server/src/data/models/review.model.js ---
// server/src/data/models/review.model.js
// File n√†y kh√¥ng c√≥ v·∫•n ƒë·ªÅ ch·ªâ m·ª•c tr√πng l·∫∑p, gi·ªØ nguy√™n n·ªôi dung
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const ReviewSchema = new Schema(
  {
    // Th√¥ng tin c∆° b·∫£n
    product: {
      type: Schema.Types.ObjectId,
      ref: 'Product',
      required: true,
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    order: {
      type: Schema.Types.ObjectId,
      ref: 'Order',
    },

    // N·ªôi dung ƒë√°nh gi√°
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    title: {
      type: String,
      trim: true,
      maxlength: 100,
    },
    review: {
      type: String,
      trim: true,
      maxlength: 2000,
    },

    // H√¨nh ·∫£nh ƒë√≠nh k√®m
    images: [
      {
        url: String,
        thumbnail: String,
        caption: String,
      },
    ],

    // Metadata
    isVerifiedPurchase: {
      type: Boolean,
      default: false,
    },
    purchaseDate: Date,

    // T∆∞∆°ng t√°c v·ªõi ƒë√°nh gi√°
    helpfulness: {
      upvotes: {
        type: Number,
        default: 0,
      },
      downvotes: {
        type: Number,
        default: 0,
      },
      voters: [
        {
          user: {
            type: Schema.Types.ObjectId,
            ref: 'User',
          },
          vote: {
            type: Number,
            enum: [1, -1],
          },
          votedAt: {
            type: Date,
            default: Date.now,
          },
        },
      ],
    },

    // Ph·∫£n h·ªìi
    responses: [
      {
        user: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
        isAdmin: {
          type: Boolean,
          default: false,
        },
        content: {
          type: String,
          required: true,
          trim: true,
          maxlength: 1000,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // Tr·∫°ng th√°i
    isVisible: {
      type: Boolean,
      default: true,
    },

    // Th√¥ng tin ki·ªÉm duy·ªát
    moderation: {
      status: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
      },
      moderatedBy: {
        type: Schema.Types.ObjectId,
        ref: 'User',
      },
      moderatedAt: Date,
      reason: String,
    },
  },
  {
    timestamps: true,
  }
);

// Ch·ªâ hi·ªÉn th·ªã ph·∫ßn khai b√°o ch·ªâ m·ª•c ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian
// Indexes v·ªõi t√™n r√µ r√†ng
ReviewSchema.index({ product: 1 }, { name: 'review_product_idx' });
ReviewSchema.index({ user: 1 }, { name: 'review_user_idx' });
ReviewSchema.index({ product: 1, createdAt: -1 }, { name: 'review_product_created_idx' });
ReviewSchema.index({ product: 1, rating: -1 }, { name: 'review_product_rating_idx' });
ReviewSchema.index(
  { product: 1, 'helpfulness.upvotes': -1 },
  { name: 'review_product_upvotes_idx' }
);
ReviewSchema.index({ 'moderation.status': 1 }, { name: 'review_moderation_status_idx' });
ReviewSchema.index(
  { product: 1, 'moderation.status': 1, isVisible: 1 },
  { name: 'review_product_moderation_visible_idx' }
);
ReviewSchema.index({ title: 'text', review: 'text' }, { name: 'review_text_search_idx' });

module.exports = mongoose.model('Review', ReviewSchema);


--- File: server/src/data/models/user.model.js ---
// server/src/data/models/user.model.js - C·∫≠p nh·∫≠t cho ph·∫ßn x√°c th·ª±c
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true, // Ch·ªâ gi·ªØ unique: true, kh√¥ng c·∫ßn th√™m index: true
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, // Kh√¥ng bao g·ªìm password trong query results
    },
    role: {
      type: String,
      enum: ['user', 'admin', 'staff'],
      default: 'user',
    },
    avatar: String,

    phone: String,
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String,
    },

    isActive: {
      type: Boolean,
      default: true,
    },
    emailVerified: {
      type: Boolean,
      default: false,
    },

    resetPasswordToken: String,
    resetPasswordExpires: Date,
    emailVerificationToken: String,
    emailVerificationExpires: Date,

    refreshToken: String,

    lastLogin: Date,
    loginCount: {
      type: Number,
      default: 0,
    },

    preferences: {
      language: {
        type: String,
        default: 'vi',
      },
      notifications: {
        email: {
          type: Boolean,
          default: true,
        },
        marketing: {
          type: Boolean,
          default: true,
        },
      },
    },
  },
  {
    timestamps: true,
  }
);

// Th√™m c√°c ch·ªâ m·ª•c ph√π h·ª£p
// Kh√¥ng c·∫ßn th√™m ch·ªâ m·ª•c cho email v√¨ unique: true ƒë√£ t·ª± t·∫°o ch·ªâ m·ª•c
userSchema.index({ role: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ emailVerified: 1 });
userSchema.index({ resetPasswordToken: 1 }, { sparse: true });
userSchema.index({ emailVerificationToken: 1 }, { sparse: true });
userSchema.index({ phone: 1 }, { sparse: true });
userSchema.index({ name: 'text' });

// Hooks
userSchema.pre('save', async function (next) {
  // Ch·ªâ hash m·∫≠t kh·∫©u n·∫øu n√≥ thay ƒë·ªïi
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Methods
userSchema.methods.comparePassword = async function (candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.generateAuthToken = function () {
  return jwt.sign({ id: this._id, role: this.role }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

userSchema.methods.generateRefreshToken = function () {
  const refreshToken = jwt.sign({ id: this._id }, process.env.JWT_REFRESH_SECRET, {
    expiresIn: process.env.JWT_REFRESH_EXPIRES_IN,
  });

  this.refreshToken = refreshToken;
  return refreshToken;
};

const User = mongoose.model('User', userSchema);

module.exports = User;


--- File: server/src/data/repositories/cartRepository.js ---
// server/src/data/repositories/cartRepository.js
const Cart = require('../models/cart.model');
const ApiError = require('../../common/errors/apiError');
const Product = require('../models/product.model');
const mongoose = require('mongoose');

class CartRepository {
  async findByUser(userId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ user: userId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findBySessionId(sessionId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ sessionId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const cart = await query.exec();

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    return cart;
  }

  async create(data) {
    const cart = new Cart({
      ...data,
      status: 'active',
      lastActivity: new Date(),
    });

    // N·∫øu l√† gi·ªè h√†ng kh√°ch v√£ng lai, ƒë·∫∑t th·ªùi gian h·∫øt h·∫°n
    if (data.sessionId && !data.user) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 days from now
      cart.expiresAt = expiryDate;
    }

    return await cart.save();
  }

  async addItem(cartId, item) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Ki·ªÉm tra t·ªìn kho
      const product = await Product.findById(item.product);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < item.quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // L·∫•y gi·ªè h√†ng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // T√¨m s·∫£n ph·∫©m trong gi·ªè h√†ng
      const existingItemIndex = cart.items.findIndex(
        (cartItem) =>
          cartItem.product.toString() === item.product.toString() &&
          JSON.stringify(cartItem.attributes || {}) === JSON.stringify(item.attributes || {})
      );

      const now = new Date();

      if (existingItemIndex > -1) {
        // C·∫≠p nh·∫≠t s·∫£n ph·∫©m ƒë√£ c√≥
        const newQuantity = cart.items[existingItemIndex].quantity + item.quantity;

        if (product.stock < newQuantity) {
          throw new ApiError(400, 'Insufficient stock');
        }

        cart.items[existingItemIndex].quantity = newQuantity;
        cart.items[existingItemIndex].updatedAt = now;
      } else {
        // Th√™m s·∫£n ph·∫©m m·ªõi v√†o gi·ªè h√†ng
        cart.items.push({
          product: item.product,
          quantity: item.quantity,
          price: product.salePrice || product.price,
          attributes: item.attributes || {},
          addedAt: now,
          updatedAt: now,
        });
      }

      // C·∫≠p nh·∫≠t t·ªïng ti·ªÅn
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // C·∫≠p nh·∫≠t timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // L∆∞u gi·ªè h√†ng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateItemQuantity(cartId, productId, quantity, attributes = {}) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Ki·ªÉm tra t·ªìn kho
      const product = await Product.findById(productId);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // L·∫•y gi·ªè h√†ng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // T√¨m s·∫£n ph·∫©m trong gi·ªè h√†ng
      const itemIndex = cart.items.findIndex(
        (item) =>
          item.product.toString() === productId.toString() &&
          JSON.stringify(item.attributes || {}) === JSON.stringify(attributes)
      );

      if (itemIndex === -1) {
        throw new ApiError(404, 'Product not found in cart');
      }

      const now = new Date();

      if (quantity <= 0) {
        // X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng
        cart.items.splice(itemIndex, 1);
      } else {
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
        cart.items[itemIndex].quantity = quantity;
        cart.items[itemIndex].updatedAt = now;
      }

      // C·∫≠p nh·∫≠t t·ªïng ti·ªÅn
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // C·∫≠p nh·∫≠t timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // L∆∞u gi·ªè h√†ng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async removeItem(cartId, productId, attributes = {}) {
    return await this.updateItemQuantity(cartId, productId, 0, attributes);
  }

  async clear(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.items = [];
    cart.subtotal = 0;
    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async applyCoupon(cartId, couponCode, discount) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = {
      code: couponCode,
      discount,
      appliedAt: new Date(),
    };

    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async removeCoupon(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async mergeGuestCart(userId, sessionId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // T√¨m gi·ªè h√†ng guest
      const guestCart = await Cart.findOne({ sessionId, status: 'active' });

      // N·∫øu kh√¥ng c√≥ gi·ªè h√†ng guest, kh√¥ng c·∫ßn h·ª£p nh·∫•t
      if (!guestCart) {
        await session.commitTransaction();
        return null;
      }

      // T√¨m gi·ªè h√†ng ng∆∞·ªùi d√πng
      let userCart = await Cart.findOne({ user: userId, status: 'active' });

      if (!userCart) {
        // N·∫øu ng∆∞·ªùi d√πng kh√¥ng c√≥ gi·ªè h√†ng, chuy·ªÉn ƒë·ªïi gi·ªè h√†ng guest th√†nh c·ªßa ng∆∞·ªùi d√πng
        guestCart.user = userId;
        guestCart.sessionId = null;
        guestCart.expiresAt = null;
        guestCart.updatedAt = new Date();
        guestCart.lastActivity = new Date();
        await guestCart.save({ session });

        await session.commitTransaction();
        return guestCart;
      }

      // H·ª£p nh·∫•t c√°c s·∫£n ph·∫©m t·ª´ gi·ªè h√†ng guest v√†o gi·ªè h√†ng ng∆∞·ªùi d√πng
      const now = new Date();

      for (const guestItem of guestCart.items) {
        // Ki·ªÉm tra t·ªìn kho
        const product = await Product.findById(guestItem.product);

        if (product) {
          const existingItemIndex = userCart.items.findIndex(
            (item) =>
              item.product.toString() === guestItem.product.toString() &&
              JSON.stringify(item.attributes || {}) === JSON.stringify(guestItem.attributes || {})
          );

          if (existingItemIndex > -1) {
            // C·ªông s·ªë l∆∞·ª£ng n·∫øu s·∫£n ph·∫©m ƒë√£ t·ªìn t·∫°i
            const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

            if (product.stock >= newQuantity) {
              userCart.items[existingItemIndex].quantity = newQuantity;
              userCart.items[existingItemIndex].updatedAt = now;
            } else {
              // N·∫øu kh√¥ng ƒë·ªß t·ªìn kho, ƒë·∫∑t s·ªë l∆∞·ª£ng t·ªëi ƒëa c√≥ th·ªÉ
              userCart.items[existingItemIndex].quantity = product.stock;
              userCart.items[existingItemIndex].updatedAt = now;
            }
          } else {
            // Th√™m s·∫£n ph·∫©m m·ªõi
            if (product.stock >= guestItem.quantity) {
              userCart.items.push({
                ...guestItem.toObject(),
                updatedAt: now,
              });
            } else if (product.stock > 0) {
              // Th√™m v·ªõi s·ªë l∆∞·ª£ng t·ªëi ƒëa c√≥ th·ªÉ
              userCart.items.push({
                ...guestItem.toObject(),
                quantity: product.stock,
                updatedAt: now,
              });
            }
          }
        }
      }

      // C·∫≠p nh·∫≠t t·ªïng ti·ªÅn
      userCart.subtotal = userCart.items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      );

      // Gi·ªØ l·∫°i coupon n·∫øu c√≥
      if (guestCart.coupon && !userCart.coupon) {
        userCart.coupon = guestCart.coupon;
      }

      // C·∫≠p nh·∫≠t timestamps
      userCart.updatedAt = now;
      userCart.lastActivity = now;

      // L∆∞u gi·ªè h√†ng ng∆∞·ªùi d√πng
      await userCart.save({ session });

      // ƒê√°nh d·∫•u gi·ªè h√†ng guest ƒë√£ ƒë∆∞·ª£c h·ª£p nh·∫•t
      guestCart.status = 'merged';
      guestCart.updatedAt = now;
      await guestCart.save({ session });

      await session.commitTransaction();
      return userCart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async getCartDetails(cartId) {
    const cart = await Cart.findById(cartId).populate({
      path: 'items.product',
      select: 'name slug images stock price salePrice',
    });

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    // Ki·ªÉm tra t·ªìn kho v√† c·∫≠p nh·∫≠t gi√° (n·∫øu c√≥ thay ƒë·ªïi)
    let needsUpdate = false;

    for (const item of cart.items) {
      const product = item.product;

      // C·∫≠p nh·∫≠t gi√° n·∫øu c√≥ thay ƒë·ªïi
      const currentPrice = product.salePrice || product.price;
      if (item.price !== currentPrice) {
        item.price = currentPrice;
        needsUpdate = true;
      }

      // Ki·ªÉm tra t·ªìn kho
      if (product.stock < item.quantity) {
        item.quantity = Math.max(0, product.stock);
        needsUpdate = true;
      }
    }

    // L·ªçc b·ªè s·∫£n ph·∫©m c√≥ s·ªë l∆∞·ª£ng 0
    cart.items = cart.items.filter((item) => item.quantity > 0);

    // C·∫≠p nh·∫≠t t·ªïng ti·ªÅn
    const newSubtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

    if (cart.subtotal !== newSubtotal) {
      cart.subtotal = newSubtotal;
      needsUpdate = true;
    }

    // L∆∞u l·∫°i gi·ªè h√†ng n·∫øu c√≥ thay ƒë·ªïi
    if (needsUpdate) {
      cart.updatedAt = new Date();
      cart.lastActivity = new Date();
      await cart.save();
    }

    return cart;
  }
}

module.exports = new CartRepository();


--- File: server/src/data/repositories/categoryRepository.js ---
// server/src/data/repositories/categoryRepository.js
const Category = require('../models/category.model');
const ApiError = require('../../common/errors/apiError');
// const mongoose = require('mongoose');

class CategoryRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { order: 1 }, limit = 0, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Category.find(filter).sort(sort);

    // √Åp d·ª•ng pagination n·∫øu limit > 0
    if (limit > 0) {
      query.skip(skip).limit(limit);
    }

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [categories, totalCount] = await Promise.all([
      query.exec(),
      Category.countDocuments(filter),
    ]);

    if (limit > 0) {
      return {
        data: categories,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };
    }

    return categories;
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Category.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async findBySlug(slug, options = {}) {
    const { populate = [] } = options;

    const query = Category.findOne({ slug });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async create(data) {
    // Ki·ªÉm tra slug ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existingCategory = await Category.findOne({ slug: data.slug }).exec();

    if (existingCategory) {
      throw new ApiError(409, 'Category with this slug already exists');
    }

    // N·∫øu c√≥ parent, c·∫≠p nh·∫≠t ancestors v√† level
    if (data.parent) {
      const parentCategory = await this.findById(data.parent);

      data.level = parentCategory.level + 1;
      data.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        },
      ];
    } else {
      data.level = 0;
      data.ancestors = [];
    }

    const category = new Category(data);
    return await category.save();
  }

  async update(id, data) {
    // N·∫øu c√≥ c·∫≠p nh·∫≠t slug, ki·ªÉm tra slug ƒë√£ t·ªìn t·∫°i ch∆∞a
    if (data.slug) {
      const existingCategory = await Category.findOne({ slug: data.slug, _id: { $ne: id } }).exec();

      if (existingCategory) {
        throw new ApiError(409, 'Category with this slug already exists');
      }
    }

    // N·∫øu c√≥ thay ƒë·ªïi parent, c·∫≠p nh·∫≠t ancestors v√† level
    if (data.parent !== undefined) {
      if (data.parent) {
        const parentCategory = await this.findById(data.parent);

        // Ki·ªÉm tra parent kh√¥ng ph·∫£i l√† con c·ªßa category hi·ªán t·∫°i
        if (parentCategory.ancestors.some((a) => a._id.toString() === id)) {
          throw new ApiError(400, 'Cannot set a child category as parent');
        }

        data.level = parentCategory.level + 1;
        data.ancestors = [
          ...parentCategory.ancestors,
          {
            _id: parentCategory._id,
            name: parentCategory.name,
            slug: parentCategory.slug,
          },
        ];
      } else {
        data.level = 0;
        data.ancestors = [];
      }
    }

    const category = await Category.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    // N·∫øu category ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng v√† name ho·∫∑c slug ƒë√£ thay ƒë·ªïi,
    // c·∫ßn c·∫≠p nh·∫≠t ancestors cho t·∫•t c·∫£ c√°c category con
    if (data.name || data.slug) {
      await this.updateChildrenAncestors(category);
    }

    return category;
  }

  async updateChildrenAncestors(parentCategory) {
    const childCategories = await Category.find({ parent: parentCategory._id });

    const updatePromises = childCategories.map(async (childCategory) => {
      // C·∫≠p nh·∫≠t ancestors
      const ancestorIndex = childCategory.ancestors.findIndex(
        (a) => a._id.toString() === parentCategory._id.toString()
      );

      if (ancestorIndex !== -1) {
        childCategory.ancestors[ancestorIndex] = {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        };

        await childCategory.save();

        // C·∫≠p nh·∫≠t ƒë·ªá quy cho con c·ªßa childCategory
        await this.updateChildrenAncestors(childCategory);
      }
    });

    await Promise.all(updatePromises);
  }

  async delete(id) {
    // Ki·ªÉm tra xem category c√≥ con kh√¥ng
    const hasChildren = await Category.exists({ parent: id });

    if (hasChildren) {
      throw new ApiError(400, 'Cannot delete category with children');
    }

    const category = await Category.findByIdAndDelete(id);

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return { success: true };
  }

  async getCategoryTree(filter = {}) {
    // L·∫•y t·∫•t c·∫£ categories
    const categories = await Category.find(filter).sort({ order: 1 }).lean();

    // T·∫°o map cho vi·ªác t√¨m ki·∫øm nhanh
    const categoryMap = {};
    categories.forEach((category) => {
      categoryMap[category._id.toString()] = {
        ...category,
        children: [],
      };
    });

    // X√¢y d·ª±ng c√¢y
    const rootCategories = [];

    categories.forEach((category) => {
      const categoryWithChildren = categoryMap[category._id.toString()];

      if (category.parent) {
        const parentId = category.parent.toString();
        if (categoryMap[parentId]) {
          categoryMap[parentId].children.push(categoryWithChildren);
        }
      } else {
        rootCategories.push(categoryWithChildren);
      }
    });

    return rootCategories;
  }

  async getVisibleCategories() {
    return await this.getCategoryTree({ isActive: true, isVisible: true });
  }
}

module.exports = new CategoryRepository();


--- File: server/src/data/repositories/orderRepository.js ---
// server/src/data/repositories/orderRepository.js
const Order = require('../models/order.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class OrderRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Order.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [orders, totalCount] = await Promise.all([query.exec(), Order.countDocuments(filter)]);

    return {
      data: orders,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Order.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async findByOrderNumber(orderNumber, options = {}) {
    const { populate = [] } = options;

    const query = Order.findOne({ orderNumber });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // T·∫°o order
      const order = new Order(data);
      await order.save({ session });

      await session.commitTransaction();
      return order;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateStatus(id, status, note, updatedBy) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    // Ki·ªÉm tra tr·∫°ng th√°i h·ª£p l·ªá
    const validStatusTransitions = {
      pending: ['processing', 'cancelled'],
      processing: ['packed', 'cancelled'],
      packed: ['shipped', 'cancelled'],
      shipped: ['delivered', 'returned'],
      delivered: ['returned'],
      cancelled: [],
      returned: [],
    };

    if (!validStatusTransitions[order.status].includes(status)) {
      throw new ApiError(400, `Invalid status transition from ${order.status} to ${status}`);
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i
    order.status = status;

    // Th√™m v√†o l·ªãch s·ª≠ tr·∫°ng th√°i
    order.statusHistory.push({
      status,
      date: new Date(),
      note,
      updatedBy,
    });

    // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng li√™n quan ƒë·∫øn completion/cancellation
    if (status === 'delivered') {
      order.completedAt = new Date();
    } else if (status === 'cancelled') {
      order.cancelledAt = new Date();
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n n·∫øu COD
    if (status === 'delivered' && order.paymentMethod === 'cod') {
      order.paymentStatus = 'paid';
      order.paymentDetails.paymentDate = new Date();
    }

    return await order.save();
  }

  async updatePaymentStatus(id, paymentStatus, paymentDetails = {}) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    order.paymentStatus = paymentStatus;

    if (Object.keys(paymentDetails).length > 0) {
      order.paymentDetails = {
        ...order.paymentDetails,
        ...paymentDetails,
      };
    }

    return await order.save();
  }

  async getUserOrders(userId, options = {}) {
    const filter = { user: userId };
    return await this.findAll(filter, options);
  }

  async getOrdersByStatus(status, options = {}) {
    const filter = { status };
    return await this.findAll(filter, options);
  }

  async getOrdersByPaymentStatus(paymentStatus, options = {}) {
    const filter = { paymentStatus };
    return await this.findAll(filter, options);
  }

  async getSalesReport(startDate, endDate) {
    const query = {
      createdAt: {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      },
      status: { $in: ['delivered', 'completed'] },
      paymentStatus: 'paid',
    };

    return await Order.aggregate([
      { $match: query },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' },
            day: { $dayOfMonth: '$createdAt' },
          },
          totalSales: { $sum: '$totalAmount' },
          orders: { $sum: 1 },
          averageOrderValue: { $avg: '$totalAmount' },
        },
      },
      {
        $sort: {
          '_id.year': 1,
          '_id.month': 1,
          '_id.day': 1,
        },
      },
    ]);
  }

  async generateOrderNumber() {
    const year = new Date().getFullYear();

    // T√¨m ƒë∆°n h√†ng cu·ªëi c√πng trong nƒÉm hi·ªán t·∫°i
    const lastOrder = await Order.findOne(
      { orderNumber: new RegExp(`^RO-${year}-`) },
      { orderNumber: 1 },
      { sort: { orderNumber: -1 } }
    );

    let nextNumber = 1;

    if (lastOrder) {
      // Extract s·ªë t·ª´ orderNumber cu·ªëi (RO-2025-0001 -> 1)
      const lastNumber = parseInt(lastOrder.orderNumber.split('-')[2]);
      nextNumber = lastNumber + 1;
    }

    // Format v·ªõi s·ªë 0 ƒë·ª©ng tr∆∞·ªõc (1 -> 0001)
    return `RO-${year}-${nextNumber.toString().padStart(4, '0')}`;
  }
}

module.exports = new OrderRepository();


--- File: server/src/data/repositories/productRepository.js ---
// server/src/data/repositories/productRepository.js
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');
const redisCache = require('../../services/cache/redisCache'); // Thay th·∫ø b·∫±ng RedisCache
const logger = require('../../utils/logger'); // Gi·∫£ ƒë·ªãnh c√≥ module logger

class ProductRepository {
  constructor() {
    // Prefix cho cache keys
    this.cachePrefix = 'products';
    // Th·ªùi gian cache m·∫∑c ƒë·ªãnh (5 ph√∫t)
    this.defaultCacheTTL = 300;
  }

  /**
   * T√¨m t·∫•t c·∫£ s·∫£n ph·∫©m v·ªõi ph√¢n trang v√† l·ªçc
   * @param {Object} filter - B·ªô l·ªçc
   * @param {Object} options - T√πy ch·ªçn
   * @returns {Object} - K·∫øt qu·∫£ v·ªõi ph√¢n trang
   */
  async findAll(filter = {}, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:all`, { filter, options });

    // Ki·ªÉm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`L·∫•y d·ªØ li·ªáu t·ª´ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Product.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const [products, totalCount] = await Promise.all([
        query.lean().exec(), // S·ª≠ d·ª•ng lean() ƒë·ªÉ tƒÉng hi·ªáu su·∫•t
        Product.countDocuments(filter),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // L∆∞u v√†o cache
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('L·ªói khi t√¨m t·∫•t c·∫£ s·∫£n ph·∫©m:', error);
      throw error;
    }
  }

  /**
   * T√¨m s·∫£n ph·∫©m theo ID
   * @param {string} id - ID s·∫£n ph·∫©m
   * @param {Object} options - T√πy ch·ªçn
   * @returns {Object} - S·∫£n ph·∫©m
   */
  async findById(id, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:id`, { id, options });

    // Ki·ªÉm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`L·∫•y s·∫£n ph·∫©m t·ª´ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findById(id);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // L∆∞u v√†o cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`L·ªói khi t√¨m s·∫£n ph·∫©m theo ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * T√¨m s·∫£n ph·∫©m theo slug
   * @param {string} slug - Slug s·∫£n ph·∫©m
   * @param {Object} options - T√πy ch·ªçn
   * @returns {Object} - S·∫£n ph·∫©m
   */
  async findBySlug(slug, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:slug`, { slug, options });

    // Ki·ªÉm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`L·∫•y s·∫£n ph·∫©m t·ª´ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findOne({ slug });

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // L∆∞u v√†o cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`L·ªói khi t√¨m s·∫£n ph·∫©m theo slug ${slug}:`, error);
      throw error;
    }
  }

  /**
   * T·∫°o s·∫£n ph·∫©m m·ªõi
   * @param {Object} data - D·ªØ li·ªáu s·∫£n ph·∫©m
   * @returns {Object} - S·∫£n ph·∫©m ƒë√£ t·∫°o
   */
  async create(data) {
    try {
      const product = new Product(data);
      const savedProduct = await product.save();

      // X√≥a cache li√™n quan ƒë·∫øn danh s√°ch s·∫£n ph·∫©m
      await this.invalidateProductListCache();

      return savedProduct;
    } catch (error) {
      logger.error('L·ªói khi t·∫°o s·∫£n ph·∫©m:', error);
      throw error;
    }
  }

  /**
   * C·∫≠p nh·∫≠t s·∫£n ph·∫©m
   * @param {string} id - ID s·∫£n ph·∫©m
   * @param {Object} data - D·ªØ li·ªáu c·∫≠p nh·∫≠t
   * @returns {Object} - S·∫£n ph·∫©m ƒë√£ c·∫≠p nh·∫≠t
   */
  async update(id, data) {
    try {
      const product = await Product.findByIdAndUpdate(
        id,
        { ...data, updatedAt: Date.now() },
        { new: true, runValidators: true }
      );

      if (!product) {
        throw ApiError.notFound('Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // X√≥a cache c·ªßa s·∫£n ph·∫©m n√†y
      await this.invalidateProductCache(id, product.slug);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`L·ªói khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m ${id}:`, error);
      throw error;
    }
  }

  /**
   * X√≥a s·∫£n ph·∫©m
   * @param {string} id - ID s·∫£n ph·∫©m
   * @returns {Object} - K·∫øt qu·∫£ x√≥a
   */
  async delete(id) {
    try {
      const product = await Product.findByIdAndDelete(id);

      if (!product) {
        throw ApiError.notFound('Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // X√≥a cache c·ªßa s·∫£n ph·∫©m n√†y v√† danh s√°ch s·∫£n ph·∫©m
      await this.invalidateProductCache(id, product.slug);
      await this.invalidateProductListCache();

      return { success: true };
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`L·ªói khi x√≥a s·∫£n ph·∫©m ${id}:`, error);
      throw error;
    }
  }

  /**
   * T√¨m ki·∫øm s·∫£n ph·∫©m theo text
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @param {Object} options - T√πy ch·ªçn
   * @returns {Object} - K·∫øt qu·∫£ t√¨m ki·∫øm v·ªõi ph√¢n trang
   */
  async searchProducts(query, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:search`, { query, options });

    // Ki·ªÉm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`L·∫•y k·∫øt qu·∫£ t√¨m ki·∫øm t·ª´ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { score: { $meta: 'textScore' } }, limit = 50, page = 1 } = options;
    const skip = (page - 1) * limit;

    const textSearchQuery = {
      $text: { $search: query },
      isActive: true,
    };

    try {
      const [products, totalCount] = await Promise.all([
        Product.find(textSearchQuery, { score: { $meta: 'textScore' } })
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .lean()
          .exec(),
        Product.countDocuments(textSearchQuery),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // L∆∞u v√†o cache v·ªõi th·ªùi gian ng·∫Øn h∆°n (2 ph√∫t) v√¨ d·ªØ li·ªáu t√¨m ki·∫øm th∆∞·ªùng thay ƒë·ªïi
      await redisCache.set(cacheKey, result, 120);

      return result;
    } catch (error) {
      logger.error(`L·ªói khi t√¨m ki·∫øm s·∫£n ph·∫©m v·ªõi t·ª´ kh√≥a "${query}":`, error);
      throw error;
    }
  }

  /**
   * C·∫≠p nh·∫≠t ƒë√°nh gi√° s·∫£n ph·∫©m
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @param {Object} rating - Th√¥ng tin ƒë√°nh gi√°
   * @returns {Object} - S·∫£n ph·∫©m ƒë√£ c·∫≠p nh·∫≠t
   */
  async updateRating(productId, rating) {
    try {
      const product = await Product.findByIdAndUpdate(
        productId,
        { ratings: rating },
        { new: true }
      );

      if (product) {
        // X√≥a cache c·ªßa s·∫£n ph·∫©m n√†y
        await this.invalidateProductCache(productId, product.slug);
      }

      return product;
    } catch (error) {
      logger.error(`L·ªói khi c·∫≠p nh·∫≠t ƒë√°nh gi√° s·∫£n ph·∫©m ${productId}:`, error);
      throw error;
    }
  }

  /**
   * T√¨m s·∫£n ph·∫©m v·ªõi c√°c b·ªô l·ªçc v√† h·ªó tr·ª£ cache
   * @param {Object} filters - C√°c b·ªô l·ªçc ƒë·ªÉ t√¨m s·∫£n ph·∫©m
   * @param {Object} options - C√°c t√πy ch·ªçn b·ªï sung
   * @returns {Object} - K·∫øt qu·∫£ t√¨m ki·∫øm v·ªõi ph√¢n trang
   */
  async findWithFilters(filters, options = {}) {
    // T·∫°o cache key d·ª±a tr√™n filters v√† options
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:filters`, { filters, options });

    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`L·∫•y k·∫øt qu·∫£ l·ªçc t·ª´ cache: ${cacheKey}`);
      return cachedResult;
    }

    const {
      category,
      minPrice,
      maxPrice,
      brand,
      sort = { createdAt: -1 },
      page = 1,
      limit = 20,
    } = filters;

    // X√¢y d·ª±ng query criteria
    const criteria = { isActive: true };

    if (category) {
      criteria.category = mongoose.Types.ObjectId(category);
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      criteria.price = {};
      if (minPrice !== undefined) criteria.price.$gte = minPrice;
      if (maxPrice !== undefined) criteria.price.$lte = maxPrice;
    }

    if (brand) {
      criteria.brand = brand;
    }

    // S·ª≠ d·ª•ng projection ƒë·ªÉ gi·∫£m k√≠ch th∆∞·ªõc response
    const projection = options.projection || {
      name: 1,
      slug: 1,
      price: 1,
      category: 1,
      brand: 1,
      images: { $slice: 1 }, // Ch·ªâ l·∫•y ·∫£nh ƒë·∫ßu ti√™n
      ratings: 1,
    };

    // T√≠nh to√°n skip value cho pagination
    const skip = (page - 1) * limit;

    try {
      // Th·ª±c hi·ªán query v·ªõi t·ªëi ∆∞u
      const products = await Product.find(criteria, projection)
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(); // S·ª≠ d·ª•ng lean() ƒë·ªÉ tƒÉng hi·ªáu su·∫•t

      // ƒê·∫øm t·ªïng s·ªë s·∫£n ph·∫©m (s·ª≠ d·ª•ng countDocuments thay v√¨ count)
      const total = await Product.countDocuments(criteria);

      const result = {
        data: products,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit),
        },
      };

      // L∆∞u k·∫øt qu·∫£ v√†o cache (TTL 5 ph√∫t)
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('L·ªói khi t√¨m s·∫£n ph·∫©m v·ªõi b·ªô l·ªçc:', error);
      throw error;
    }
  }

  /**
   * X√≥a cache c·ªßa m·ªôt s·∫£n ph·∫©m c·ª• th·ªÉ
   * @param {string} id - ID s·∫£n ph·∫©m
   * @param {string} slug - Slug s·∫£n ph·∫©m
   * @returns {Promise<void>}
   */
  async invalidateProductCache(id, slug) {
    try {
      // X√≥a cache theo ID
      await redisCache.deleteByPattern(`${this.cachePrefix}:id:*${id}*`);

      // X√≥a cache theo slug n·∫øu c√≥
      if (slug) {
        await redisCache.deleteByPattern(`${this.cachePrefix}:slug:*${slug}*`);
      }

      logger.info(`ƒê√£ x√≥a cache cho s·∫£n ph·∫©m: ${id}`);
    } catch (error) {
      logger.error(`L·ªói khi x√≥a cache s·∫£n ph·∫©m ${id}:`, error);
    }
  }

  /**
   * X√≥a cache c·ªßa danh s√°ch s·∫£n ph·∫©m
   * @returns {Promise<void>}
   */
  async invalidateProductListCache() {
    try {
      // X√≥a t·∫•t c·∫£ cache li√™n quan ƒë·∫øn danh s√°ch s·∫£n ph·∫©m
      await redisCache.deleteByPattern(`${this.cachePrefix}:all:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:filters:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:search:*`);

      logger.info('ƒê√£ x√≥a cache danh s√°ch s·∫£n ph·∫©m');
    } catch (error) {
      logger.error('L·ªói khi x√≥a cache danh s√°ch s·∫£n ph·∫©m:', error);
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t
   * @param {number} limit - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m c·∫ßn l·∫•y
   * @returns {Array} - Danh s√°ch s·∫£n ph·∫©m n·ªïi b·∫≠t
   */
  async getFeaturedProducts(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:featured`, { limit });

    // Ki·ªÉm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t t·ª´ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({
        isActive: true,
        isFeatured: true,
      })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // L∆∞u v√†o cache (TTL 1 gi·ªù)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('L·ªói khi l·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t:', error);
      throw error;
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m m·ªõi nh·∫•t
   * @param {number} limit - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m c·∫ßn l·∫•y
   * @returns {Array} - Danh s√°ch s·∫£n ph·∫©m m·ªõi nh·∫•t
   */
  async getNewArrivals(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:new`, { limit });

    // Ki·ªÉm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`L·∫•y s·∫£n ph·∫©m m·ªõi t·ª´ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // L∆∞u v√†o cache (TTL 30 ph√∫t)
      await redisCache.set(cacheKey, products, 1800);

      return products;
    } catch (error) {
      logger.error('L·ªói khi l·∫•y s·∫£n ph·∫©m m·ªõi nh·∫•t:', error);
      throw error;
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m b√°n ch·∫°y nh·∫•t
   * @param {number} limit - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m c·∫ßn l·∫•y
   * @returns {Array} - Danh s√°ch s·∫£n ph·∫©m b√°n ch·∫°y
   */
  async getBestSellers(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:bestsellers`, { limit });

    // Ki·ªÉm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`L·∫•y s·∫£n ph·∫©m b√°n ch·∫°y t·ª´ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ soldCount: -1 })
        .limit(limit)
        .lean()
        .exec();

      // L∆∞u v√†o cache (TTL 1 gi·ªù)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('L·ªói khi l·∫•y s·∫£n ph·∫©m b√°n ch·∫°y:', error);
      throw error;
    }
  }
}

module.exports = new ProductRepository();


--- File: server/src/data/repositories/reviewRepository.js ---
// server/src/data/repositories/reviewRepository.js
const Review = require('../models/review.model');
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class ReviewRepository {
  // server/src/data/repositories/reviewRepository.js (ti·∫øp)
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Review.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [reviews, totalCount] = await Promise.all([query.exec(), Review.countDocuments(filter)]);

    return {
      data: reviews,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Review.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const review = await query.exec();

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    return review;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // T·∫°o review
      const review = new Review(data);
      await review.save({ session });

      // C·∫≠p nh·∫≠t rating cho product
      await this.updateProductRating(data.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async update(id, data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findByIdAndUpdate(id, data, {
        new: true,
        runValidators: true,
        session,
      });

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // C·∫≠p nh·∫≠t rating cho product
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async delete(id) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findById(id).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      const productId = review.product;

      await Review.findByIdAndDelete(id).session(session);

      // C·∫≠p nh·∫≠t rating cho product
      await this.updateProductRating(productId, session);

      await session.commitTransaction();
      return { success: true };
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateProductRating(productId, session = null) {
    // L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° ƒë∆∞·ª£c ph√™ duy·ªát cho s·∫£n ph·∫©m
    const aggregateOptions = session ? { session } : {};

    const reviews = await Review.aggregate(
      [
        {
          $match: {
            product: new mongoose.Types.ObjectId(productId),
            'moderation.status': 'approved',
            isVisible: true,
          },
        },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            count: { $sum: 1 },
          },
        },
      ],
      aggregateOptions
    );

    let averageRating = 0;
    let count = 0;

    if (reviews.length > 0) {
      averageRating = reviews[0].averageRating;
      count = reviews[0].count;
    }

    // C·∫≠p nh·∫≠t product
    const updateOptions = session ? { session } : {};

    await Product.findByIdAndUpdate(
      productId,
      {
        'ratings.average': parseFloat(averageRating.toFixed(1)),
        'ratings.count': count,
      },
      updateOptions
    );
  }

  async getProductReviews(productId, options = {}) {
    const { sort = 'newest', page = 1, limit = 10, filter = {} } = options;

    const sortOptions = {
      newest: { createdAt: -1 },
      oldest: { createdAt: 1 },
      highestRating: { rating: -1 },
      lowestRating: { rating: 1 },
      mostHelpful: { 'helpfulness.upvotes': -1 },
    };

    const query = {
      product: productId,
      'moderation.status': 'approved',
      isVisible: true,
      ...filter,
    };

    return await this.findAll(query, {
      sort: sortOptions[sort] || sortOptions.newest,
      page,
      limit,
      populate: [{ path: 'user', select: 'name avatar' }],
    });
  }

  async getUserReviews(userId, options = {}) {
    const query = { user: userId };
    return await this.findAll(query, options);
  }

  async moderateReview(reviewId, action, reason, adminId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Validate action
      if (!['approve', 'reject'].includes(action)) {
        throw new ApiError(400, 'Invalid moderation action');
      }

      // T√¨m review
      const review = await Review.findById(reviewId).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i ki·ªÉm duy·ªát
      review.moderation = {
        status: action === 'approve' ? 'approved' : 'rejected',
        moderatedBy: adminId,
        moderatedAt: new Date(),
        reason: action === 'reject' ? reason : undefined,
      };

      // N·∫øu t·ª´ ch·ªëi, ·∫©n review
      if (action === 'reject') {
        review.isVisible = false;
      }

      // L∆∞u review
      await review.save({ session });

      // C·∫≠p nh·∫≠t t·ªïng rating cho s·∫£n ph·∫©m
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async voteReview(reviewId, userId, vote) {
    // Validate vote
    if (![1, -1].includes(vote)) {
      throw new ApiError(400, 'Invalid vote value');
    }

    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ vote ch∆∞a
    const voterIndex = review.helpfulness.voters.findIndex(
      (voter) => voter.user.toString() === userId.toString()
    );

    if (voterIndex > -1) {
      const previousVote = review.helpfulness.voters[voterIndex].vote;

      // N·∫øu vote tr√πng v·ªõi vote c≈©, x√≥a vote
      if (previousVote === vote) {
        // C·∫≠p nh·∫≠t upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes--;
        } else {
          review.helpfulness.downvotes--;
        }

        // X√≥a voter
        review.helpfulness.voters.splice(voterIndex, 1);
      } else {
        // N·∫øu vote kh√°c v·ªõi vote c≈©, c·∫≠p nh·∫≠t vote
        review.helpfulness.voters[voterIndex].vote = vote;
        review.helpfulness.voters[voterIndex].votedAt = new Date();

        // C·∫≠p nh·∫≠t upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes++;
          review.helpfulness.downvotes--;
        } else {
          review.helpfulness.upvotes--;
          review.helpfulness.downvotes++;
        }
      }
    } else {
      // N·∫øu ch∆∞a vote, th√™m vote m·ªõi
      review.helpfulness.voters.push({
        user: userId,
        vote,
        votedAt: new Date(),
      });

      // C·∫≠p nh·∫≠t upvotes/downvotes
      if (vote === 1) {
        review.helpfulness.upvotes++;
      } else {
        review.helpfulness.downvotes++;
      }
    }

    return await review.save();
  }

  async addResponse(reviewId, userId, content, isAdmin = false) {
    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    review.responses.push({
      user: userId,
      isAdmin,
      content,
      createdAt: new Date(),
    });

    return await review.save();
  }

  async getRatingDistribution(productId) {
    return await Review.aggregate([
      {
        $match: {
          product: new mongoose.Types.ObjectId(productId),
          'moderation.status': 'approved',
          isVisible: true,
        },
      },
      {
        $group: {
          _id: '$rating',
          count: { $sum: 1 },
        },
      },
      {
        $project: {
          rating: '$_id',
          count: 1,
          _id: 0,
        },
      },
      {
        $sort: { rating: -1 },
      },
    ]);
  }
}

module.exports = new ReviewRepository();
// module.exports = ReviewRepository;


--- File: server/src/data/repositories/userRepository.js ---
// server/src/data/repositories/userRepository.js
const User = require('../models/user.model');
const ApiError = require('../../common/errors/apiError');

class UserRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, select = '' } = options;
    const skip = (page - 1) * limit;

    const [users, totalCount] = await Promise.all([
      User.find(filter).sort(sort).skip(skip).limit(limit).select(select).exec(),
      User.countDocuments(filter),
    ]);

    return {
      data: users,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, select = '') {
    const user = await User.findById(id).select(select).exec();

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async findByEmail(email) {
    const user = await User.findOne({ email }).exec();
    return user;
  }

  async create(data) {
    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existingUser = await this.findByEmail(data.email);

    if (existingUser) {
      throw new ApiError(409, 'Email already exists');
    }

    const user = new User(data);
    return await user.save();
  }

  async update(id, data) {
    // N·∫øu c√≥ c·∫≠p nh·∫≠t email, ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    if (data.email) {
      const existingUser = await User.findOne({ email: data.email, _id: { $ne: id } }).exec();

      if (existingUser) {
        throw new ApiError(409, 'Email already exists');
      }
    }

    const user = await User.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async delete(id) {
    const user = await User.findByIdAndDelete(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return { success: true };
  }

  async updatePassword(id, newPassword) {
    const user = await User.findById(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    user.password = newPassword;
    return await user.save();
  }

  async findByResetToken(token) {
    return await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() },
    });
  }

  async findByVerificationToken(token) {
    return await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() },
    });
  }

  async updateLoginStats(id) {
    return await User.findByIdAndUpdate(id, {
      $inc: { loginCount: 1 },
      lastLogin: Date.now(),
    });
  }
}

module.exports = new UserRepository();


--- File: server/src/migrations/config.js ---
/**
 * C·∫•u h√¨nh cho h·ªá th·ªëng migration
 */
const config = {
  // Collection ƒë·ªÉ l∆∞u tr·∫°ng th√°i c√°c migrations ƒë√£ ch·∫°y
  migrationCollection: 'migrations',

  // Th∆∞ m·ª•c ch·ª©a c√°c migration scripts
  scriptsDir: './scripts',

  // M√¥i tr∆∞·ªùng ch·∫°y migrations
  environment: process.env.NODE_ENV || 'development',

  // C√≥ b·∫Øt bu·ªôc migrations ph·∫£i ch·∫°y theo th·ª© t·ª± kh√¥ng
  requireSequential: true,

  // Logger cho migrations
  logger: console,
};

module.exports = config;


--- File: server/src/migrations/index.js ---
const migrationRunner = require('./migrationRunner');
const mongoose = require('mongoose');
const config = require('../config/environment');

/**
 * L·ªõp l·ªói t√πy ch·ªânh cho migrations
 */
class MigrationError extends Error {
  constructor(message, originalError = null) {
    super(message);
    this.name = 'MigrationError';
    this.originalError = originalError;
  }
}

/**
 * ƒê√≥ng k·∫øt n·ªëi database
 */
const closeConnection = async () => {
  if (mongoose.connection.readyState !== 0) {
    console.log('Closing database connection...');
    await mongoose.connection.close();
  }
};

/**
 * Ch·∫°y migrations
 */
const runMigrations = async () => {
  try {
    // K·∫øt n·ªëi database n·∫øu ch∆∞a k·∫øt n·ªëi
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Running migrations...');
    await migrationRunner.migrate();

    console.log('Migrations completed successfully');
  } catch (error) {
    console.error('Error running migrations:', error);
    throw new MigrationError('Failed to run migrations', error);
  }
};

/**
 * Rollback migration g·∫ßn nh·∫•t
 */
const rollbackMigration = async () => {
  try {
    // K·∫øt n·ªëi database n·∫øu ch∆∞a k·∫øt n·ªëi
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Rolling back last migration...');
    await migrationRunner.rollback();

    console.log('Rollback completed successfully');
  } catch (error) {
    console.error('Error rolling back migration:', error);
    throw new MigrationError('Failed to rollback migration', error);
  }
};

// X·ª≠ l√Ω arguments t·ª´ command line
const processArguments = async () => {
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'migrate':
        await runMigrations();
        break;
      case 'rollback':
        await rollbackMigration();
        break;
      default:
        console.log('Usage: node migrations [migrate|rollback]');
        return; // Tho√°t h√†m m√† kh√¥ng n√©m l·ªói v√¨ ƒë√¢y kh√¥ng ph·∫£i l·ªói th·ª±c s·ª±
    }
  } catch (error) {
    // X·ª≠ l√Ω l·ªói ·ªü c·∫•p cao nh·∫•t
    console.error(`Migration command '${command}' failed:`, error);
    // ƒê·∫∑t m√£ tho√°t l√† 1 ƒë·ªÉ ch·ªâ ra l·ªói
    process.exitCode = 1;
  } finally {
    // ƒê·∫£m b·∫£o ƒë√≥ng k·∫øt n·ªëi database trong m·ªçi tr∆∞·ªùng h·ª£p
    await closeConnection();
  }
};

// Ch·ªâ ch·∫°y n·∫øu ƒë∆∞·ª£c g·ªçi tr·ª±c ti·∫øp (kh√¥ng ph·∫£i require)
if (require.main === module) {
  processArguments().catch((error) => {
    console.error('Unhandled error in migrations:', error);
    process.exitCode = 1;
  });
} else {
  // Export functions ƒë·ªÉ c√≥ th·ªÉ g·ªçi t·ª´ module kh√°c
  module.exports = {
    runMigrations,
    rollbackMigration,
    closeConnection, // Export th√™m h√†m ƒë√≥ng k·∫øt n·ªëi ƒë·ªÉ module kh√°c c√≥ th·ªÉ s·ª≠ d·ª•ng
  };
}


--- File: server/src/migrations/migrationFramework.js ---
// server/src/data/migrations/migrationFramework.js
const mongoose = require('mongoose');
const logger = require('../config/logger');

// Migration Model
const migrationSchema = new mongoose.Schema({
  version: {
    type: String,
    required: true,
    unique: true,
  },
  description: {
    type: String,
    required: true,
  },
  appliedAt: {
    type: Date,
    default: Date.now,
  },
});

const Migration = mongoose.model('Migration', migrationSchema);

// Migration Framework
class MigrationFramework {
  constructor() {
    this.migrations = [];
  }

  register(version, description, up, down) {
    this.migrations.push({
      version,
      description,
      up,
      down,
    });

    return this;
  }

  async migrate(targetVersion = null) {
    logger.info('Starting migrations...');

    try {
      // S·∫Øp x·∫øp migrations theo version
      this.migrations.sort((a, b) => {
        return a.version.localeCompare(b.version, undefined, { numeric: true });
      });

      // L·∫•y t·∫•t c·∫£ migrations ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng
      const appliedMigrations = await Migration.find().sort({ version: 1 });
      const lastAppliedVersion = appliedMigrations.length
        ? appliedMigrations[appliedMigrations.length - 1].version
        : null;

      // N·∫øu kh√¥ng c√≥ targetVersion, d√πng migration cu·ªëi c√πng
      targetVersion = targetVersion || this.migrations[this.migrations.length - 1].version;

      if (lastAppliedVersion === targetVersion) {
        logger.info(`Database already at version ${targetVersion}`);
        return;
      }

      // L·∫•y danh s√°ch c√°c versions ƒë√£ √°p d·ª•ng
      const appliedVersions = appliedMigrations.map((m) => m.version);

      // N·∫øu downgrade
      if (
        lastAppliedVersion &&
        lastAppliedVersion.localeCompare(targetVersion, undefined, { numeric: true }) > 0
      ) {
        logger.info(`Downgrading from ${lastAppliedVersion} to ${targetVersion}`);

        // L·∫•y c√°c migrations c·∫ßn rollback
        const migrationsToRollback = this.migrations
          .filter(
            (m) =>
              m.version.localeCompare(targetVersion, undefined, { numeric: true }) > 0 &&
              appliedVersions.includes(m.version)
          )
          .reverse();

        // √Åp d·ª•ng rollback
        for (const migration of migrationsToRollback) {
          logger.info(`Rolling back migration ${migration.version}: ${migration.description}`);
          await migration.down();
          await Migration.deleteOne({ version: migration.version });
        }

        logger.info(`Successfully downgraded to version ${targetVersion}`);
      }
      // N·∫øu upgrade
      else {
        logger.info(`Upgrading to version ${targetVersion}`);

        // L·∫•y c√°c migrations c·∫ßn √°p d·ª•ng
        const migrationsToApply = this.migrations.filter(
          (m) =>
            !appliedVersions.includes(m.version) &&
            m.version.localeCompare(targetVersion, undefined, { numeric: true }) <= 0
        );

        // √Åp d·ª•ng migrations
        for (const migration of migrationsToApply) {
          logger.info(`Applying migration ${migration.version}: ${migration.description}`);
          await migration.up();
          await Migration.create({
            version: migration.version,
            description: migration.description,
          });
        }

        logger.info(`Successfully upgraded to version ${targetVersion}`);
      }
    } catch (error) {
      logger.error('Migration failed', error);
      throw error;
    }
  }

  // L·∫•y version hi·ªán t·∫°i
  async getCurrentVersion() {
    const lastMigration = await Migration.findOne().sort({ version: -1 });
    return lastMigration ? lastMigration.version : null;
  }
}

module.exports = { MigrationFramework, Migration };


--- File: server/src/migrations/migrationRunner.js ---
const mongoose = require('mongoose');
const fs = require('fs');
const path = require('path');
const config = require('./config');

/**
 * L·ªõp qu·∫£n l√Ω v√† ch·∫°y migrations
 */
class MigrationRunner {
  constructor() {
    this.db = mongoose.connection;
    this.migrationCollection = this.db.collection(config.migrationCollection);
    this.logger = config.logger;
  }

  /**
   * L·∫•y danh s√°ch c√°c migrations ƒë√£ ch·∫°y
   * @returns {Promise<Array>} Danh s√°ch migrations ƒë√£ ch·∫°y
   */
  async getCompletedMigrations() {
    try {
      // N·∫øu collection kh√¥ng t·ªìn t·∫°i, t·∫°o m·ªõi
      const collections = await this.db.db
        .listCollections({ name: config.migrationCollection })
        .toArray();

      if (collections.length === 0) {
        await this.db.createCollection(config.migrationCollection);
        return [];
      }

      // L·∫•y danh s√°ch migrations ƒë√£ ch·∫°y
      const completedMigrations = await this.migrationCollection
        .find({})
        .sort({ timestamp: 1 })
        .toArray();
      return completedMigrations.map((migration) => migration.name);
    } catch (error) {
      this.logger.error('Error getting completed migrations:', error);
      throw error;
    }
  }

  /**
   * ƒê√°nh d·∫•u m·ªôt migration ƒë√£ ch·∫°y th√†nh c√¥ng
   * @param {String} name - T√™n migration
   * @returns {Promise<void>}
   */
  async markMigrationAsCompleted(name) {
    try {
      await this.migrationCollection.insertOne({
        name,
        timestamp: new Date(),
        environment: config.environment,
      });

      this.logger.info(`Migration ${name} marked as completed`);
    } catch (error) {
      this.logger.error(`Error marking migration ${name} as completed:`, error);
      throw error;
    }
  }

  /**
   * L·∫•y danh s√°ch t·∫•t c·∫£ c√°c migration scripts
   * @returns {Promise<Array>} Danh s√°ch t√™n c√°c migration scripts
   */
  async getAllMigrationScripts() {
    try {
      const scriptsDir = path.resolve(__dirname, config.scriptsDir);
      const files = fs.readdirSync(scriptsDir);

      // L·ªçc ch·ªâ l·∫•y c√°c file JavaScript
      return files.filter((file) => file.endsWith('.js')).sort(); // S·∫Øp x·∫øp theo th·ª© t·ª± t√™n file
    } catch (error) {
      this.logger.error('Error getting migration scripts:', error);
      throw error;
    }
  }

  /**
   * L·∫•y danh s√°ch c√°c migrations c·∫ßn ch·∫°y
   * @returns {Promise<Array>} Danh s√°ch t√™n c√°c migrations c·∫ßn ch·∫°y
   */
  async getPendingMigrations() {
    const completedMigrations = await this.getCompletedMigrations();
    const allMigrations = await this.getAllMigrationScripts();

    // L·ªçc c√°c migrations ch∆∞a ch·∫°y
    return allMigrations.filter((migration) => !completedMigrations.includes(migration));
  }

  /**
   * Ch·∫°y m·ªôt migration script
   * @param {String} scriptName - T√™n file script
   * @returns {Promise<void>}
   */
  async runMigration(scriptName) {
    try {
      this.logger.info(`Running migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Ch·∫°y migration
      if (typeof migration.up !== 'function') {
        throw new Error(`Migration ${scriptName} does not have an 'up' function`);
      }

      await migration.up(this.db);

      // ƒê√°nh d·∫•u migration ƒë√£ ho√†n th√†nh
      await this.markMigrationAsCompleted(scriptName);

      this.logger.info(`Migration ${scriptName} completed successfully`);
    } catch (error) {
      this.logger.error(`Error running migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Rollback m·ªôt migration
   * @param {String} scriptName - T√™n file script
   * @returns {Promise<void>}
   */
  async rollbackMigration(scriptName) {
    try {
      this.logger.info(`Rolling back migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Ch·∫°y rollback
      if (typeof migration.down !== 'function') {
        throw new Error(`Migration ${scriptName} does not have a 'down' function`);
      }

      await migration.down(this.db);

      // X√≥a migration kh·ªèi danh s√°ch ƒë√£ ho√†n th√†nh
      await this.migrationCollection.deleteOne({ name: scriptName });

      this.logger.info(`Migration ${scriptName} rolled back successfully`);
    } catch (error) {
      this.logger.error(`Error rolling back migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Ch·∫°y t·∫•t c·∫£ c√°c migrations ch∆∞a ho√†n th√†nh
   * @returns {Promise<void>}
   */
  async migrate() {
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info('No pending migrations to run');
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Ch·∫°y t·ª´ng migration theo th·ª© t·ª±
    for (const migration of pendingMigrations) {
      await this.runMigration(migration);
    }

    this.logger.info('All migrations completed successfully');
  }

  /**
   * Rollback migration cu·ªëi c√πng ƒë√£ ch·∫°y
   * @returns {Promise<void>}
   */
  async rollback() {
    const completedMigrations = await this.getCompletedMigrations();

    if (completedMigrations.length === 0) {
      this.logger.info('No migrations to roll back');
      return;
    }

    // L·∫•y migration cu·ªëi c√πng
    const lastMigration = completedMigrations[completedMigrations.length - 1];

    await this.rollbackMigration(lastMigration);
  }
}

module.exports = new MigrationRunner();


--- File: server/src/migrations/scripts/001-initial-categories.js ---
/**
 * Migration: T·∫°o c√°c danh m·ª•c s·∫£n ph·∫©m ban ƒë·∫ßu
 */
module.exports = {
  /**
   * Ch·∫°y migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // T·∫°o collection categories n·∫øu ch∆∞a t·ªìn t·∫°i
    const collections = await db.db.listCollections({ name: 'categories' }).toArray();
    if (collections.length === 0) {
      await db.db.createCollection('categories');
    }

    const categories = db.collection('categories');

    // Danh s√°ch c√°c danh m·ª•c c∆° b·∫£n
    const initialCategories = [
      {
        name: 'G·∫≠y Billiard',
        slug: 'gay-billiard',
        description: 'T·∫•t c·∫£ c√°c lo·∫°i g·∫≠y billiard ch·∫•t l∆∞·ª£ng cao',
        parent: null,
        level: 0,
        order: 1,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Bi Billiard',
        slug: 'bi-billiard',
        description: 'C√°c b·ªô bi billiard ti√™u chu·∫©n qu·ªëc t·∫ø',
        parent: null,
        level: 0,
        order: 2,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Ph·ª• Ki·ªán',
        slug: 'phu-kien',
        description: 'Ph·ª• ki·ªán billiard ch·∫•t l∆∞·ª£ng cao',
        parent: null,
        level: 0,
        order: 3,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Ch√®n c√°c danh m·ª•c v√†o database
    await categories.insertMany(initialCategories);
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const categories = db.collection('categories');

    // X√≥a c√°c danh m·ª•c ƒë√£ t·∫°o
    await categories.deleteMany({
      slug: { $in: ['gay-billiard', 'bi-billiard', 'phu-kien'] },
    });
  },
};


--- File: server/src/migrations/scripts/002-add-indexes.js ---
/**
 * Migration: T·∫°o c√°c indexes cho database
 */
module.exports = {
  /**
   * Ch·∫°y migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // Index cho User collection
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
    await db.collection('users').createIndex({ role: 1 });

    // Index cho Product collection
    await db.collection('products').createIndex({ slug: 1 }, { unique: true });
    await db.collection('products').createIndex({ category: 1 });
    await db.collection('products').createIndex({ createdAt: -1 });
    await db.collection('products').createIndex({ price: 1 });

    // Text index cho t√¨m ki·∫øm s·∫£n ph·∫©m
    await db.collection('products').createIndex(
      { name: 'text', description: 'text' },
      {
        weights: {
          name: 10,
          description: 5,
        },
        default_language: 'none',
      }
    );

    // Index cho Category collection
    await db.collection('categories').createIndex({ slug: 1 }, { unique: true });
    await db.collection('categories').createIndex({ parent: 1 });

    // Index cho Order collection
    await db.collection('orders').createIndex({ orderNumber: 1 }, { unique: true });
    await db.collection('orders').createIndex({ user: 1 });
    await db.collection('orders').createIndex({ status: 1 });
    await db.collection('orders').createIndex({ createdAt: -1 });

    // Index cho Cart collection
    await db.collection('carts').createIndex({ user: 1 }, { sparse: true });
    await db.collection('carts').createIndex({ sessionId: 1 }, { sparse: true });

    // TTL index cho cart expiration
    await db.collection('carts').createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });

    // Index cho Review collection
    await db.collection('reviews').createIndex({ product: 1 });
    await db.collection('reviews').createIndex({ user: 1 });
    await db.collection('reviews').createIndex({ product: 1, createdAt: -1 });
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    // Drop indexes t·ª´ User collection
    await db.collection('users').dropIndex({ email: 1 });
    await db.collection('users').dropIndex({ role: 1 });

    // Drop indexes t·ª´ Product collection
    await db.collection('products').dropIndex({ slug: 1 });
    await db.collection('products').dropIndex({ category: 1 });
    await db.collection('products').dropIndex({ createdAt: -1 });
    await db.collection('products').dropIndex({ price: 1 });
    await db.collection('products').dropIndex('name_text_description_text');

    // Drop indexes t·ª´ Category collection
    await db.collection('categories').dropIndex({ slug: 1 });
    await db.collection('categories').dropIndex({ parent: 1 });

    // Drop indexes t·ª´ Order collection
    await db.collection('orders').dropIndex({ orderNumber: 1 });
    await db.collection('orders').dropIndex({ user: 1 });
    await db.collection('orders').dropIndex({ status: 1 });
    await db.collection('orders').dropIndex({ createdAt: -1 });

    // Drop indexes t·ª´ Cart collection
    await db.collection('carts').dropIndex({ user: 1 });
    await db.collection('carts').dropIndex({ sessionId: 1 });
    await db.collection('carts').dropIndex({ expiresAt: 1 });

    // Drop indexes t·ª´ Review collection
    await db.collection('reviews').dropIndex({ product: 1 });
    await db.collection('reviews').dropIndex({ user: 1 });
    await db.collection('reviews').dropIndex({ product: 1, createdAt: -1 });
  },
};


--- File: server/src/migrations/scripts/003-add-admin-user.js ---
const bcrypt = require('bcrypt');

/**
 * Migration: T·∫°o user admin m·∫∑c ƒë·ªãnh
 */
module.exports = {
  /**
   * Ch·∫°y migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    const users = db.collection('users');

    // Ki·ªÉm tra xem ƒë√£ c√≥ admin ch∆∞a
    const adminExists = await users.findOne({ role: 'admin' });

    if (!adminExists) {
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash('Admin@123', salt);

      // T·∫°o admin user
      await users.insertOne({
        name: 'Admin',
        email: 'admin@runout-biliard.com',
        password: hashedPassword,
        role: 'admin',
        isActive: true,
        emailVerified: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const users = db.collection('users');

    // X√≥a admin user
    await users.deleteOne({ email: 'admin@runout-biliard.com' });
  },
};


--- File: server/src/seeds/data/carts.js ---
// server/src/seeds/data/carts.js

module.exports = [
  {
    user: 'nguyenvana@example.com', // email c·ªßa user
    items: [
      {
        product: 'gay-billiard-pro-series-x1', // slug c·ªßa s·∫£n ph·∫©m
        quantity: 1,
        price: 1500000,
        addedAt: new Date('2023-05-10T08:30:15.123Z'),
      },
    ],
    subtotal: 1500000,
    status: 'active',
    createdAt: new Date('2023-05-10T08:30:15.123Z'),
    updatedAt: new Date('2023-05-10T08:30:15.123Z'),
    lastActivity: new Date('2023-05-10T08:30:15.123Z'),
  },
  {
    user: 'tranthib@example.com', // email c·ªßa user
    items: [
      {
        product: 'bo-bi-a-pro-tournament', // slug c·ªßa s·∫£n ph·∫©m
        quantity: 1,
        price: 850000,
        addedAt: new Date('2023-05-12T10:15:30.456Z'),
      },
      {
        product: 'gay-billiard-pro-series-x1', // slug c·ªßa s·∫£n ph·∫©m
        quantity: 1,
        price: 1500000,
        addedAt: new Date('2023-05-12T10:20:45.789Z'),
      },
    ],
    subtotal: 2350000,
    coupon: {
      code: 'SUMMER10',
      discount: 235000,
      appliedAt: new Date('2023-05-12T10:25:10.123Z'),
    },
    status: 'active',
    createdAt: new Date('2023-05-12T10:15:30.456Z'),
    updatedAt: new Date('2023-05-12T10:25:10.123Z'),
    lastActivity: new Date('2023-05-12T10:25:10.123Z'),
  },
  {
    sessionId: 'sess_12345abcde67890fghijk',
    items: [
      {
        product: 'ban-billiard-champion-9ft', // slug c·ªßa s·∫£n ph·∫©m
        quantity: 1,
        price: 45000000,
        addedAt: new Date('2023-05-15T14:45:20.321Z'),
      },
    ],
    subtotal: 45000000,
    status: 'active',
    createdAt: new Date('2023-05-15T14:45:20.321Z'),
    updatedAt: new Date('2023-05-15T14:45:20.321Z'),
    lastActivity: new Date('2023-05-15T14:45:20.321Z'),
    expiresAt: new Date('2023-05-22T14:45:20.321Z'), // 7 ng√†y sau
  },
];


--- File: server/src/seeds/data/categories.js ---
// server/src/seeds/data/categories.js

module.exports = [
  {
    name: 'G·∫≠y Billiard',
    slug: 'gay-billiard',
    description: 'T·∫•t c·∫£ c√°c lo·∫°i g·∫≠y billiard ch·∫•t l∆∞·ª£ng cao',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/gays-billiard.jpg',
      alt: 'B·ªô s∆∞u t·∫≠p g·∫≠y billiard',
    },
    icon: 'cue-stick-icon',
    color: '#3498db',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'G·∫≠y Billiard Chuy√™n Nghi·ªáp',
    slug: 'gay-billiard-chuyen-nghiep',
    description: 'G·∫≠y billiard d√†nh cho ng∆∞·ªùi ch∆°i chuy√™n nghi·ªáp',
    level: 1,
    image: {
      url: '/assets/categories/gay-chuyen-nghiep.jpg',
      alt: 'G·∫≠y billiard chuy√™n nghi·ªáp',
    },
    icon: 'pro-cue-icon',
    color: '#2980b9',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: false,
  },
  {
    name: 'Bi-a',
    slug: 'bi-a',
    description: 'C√°c lo·∫°i bi-a ch√≠nh h√£ng',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/bi-a.jpg',
      alt: 'Bi-a c√°c lo·∫°i',
    },
    icon: 'ball-icon',
    color: '#e74c3c',
    order: 2,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'Ph·ª• Ki·ªán',
    slug: 'phu-kien',
    description: 'Ph·ª• ki·ªán cho c√°c lo·∫°i g·∫≠y v√† b√†n billiard',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/phu-kien.jpg',
      alt: 'Ph·ª• ki·ªán billiard',
    },
    icon: 'accessories-icon',
    color: '#f39c12',
    order: 3,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'B√†n Billiard',
    slug: 'ban-billiard',
    description: 'C√°c lo·∫°i b√†n billiard nh·∫≠p kh·∫©u',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/ban-billiard.jpg',
      alt: 'B√†n billiard',
    },
    icon: 'table-icon',
    color: '#27ae60',
    order: 4,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
];


--- File: server/src/seeds/data/orders.js ---
// server/src/seeds/data/orders.js

module.exports = [
  {
    orderNumber: 'RO-2023-0001',
    customerInfo: {
      name: 'Nguy·ªÖn VƒÉn A',
      email: 'nguyenvana@example.com',
      phone: '0901234567',
    },
    items: [
      {
        product: 'gay-billiard-pro-series-x1', // slug c·ªßa s·∫£n ph·∫©m
        name: 'G·∫≠y Billiard Pro Series X1',
        price: 1500000,
        quantity: 1,
        totalPrice: 1500000,
        discount: 0,
      },
    ],
    subtotal: 1500000,
    shippingCost: 30000,
    tax: 0,
    discount: {
      amount: 100000,
      code: 'WELCOME10',
    },
    totalAmount: 1430000,
    shippingAddress: {
      name: 'Nguy·ªÖn VƒÉn A',
      phone: '0901234567',
      street: '123 Nguy·ªÖn Hu·ªá',
      city: 'H·ªì Ch√≠ Minh',
      state: '',
      zipCode: '70000',
      country: 'Vi·ªát Nam',
      notes: 'Giao h√†ng v√†o bu·ªïi s√°ng',
    },
    shippingMethod: 'standard',
    paymentMethod: 'cod',
    paymentStatus: 'pending',
    status: 'processing',
    statusHistory: [
      {
        status: 'pending',
        date: new Date('2023-03-15T08:30:15.123Z'),
        note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o',
      },
      {
        status: 'processing',
        date: new Date('2023-03-15T09:45:30.456Z'),
        note: 'ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω',
      },
    ],
    customerNotes: 'Vui l√≤ng g·ªçi tr∆∞·ªõc khi giao h√†ng',
    createdAt: new Date('2023-03-15T08:30:15.123Z'),
    updatedAt: new Date('2023-03-15T09:45:30.456Z'),
  },
  {
    orderNumber: 'RO-2023-0002',
    customerInfo: {
      name: 'Tr·∫ßn Th·ªã B',
      email: 'tranthib@example.com',
      phone: '0912345678',
    },
    items: [
      {
        product: 'bo-bi-a-pro-tournament', // slug c·ªßa s·∫£n ph·∫©m
        name: 'B·ªô Bi-a Pro Tournament',
        price: 850000,
        quantity: 1,
        totalPrice: 850000,
        discount: 0,
      },
      {
        product: 'gay-billiard-pro-series-x1', // slug c·ªßa s·∫£n ph·∫©m
        name: 'G·∫≠y Billiard Pro Series X1',
        price: 1500000,
        quantity: 1,
        totalPrice: 1500000,
        discount: 0,
      },
    ],
    subtotal: 2350000,
    shippingCost: 50000,
    tax: 0,
    totalAmount: 2400000,
    shippingAddress: {
      name: 'Tr·∫ßn Th·ªã B',
      phone: '0912345678',
      street: '101 L√™ Du·∫©n',
      city: 'ƒê√† N·∫µng',
      state: '',
      zipCode: '50000',
      country: 'Vi·ªát Nam',
    },
    shippingMethod: 'express',
    paymentMethod: 'bank_transfer',
    paymentStatus: 'paid',
    status: 'delivered',
    statusHistory: [
      {
        status: 'pending',
        date: new Date('2023-03-20T10:15:20.123Z'),
        note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o',
      },
      {
        status: 'processing',
        date: new Date('2023-03-20T11:30:45.456Z'),
        note: 'ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω',
      },
      {
        status: 'shipped',
        date: new Date('2023-03-21T09:15:30.789Z'),
        note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao cho ƒë∆°n v·ªã v·∫≠n chuy·ªÉn',
      },
      {
        status: 'delivered',
        date: new Date('2023-03-22T14:20:10.321Z'),
        note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao th√†nh c√¥ng',
      },
    ],
    createdAt: new Date('2023-03-20T10:15:20.123Z'),
    updatedAt: new Date('2023-03-22T14:20:10.321Z'),
    completedAt: new Date('2023-03-22T14:20:10.321Z'),
  },
];


--- File: server/src/seeds/data/products.js ---
// server/src/seeds/data/products.js

module.exports = [
  {
    name: 'G·∫≠y Billiard Pro Series X1',
    slug: 'gay-billiard-pro-series-x1',
    description: {
      short: 'G·∫≠y billiard chuy√™n nghi·ªáp v·ªõi tr·ªçng l∆∞·ª£ng c√¢n b·∫±ng ho√†n h·∫£o',
      long: 'G·∫≠y billiard Pro Series X1 ƒë∆∞·ª£c thi·∫øt k·∫ø d√†nh cho ng∆∞·ªùi ch∆°i chuy√™n nghi·ªáp, v·ªõi th√¢n g·∫≠y l√†m t·ª´ g·ªó s·ªìi cao c·∫•p v√† ƒë·∫ßu tip c·ª©ng. S·∫£n ph·∫©m mang l·∫°i ƒë·ªô ch√≠nh x√°c v√† c·∫£m gi√°c tuy·ªát v·ªùi khi ch∆°i.',
    },
    category: 'gay-billiard-chuyen-nghiep', // slug c·ªßa danh m·ª•c
    brand: 'ProCue',
    manufacturer: 'Billiard Master',
    countryOfOrigin: 'USA',
    price: 1500000,
    stock: 15,
    sku: 'PC-X1-001',
    images: [
      {
        url: '/assets/products/pc-x1-001-main.jpg',
        alt: 'G·∫≠y Billiard Pro Series X1 - H√¨nh ch√≠nh',
        isPrimary: true,
      },
      {
        url: '/assets/products/pc-x1-001-angle.jpg',
        alt: 'G·∫≠y Billiard Pro Series X1 - G√≥c nh√¨n kh√°c',
        isPrimary: false,
      },
    ],
    features: [
      'Th√¢n g·∫≠y l√†m t·ª´ g·ªó s·ªìi cao c·∫•p',
      'ƒê·∫ßu tip c·ª©ng ƒë·ªô b·ªÅn cao',
      'Tr·ªçng l∆∞·ª£ng c√¢n b·∫±ng ho√†n h·∫£o',
      'Tay c·∫ßm ch·ªëng tr∆∞·ª£t',
    ],
    specifications: {
      weight: 567,
      length: 147,
      diameter: 13,
      material: 'G·ªó s·ªìi',
      tipSize: '13mm',
      wrap: 'Irish linen',
    },
    isActive: true,
    isPromoted: true,
    isFeatured: true,
  },
  {
    name: 'B·ªô Bi-a Pro Tournament',
    slug: 'bo-bi-a-pro-tournament',
    description: {
      short: 'B·ªô bi-a ti√™u chu·∫©n gi·∫£i ƒë·∫•u chuy√™n nghi·ªáp',
      long: 'B·ªô bi-a Pro Tournament ƒë∆∞·ª£c s·∫£n xu·∫•t v·ªõi ƒë·ªô ch√≠nh x√°c cao, ƒë·∫°t ti√™u chu·∫©n gi·∫£i ƒë·∫•u qu·ªëc t·∫ø. C√°c vi√™n bi ƒë∆∞·ª£c l√†m t·ª´ nh·ª±a phenolic ch·∫•t l∆∞·ª£ng cao, ƒë·∫£m b·∫£o ƒë·ªô b·ªÅn v√† ƒë·ªô ch√≠nh x√°c trong m·ªçi pha ch∆°i.',
    },
    category: 'bi-a', // slug c·ªßa danh m·ª•c
    brand: 'ProGame',
    manufacturer: 'Aramith',
    countryOfOrigin: 'Belgium',
    price: 850000,
    stock: 10,
    sku: 'PB-T1-001',
    images: [
      {
        url: '/assets/products/pb-t1-001-main.jpg',
        alt: 'B·ªô Bi-a Pro Tournament - H√¨nh ch√≠nh',
        isPrimary: true,
      },
    ],
    features: [
      'Ti√™u chu·∫©n gi·∫£i ƒë·∫•u qu·ªëc t·∫ø',
      'L√†m t·ª´ nh·ª±a phenolic cao c·∫•p',
      'ƒê·ªô ch√≠nh x√°c cao',
      'Bao g·ªìm 16 vi√™n bi',
    ],
    specifications: {
      material: 'Phenolic resin',
      weight: 170,
      diameter: 57.2,
      set: '16 balls',
    },
    isActive: true,
    isPromoted: true,
    isFeatured: false,
  },
  {
    name: 'B√†n Billiard Champion 9ft',
    slug: 'ban-billiard-champion-9ft',
    description: {
      short: 'B√†n billiard cao c·∫•p 9ft d√†nh cho c√°c c√¢u l·∫°c b·ªô chuy√™n nghi·ªáp',
      long: 'B√†n Billiard Champion 9ft ƒë∆∞·ª£c thi·∫øt k·∫ø d√†nh cho c√°c c√¢u l·∫°c b·ªô v√† gi·∫£i ƒë·∫•u chuy√™n nghi·ªáp. B√†n ƒë∆∞·ª£c l√†m t·ª´ g·ªó s·ªìi M·ªπ cao c·∫•p, khung b√†n v·ªØng ch·∫Øc v√† m·∫∑t b√†n ƒë∆∞·ª£c ph·ªß v·∫£i wool-nylon blend cao c·∫•p ƒë·∫£m b·∫£o ƒë·ªô b·ªÅn v√† c·∫£m gi√°c ch∆°i tuy·ªát v·ªùi.',
    },
    category: 'ban-billiard', // slug c·ªßa danh m·ª•c
    brand: 'Champion',
    manufacturer: 'Billiard Master',
    countryOfOrigin: 'USA',
    price: 45000000,
    stock: 3,
    sku: 'BT-C9-001',
    images: [
      {
        url: '/assets/products/bt-c9-001-main.jpg',
        alt: 'B√†n Billiard Champion 9ft - H√¨nh ch√≠nh',
        isPrimary: true,
      },
      {
        url: '/assets/products/bt-c9-001-angle.jpg',
        alt: 'B√†n Billiard Champion 9ft - G√≥c nh√¨n kh√°c',
        isPrimary: false,
      },
    ],
    features: [
      'K√≠ch th∆∞·ªõc chu·∫©n 9ft',
      'L√†m t·ª´ g·ªó s·ªìi M·ªπ cao c·∫•p',
      'M·∫∑t b√†n ph·ªß v·∫£i wool-nylon blend',
      'Khung b√†n v·ªØng ch·∫Øc',
    ],
    specifications: {
      length: 274,
      width: 137,
      height: 79,
      frameType: '1-piece slate',
      clothType: 'Championship wool-nylon blend',
      railCushions: 'K-66 profile',
    },
    isActive: true,
    isPromoted: false,
    isFeatured: true,
  },
];


--- File: server/src/seeds/data/reviews.js ---
// server/src/seeds/data/reviews.js

module.exports = [
  {
    product: 'gay-billiard-pro-series-x1', // slug c·ªßa s·∫£n ph·∫©m
    user: 'nguyenvana@example.com', // email c·ªßa user
    rating: 5,
    title: 'S·∫£n ph·∫©m tuy·ªát v·ªùi, ƒë√°ng ƒë·ªìng ti·ªÅn',
    review:
      'G·∫≠y billiard Pro Series X1 c√≥ ch·∫•t l∆∞·ª£ng r·∫•t t·ªët, c√¢n b·∫±ng ho√†n h·∫£o v√† cho c·∫£m gi√°c r·∫•t tho·∫£i m√°i khi ch∆°i. T√¥i ƒë·∫∑c bi·ªát th√≠ch ch·∫•t li·ªáu g·ªó s·ªìi cao c·∫•p v√† ƒë·∫ßu tip c·ª©ng. Sau khi s·ª≠ d·ª•ng, t√¥i c·∫£m th·∫•y k·ªπ nƒÉng ch∆°i c·ªßa m√¨nh c≈©ng ƒë∆∞·ª£c c·∫£i thi·ªán ƒë√°ng k·ªÉ. R·∫•t h√†i l√≤ng v·ªõi s·∫£n ph·∫©m n√†y!',
    images: [
      {
        url: '/assets/reviews/review-1-1.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-1-1.jpg',
        caption: 'G·∫≠y billiard sau 2 tu·∫ßn s·ª≠ d·ª•ng',
      },
    ],
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 12,
      downvotes: 1,
    },
    isVisible: true,
    createdAt: new Date('2023-03-25T10:15:20.123Z'),
    updatedAt: new Date('2023-03-25T10:15:20.123Z'),
  },
  {
    product: 'bo-bi-a-pro-tournament', // slug c·ªßa s·∫£n ph·∫©m
    user: 'tranthib@example.com', // email c·ªßa user
    rating: 4,
    title: 'B·ªô bi-a ch·∫•t l∆∞·ª£ng t·ªët',
    review:
      'B·ªô bi-a Pro Tournament c√≥ ch·∫•t l∆∞·ª£ng r·∫•t t·ªët, ƒë√∫ng nh∆∞ m√¥ t·∫£. C√°c vi√™n bi c√≥ tr·ªçng l∆∞·ª£ng c√¢n ƒë·ªëi, m√†u s·∫Øc t∆∞∆°i s√°ng. Tuy nhi√™n, h·ªôp ƒë·ª±ng kh√¥ng ƒë∆∞·ª£c ch·∫Øc ch·∫Øn l·∫Øm n√™n ch·ªâ ƒë√°nh gi√° 4 sao.',
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 8,
      downvotes: 0,
    },
    isVisible: true,
    createdAt: new Date('2023-03-28T15:45:30.456Z'),
    updatedAt: new Date('2023-03-28T15:45:30.456Z'),
  },
  {
    product: 'ban-billiard-champion-9ft', // slug c·ªßa s·∫£n ph·∫©m
    user: 'levanc@example.com', // email c·ªßa user
    rating: 5,
    title: 'B√†n billiard ƒë·∫≥ng c·∫•p chuy√™n nghi·ªáp',
    review:
      'B√†n billiard Champion 9ft th·ª±c s·ª± x·ª©ng ƒë√°ng v·ªõi gi√° ti·ªÅn. M·∫∑t b√†n c·ª±c k·ª≥ ph·∫≥ng, vi√™n bi lƒÉn r·∫•t m∆∞·ª£t m√† v√† ch√≠nh x√°c. Khung b√†n v·ªØng ch·∫Øc, thi·∫øt k·∫ø sang tr·ªçng v√† ƒë·∫≥ng c·∫•p. T√¥i ƒë√£ mua cho c√¢u l·∫°c b·ªô c·ªßa m√¨nh v√† t·∫•t c·∫£ c√°c th√†nh vi√™n ƒë·ªÅu r·∫•t h√†i l√≤ng v·ªõi s·∫£n ph·∫©m n√†y.',
    images: [
      {
        url: '/assets/reviews/review-3-1.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-3-1.jpg',
        caption: 'B√†n billiard trong c√¢u l·∫°c b·ªô c·ªßa t√¥i',
      },
      {
        url: '/assets/reviews/review-3-2.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-3-2.jpg',
        caption: 'Chi ti·∫øt g√≥c b√†n',
      },
    ],
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 20,
      downvotes: 0,
    },
    isVisible: true,
    createdAt: new Date('2023-04-05T09:30:15.789Z'),
    updatedAt: new Date('2023-04-05T09:30:15.789Z'),
  },
];


--- File: server/src/seeds/data/users.js ---
// server/src/seeds/data/users.js

module.exports = [
  {
    name: 'Admin User',
    email: 'admin@runout-biliard.com',
    password: 'Admin@123', // S·∫Ω ƒë∆∞·ª£c hash tr∆∞·ªõc khi l∆∞u v√†o database
    role: 'admin',
    phone: '0901234567',
    address: {
      street: '123 Nguy·ªÖn Hu·ªá',
      city: 'H·ªì Ch√≠ Minh',
      state: '',
      zipCode: '70000',
      country: 'Vi·ªát Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Staff User',
    email: 'staff@runout-biliard.com',
    password: 'Staff@123',
    role: 'staff',
    phone: '0909876543',
    address: {
      street: '456 L√™ L·ª£i',
      city: 'H·ªì Ch√≠ Minh',
      state: '',
      zipCode: '70000',
      country: 'Vi·ªát Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Nguy·ªÖn VƒÉn A',
    email: 'nguyenvana@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0901234567',
    address: {
      street: '789 Tr·∫ßn H∆∞ng ƒê·∫°o',
      city: 'H√† N·ªôi',
      state: '',
      zipCode: '10000',
      country: 'Vi·ªát Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Tr·∫ßn Th·ªã B',
    email: 'tranthib@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0912345678',
    address: {
      street: '101 L√™ Du·∫©n',
      city: 'ƒê√† N·∫µng',
      state: '',
      zipCode: '50000',
      country: 'Vi·ªát Nam',
    },
    isActive: true,
    emailVerified: false,
  },
  {
    name: 'L√™ VƒÉn C',
    email: 'levanc@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0923456789',
    address: {
      street: '202 Nguy·ªÖn VƒÉn Linh',
      city: 'C·∫ßn Th∆°',
      state: '',
      zipCode: '90000',
      country: 'Vi·ªát Nam',
    },
    isActive: true,
    emailVerified: true,
  },
];


--- File: server/src/seeds/index.js ---
// server/src/data/seeds/index.js
const { seedUsers } = require('./scripts/userSeeder');
const { seedCategories } = require('./scripts/categorySeeder');
const { seedProducts } = require('./scripts/productSeeder');
const { seedOrders } = require('./scripts/orderSeeder');
const { seedReviews } = require('./scripts/reviewSeeder');
const { seedCarts } = require('./scripts/cartSeeder');
const logger = require('../config/logger');

const runSeeds = async () => {
  try {
    logger.info('Starting database seeding...');

    // Th·ª© t·ª± ch·∫°y seed quan tr·ªçng do c√°c dependencies
    await seedUsers();
    await seedCategories();
    await seedProducts();
    await seedOrders();
    await seedReviews();
    await seedCarts();

    logger.info('All database seeding completed successfully');
  } catch (error) {
    logger.error('Error running seeds', error);
    throw error;
  }
};

module.exports = { runSeeds };


--- File: server/src/seeds/runner.js ---
// server/src/seeds/runner.js
const User = require('../data/models/user.model');
const Category = require('../data/models/category.model');
const Product = require('../data/models/product.model');
const Order = require('../data/models/order.model');
const Review = require('../data/models/review.model');

const users = require('./data/users');
const categories = require('./data/categories');
const products = require('./data/products');
const orders = require('./data/orders');
const reviews = require('./data/reviews');

class SeedRunner {
  async run(environment = 'development') {
    try {
      console.log(`Seeding database for ${environment} environment...`);

      // X√≥a d·ªØ li·ªáu c≈© (ch·ªâ trong m√¥i tr∆∞·ªùng development v√† testing)
      if (['development', 'testing'].includes(environment)) {
        await this.clearDatabase();
      }

      // Seed c√°c collections
      const createdUsers = await this.seedUsers();
      const createdCategories = await this.seedCategories();

      // Seed products v·ªõi references ƒë·∫øn categories
      const productData = this.prepareProducts(createdCategories);
      const createdProducts = await this.seedProducts(productData);

      // Seed orders v√† reviews v·ªõi references ƒë·∫øn users v√† products
      await this.seedOrders(createdUsers, createdProducts);
      await this.seedReviews(createdUsers, createdProducts);

      console.log('Seeding completed successfully.');
    } catch (error) {
      console.error('Seeding failed:', error);
      throw error;
    }
  }

  async clearDatabase() {
    console.log('Clearing database...');
    await User.deleteMany({});
    await Category.deleteMany({});
    await Product.deleteMany({});
    await Order.deleteMany({});
    await Review.deleteMany({});
  }

  async seedUsers() {
    console.log('Seeding users...');
    return await User.insertMany(users);
  }

  async seedCategories() {
    console.log('Seeding categories...');
    return await Category.insertMany(categories);
  }

  prepareProducts(createdCategories) {
    console.log('Preparing product data with category references...');
    // G√°n category ID th·ª±c t·∫ø cho m·ªói s·∫£n ph·∫©m
    return products.map((product) => {
      // T√¨m category t∆∞∆°ng ·ª©ng d·ª±a tr√™n t√™n ho·∫∑c slug
      const category = createdCategories.find(
        (cat) => cat.name === product.categoryName || cat.slug === product.categorySlug
      );

      // N·∫øu t√¨m th·∫•y category, g√°n ID c·ªßa category ƒë√≥ cho s·∫£n ph·∫©m
      if (category) {
        return {
          ...product,
          category: category._id,
          // X√≥a c√°c tr∆∞·ªùng t·∫°m kh√¥ng c·∫ßn thi·∫øt
          categoryName: undefined,
          categorySlug: undefined,
        };
      }

      return product;
    });
  }

  async seedProducts(productData) {
    console.log('Seeding products...');
    return await Product.insertMany(productData);
  }

  async seedOrders(createdUsers, createdProducts) {
    console.log('Seeding orders...');

    // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë∆°n h√†ng v·ªõi references ƒë·∫øn users v√† products
    const preparedOrders = orders
      .map((order) => {
        // T√¨m user t∆∞∆°ng ·ª©ng
        const user = createdUsers.find((u) => u.email === order.userEmail);

        // Chu·∫©n b·ªã c√°c item trong ƒë∆°n h√†ng
        const items = order.items
          .map((item) => {
            // T√¨m product t∆∞∆°ng ·ª©ng
            const product = createdProducts.find((p) => p.sku === item.productSku);

            return {
              product: product ? product._id : null,
              quantity: item.quantity,
              price: item.price,
            };
          })
          .filter((item) => item.product !== null);

        return {
          user: user ? user._id : null,
          items: items,
          totalAmount: order.totalAmount,
          status: order.status,
          shippingAddress: order.shippingAddress,
          paymentMethod: order.paymentMethod,
          createdAt: order.createdAt || new Date(),
        };
      })
      .filter((order) => order.user !== null && order.items.length > 0);

    return await Order.insertMany(preparedOrders);
  }

  async seedReviews(createdUsers, createdProducts) {
    console.log('Seeding reviews...');

    // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë√°nh gi√° v·ªõi references ƒë·∫øn users v√† products
    const preparedReviews = reviews
      .map((review) => {
        // T√¨m user v√† product t∆∞∆°ng ·ª©ng
        const user = createdUsers.find((u) => u.email === review.userEmail);
        const product = createdProducts.find((p) => p.sku === review.productSku);

        if (user && product) {
          return {
            user: user._id,
            product: product._id,
            rating: review.rating,
            comment: review.comment,
            createdAt: review.createdAt || new Date(),
          };
        }
        return null;
      })
      .filter((review) => review !== null);

    return await Review.insertMany(preparedReviews);
  }
}

module.exports = new SeedRunner();


--- File: server/src/seeds/scripts/cartSeeder.js ---
// server/src/data/seeds/cartSeeds.js
const Cart = require('../data/carts');
const User = require('../data/users');
const Product = require('../data/products');
const logger = require('../../config/logger');

const seedCarts = async () => {
  try {
    // Ki·ªÉm tra xem ƒë√£ c√≥ carts trong DB ch∆∞a
    const count = await Cart.countDocuments();
    if (count > 0) {
      logger.info('Carts collection already seeded');
      return;
    }

    // L·∫•y m·ªôt s·ªë users v√† products ƒë·ªÉ t·∫°o carts
    const users = await User.find().limit(5);
    const products = await Product.find().limit(10);

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed carts: No users or products found');
      return;
    }

    const carts = [];

    // T·∫°o m·ªôt gi·ªè h√†ng cho m·ªói user
    for (const user of users) {
      // T·∫°o 1-4 items cho m·ªói gi·ªè h√†ng
      const itemCount = Math.floor(Math.random() * 4) + 1;
      const items = [];
      let subtotal = 0;

      for (let i = 0; i < itemCount; i++) {
        const product = products[Math.floor(Math.random() * products.length)];
        const quantity = Math.floor(Math.random() * 3) + 1;
        const price = product.price;

        items.push({
          product: product._id,
          quantity,
          price,
          attributes: {},
          addedAt: new Date(),
          updatedAt: new Date(),
        });

        subtotal += price * quantity;
      }

      const now = new Date();

      carts.push({
        user: user._id,
        items,
        subtotal,
        status: 'active',
        createdAt: now,
        updatedAt: now,
        lastActivity: now,
      });
    }

    // T·∫°o m·ªôt s·ªë gi·ªè h√†ng cho kh√°ch v√£ng lai
    for (let i = 0; i < 3; i++) {
      const itemCount = Math.floor(Math.random() * 3) + 1;
      const items = [];
      let subtotal = 0;

      for (let j = 0; j < itemCount; j++) {
        const product = products[Math.floor(Math.random() * products.length)];
        const quantity = Math.floor(Math.random() * 2) + 1;
        const price = product.price;

        items.push({
          product: product._id,
          quantity,
          price,
          attributes: {},
          addedAt: new Date(),
          updatedAt: new Date(),
        });

        subtotal += price * quantity;
      }

      const now = new Date();
      const expiryDate = new Date();
      expiryDate.setDate(now.getDate() + 7); // 7 ng√†y h·∫øt h·∫°n

      carts.push({
        sessionId: `sess_guest_${i}_${Date.now()}`,
        items,
        subtotal,
        status: 'active',
        createdAt: now,
        updatedAt: now,
        lastActivity: now,
        expiresAt: expiryDate,
      });
    }

    // L∆∞u v√†o database
    await Cart.insertMany(carts);
    logger.info(`Seeded ${carts.length} carts`);
  } catch (error) {
    logger.error('Error seeding carts', error);
    throw error;
  }
};

module.exports = { seedCarts };


--- File: server/src/seeds/scripts/categorySeeder.js ---
/**
 * Category Seeder
 * 
 * File n√†y t·∫°o d·ªØ li·ªáu m·∫´u cho c√°c danh m·ª•c s·∫£n ph·∫©m trong c·ª≠a h√†ng billiard
 * Bao g·ªìm c·∫£ danh m·ª•c ch√≠nh v√† danh m·ª•c con
 * File categorySeeder.js n√†y th·ª±c hi·ªán c√°c ch·ª©c nƒÉng sau:

ƒê·ªãnh nghƒ©a d·ªØ li·ªáu m·∫´u cho c√°c danh m·ª•c ch√≠nh v√† danh m·ª•c con
T·∫°o slugs t·ª± ƒë·ªông cho c√°c danh m·ª•c d·ª±a tr√™n t√™n
Thi·∫øt l·∫≠p m·ªëi quan h·ªá ph√¢n c·∫•p gi·ªØa danh m·ª•c ch√≠nh v√† danh m·ª•c con
Ki·ªÉm tra xem danh m·ª•c ƒë√£ t·ªìn t·∫°i tr∆∞·ªõc khi seed ƒë·ªÉ tr√°nh tr√πng l·∫∑p
Ghi log qu√° tr√¨nh seed ƒë·ªÉ d·ªÖ d√†ng debug
 */
// const mongoose = require('mongoose');
const Category = require('../../data/models/category.model');
const { slugify } = require('../../common/utils/formatters');
const logger = require('../../config/logger');

/**
 * D·ªØ li·ªáu m·∫´u cho danh m·ª•c ch√≠nh
 */
const mainCategories = [
  {
    name: 'G·∫≠y Billiard',
    description:
      'T·∫•t c·∫£ c√°c lo·∫°i g·∫≠y billiard ch·∫•t l∆∞·ª£ng cao t·ª´ c√°c th∆∞∆°ng hi·ªáu uy t√≠n trong v√† ngo√†i n∆∞·ªõc',
    image: {
      url: '/images/categories/gay-billiard.jpg',
      alt: 'G·∫≠y Billiard',
    },
    icon: 'cue-stick-icon',
    color: '#3498db',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'G·∫≠y Billiard Ch·∫•t L∆∞·ª£ng Cao | RunOut-Biliard',
      metaDescription:
        'Kh√°m ph√° b·ªô s∆∞u t·∫≠p g·∫≠y billiard ch·∫•t l∆∞·ª£ng cao cho ng∆∞·ªùi ch∆°i ·ªü m·ªçi tr√¨nh ƒë·ªô t·∫°i RunOut-Biliard',
      keywords: ['g·∫≠y billiard', 'g·∫≠y bida', 'c∆° bida', 'g·∫≠y ch∆°i bida'],
    },
    filters: [
      {
        name: 'Ch·∫•t li·ªáu',
        type: 'select',
        options: ['G·ªó s·ªìi', 'G·ªó th√≠ch', 'G·ªó maple', 'Composit'],
      },
      {
        name: 'Tr·ªçng l∆∞·ª£ng',
        type: 'range',
        min: 400,
        max: 700,
        unit: 'g',
      },
    ],
  },
  {
    name: 'Bi Billiard',
    description: 'C√°c b·ªô bi billiard ti√™u chu·∫©n qu·ªëc t·∫ø, ph√π h·ª£p cho m·ªçi lo·∫°i h√¨nh ch∆°i',
    image: {
      url: '/images/categories/bi-billiard.jpg',
      alt: 'Bi Billiard',
    },
    icon: 'billiard-ball-icon',
    color: '#e74c3c',
    order: 2,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'Bi Billiard Ch√≠nh H√£ng | RunOut-Biliard',
      metaDescription:
        'B·ªô s∆∞u t·∫≠p bi billiard ch·∫•t l∆∞·ª£ng cao, ƒë·∫°t ti√™u chu·∫©n qu·ªëc t·∫ø cho c√°c gi·∫£i ƒë·∫•u chuy√™n nghi·ªáp',
      keywords: ['bi billiard', 'bi bida', 'b·ªô bi bida', 'bi l·ªó', 'bi carom'],
    },
  },
  {
    name: 'Ph·ª• Ki·ªán',
    description: 'C√°c ph·ª• ki·ªán billiard ch·∫•t l∆∞·ª£ng cao, t·ª´ ph·∫•n, gƒÉng tay ƒë·∫øn t√∫i ƒë·ª±ng g·∫≠y',
    image: {
      url: '/images/categories/phu-kien.jpg',
      alt: 'Ph·ª• Ki·ªán Billiard',
    },
    icon: 'billiard-accessories-icon',
    color: '#2ecc71',
    order: 3,
    isActive: true,
    isVisible: true,
    isFeatured: false,
    seo: {
      metaTitle: 'Ph·ª• Ki·ªán Billiard | RunOut-Biliard',
      metaDescription:
        'ƒêa d·∫°ng ph·ª• ki·ªán billiard ch·∫•t l∆∞·ª£ng cao gi√∫p n√¢ng cao tr·∫£i nghi·ªám ch∆°i bida c·ªßa b·∫°n',
      keywords: ['ph·ª• ki·ªán billiard', 'ph·∫•n bida', 'gƒÉng tay bida', 't√∫i ƒë·ª±ng g·∫≠y'],
    },
  },
  {
    name: 'B√†n Billiard',
    description: 'C√°c lo·∫°i b√†n billiard cao c·∫•p cho gia ƒë√¨nh v√† kinh doanh',
    image: {
      url: '/images/categories/ban-billiard.jpg',
      alt: 'B√†n Billiard',
    },
    icon: 'billiard-table-icon',
    color: '#9b59b6',
    order: 4,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'B√†n Billiard Ch·∫•t L∆∞·ª£ng Cao | RunOut-Biliard',
      metaDescription:
        'B√†n billiard ch·∫•t l∆∞·ª£ng cao, ƒëa d·∫°ng k√≠ch th∆∞·ªõc v√† thi·∫øt k·∫ø cho gia ƒë√¨nh v√† kinh doanh',
      keywords: ['b√†n billiard', 'b√†n bida', 'b√†n bi-a', 'b√†n pool', 'b√†n carom'],
    },
  },
];

/**
 * D·ªØ li·ªáu m·∫´u cho danh m·ª•c con
 * M·ªói item trong m·∫£ng ƒë·∫°i di·ªán cho m·ªôt danh m·ª•c con c·ªßa m·ªôt danh m·ª•c ch√≠nh
 * parentName: t√™n c·ªßa danh m·ª•c cha
 */
const subCategories = [
  // Danh m·ª•c con c·ªßa "G·∫≠y Billiard"
  {
    name: 'G·∫≠y Billiard Cao C·∫•p',
    description: 'C√°c lo·∫°i g·∫≠y billiard cao c·∫•p d√†nh cho ng∆∞·ªùi ch∆°i chuy√™n nghi·ªáp',
    parentName: 'G·∫≠y Billiard',
    image: {
      url: '/images/categories/gay-billiard-cao-cap.jpg',
      alt: 'G·∫≠y Billiard Cao C·∫•p',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'G·∫≠y Billiard Ph·ªï Th√¥ng',
    description: 'C√°c lo·∫°i g·∫≠y billiard gi√° c·∫£ ph·∫£i chƒÉng cho ng∆∞·ªùi m·ªõi ch∆°i',
    parentName: 'G·∫≠y Billiard',
    image: {
      url: '/images/categories/gay-billiard-pho-thong.jpg',
      alt: 'G·∫≠y Billiard Ph·ªï Th√¥ng',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'G·∫≠y Billiard Thi ƒê·∫•u',
    description: 'C√°c lo·∫°i g·∫≠y billiard chuy√™n d·ª•ng cho thi ƒë·∫•u',
    parentName: 'G·∫≠y Billiard',
    image: {
      url: '/images/categories/gay-billiard-thi-dau.jpg',
      alt: 'G·∫≠y Billiard Thi ƒê·∫•u',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh m·ª•c con c·ªßa "Bi Billiard"
  {
    name: 'Bi Pool',
    description: 'B·ªô bi d√†nh cho billiard l·ªó (Pool)',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-pool.jpg',
      alt: 'Bi Pool',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bi Carom',
    description: 'B·ªô bi d√†nh cho billiard kh√¥ng l·ªó (Carom)',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-carom.jpg',
      alt: 'Bi Carom',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bi Snooker',
    description: 'B·ªô bi d√†nh cho billiard snooker',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-snooker.jpg',
      alt: 'Bi Snooker',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh m·ª•c con c·ªßa "Ph·ª• Ki·ªán"
  {
    name: 'Ph·∫•n Billiard',
    description: 'C√°c lo·∫°i ph·∫•n billiard ch·∫•t l∆∞·ª£ng cao',
    parentName: 'Ph·ª• Ki·ªán',
    image: {
      url: '/images/categories/phan-billiard.jpg',
      alt: 'Ph·∫•n Billiard',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'GƒÉng Tay',
    description: 'GƒÉng tay billiard gi√∫p tƒÉng ƒë·ªô ch√≠nh x√°c',
    parentName: 'Ph·ª• Ki·ªán',
    image: {
      url: '/images/categories/gang-tay.jpg',
      alt: 'GƒÉng Tay Billiard',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'T√∫i ƒê·ª±ng G·∫≠y',
    description: 'C√°c lo·∫°i t√∫i ƒë·ª±ng g·∫≠y billiard ƒëa d·∫°ng k√≠ch th∆∞·ªõc',
    parentName: 'Ph·ª• Ki·ªán',
    image: {
      url: '/images/categories/tui-dung-gay.jpg',
      alt: 'T√∫i ƒê·ª±ng G·∫≠y Billiard',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh m·ª•c con c·ªßa "B√†n Billiard"
  {
    name: 'B√†n Pool',
    description: 'B√†n billiard l·ªó ti√™u chu·∫©n qu·ªëc t·∫ø',
    parentName: 'B√†n Billiard',
    image: {
      url: '/images/categories/ban-pool.jpg',
      alt: 'B√†n Pool',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'B√†n Carom',
    description: 'B√†n billiard kh√¥ng l·ªó chuy√™n nghi·ªáp',
    parentName: 'B√†n Billiard',
    image: {
      url: '/images/categories/ban-carom.jpg',
      alt: 'B√†n Carom',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'B√†n Snooker',
    description: 'B√†n billiard snooker ƒë·∫°t ti√™u chu·∫©n thi ƒë·∫•u',
    parentName: 'B√†n Billiard',
    image: {
      url: '/images/categories/ban-snooker.jpg',
      alt: 'B√†n Snooker',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },
];

/**
 * H√†m seed danh m·ª•c ch√≠nh
 */
const seedMainCategories = async () => {
  logger.info('Seeding main categories...');

  try {
    // X√≥a t·∫•t c·∫£ danh m·ª•c hi·ªán c√≥ n·∫øu c·∫ßn thi·∫øt
    // await Category.deleteMany({});

    // Th√™m tr∆∞·ªùng slug v√† timestamps cho m·ªói danh m·ª•c
    const mainCategoriesWithSlug = mainCategories.map((category) => ({
      ...category,
      slug: slugify(category.name),
      ancestors: [],
      level: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
    }));

    // Ch√®n danh m·ª•c v√†o database
    await Category.insertMany(mainCategoriesWithSlug);

    logger.info(`Seeded ${mainCategoriesWithSlug.length} main categories successfully!`);
    return mainCategoriesWithSlug;
  } catch (error) {
    logger.error('Error seeding main categories:', error);
    throw error;
  }
};

/**
 * H√†m seed danh m·ª•c con
 */
const seedSubCategories = async (mainCategoriesData) => {
  logger.info('Seeding sub categories...');

  try {
    // Chu·∫©n b·ªã danh m·ª•c con v·ªõi slug, parent, ancestors v√† level
    const subcategoriesWithDetails = [];

    for (const subCategory of subCategories) {
      // T√¨m danh m·ª•c cha t∆∞∆°ng ·ª©ng
      const parent = mainCategoriesData.find((cat) => cat.name === subCategory.parentName);

      if (!parent) {
        logger.warn(
          `Parent category "${subCategory.parentName}" not found for "${subCategory.name}"`
        );
        continue;
      }

      // Chu·∫©n b·ªã th√¥ng tin danh m·ª•c con
      const subCategoryWithDetails = {
        ...subCategory,
        slug: slugify(subCategory.name),
        parent: parent._id,
        ancestors: [
          {
            _id: parent._id,
            name: parent.name,
            slug: parent.slug,
          },
        ],
        level: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // Lo·∫°i b·ªè tr∆∞·ªùng parentName v√¨ kh√¥ng c·∫ßn thi·∫øt n·ªØa
      delete subCategoryWithDetails.parentName;

      subcategoriesWithDetails.push(subCategoryWithDetails);
    }

    // Ch√®n danh m·ª•c con v√†o database
    await Category.insertMany(subcategoriesWithDetails);

    logger.info(`Seeded ${subcategoriesWithDetails.length} sub categories successfully!`);
  } catch (error) {
    logger.error('Error seeding sub categories:', error);
    throw error;
  }
};

/**
 * H√†m ch√≠nh ƒë·ªÉ seed t·∫•t c·∫£ danh m·ª•c
 */
const seedCategories = async () => {
  try {
    logger.info('Starting category seeding process...');

    // Ki·ªÉm tra xem ƒë√£ c√≥ danh m·ª•c n√†o ch∆∞a
    const existingCategories = await Category.countDocuments();

    if (existingCategories > 0) {
      logger.info(`Found ${existingCategories} existing categories. Skipping seeding process.`);
      return;
    }

    // Seed danh m·ª•c ch√≠nh tr∆∞·ªõc
    const mainCategoriesData = await seedMainCategories();

    // Seed danh m·ª•c con sau khi ƒë√£ c√≥ danh m·ª•c ch√≠nh
    await seedSubCategories(mainCategoriesData);

    logger.info('Category seeding completed successfully!');
  } catch (error) {
    logger.error('Category seeding failed:', error);
    throw error;
  }
};

module.exports = seedCategories;
/**
 * Ch·∫°y script n√†y ƒë·ªÉ seed danh m·ª•c v√†o database
 * S·ª≠ d·ª•ng l·ªánh: node src/seeds/scripts/categorySeeder.js
 * ƒê·∫£m b·∫£o ƒë√£ k·∫øt n·ªëi v·ªõi MongoDB tr∆∞·ªõc khi ch·∫°y script n√†y
 */


--- File: server/src/seeds/scripts/orderSeeder.js ---
// server/src/data/seeds/orderSeeds.js
// const mongoose = require('mongoose');
const Order = require('../data/orders');
const User = require('../data/users');
const Product = require('../data/products');
const logger = require('../../config/logger');

const seedOrders = async () => {
  try {
    // Ki·ªÉm tra xem ƒë√£ c√≥ orders trong DB ch∆∞a
    const count = await Order.countDocuments();
    if (count > 0) {
      logger.info('Orders collection already seeded');
      return;
    }

    // L·∫•y m·ªôt s·ªë users v√† products ƒë·ªÉ t·∫°o orders
    const users = await User.find().limit(5);
    const products = await Product.find().limit(10);

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed orders: No users or products found');
      return;
    }

    const orders = [];

    // T·∫°o m·ªôt s·ªë orders m·∫´u
    for (let i = 0; i < users.length; i++) {
      const user = users[i];
      // T·∫°o 1-3 orders cho m·ªói user
      const orderCount = Math.floor(Math.random() * 3) + 1;

      for (let j = 0; j < orderCount; j++) {
        // T·∫°o items cho order
        const itemCount = Math.floor(Math.random() * 3) + 1;
        const items = [];
        let subtotal = 0;

        for (let k = 0; k < itemCount; k++) {
          const product = products[Math.floor(Math.random() * products.length)];
          const quantity = Math.floor(Math.random() * 3) + 1;
          const price = product.price;
          const totalPrice = price * quantity;

          items.push({
            product: product._id,
            name: product.name,
            price,
            quantity,
            totalPrice,
            attributes: {},
            sku: `SKU-${product._id.toString().substr(-6)}`,
            image: product.images && product.images.length > 0 ? product.images[0].url : '',
          });

          subtotal += totalPrice;
        }

        const shippingCost = 30000;
        const totalAmount = subtotal + shippingCost;

        const statuses = ['pending', 'processing', 'shipped', 'delivered'];
        const status = statuses[Math.floor(Math.random() * statuses.length)];

        const createdAt = new Date();
        createdAt.setDate(createdAt.getDate() - Math.floor(Math.random() * 30));

        orders.push({
          orderNumber: `RO-${2025}-${String(i * 3 + j + 1).padStart(4, '0')}`,
          user: user._id,
          customerInfo: {
            name: user.name,
            email: user.email,
            phone: user.phone || '0901234567',
          },
          items,
          subtotal,
          shippingCost,
          tax: 0,
          totalAmount,
          shippingAddress: {
            name: user.name,
            phone: user.phone || '0901234567',
            street: user.address?.street || '123 Nguy·ªÖn Hu·ªá',
            city: user.address?.city || 'H·ªì Ch√≠ Minh',
            state: user.address?.state || '',
            zipCode: user.address?.zipCode || '70000',
            country: user.address?.country || 'Vi·ªát Nam',
          },
          shippingMethod: 'standard',
          paymentMethod: 'cod',
          paymentStatus: status === 'delivered' ? 'paid' : 'pending',
          status,
          statusHistory: [
            {
              status: 'pending',
              date: createdAt,
              note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o',
            },
            ...(status !== 'pending'
              ? [
                  {
                    status: 'processing',
                    date: new Date(createdAt.getTime() + 86400000),
                    note: 'ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω',
                  },
                ]
              : []),
            ...(status === 'shipped' || status === 'delivered'
              ? [
                  {
                    status: 'shipped',
                    date: new Date(createdAt.getTime() + 86400000 * 2),
                    note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao cho ƒë∆°n v·ªã v·∫≠n chuy·ªÉn',
                  },
                ]
              : []),
            ...(status === 'delivered'
              ? [
                  {
                    status: 'delivered',
                    date: new Date(createdAt.getTime() + 86400000 * 4),
                    note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao th√†nh c√¥ng',
                  },
                ]
              : []),
          ],
          createdAt,
          updatedAt: createdAt,
          ...(status === 'delivered'
            ? { completedAt: new Date(createdAt.getTime() + 86400000 * 4) }
            : {}),
        });
      }
    }

    // L∆∞u v√†o database
    await Order.insertMany(orders);
    logger.info(`Seeded ${orders.length} orders`);
  } catch (error) {
    logger.error('Error seeding orders', error);
    throw error;
  }
};

module.exports = { seedOrders };


--- File: server/src/seeds/scripts/productSeeder.js ---
// server/src/seeds/productSeeder.js

const Product = require('../data/products');
const Category = require('../data/categories');
// const mongoose = require('mongoose');

async function seedProducts() {
  console.log('Seeding products...');

  // X√≥a t·∫•t c·∫£ s·∫£n ph·∫©m hi·ªán c√≥ (ch·ªâ d√πng trong development)
  if (process.env.NODE_ENV !== 'production') {
    await Product.deleteMany({});
  }

  // L·∫•y ID c√°c danh m·ª•c
  const gayChuyenNghiepCategory = await Category.findOne({ slug: 'gay-billiard-chuyen-nghiep' });
  const gayPhoThongCategory = await Category.findOne({ slug: 'gay-billiard-pho-thong' });
  const biCategory = await Category.findOne({ slug: 'bi-billiard' });

  if (!gayChuyenNghiepCategory || !gayPhoThongCategory || !biCategory) {
    console.error('Categories not found. Please run category seeder first.');
    return;
  }

  // T·∫°o s·∫£n ph·∫©m m·∫´u
  const sampleProducts = [
    {
      name: 'G·∫≠y Billiard Pro Series X1',
      slug: 'gay-billiard-pro-series-x1',
      description: {
        short: 'G·∫≠y billiard chuy√™n nghi·ªáp v·ªõi tr·ªçng l∆∞·ª£ng c√¢n b·∫±ng ho√†n h·∫£o',
        long: 'G·∫≠y billiard Pro Series X1 ƒë∆∞·ª£c thi·∫øt k·∫ø d√†nh cho ng∆∞·ªùi ch∆°i chuy√™n nghi·ªáp, v·ªõi th√¢n g·∫≠y l√†m t·ª´ g·ªó s·ªìi cao c·∫•p v√† ƒë·∫ßu tip c·ª©ng. S·∫£n ph·∫©m mang l·∫°i ƒë·ªô ch√≠nh x√°c v√† c·∫£m gi√°c tuy·ªát v·ªùi khi ch∆°i.',
      },
      category: gayChuyenNghiepCategory._id,
      brand: 'ProCue',
      manufacturer: 'Billiard Master',
      countryOfOrigin: 'USA',
      price: 1500000,
      stock: 15,
      sku: 'PC-X1-001',
      images: [
        {
          url: 'https://example.com/products/pc-x1-001-main.jpg',
          alt: 'G·∫≠y Billiard Pro Series X1 - H√¨nh ch√≠nh',
          isPrimary: true,
        },
      ],
      features: [
        'Th√¢n g·∫≠y l√†m t·ª´ g·ªó s·ªìi cao c·∫•p',
        'ƒê·∫ßu tip c·ª©ng ƒë·ªô b·ªÅn cao',
        'Tr·ªçng l∆∞·ª£ng c√¢n b·∫±ng ho√†n h·∫£o',
        'Tay c·∫ßm ch·ªëng tr∆∞·ª£t',
      ],
      specifications: {
        weight: 567,
        length: 147,
        diameter: 13,
        material: 'G·ªó s·ªìi',
        tipSize: '13mm',
        wrap: 'Irish linen',
      },
      isActive: true,
      isPromoted: true,
      isFeatured: true,
    },
    {
      name: 'G·∫≠y Billiard Starter S1',
      slug: 'gay-billiard-starter-s1',
      description: {
        short: 'G·∫≠y billiard ph·ªï th√¥ng d√†nh cho ng∆∞·ªùi m·ªõi ch∆°i',
        long: 'G·∫≠y billiard Starter S1 l√† l·ª±a ch·ªçn ho√†n h·∫£o cho ng∆∞·ªùi m·ªõi b·∫Øt ƒë·∫ßu ch∆°i billiard. V·ªõi thi·∫øt k·∫ø c√¢n b·∫±ng v√† d·ªÖ s·ª≠ d·ª•ng, S1 gi√∫p ng∆∞·ªùi ch∆°i nhanh ch√≥ng l√†m quen v·ªõi k·ªπ thu·∫≠t c∆° b·∫£n.',
      },
      category: gayPhoThongCategory._id,
      brand: 'StarterCue',
      manufacturer: 'Billiard Master',
      countryOfOrigin: 'Vietnam',
      price: 750000,
      stock: 30,
      sku: 'SC-S1-001',
      images: [
        {
          url: 'https://example.com/products/sc-s1-001-main.jpg',
          alt: 'G·∫≠y Billiard Starter S1 - H√¨nh ch√≠nh',
          isPrimary: true,
        },
      ],
      features: [
        'Thi·∫øt k·∫ø c√¢n b·∫±ng d·ªÖ s·ª≠ d·ª•ng',
        'Th√¢n g·∫≠y l√†m t·ª´ g·ªó maple',
        'ƒê·∫ßu tip m·ªÅm th√¢n thi·ªán cho ng∆∞·ªùi m·ªõi',
        'Gi√° c·∫£ ph·∫£i chƒÉng',
      ],
      specifications: {
        weight: 540,
        length: 145,
        diameter: 13,
        material: 'G·ªó maple',
        tipSize: '13mm',
        wrap: 'Nylon',
      },
      isActive: true,
      isPromoted: false,
      isFeatured: true,
    },
    {
      name: 'B·ªô Bi Billiard Pro Tournament',
      slug: 'bo-bi-billiard-pro-tournament',
      description: {
        short: 'B·ªô bi billiard chuy√™n nghi·ªáp cho gi·∫£i ƒë·∫•u',
        long: 'B·ªô Bi Billiard Pro Tournament ƒë∆∞·ª£c l√†m t·ª´ ch·∫•t li·ªáu cao c·∫•p, ƒë·∫°t chu·∫©n thi ƒë·∫•u qu·ªëc t·∫ø. ƒê·ªô b√≥ng v√† c√¢n b·∫±ng ho√†n h·∫£o gi√∫p ƒë·∫£m b·∫£o c√°c v√°n ƒë·∫•u c√¥ng b·∫±ng v√† ch√≠nh x√°c.',
      },
      category: biCategory._id,
      brand: 'MasterBall',
      manufacturer: 'Professional Billiards',
      countryOfOrigin: 'Belgium',
      price: 2200000,
      stock: 10,
      sku: 'MB-PT-001',
      images: [
        {
          url: 'https://example.com/products/mb-pt-001-main.jpg',
          alt: 'B·ªô Bi Billiard Pro Tournament - H√¨nh ch√≠nh',
          isPrimary: true,
        },
      ],
      features: [
        'Chu·∫©n thi ƒë·∫•u qu·ªëc t·∫ø',
        'Ch·∫•t li·ªáu resin cao c·∫•p',
        'ƒê·ªô b√≥ng v√† c√¢n b·∫±ng ho√†n h·∫£o',
        'Tu·ªïi th·ªç cao',
      ],
      specifications: {
        diameter: 57.2,
        weight: 170,
        material: 'Resin',
        quantity: 16,
      },
      isActive: true,
      isPromoted: true,
      isFeatured: false,
    },
  ];

  await Product.insertMany(sampleProducts);
  console.log(`Seeded ${sampleProducts.length} products successfully.`);
}

module.exports = seedProducts;


--- File: server/src/seeds/scripts/reviewSeeder.js ---
// server/src/data/seeds/reviewSeeds.js
const Review = require('../data/reviews');
const User = require('../data/users');
const Product = require('../data/products');
const Order = require('../data/orders');
const logger = require('../../config/logger');

const seedReviews = async () => {
  try {
    // Ki·ªÉm tra xem ƒë√£ c√≥ reviews trong DB ch∆∞a
    const count = await Review.countDocuments();
    if (count > 0) {
      logger.info('Reviews collection already seeded');
      return;
    }

    // L·∫•y users, products v√† orders ƒë·ªÉ t·∫°o reviews
    const users = await User.find().limit(10);
    const products = await Product.find().limit(20);
    const orders = await Order.find({ status: 'delivered' });

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed reviews: No users or products found');
      return;
    }

    const reviews = [];
    const reviewTitles = [
      'S·∫£n ph·∫©m tuy·ªát v·ªùi',
      'R·∫•t h√†i l√≤ng v·ªõi s·∫£n ph·∫©m',
      'Ch·∫•t l∆∞·ª£ng t·ªët',
      'ƒê√°ng ƒë·ªìng ti·ªÅn',
      'S·∫Ω mua l·∫°i',
      'Kh√° ·ªïn',
      'B√¨nh th∆∞·ªùng',
    ];

    const reviewContents = [
      'S·∫£n ph·∫©m ƒë√∫ng nh∆∞ m√¥ t·∫£, giao h√†ng nhanh, ƒë√≥ng g√≥i c·∫©n th·∫≠n.',
      'Ch·∫•t l∆∞·ª£ng s·∫£n ph·∫©m r·∫•t t·ªët, ƒë√∫ng nh∆∞ mong ƒë·ª£i. S·∫Ω ti·∫øp t·ª•c ·ªßng h·ªô shop.',
      'S·∫£n ph·∫©m ƒë·∫πp, ch·∫•t l∆∞·ª£ng t·ªët, giao h√†ng nhanh, ƒë√≥ng g√≥i c·∫©n th·∫≠n, shop t∆∞ v·∫•n nhi·ªát t√¨nh.',
      'S·∫£n ph·∫©m ƒë√∫ng nh∆∞ h√¨nh, ch·∫•t l∆∞·ª£ng t·ªët, s·∫Ω ·ªßng h·ªô shop d√†i d√†i.',
      'M√¨nh r·∫•t th√≠ch s·∫£n ph·∫©m n√†y, ch·∫•t l∆∞·ª£ng tuy·ªát v·ªùi, gi√° c·∫£ h·ª£p l√Ω.',
      'Kh√° ·ªïn v·ªõi m·ª©c gi√° n√†y, c√≥ th·ªÉ c·∫£i thi·ªán th√™m v·ªÅ ph·∫ßn ƒë√≥ng g√≥i.',
      'S·∫£n ph·∫©m t·∫°m ƒë∆∞·ª£c, kh√¥ng xu·∫•t s·∫Øc nh∆∞ng c≈©ng kh√¥ng t·ªá.',
    ];

    // T·∫°o reviews t·ª´ c√°c ƒë∆°n h√†ng ƒë√£ giao
    for (const order of orders) {
      for (const item of order.items) {
        const rating = Math.floor(Math.random() * 3) + 3; // 3-5 sao
        const reviewTitle = reviewTitles[Math.floor(Math.random() * reviewTitles.length)];
        const reviewContent = reviewContents[Math.floor(Math.random() * reviewContents.length)];

        const createdAt = new Date(order.completedAt);
        createdAt.setDate(createdAt.getDate() + Math.floor(Math.random() * 7)); // 0-7 ng√†y sau khi ƒë∆°n h√†ng ho√†n th√†nh

        reviews.push({
          product: item.product,
          user: order.user,
          order: order._id,
          rating,
          title: reviewTitle,
          review: reviewContent,
          isVerifiedPurchase: true,
          purchaseDate: order.createdAt,
          helpfulness: {
            upvotes: Math.floor(Math.random() * 10),
            downvotes: Math.floor(Math.random() * 3),
            voters: [],
          },
          moderation: {
            status: 'approved',
            moderatedAt: new Date(),
          },
          isVisible: true,
          createdAt,
          updatedAt: createdAt,
        });
      }
    }

    // T·∫°o th√™m m·ªôt s·ªë reviews ng·∫´u nhi√™n
    for (let i = 0; i < 30; i++) {
      const user = users[Math.floor(Math.random() * users.length)];
      const product = products[Math.floor(Math.random() * products.length)];
      const rating = Math.floor(Math.random() * 5) + 1; // 1-5 sao
      const reviewTitle =
        rating >= 3
          ? reviewTitles[Math.floor(Math.random() * reviewTitles.length)]
          : 'Kh√¥ng nh∆∞ mong ƒë·ª£i';
      const reviewContent =
        rating >= 3
          ? reviewContents[Math.floor(Math.random() * reviewContents.length)]
          : 'S·∫£n ph·∫©m kh√¥ng ƒë√∫ng nh∆∞ m√¥ t·∫£, ch·∫•t l∆∞·ª£ng k√©m.';

      const createdAt = new Date();
      createdAt.setDate(createdAt.getDate() - Math.floor(Math.random() * 30));

      reviews.push({
        product: product._id,
        user: user._id,
        rating,
        title: reviewTitle,
        review: reviewContent,
        isVerifiedPurchase: false,
        helpfulness: {
          upvotes: Math.floor(Math.random() * 5),
          downvotes: Math.floor(Math.random() * 2),
          voters: [],
        },
        moderation: {
          status: 'approved',
          moderatedAt: new Date(),
        },
        isVisible: true,
        createdAt,
        updatedAt: createdAt,
      });
    }

    // L∆∞u v√†o database
    await Review.insertMany(reviews);
    logger.info(`Seeded ${reviews.length} reviews`);

    // C·∫≠p nh·∫≠t ratings cho products
    for (const product of products) {
      const productReviews = reviews.filter(
        (review) => review.product.toString() === product._id.toString()
      );

      if (productReviews.length > 0) {
        const totalRating = productReviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = totalRating / productReviews.length;

        await Product.findByIdAndUpdate(product._id, {
          'ratings.average': parseFloat(averageRating.toFixed(1)),
          'ratings.count': productReviews.length,
        });
      }
    }

    logger.info('Updated product ratings');
  } catch (error) {
    logger.error('Error seeding reviews', error);
    throw error;
  }
};

module.exports = { seedReviews };


--- File: server/src/seeds/scripts/userSeeder.js ---
// server/src/seeds/userSeeder.js

const { User } = require('../data/users');
const bcrypt = require('bcrypt');

async function seedUsers() {
  console.log('Seeding users...');

  // X√≥a t·∫•t c·∫£ ng∆∞·ªùi d√πng hi·ªán c√≥ (ch·ªâ d√πng trong development)
  if (process.env.NODE_ENV !== 'production') {
    await User.deleteMany({});
  }

  // Hash m·∫≠t kh·∫©u
  const saltRounds = 10;
  const adminPasswordHash = await bcrypt.hash('admin123', saltRounds);
  const userPasswordHash = await bcrypt.hash('user123', saltRounds);

  // T·∫°o ng∆∞·ªùi d√πng m·∫´u
  const users = [
    {
      name: 'Admin User',
      email: 'admin@runout-biliard.com',
      password: adminPasswordHash,
      role: 'admin',
      phone: '0901234567',
      address: {
        street: '123 Nguy·ªÖn Hu·ªá',
        city: 'H·ªì Ch√≠ Minh',
        state: '',
        zipCode: '70000',
        country: 'Vi·ªát Nam',
      },
      isActive: true,
      emailVerified: true,
      preferences: {
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      },
    },
    {
      name: 'Regular User',
      email: 'user@example.com',
      password: userPasswordHash,
      role: 'user',
      phone: '0909876543',
      address: {
        street: '456 L√™ L·ª£i',
        city: 'H√† N·ªôi',
        state: '',
        zipCode: '10000',
        country: 'Vi·ªát Nam',
      },
      isActive: true,
      emailVerified: true,
      preferences: {
        language: 'vi',
        notifications: {
          email: true,
          marketing: false,
        },
      },
    },
  ];

  await User.insertMany(users);
  console.log(`Seeded ${users.length} users successfully.`);
}

module.exports = seedUsers;


--- File: server/src/server.js ---
/**
 * Server ch√≠nh cho ·ª©ng d·ª•ng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const http = require('http');
const app = require('./app');
const config = require('./config/environment');
const logger = require('./config/logger');

// L·∫•y PORT t·ª´ c·∫•u h√¨nh ho·∫∑c bi·∫øn m√¥i tr∆∞·ªùng
const PORT = process.env.PORT || config.app.port || 5000;

// T·∫°o HTTP server
const server = http.createServer(app);

// X·ª≠ l√Ω c√°c l·ªói server
server.on('error', (error) => {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof PORT === 'string' ? 'Pipe ' + PORT : 'Port ' + PORT;

  // X·ª≠ l√Ω c√°c l·ªói server c·ª• th·ªÉ v·ªõi th√¥ng b√°o th√¢n thi·ªán
  switch (error.code) {
    case 'EACCES':
      logger.error(`${bind} y√™u c·∫ßu quy·ªÅn n√¢ng cao`);
      throw new Error(`${bind} y√™u c·∫ßu quy·ªÅn n√¢ng cao`);
    case 'EADDRINUSE':
      logger.error(`${bind} ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng`);
      throw new Error(`${bind} ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng`);
    default:
      throw error;
  }
});

// Kh·ªüi ƒë·ªông server
server.listen(PORT, () => {
  logger.info(`üöÄ Server ƒëang ch·∫°y trong m√¥i tr∆∞·ªùng ${config.app.environment}`);
  logger.info(`üåê ƒê·ªãa ch·ªâ: http://${config.app.host}:${PORT}`);
});

// X·ª≠ l√Ω t·∫Øt server an to√†n
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

/**
 * ƒê√≥ng server m·ªôt c√°ch an to√†n
 */
function gracefulShutdown() {
  logger.info('Nh·∫≠n t√≠n hi·ªáu t·∫Øt server, ƒëang ƒë√≥ng k·∫øt n·ªëi...');

  server.close(() => {
    logger.info('Server ƒë√£ ƒë√≥ng, ƒëang ng·∫Øt k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu...');

    // ƒê√≥ng k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu n·∫øu c·∫ßn
    try {
      if (require('mongoose').connection.readyState) {
        require('mongoose').connection.close(false, () => {
          logger.info('ƒê√£ ng·∫Øt k·∫øt n·ªëi MongoDB.');
          throw new Error('Server ƒë√£ ƒë√≥ng v√† ng·∫Øt k·∫øt n·ªëi th√†nh c√¥ng');
        });
      } else {
        throw new Error('Server ƒë√£ ƒë√≥ng v√† kh√¥ng c·∫ßn ng·∫Øt k·∫øt n·ªëi');
      }
    } catch (err) {
      logger.error(`L·ªói khi ƒë√≥ng k·∫øt n·ªëi: ${err.message}`);
      throw new Error(`L·ªói khi ƒë√≥ng k·∫øt n·ªëi: ${err.message}`);
    }
  });

  // N·∫øu server kh√¥ng ƒë√≥ng sau 10s, t·∫Øt c∆∞·ª°ng ch·∫ø
  setTimeout(() => {
    logger.error('Kh√¥ng th·ªÉ ƒë√≥ng k·∫øt n·ªëi m·ªôt c√°ch √™m d·ªãu, ƒëang t·∫Øt c∆∞·ª°ng ch·∫ø...');
    throw new Error('Kh√¥ng th·ªÉ ƒë√≥ng k·∫øt n·ªëi m·ªôt c√°ch √™m d·ªãu, ƒëang t·∫Øt c∆∞·ª°ng ch·∫ø...');
  }, 10000);
}

// X·ª≠ l√Ω c√°c l·ªói kh√¥ng b·∫Øt ƒë∆∞·ª£c kh√°c
process.on('uncaughtException', (error) => {
  logger.error(`L·ªói kh√¥ng b·∫Øt ƒë∆∞·ª£c: ${error.message}`);
  logger.error(error.stack);

  // Trong m√¥i tr∆∞·ªùng s·∫£n xu·∫•t, ƒë·∫£m b·∫£o server ƒë√≥ng an to√†n sau l·ªói kh√¥ng b·∫Øt ƒë∆∞·ª£c
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('L·ªùi h·ª©a b·ªã t·ª´ ch·ªëi kh√¥ng ƒë∆∞·ª£c x·ª≠ l√Ω:');
  logger.error(`Promise: ${promise}, Reason: ${reason}`);

  // Trong m√¥i tr∆∞·ªùng s·∫£n xu·∫•t, c√≥ th·ªÉ xem x√©t t·∫Øt ·ª©ng d·ª•ng
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

module.exports = server; // Export ƒë·ªÉ s·ª≠ d·ª•ng trong ki·ªÉm th·ª≠


--- File: server/src/services/auth/authService.js ---
/**
 * Auth Service - x·ª≠ l√Ω logic x√°c th·ª±c v√† ph√¢n quy·ªÅn
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const User = require('../../data/models/user.model');
const { ApiError } = require('../../common/errors/apiError');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../email/emailService');

/**
 * Class AuthService x·ª≠ l√Ω logic x√°c th·ª±c v√† ph√¢n quy·ªÅn
 */
class AuthService {
  /**
   * ƒêƒÉng k√Ω t√†i kho·∫£n m·ªõi
   * @param {Object} userData - Th√¥ng tin ƒëƒÉng k√Ω
   * @param {string} host - Host ƒë·ªÉ t·∫°o URL x√°c th·ª±c
   * @returns {Promise<Object>} - Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ t·∫°o
   */
  async register(userData, host) {
    try {
      const { name, email, password, phone } = userData;

      // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        throw new ApiError(409, 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng');
      }

      // T·∫°o verification token
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(verificationToken).digest('hex');

      // T·∫°o user m·ªõi
      const newUser = await User.create({
        name,
        email,
        password,
        phone,
        emailVerificationToken: hashedToken,
        emailVerificationExpires: Date.now() + 24 * 60 * 60 * 1000, // 24 gi·ªù
      });

      // T·∫°o URL x√°c th·ª±c
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const verifyURL = `${protocol}://${host}/api/auth/verify-email/${verificationToken}`;

      // G·ª≠i email x√°c th·ª±c
      await sendEmail({
        to: email,
        subject: 'X√°c th·ª±c t√†i kho·∫£n RunOut-Biliard',
        template: 'verification',
        context: {
          name,
          verifyURL,
        },
      });

      // Kh√¥ng g·ª≠i m·∫≠t kh·∫©u v√† token trong response
      const userObj = newUser.toObject();
      delete userObj.password;
      delete userObj.emailVerificationToken;

      return userObj;
    } catch (error) {
      logger.error(`L·ªói ƒëƒÉng k√Ω: ${error.message}`);
      throw error;
    }
  }

  /**
   * ƒêƒÉng nh·∫≠p
   * @param {string} email - Email ng∆∞·ªùi d√πng
   * @param {string} password - M·∫≠t kh·∫©u
   * @returns {Promise<Object>} - Th√¥ng tin ng∆∞·ªùi d√πng v√† token
   */
  async login(email, password) {
    try {
      // T√¨m user v√† l·∫•y c·∫£ password (m·∫∑c ƒë·ªãnh password b·ªã lo·∫°i tr·ª´)
      const user = await User.findOne({ email }).select('+password');

      // Ki·ªÉm tra user t·ªìn t·∫°i v√† password ƒë√∫ng
      if (!user || !(await user.correctPassword(password, user.password))) {
        throw new ApiError(401, 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng');
      }

      // Ki·ªÉm tra email ƒë√£ x√°c th·ª±c ch∆∞a
      if (!user.emailVerified) {
        throw new ApiError(401, 'Vui l√≤ng x√°c th·ª±c email tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p');
      }

      // Ki·ªÉm tra user c√≥ active kh√¥ng
      if (!user.isActive) {
        throw new ApiError(401, 'T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a');
      }

      // T·∫°o JWT token v√† refresh token
      const token = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // C·∫≠p nh·∫≠t th√¥ng tin ƒëƒÉng nh·∫≠p
      user.lastLogin = Date.now();
      user.loginCount += 1;
      await user.save({ validateBeforeSave: false });

      // Chuy·ªÉn ƒë·ªïi user th√†nh object v√† lo·∫°i b·ªè password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token,
        refreshToken,
      };
    } catch (error) {
      logger.error(`L·ªói ƒëƒÉng nh·∫≠p: ${error.message}`);
      throw error;
    }
  }

  /**
   * T·∫°o JWT token
   * @param {Object} user - User object
   * @returns {string} - JWT token
   */
  generateToken(user) {
    return jwt.sign({ id: user._id, role: user.role }, environment.auth.jwtSecret, {
      expiresIn: environment.auth.jwtExpiresIn,
    });
  }

  /**
   * T·∫°o refresh token
   * @param {Object} user - User object
   * @returns {string} - Refresh token
   */
  generateRefreshToken(user) {
    return jwt.sign({ id: user._id }, environment.auth.jwtRefreshSecret, {
      expiresIn: environment.auth.jwtRefreshExpiresIn,
    });
  }

  /**
   * L√†m m·ªõi token
   * @param {string} refreshToken - Refresh token
   * @returns {Promise<Object>} - Token m·ªõi
   */
  async refreshToken(refreshToken) {
    try {
      // X√°c th·ª±c refresh token
      const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);

      // T√¨m user
      const user = await User.findById(decoded.id);

      if (!user || !user.isActive) {
        throw new ApiError(401, 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã v√¥ hi·ªáu h√≥a');
      }

      // T·∫°o token m·ªõi
      const newToken = this.generateToken(user);

      return { token: newToken };
    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new ApiError(401, 'Refresh token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
      }

      logger.error(`L·ªói refresh token: ${error.message}`);
      throw error;
    }
  }

  /**
   * Qu√™n m·∫≠t kh·∫©u
   * @param {string} email - Email ng∆∞·ªùi d√πng
   * @param {string} host - Host ƒë·ªÉ t·∫°o URL reset
   * @returns {Promise<boolean>} - Th√†nh c√¥ng hay kh√¥ng
   */
  async forgotPassword(email, host) {
    try {
      // T√¨m user theo email
      const user = await User.findOne({ email });

      if (!user) {
        throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi email n√†y');
      }

      // T·∫°o reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');

      // L∆∞u token v√† th·ªùi h·∫°n v√†o database
      user.resetPasswordToken = hashedToken;
      user.resetPasswordExpires = Date.now() + 10 * 60 * 1000; // 10 ph√∫t
      await user.save({ validateBeforeSave: false });

      // T·∫°o URL reset
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const resetURL = `${protocol}://${host}/reset-password/${resetToken}`;

      // G·ª≠i email
      await sendEmail({
        to: user.email,
        subject: 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u RunOut-Biliard (c√≥ hi·ªáu l·ª±c trong 10 ph√∫t)',
        template: 'resetPassword',
        context: {
          name: user.name,
          resetURL,
        },
      });

      return true;
    } catch (error) {
      logger.error(`L·ªói qu√™n m·∫≠t kh·∫©u: ${error.message}`);

      // N·∫øu g·ª≠i email th·∫•t b·∫°i, x√≥a c√°c fields reset
      if (error.message.includes('email')) {
        try {
          const user = await User.findOne({ email });
          if (user) {
            user.resetPasswordToken = undefined;
            user.resetPasswordExpires = undefined;
            await user.save({ validateBeforeSave: false });
          }
        } catch (innerError) {
          logger.error(`L·ªói khi x√≥a token reset: ${innerError.message}`);
        }
      }

      throw error;
    }
  }

  /**
   * ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u
   * @param {string} token - Reset token
   * @param {string} password - M·∫≠t kh·∫©u m·ªõi
   * @returns {Promise<Object>} - Th√¥ng tin ng∆∞·ªùi d√πng v√† token
   */
  async resetPassword(token, password) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // T√¨m user v·ªõi token v√† ki·ªÉm tra th·ªùi h·∫°n
      const user = await User.findOne({
        resetPasswordToken: hashedToken,
        resetPasswordExpires: { $gt: Date.now() },
      });

      // Ki·ªÉm tra n·∫øu token h·ª£p l·ªá
      if (!user) {
        throw new ApiError(400, 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
      }

      // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
      user.password = password;
      user.resetPasswordToken = undefined;
      user.resetPasswordExpires = undefined;
      await user.save();

      // T·∫°o token m·ªõi
      const jwtToken = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // Chuy·ªÉn ƒë·ªïi user th√†nh object v√† lo·∫°i b·ªè password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token: jwtToken,
        refreshToken,
      };
    } catch (error) {
      logger.error(`L·ªói ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u: ${error.message}`);
      throw error;
    }
  }

  /**
   * X√°c th·ª±c email
   * @param {string} token - Verification token
   * @returns {Promise<boolean>} - Th√†nh c√¥ng hay kh√¥ng
   */
  async verifyEmail(token) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // T√¨m user v√† ki·ªÉm tra th·ªùi h·∫°n
      const user = await User.findOne({
        emailVerificationToken: hashedToken,
        emailVerificationExpires: { $gt: Date.now() },
      });

      // Ki·ªÉm tra n·∫øu token h·ª£p l·ªá
      if (!user) {
        throw new ApiError(400, 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i x√°c th·ª±c
      user.emailVerified = true;
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });

      return true;
    } catch (error) {
      logger.error(`L·ªói x√°c th·ª±c email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new AuthService();


--- File: server/src/services/base/baseService.js ---
/**
 * Base Service - cung c·∫•p c√°c ph∆∞∆°ng th·ª©c CRUD c∆° b·∫£n
 * @author Steve
 * @project RunOut-Biliard
 */

const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * L·ªõp BaseService cung c·∫•p c√°c ph∆∞∆°ng th·ª©c CRUD c∆° b·∫£n cho c√°c service
 */
class BaseService {
  /**
   * Kh·ªüi t·∫°o service v·ªõi model t∆∞∆°ng ·ª©ng
   * @param {mongoose.Model} model - Mongoose model
   * @param {string} modelName - T√™n c·ªßa model (d√πng cho log v√† th√¥ng b√°o l·ªói)
   */
  constructor(model, modelName) {
    this.model = model;
    this.modelName = modelName || model.modelName;
  }

  /**
   * L·∫•y t·∫•t c·∫£ documents v·ªõi filter, sort v√† pagination
   * @param {Object} filter - ƒêi·ªÅu ki·ªán filter
   * @param {Object} options - C√°c options b·ªï sung (sort, pagination, select)
   * @returns {Promise<{data: Array, pagination: Object}>} - D·ªØ li·ªáu v√† th√¥ng tin ph√¢n trang
   */
  async findAll(filter = {}, options = {}) {
    try {
      const { sort = '-createdAt', page = 1, limit = 10, select = '', populate = '' } = options;

      const skip = (page - 1) * limit;

      // Build query
      let query = this.model.find(filter);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query with sort, skip and limit
      const data = await query.sort(sort).skip(skip).limit(limit);

      // Count total documents matching filter
      const total = await this.model.countDocuments(filter);

      // Calculate pagination info
      const totalPages = Math.ceil(total / limit);
      const hasNext = page < totalPages;
      const hasPrev = page > 1;

      return {
        data,
        pagination: {
          total,
          page,
          limit,
          totalPages,
          hasNext,
          hasPrev,
        },
      };
    } catch (error) {
      logger.error(`Error in ${this.modelName}.findAll: ${error.message}`);
      throw error;
    }
  }

  /**
   * L·∫•y document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} options - C√°c options (select, populate)
   * @returns {Promise<Document>} - Document t√¨m th·∫•y
   * @throws {ApiError} - 404 n·∫øu kh√¥ng t√¨m th·∫•y
   */
  async findById(id, options = {}) {
    try {
      const { select = '', populate = '' } = options;

      // Build query
      let query = this.model.findById(id);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query
      const data = await query;

      // Throw error if not found
      if (!data) {
        throw new ApiError(404, `${this.modelName} kh√¥ng t√¨m th·∫•y v·ªõi ID: ${id}`);
      }

      return data;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.findById: ${error.message}`);
      throw error;
    }
  }

  /**
   * T·∫°o document m·ªõi
   * @param {Object} data - D·ªØ li·ªáu cho document m·ªõi
   * @returns {Promise<Document>} - Document ƒë√£ t·∫°o
   */
  async create(data) {
    try {
      const newDoc = await this.model.create(data);
      return newDoc;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.create: ${error.message}`);
      throw error;
    }
  }

  /**
   * C·∫≠p nh·∫≠t document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} data - D·ªØ li·ªáu c·∫≠p nh·∫≠t
   * @param {Object} options - C√°c options (new, runValidators)
   * @returns {Promise<Document>} - Document ƒë√£ c·∫≠p nh·∫≠t
   * @throws {ApiError} - 404 n·∫øu kh√¥ng t√¨m th·∫•y
   */
  async update(id, data, options = {}) {
    try {
      const opts = {
        new: true,
        runValidators: true,
        ...options,
      };

      const updated = await this.model.findByIdAndUpdate(id, data, opts);

      if (!updated) {
        throw new ApiError(404, `${this.modelName} kh√¥ng t√¨m th·∫•y v·ªõi ID: ${id}`);
      }

      return updated;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.update: ${error.message}`);
      throw error;
    }
  }

  /**
   * X√≥a document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<Document>} - Document ƒë√£ x√≥a
   * @throws {ApiError} - 404 n·∫øu kh√¥ng t√¨m th·∫•y
   */
  async delete(id) {
    try {
      const deleted = await this.model.findByIdAndDelete(id);

      if (!deleted) {
        throw new ApiError(404, `${this.modelName} kh√¥ng t√¨m th·∫•y v·ªõi ID: ${id}`);
      }

      return deleted;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.delete: ${error.message}`);
      throw error;
    }
  }

  /**
   * Ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<boolean>} - true n·∫øu document t·ªìn t·∫°i, false n·∫øu kh√¥ng
   */
  async exists(id) {
    try {
      const count = await this.model.countDocuments({ _id: id });
      return count > 0;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.exists: ${error.message}`);
      throw error;
    }
  }
}

module.exports = BaseService;


--- File: server/src/services/cache/redisCache.js ---
// server/src/services/cache/redisCache.js
const redis = require('redis');
const { promisify } = require('util');
const config = require('../../config/environment');
const { logger } = require('../../utils/logger'); // S·ª≠a c√°ch import logger

class RedisCache {
  constructor() {
    this.isConnected = false;
    this.client = redis.createClient({
      url: config.redis.url,
      retry_strategy: (options) => {
        if (options.error && options.error.code === 'ECONNREFUSED') {
          logger.error('K·∫øt n·ªëi Redis b·ªã t·ª´ ch·ªëi. ƒê·∫£m b·∫£o Redis server ƒëang ch·∫°y.');
          return new Error('K·∫øt n·ªëi Redis b·ªã t·ª´ ch·ªëi');
        }
        if (options.total_retry_time > 1000 * 60 * 60) {
          logger.error('ƒê√£ v∆∞·ª£t qu√° th·ªùi gian th·ª≠ l·∫°i k·∫øt n·ªëi Redis.');
          return new Error('ƒê√£ v∆∞·ª£t qu√° th·ªùi gian th·ª≠ l·∫°i');
        }
        if (options.attempt > 10) {
          logger.error('ƒê√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠ l·∫°i k·∫øt n·ªëi Redis.');
          return undefined;
        }
        // Th·ª≠ l·∫°i sau m·ªôt kho·∫£ng th·ªùi gian tƒÉng d·∫ßn
        return Math.min(options.attempt * 100, 3000);
      },
    });

    // X·ª≠ l√Ω s·ª± ki·ªán Redis tr∆∞·ªõc khi promisify
    this.client.on('error', (error) => {
      this.isConnected = false;
      logger.error('L·ªói Redis:', error);
    });

    this.client.on('connect', () => {
      this.isConnected = true;
      logger.info('ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng ƒë·∫øn Redis server');
    });

    this.client.on('reconnecting', () => {
      logger.info('ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i ƒë·∫øn Redis server...');
    });

    this.client.on('end', () => {
      this.isConnected = false;
      logger.info('K·∫øt n·ªëi Redis ƒë√£ ƒë√≥ng');
    });

    // Promisify c√°c ph∆∞∆°ng th·ª©c Redis - S·ª≠a c√°ch th·ª±c hi·ªán bind
    this._initPromisifiedMethods();
  }

  /**
   * Kh·ªüi t·∫°o c√°c ph∆∞∆°ng th·ª©c Redis ƒë√£ promisify v·ªõi ki·ªÉm tra an to√†n
   * @private
   */
  _initPromisifiedMethods() {
    try {
      // Ki·ªÉm tra xem client c√≥ t·ªìn t·∫°i kh√¥ng
      if (!this.client) {
        throw new Error('Redis client ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');
      }

      // S·ª≠ d·ª•ng try-catch ri√™ng cho t·ª´ng ph∆∞∆°ng th·ª©c
      try {
        if (typeof this.client.get === 'function')
          this.getAsync = promisify(this.client.get.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c get');
      }

      try {
        if (typeof this.client.set === 'function')
          this.setAsync = promisify(this.client.set.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c set');
      }

      try {
        if (typeof this.client.del === 'function')
          this.delAsync = promisify(this.client.del.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c del');
      }

      try {
        if (typeof this.client.keys === 'function')
          this.keysAsync = promisify(this.client.keys.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c keys');
      }

      try {
        if (typeof this.client.flushdb === 'function')
          this.flushdbAsync = promisify(this.client.flushdb.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c flushdb');
      }

      try {
        if (typeof this.client.exists === 'function')
          this.existsAsync = promisify(this.client.exists.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c exists');
      }

      try {
        if (typeof this.client.expire === 'function')
          this.expireAsync = promisify(this.client.expire.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c expire');
      }

      try {
        if (typeof this.client.ttl === 'function')
          this.ttlAsync = promisify(this.client.ttl.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c ttl');
      }

      try {
        if (typeof this.client.incr === 'function')
          this.incrAsync = promisify(this.client.incr.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c incr');
      }

      try {
        if (typeof this.client.decr === 'function')
          this.decrAsync = promisify(this.client.decr.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c decr');
      }

      try {
        if (typeof this.client.hgetall === 'function')
          this.hgetallAsync = promisify(this.client.hgetall.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c hgetall');
      }

      try {
        if (typeof this.client.hset === 'function')
          this.hsetAsync = promisify(this.client.hset.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c hset');
      }

      try {
        if (typeof this.client.hmset === 'function')
          this.hmsetAsync = promisify(this.client.hmset.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c hmset');
      }

      try {
        if (typeof this.client.hdel === 'function')
          this.hdelAsync = promisify(this.client.hdel.bind(this.client));
      } catch (e) {
        logger.warn('Kh√¥ng th·ªÉ promisify ph∆∞∆°ng th·ª©c hdel');
      }

      logger.info('C√°c ph∆∞∆°ng th·ª©c Redis ƒë√£ ƒë∆∞·ª£c promisify th√†nh c√¥ng');
    } catch (error) {
      logger.error('L·ªói khi promisify c√°c ph∆∞∆°ng th·ª©c Redis:', error);
      throw new Error('Kh√¥ng th·ªÉ kh·ªüi t·∫°o c√°c ph∆∞∆°ng th·ª©c Redis: ' + error.message);
    }
  }

  /**
   * Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi Redis
   * @returns {boolean} Tr·∫°ng th√°i k·∫øt n·ªëi
   */
  isReady() {
    return this.isConnected;
  }

  /**
   * L·∫•y d·ªØ li·ªáu t·ª´ cache
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<any>} D·ªØ li·ªáu ƒë√£ l∆∞u trong cache ho·∫∑c null
   */
  async get(key) {
    try {
      const data = await this.getAsync(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error(`L·ªói khi l·∫•y cache v·ªõi kh√≥a ${key}:`, error);
      return null;
    }
  }

  /**
   * L∆∞u d·ªØ li·ªáu v√†o cache
   * @param {string} key - Kh√≥a cache
   * @param {any} value - D·ªØ li·ªáu c·∫ßn l∆∞u
   * @param {number} ttl - Th·ªùi gian s·ªëng (gi√¢y)
   * @returns {Promise<boolean>} K·∫øt qu·∫£ l∆∞u cache
   */
  async set(key, value, ttl = 3600) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.setAsync(key, serializedValue, 'EX', ttl);
      return true;
    } catch (error) {
      logger.error(`L·ªói khi l∆∞u cache v·ªõi kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * X√≥a d·ªØ li·ªáu kh·ªèi cache
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<boolean>} K·∫øt qu·∫£ x√≥a cache
   */
  async delete(key) {
    try {
      const result = await this.delAsync(key);
      return result > 0;
    } catch (error) {
      logger.error(`L·ªói khi x√≥a cache v·ªõi kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * T·∫°o kh√≥a cache t·ª´ prefix v√† tham s·ªë
   * @param {string} prefix - Ti·ªÅn t·ªë cho kh√≥a
   * @param {object} params - Tham s·ªë ƒë·ªÉ t·∫°o kh√≥a
   * @returns {string} Kh√≥a cache ƒë√£ t·∫°o
   */
  generateKey(prefix, params) {
    if (typeof params === 'object') {
      // S·∫Øp x·∫øp c√°c kh√≥a ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n
      const sortedParams = {};
      Object.keys(params)
        .sort()
        .forEach((key) => {
          sortedParams[key] = params[key];
        });
      return `${prefix}:${Buffer.from(JSON.stringify(sortedParams)).toString('base64')}`;
    }
    return `${prefix}:${params}`;
  }

  /**
   * Ki·ªÉm tra xem kh√≥a c√≥ t·ªìn t·∫°i trong cache kh√¥ng
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<boolean>} K·∫øt qu·∫£ ki·ªÉm tra
   */
  async exists(key) {
    try {
      const result = await this.existsAsync(key);
      return result === 1;
    } catch (error) {
      logger.error(`L·ªói khi ki·ªÉm tra t·ªìn t·∫°i kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * C·∫≠p nh·∫≠t th·ªùi gian h·∫øt h·∫°n cho kh√≥a
   * @param {string} key - Kh√≥a cache
   * @param {number} ttl - Th·ªùi gian s·ªëng m·ªõi (gi√¢y)
   * @returns {Promise<boolean>} K·∫øt qu·∫£ c·∫≠p nh·∫≠t
   */
  async expire(key, ttl) {
    try {
      const result = await this.expireAsync(key, ttl);
      return result === 1;
    } catch (error) {
      logger.error(`L·ªói khi c·∫≠p nh·∫≠t th·ªùi gian h·∫øt h·∫°n cho kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * L·∫•y th·ªùi gian c√≤n l·∫°i tr∆∞·ªõc khi kh√≥a h·∫øt h·∫°n
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<number>} Th·ªùi gian c√≤n l·∫°i (gi√¢y)
   */
  async ttl(key) {
    try {
      return await this.ttlAsync(key);
    } catch (error) {
      logger.error(`L·ªói khi l·∫•y TTL cho kh√≥a ${key}:`, error);
      return -2; // -2 l√† gi√° tr·ªã Redis tr·∫£ v·ªÅ khi kh√≥a kh√¥ng t·ªìn t·∫°i
    }
  }

  /**
   * TƒÉng gi√° tr·ªã c·ªßa kh√≥a l√™n 1
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<number>} Gi√° tr·ªã m·ªõi
   */
  async increment(key) {
    try {
      return await this.incrAsync(key);
    } catch (error) {
      logger.error(`L·ªói khi tƒÉng gi√° tr·ªã cho kh√≥a ${key}:`, error);
      return null;
    }
  }

  /**
   * Gi·∫£m gi√° tr·ªã c·ªßa kh√≥a ƒëi 1
   * @param {string} key - Kh√≥a cache
   * @returns {Promise<number>} Gi√° tr·ªã m·ªõi
   */
  async decrement(key) {
    try {
      return await this.decrAsync(key);
    } catch (error) {
      logger.error(`L·ªói khi gi·∫£m gi√° tr·ªã cho kh√≥a ${key}:`, error);
      return null;
    }
  }

  /**
   * X√≥a t·∫•t c·∫£ c√°c kh√≥a c√≥ c√πng pattern
   * @param {string} pattern - M·∫´u kh√≥a c·∫ßn x√≥a (v√≠ d·ª•: 'products:*')
   * @returns {Promise<number>} S·ªë l∆∞·ª£ng kh√≥a ƒë√£ x√≥a
   */
  async deleteByPattern(pattern) {
    try {
      const keys = await this.keysAsync(pattern);
      if (keys.length > 0) {
        return await this.delAsync(keys);
      }
      return 0;
    } catch (error) {
      logger.error(`L·ªói khi x√≥a cache theo m·∫´u ${pattern}:`, error);
      return 0;
    }
  }

  /**
   * X√≥a to√†n b·ªô cache
   * @returns {Promise<boolean>} K·∫øt qu·∫£ x√≥a cache
   */
  async flush() {
    try {
      await this.flushdbAsync();
      logger.info('ƒê√£ x√≥a to√†n b·ªô cache');
      return true;
    } catch (error) {
      logger.error('L·ªói khi x√≥a to√†n b·ªô cache:', error);
      return false;
    }
  }

  /**
   * L·∫•y t·∫•t c·∫£ c√°c tr∆∞·ªùng v√† gi√° tr·ªã c·ªßa m·ªôt hash
   * @param {string} key - Kh√≥a hash
   * @returns {Promise<object>} ƒê·ªëi t∆∞·ª£ng ch·ª©a c√°c tr∆∞·ªùng v√† gi√° tr·ªã
   */
  async getHash(key) {
    try {
      const data = await this.hgetallAsync(key);
      if (!data) return null;

      // Chuy·ªÉn ƒë·ªïi c√°c gi√° tr·ªã t·ª´ JSON string sang object
      const result = {};
      for (const field in data) {
        try {
          result[field] = JSON.parse(data[field]);
        } catch (e) {
          result[field] = data[field];
        }
      }
      return result;
    } catch (error) {
      logger.error(`L·ªói khi l·∫•y hash v·ªõi kh√≥a ${key}:`, error);
      return null;
    }
  }

  /**
   * L∆∞u m·ªôt tr∆∞·ªùng v√†o hash
   * @param {string} key - Kh√≥a hash
   * @param {string} field - T√™n tr∆∞·ªùng
   * @param {any} value - Gi√° tr·ªã c·∫ßn l∆∞u
   * @returns {Promise<boolean>} K·∫øt qu·∫£ l∆∞u hash
   */
  async setHashField(key, field, value) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.hsetAsync(key, field, serializedValue);
      return true;
    } catch (error) {
      logger.error(`L·ªói khi l∆∞u tr∆∞·ªùng hash ${field} v·ªõi kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * L∆∞u nhi·ªÅu tr∆∞·ªùng v√†o hash
   * @param {string} key - Kh√≥a hash
   * @param {object} fields - ƒê·ªëi t∆∞·ª£ng ch·ª©a c√°c tr∆∞·ªùng v√† gi√° tr·ªã
   * @returns {Promise<boolean>} K·∫øt qu·∫£ l∆∞u hash
   */
  async setHash(key, fields) {
    try {
      const serializedFields = {};
      for (const field in fields) {
        serializedFields[field] = JSON.stringify(fields[field]);
      }
      await this.hmsetAsync(key, serializedFields);
      return true;
    } catch (error) {
      logger.error(`L·ªói khi l∆∞u hash v·ªõi kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * X√≥a m·ªôt tr∆∞·ªùng kh·ªèi hash
   * @param {string} key - Kh√≥a hash
   * @param {string} field - T√™n tr∆∞·ªùng
   * @returns {Promise<boolean>} K·∫øt qu·∫£ x√≥a tr∆∞·ªùng
   */
  async deleteHashField(key, field) {
    try {
      const result = await this.hdelAsync(key, field);
      return result > 0;
    } catch (error) {
      logger.error(`L·ªói khi x√≥a tr∆∞·ªùng hash ${field} v·ªõi kh√≥a ${key}:`, error);
      return false;
    }
  }

  /**
   * ƒê√≥ng k·∫øt n·ªëi Redis
   * @returns {Promise<void>}
   */
  async close() {
    return new Promise((resolve) => {
      this.client.quit(() => {
        logger.info('K·∫øt n·ªëi Redis ƒë√£ ƒë√≥ng');
        this.isConnected = false;
        resolve();
      });
    });
  }
}

module.exports = new RedisCache();


--- File: server/src/services/cart/cartService.js ---
/**
 * Cart Service
 * X·ª≠ l√Ω logic nghi·ªáp v·ª• cho gi·ªè h√†ng
 */

const { ApiError } = require('../../common/errors/apiError');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const crypto = require('crypto');

/**
 * T·∫°o ID phi√™n cho kh√°ch v√£ng lai
 * @returns {string} Session ID
 */
const generateSessionId = () => {
  return crypto.randomBytes(16).toString('hex');
};

/**
 * L·∫•y gi·ªè h√†ng ƒëang active c·ªßa ng∆∞·ªùi d√πng ho·∫∑c kh√°ch v√£ng lai
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @returns {Promise<Object>} Th√¥ng tin gi·ªè h√†ng
 */
const getActiveCart = async (userId, sessionId) => {
  let cart;

  // Tr∆∞·ªùng h·ª£p 1: User ƒë√£ ƒëƒÉng nh·∫≠p
  if (userId) {
    cart = await cartRepository.findOne({ user: userId, status: 'active' });
  }
  // Tr∆∞·ªùng h·ª£p 2: Kh√°ch v√£ng lai
  else if (sessionId) {
    cart = await cartRepository.findOne({ sessionId, status: 'active' });
  }

  // N·∫øu ch∆∞a c√≥ gi·ªè h√†ng, t·∫°o m·ªõi
  if (!cart) {
    const newCart = {
      user: userId || null,
      sessionId: userId ? null : sessionId,
      items: [],
      subtotal: 0,
      status: 'active',
      lastActivity: new Date(),
    };

    // Th·ªùi h·∫°n cho gi·ªè h√†ng c·ªßa kh√°ch v√£ng lai
    if (!userId && sessionId) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 ng√†y
      newCart.expiresAt = expiryDate;
    }

    cart = await cartRepository.create(newCart);
  }

  return cart;
};

/**
 * Th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
 * @param {number} quantity - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m
 * @param {Object} attributes - C√°c thu·ªôc t√≠nh t√πy ch·ªçn c·ªßa s·∫£n ph·∫©m
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu c√≥ l·ªói khi th√™m s·∫£n ph·∫©m
 */
const addItemToCart = async (userId, sessionId, productId, quantity, attributes = {}) => {
  // Ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i v√† c√≤n h√†ng
  const product = await productRepository.findById(productId);

  if (!product) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
  }

  if (!product.isActive) {
    throw new ApiError(400, 'S·∫£n ph·∫©m kh√¥ng kh·∫£ d·ª•ng');
  }

  if (product.stock < quantity) {
    throw new ApiError(400, `S·∫£n ph·∫©m ch·ªâ c√≤n ${product.stock} trong kho`);
  }

  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i ho·∫∑c t·∫°o m·ªõi
  const cart = await getActiveCart(userId, sessionId);

  // Ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√£ c√≥ trong gi·ªè h√†ng ch∆∞a
  const existingItemIndex = cart.items.findIndex((item) => {
    return (
      item.product.toString() === productId &&
      JSON.stringify(item.attributes) === JSON.stringify(attributes)
    );
  });

  // T√≠nh gi√° s·∫£n ph·∫©m (∆∞u ti√™n gi√° khuy·∫øn m√£i n·∫øu c√≥)
  const itemPrice = product.salePrice || product.price;

  // N·∫øu s·∫£n ph·∫©m ƒë√£ c√≥ trong gi·ªè, c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
  if (existingItemIndex > -1) {
    const existingItem = cart.items[existingItemIndex];
    const newQuantity = existingItem.quantity + quantity;

    // Ki·ªÉm tra l·∫°i t·ªìn kho
    if (product.stock < newQuantity) {
      throw new ApiError(400, `Kh√¥ng ƒë·ªß h√†ng trong kho. Ch·ªâ c√≤n ${product.stock} s·∫£n ph·∫©m.`);
    }

    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng v√† t·ªïng gi√°
    cart.items[existingItemIndex].quantity = newQuantity;
    cart.items[existingItemIndex].updatedAt = new Date();
  }
  // N·∫øu ch∆∞a c√≥, th√™m m·ªõi v√†o gi·ªè h√†ng
  else {
    cart.items.push({
      product: productId,
      quantity,
      price: itemPrice,
      attributes,
      addedAt: new Date(),
      updatedAt: new Date(),
    });
  }

  // T√≠nh l·∫°i t·ªïng ti·ªÅn
  cart.subtotal = calculateSubtotal(cart.items);

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m trong gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {string} itemId - ID c·ªßa item trong gi·ªè h√†ng
 * @param {number} quantity - S·ªë l∆∞·ª£ng m·ªõi
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu c√≥ l·ªói khi c·∫≠p nh·∫≠t
 */
const updateCartItem = async (userId, sessionId, itemId, quantity) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // T√¨m item trong gi·ªè h√†ng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m trong gi·ªè h√†ng');
  }

  // L·∫•y th√¥ng tin s·∫£n ph·∫©m
  const cartItem = cart.items[itemIndex];
  const product = await productRepository.findById(cartItem.product);

  if (!product) {
    throw new ApiError(404, 'S·∫£n ph·∫©m kh√¥ng c√≤n t·ªìn t·∫°i');
  }

  // Ki·ªÉm tra t·ªìn kho
  if (product.stock < quantity) {
    throw new ApiError(400, `Kh√¥ng ƒë·ªß h√†ng trong kho. Ch·ªâ c√≤n ${product.stock} s·∫£n ph·∫©m.`);
  }

  // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
  cart.items[itemIndex].quantity = quantity;
  cart.items[itemIndex].updatedAt = new Date();

  // T√≠nh l·∫°i t·ªïng ti·ªÅn
  cart.subtotal = calculateSubtotal(cart.items);

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {string} itemId - ID c·ªßa item trong gi·ªè h√†ng
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu c√≥ l·ªói khi x√≥a s·∫£n ph·∫©m
 */
const removeItemFromCart = async (userId, sessionId, itemId) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // Ki·ªÉm tra item t·ªìn t·∫°i trong gi·ªè h√†ng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m trong gi·ªè h√†ng');
  }

  // X√≥a item kh·ªèi gi·ªè h√†ng
  cart.items.splice(itemIndex, 1);

  // T√≠nh l·∫°i t·ªïng ti·ªÅn
  cart.subtotal = calculateSubtotal(cart.items);

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * X√≥a to√†n b·ªô gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @returns {Promise<Object>} Gi·ªè h√†ng tr·ªëng
 */
const clearCart = async (userId, sessionId) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // X√≥a t·∫•t c·∫£ items
  cart.items = [];
  cart.subtotal = 0;

  // X√≥a m√£ gi·∫£m gi√° n·∫øu c√≥
  if (cart.coupon) {
    cart.coupon = null;
  }

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * √Åp d·ª•ng m√£ gi·∫£m gi√° v√†o gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {string} code - M√£ gi·∫£m gi√°
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu m√£ gi·∫£m gi√° kh√¥ng h·ª£p l·ªá
 */
const applyCoupon = async (userId, sessionId, code) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // Ki·ªÉm tra gi·ªè h√†ng c√≥ s·∫£n ph·∫©m kh√¥ng
  if (cart.items.length === 0) {
    throw new ApiError(400, 'Gi·ªè h√†ng tr·ªëng, kh√¥ng th·ªÉ √°p d·ª•ng m√£ gi·∫£m gi√°');
  }

  // TODO: Tri·ªÉn khai logic x√°c th·ª±c m√£ gi·∫£m gi√° th·ª±c t·∫ø
  // V√≠ d·ª• ƒë∆°n gi·∫£n: ki·ªÉm tra m√£ "WELCOME10" gi·∫£m 10% t·ªïng gi√° tr·ªã
  if (code === 'WELCOME10') {
    const discount = Math.round(cart.subtotal * 0.1); // Gi·∫£m 10%

    cart.coupon = {
      code,
      discount,
      appliedAt: new Date(),
    };

    // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
    cart.lastActivity = new Date();

    // L∆∞u gi·ªè h√†ng
    return await cartRepository.update(cart._id, cart);
  }

  throw new ApiError(400, 'M√£ gi·∫£m gi√° kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
};

/**
 * X√≥a m√£ gi·∫£m gi√° kh·ªèi gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 */
const removeCoupon = async (userId, sessionId) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // X√≥a m√£ gi·∫£m gi√°
  cart.coupon = null;

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * H·ª£p nh·∫•t gi·ªè h√†ng khi ƒëƒÉng nh·∫≠p
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p
 * @param {string} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ h·ª£p nh·∫•t
 */
const mergeCartsOnLogin = async (userId, sessionId) => {
  // T√¨m gi·ªè h√†ng c·ªßa kh√°ch v√£ng lai
  const guestCart = await cartRepository.findOne({ sessionId, status: 'active' });

  if (!guestCart) {
    return await getActiveCart(userId, null);
  }

  // T√¨m ho·∫∑c t·∫°o gi·ªè h√†ng c·ªßa ng∆∞·ªùi d√πng
  const userCart = await getActiveCart(userId, null);

  // N·∫øu gi·ªè h√†ng kh√°ch kh√¥ng c√≥ s·∫£n ph·∫©m, kh√¥ng c·∫ßn h·ª£p nh·∫•t
  if (guestCart.items.length === 0) {
    // ƒê√°nh d·∫•u gi·ªè h√†ng kh√°ch l√† ƒë√£ h·ª£p nh·∫•t
    await cartRepository.update(guestCart._id, {
      status: 'merged',
      updatedAt: new Date(),
    });

    return userCart;
  }

  // H·ª£p nh·∫•t c√°c s·∫£n ph·∫©m t·ª´ gi·ªè h√†ng kh√°ch v√†o gi·ªè h√†ng ng∆∞·ªùi d√πng
  for (const guestItem of guestCart.items) {
    const existingItemIndex = userCart.items.findIndex((item) => {
      return (
        item.product.toString() === guestItem.product.toString() &&
        JSON.stringify(item.attributes) === JSON.stringify(guestItem.attributes)
      );
    });

    // N·∫øu s·∫£n ph·∫©m ƒë√£ c√≥ trong gi·ªè h√†ng ng∆∞·ªùi d√πng, c·ªông s·ªë l∆∞·ª£ng
    if (existingItemIndex > -1) {
      // L·∫•y th√¥ng tin s·∫£n ph·∫©m ƒë·ªÉ ki·ªÉm tra t·ªìn kho
      const product = await productRepository.findById(guestItem.product);

      if (product) {
        const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

        // Ki·ªÉm tra t·ªìn kho
        if (product.stock >= newQuantity) {
          userCart.items[existingItemIndex].quantity = newQuantity;
        } else {
          // N·∫øu kh√¥ng ƒë·ªß t·ªìn kho, gi·ªõi h·∫°n s·ªë l∆∞·ª£ng
          userCart.items[existingItemIndex].quantity = product.stock;
        }

        userCart.items[existingItemIndex].updatedAt = new Date();
      }
    }
    // N·∫øu s·∫£n ph·∫©m ch∆∞a c√≥, th√™m v√†o gi·ªè h√†ng ng∆∞·ªùi d√πng
    else {
      // Ki·ªÉm tra l·∫°i s·∫£n ph·∫©m v√† t·ªìn kho
      const product = await productRepository.findById(guestItem.product);

      if (product && product.isActive) {
        // ƒêi·ªÅu ch·ªânh s·ªë l∆∞·ª£ng n·∫øu v∆∞·ª£t qu√° t·ªìn kho
        const quantity = product.stock >= guestItem.quantity ? guestItem.quantity : product.stock;

        if (quantity > 0) {
          userCart.items.push({
            ...guestItem,
            quantity,
            updatedAt: new Date(),
          });
        }
      }
    }
  }

  // T√≠nh l·∫°i t·ªïng ti·ªÅn
  userCart.subtotal = calculateSubtotal(userCart.items);

  // √Åp d·ª•ng m√£ gi·∫£m gi√° t·ª´ gi·ªè h√†ng kh√°ch n·∫øu c√≥ v√† gi·ªè h√†ng ng∆∞·ªùi d√πng ch∆∞a c√≥
  if (guestCart.coupon && !userCart.coupon) {
    userCart.coupon = {
      ...guestCart.coupon,
      appliedAt: new Date(),
    };
  }

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  userCart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng ng∆∞·ªùi d√πng
  const updatedUserCart = await cartRepository.update(userCart._id, userCart);

  // ƒê√°nh d·∫•u gi·ªè h√†ng kh√°ch l√† ƒë√£ h·ª£p nh·∫•t
  await cartRepository.update(guestCart._id, {
    status: 'merged',
    updatedAt: new Date(),
  });

  return updatedUserCart;
};

/**
 * T√≠nh t·ªïng ti·ªÅn gi·ªè h√†ng
 * @param {Array} items - C√°c s·∫£n ph·∫©m trong gi·ªè h√†ng
 * @returns {number} T·ªïng ti·ªÅn
 */
const calculateSubtotal = (items) => {
  return items.reduce((total, item) => total + item.price * item.quantity, 0);
};

/**
 * C·∫≠p nh·∫≠t th√¥ng tin v·∫≠n chuy·ªÉn cho gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {Object} shippingAddress - Th√¥ng tin ƒë·ªãa ch·ªâ giao h√†ng
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 */
const updateShippingAddress = async (userId, sessionId, shippingAddress) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // C·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng
  cart.shippingAddress = shippingAddress;

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * C·∫≠p nh·∫≠t ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn cho gi·ªè h√†ng
 * @param {string|null} userId - ID c·ªßa ng∆∞·ªùi d√πng (null n·∫øu l√† kh√°ch v√£ng lai)
 * @param {string|null} sessionId - ID phi√™n c·ªßa kh√°ch v√£ng lai
 * @param {Object} shippingMethod - Th√¥ng tin ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 */
const updateShippingMethod = async (userId, sessionId, shippingMethod) => {
  // L·∫•y gi·ªè h√†ng hi·ªán t·∫°i
  const cart = await getActiveCart(userId, sessionId);

  // C·∫≠p nh·∫≠t ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn
  cart.shippingMethod = shippingMethod;

  // C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông
  cart.lastActivity = new Date();

  // L∆∞u gi·ªè h√†ng
  return await cartRepository.update(cart._id, cart);
};

/**
 * ƒê√°nh d·∫•u gi·ªè h√†ng l√† ƒë√£ b·ªã b·ªè r∆°i
 * @param {string} cartId - ID c·ªßa gi·ªè h√†ng
 * @returns {Promise<Object>} Gi·ªè h√†ng ƒë√£ c·∫≠p nh·∫≠t
 */
const markCartAsAbandoned = async (cartId) => {
  return await cartRepository.update(cartId, {
    status: 'abandoned',
    updatedAt: new Date(),
  });
};

/**
 * L·∫•y danh s√°ch gi·ªè h√†ng b·ªã b·ªè r∆°i ƒë·ªÉ g·ª≠i email nh·∫Øc nh·ªü
 * @param {number} hoursSinceLastActivity - S·ªë gi·ªù k·ªÉ t·ª´ l·∫ßn ho·∫°t ƒë·ªông cu·ªëi c√πng
 * @returns {Promise<Array>} Danh s√°ch gi·ªè h√†ng b·ªã b·ªè r∆°i
 */
const getAbandonedCarts = async (hoursSinceLastActivity = 24) => {
  const date = new Date();
  date.setHours(date.getHours() - hoursSinceLastActivity);

  return await cartRepository.find({
    status: 'active',
    lastActivity: { $lt: date },
    items: { $exists: true, $not: { $size: 0 } },
  });
};

module.exports = {
  generateSessionId,
  getActiveCart,
  addItemToCart,
  updateCartItem,
  removeItemFromCart,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCartsOnLogin,
  updateShippingAddress,
  updateShippingMethod,
  markCartAsAbandoned,
  getAbandonedCarts,
};


--- File: server/src/services/category/categoryService.js ---
/**
 * Category Service
 * X·ª≠ l√Ω logic nghi·ªáp v·ª• cho danh m·ª•c s·∫£n ph·∫©m
 */

const { ApiError } = require('../../common/errors/apiError');
const categoryRepository = require('../../data/repositories/categoryRepository');
const productRepository = require('../../data/repositories/productRepository');
const slugify = require('slugify');

/**
 * L·∫•y t·∫•t c·∫£ danh m·ª•c (c√≥ th·ªÉ l·ªçc, s·∫Øp x·∫øp, ph√¢n trang)
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Array>} Danh s√°ch danh m·ª•c
 */
const getAllCategories = async (features = {}) => {
  return await categoryRepository.findAll(features);
};

/**
 * L·∫•y danh m·ª•c theo ID
 * @param {string} id - ID c·ªßa danh m·ª•c
 * @returns {Promise<Object>} Th√¥ng tin danh m·ª•c
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y danh m·ª•c
 */
const getCategoryById = async (id) => {
  const category = await categoryRepository.findById(id);
  if (!category) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y danh m·ª•c');
  }
  return category;
};

/**
 * L·∫•y danh m·ª•c theo slug
 * @param {string} slug - Slug c·ªßa danh m·ª•c
 * @returns {Promise<Object>} Th√¥ng tin danh m·ª•c
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y danh m·ª•c
 */
const getCategoryBySlug = async (slug) => {
  const category = await categoryRepository.findOne({ slug });
  if (!category) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y danh m·ª•c');
  }
  return category;
};

/**
 * L·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m trong danh m·ª•c
 * @param {string} categoryId - ID c·ªßa danh m·ª•c
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Array>} Danh s√°ch s·∫£n ph·∫©m trong danh m·ª•c
 */
const getCategoryProducts = async (categoryId, features = {}) => {
  // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i
  const category = await getCategoryById(categoryId);
  
  // Th√™m filter cho category v√†o features
  const categoryFilter = { ...features };
  categoryFilter.filter = { ...categoryFilter.filter, category: categoryId };
  
  // L·∫•y t·∫•t c·∫£ c√°c danh m·ª•c con
  const subcategories = await getSubcategories(categoryId);
  
  // N·∫øu c√≥ danh m·ª•c con, th√™m v√†o filter
  if (subcategories.length > 0) {
    const subcategoryIds = subcategories.map(subcat => subcat._id);
    categoryFilter.filter = { 
      ...categoryFilter.filter, 
      $or: [
        { category: categoryId },
        { category: { $in: subcategoryIds } }
      ]
    };
  }
  
  return await productRepository.findAll(categoryFilter);
};

/**
 * T·∫°o danh m·ª•c m·ªõi
 * @param {Object} categoryData - D·ªØ li·ªáu danh m·ª•c
 * @returns {Promise<Object>} Danh m·ª•c ƒë√£ t·∫°o
 */
const createCategory = async (categoryData) => {
  // N·∫øu kh√¥ng c√≥ slug, t·∫°o t·ª´ t√™n
  if (!categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Ki·ªÉm tra slug ƒë√£ t·ªìn t·∫°i ch∆∞a
  const existingCategory = await categoryRepository.findOne({ slug: categoryData.slug });
  if (existingCategory) {
    throw new ApiError(400, 'Slug ƒë√£ t·ªìn t·∫°i');
  }
  
  // X·ª≠ l√Ω danh m·ª•c cha v√† ancestors
  if (categoryData.parent) {
    const parentCategory = await getCategoryById(categoryData.parent);
    
    // Thi·∫øt l·∫≠p level v√† ancestors
    categoryData.level = parentCategory.level + 1;
    categoryData.ancestors = [
      ...parentCategory.ancestors,
      {
        _id: parentCategory._id,
        name: parentCategory.name,
        slug: parentCategory.slug
      }
    ];
  } else {
    // Danh m·ª•c g·ªëc
    categoryData.level = 0;
    categoryData.ancestors = [];
  }
  
  return await categoryRepository.create(categoryData);
};

/**
 * C·∫≠p nh·∫≠t danh m·ª•c
 * @param {string} id - ID c·ªßa danh m·ª•c
 * @param {Object} categoryData - D·ªØ li·ªáu c·∫≠p nh·∫≠t
 * @returns {Promise<Object>} Danh m·ª•c ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y danh m·ª•c
 */
const updateCategory = async (id, categoryData) => {
  // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i
  const category = await getCategoryById(id);
  
  // N·∫øu thay ƒë·ªïi t√™n v√† kh√¥ng cung c·∫•p slug, c·∫≠p nh·∫≠t slug
  if (categoryData.name && !categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Ki·ªÉm tra slug m·ªõi c√≥ b·ªã tr√πng kh√¥ng
  if (categoryData.slug && categoryData.slug !== category.slug) {
    const existingCategory = await categoryRepository.findOne({ 
      slug: categoryData.slug,
      _id: { $ne: id }
    });
    
    if (existingCategory) {
      throw new ApiError(400, 'Slug ƒë√£ t·ªìn t·∫°i');
    }
  }
  
  // N·∫øu thay ƒë·ªïi danh m·ª•c cha
  if (categoryData.parent !== undefined && categoryData.parent !== category.parent) {
    // Kh√¥ng cho ph√©p ƒë·∫∑t danh m·ª•c con l√†m cha c·ªßa ch√≠nh n√≥
    const subcategories = await getSubcategories(id);
    const subcategoryIds = subcategories.map(subcat => subcat._id.toString());
    
    if (categoryData.parent && (categoryData.parent === id || subcategoryIds.includes(categoryData.parent))) {
      throw new ApiError(400, 'Kh√¥ng th·ªÉ ƒë·∫∑t danh m·ª•c con l√†m cha c·ªßa ch√≠nh n√≥');
    }
    
    // C·∫≠p nh·∫≠t level v√† ancestors
    if (categoryData.parent) {
      const parentCategory = await getCategoryById(categoryData.parent);
      
      categoryData.level = parentCategory.level + 1;
      categoryData.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug
        }
      ];
    } else {
      // Chuy·ªÉn th√†nh danh m·ª•c g·ªëc
      categoryData.level = 0;
      categoryData.ancestors = [];
    }
    
    // C·∫≠p nh·∫≠t t·∫•t c·∫£ danh m·ª•c con
    await updateSubcategoryAncestors(id, category.name, category.slug);
  }
  
  // C·∫≠p nh·∫≠t danh m·ª•c
  const updatedCategory = await categoryRepository.update(id, categoryData);
  
  // N·∫øu thay ƒë·ªïi t√™n ho·∫∑c slug, c·∫≠p nh·∫≠t ancestors cho t·∫•t c·∫£ danh m·ª•c con
  if ((categoryData.name && categoryData.name !== category.name) ||
      (categoryData.slug && categoryData.slug !== category.slug)) {
    await updateSubcategoryAncestors(id, updatedCategory.name, updatedCategory.slug);
  }
  
  return updatedCategory;
};

/**
 * X√≥a danh m·ª•c
 * @param {string} id - ID c·ªßa danh m·ª•c
 * @returns {Promise<void>}
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y danh m·ª•c ho·∫∑c c√≥ danh m·ª•c con
 */
const deleteCategory = async (id) => {
  // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i
  const category = await getCategoryById(id);
  
  // Ki·ªÉm tra n·∫øu c√≥ danh m·ª•c con
  const subcategories = await categoryRepository.find({ parent: id });
  if (subcategories.length > 0) {
    throw new ApiError(400, 'Kh√¥ng th·ªÉ x√≥a danh m·ª•c c√≥ danh m·ª•c con');
  }
  
  // Ki·ªÉm tra n·∫øu c√≥ s·∫£n ph·∫©m trong danh m·ª•c
  const products = await productRepository.find({ category: id }, { limit: 1 });
  if (products.length > 0) {
    throw new ApiError(400, 'Kh√¥ng th·ªÉ x√≥a danh m·ª•c c√≥ s·∫£n ph·∫©m');
  }
  
  // X√≥a danh m·ª•c
  await categoryRepository.delete(id);
};

/**
 * L·∫•y t·∫•t c·∫£ danh m·ª•c con tr·ª±c ti·∫øp
 * @param {string} parentId - ID c·ªßa danh m·ª•c cha
 * @returns {Promise<Array>} Danh s√°ch danh m·ª•c con
 */
const getDirectSubcategories = async (parentId) => {
  return await categoryRepository.find({ parent: parentId });
};

/**
 * L·∫•y t·∫•t c·∫£ danh m·ª•c con (bao g·ªìm c·∫£ con c·ªßa con)
 * @param {string} categoryId - ID c·ªßa danh m·ª•c
 * @returns {Promise<Array>} Danh s√°ch t·∫•t c·∫£ danh m·ª•c con
 */
const getSubcategories = async (categoryId) => {
  return await categoryRepository.findSubcategories(categoryId);
};

/**
 * C·∫≠p nh·∫≠t ancestors cho t·∫•t c·∫£ danh m·ª•c con khi danh m·ª•c cha thay ƒë·ªïi
 * @param {string} categoryId - ID c·ªßa danh m·ª•c cha
 * @param {string} categoryName - T√™n m·ªõi c·ªßa danh m·ª•c cha
 * @param {string} categorySlug - Slug m·ªõi c·ªßa danh m·ª•c cha
 * @returns {Promise<void>}
 */
const updateSubcategoryAncestors = async (categoryId, categoryName, categorySlug) => {
  // L·∫•y t·∫•t c·∫£ danh m·ª•c con tr·ª±c ti·∫øp
  const directSubcategories = await getDirectSubcategories(categoryId);
  
  // C·∫≠p nh·∫≠t ancestors cho t·ª´ng danh m·ª•c con
  for (const subcategory of directSubcategories) {
    // T√¨m v·ªã tr√≠ c·ªßa danh m·ª•c cha trong ancestors
    const ancestorIndex = subcategory.ancestors.findIndex(
      ancestor => ancestor._id.toString() === categoryId
    );
    
    if (ancestorIndex !== -1) {
      // C·∫≠p nh·∫≠t th√¥ng tin ancestor
      const updatedAncestors = [...subcategory.ancestors];
      updatedAncestors[ancestorIndex] = {
        _id: categoryId,
        name: categoryName,
        slug: categorySlug
      };
      
      // C·∫≠p nh·∫≠t danh m·ª•c con
      await categoryRepository.update(subcategory._id, {
        ancestors: updatedAncestors
      });
      
      // ƒê·ªá quy c·∫≠p nh·∫≠t c√°c danh m·ª•c con c·ªßa con
      await updateSubcategoryAncestors(
        subcategory._id,
        subcategory.name,
        subcategory.slug
      );
    }
  }
};

/**
 * T·∫°o breadcrumbs t·ª´ ancestors
 * @param {string} categoryId - ID c·ªßa danh m·ª•c
 * @returns {Promise<Array>} Danh s√°ch breadcrumbs
 */
const createBreadcrumbs = async (categoryId) => {
  const category = await getCategoryById(categoryId);
  
  // T·∫°o breadcrumbs t·ª´ ancestors v√† th√™m danh m·ª•c hi·ªán t·∫°i
  const breadcrumbs = [
    ...category.ancestors.map(ancestor => ({
      id: ancestor._id,
      name: ancestor.name,
      slug: ancestor.slug
    })),
    {
      id: category._id,
      name: category.name,
      slug: category.slug
    }
  ];
  
  return breadcrumbs;
};

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryBySlug,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getDirectSubcategories,
  getSubcategories,
  createBreadcrumbs
};

--- File: server/src/services/email/emailService.js ---
/**
 * Email Service - x·ª≠ l√Ω g·ª≠i email
 * @author Steve
 * @project RunOut-Biliard
 */

const nodemailer = require('nodemailer');
const path = require('path');
const fs = require('fs').promises;
const handlebars = require('handlebars');
const logger = require('../../config/logger');
const environment = require('../../config/environment');

/**
 * Class EmailService - x·ª≠ l√Ω g·ª≠i email
 */
class EmailService {
  constructor() {
    // Thi·∫øt l·∫≠p transporter
    this.setupTransporter();

    // ƒê∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c ch·ª©a templates
    this.templatesDir = path.resolve(__dirname, 'templates');

    // Cache cho templates ƒë√£ compile
    this.templateCache = {};
  }

  /**
   * Thi·∫øt l·∫≠p transporter cho Nodemailer
   */
  setupTransporter() {
    // S·ª≠ d·ª•ng c·∫•u h√¨nh kh√°c nhau t√πy thu·ªôc v√†o m√¥i tr∆∞·ªùng
    if (environment.app.environment === 'development') {
      // S·ª≠ d·ª•ng Ethereal cho m√¥i tr∆∞·ªùng development
      this.createTestAccount();
    } else {
      // S·ª≠ d·ª•ng c·∫•u h√¨nh SMTP th·ª±c cho production
      this.transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST,
        port: process.env.EMAIL_PORT,
        secure: process.env.EMAIL_SECURE === 'true',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS,
        },
      });
    }
  }

  /**
   * T·∫°o test account v·ªõi Ethereal cho m√¥i tr∆∞·ªùng development
   */
  async createTestAccount() {
    try {
      const testAccount = await nodemailer.createTestAccount();

      this.transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email',
        port: 587,
        secure: false,
        auth: {
          user: testAccount.user,
          pass: testAccount.pass,
        },
      });

      logger.info(`ƒê√£ t·∫°o test account v·ªõi Ethereal Email: ${testAccount.user}`);
    } catch (error) {
      logger.error(`Kh√¥ng th·ªÉ t·∫°o test account: ${error.message}`);

      // Fallback ƒë·∫øn c·∫•u h√¨nh gi·∫£ l·∫≠p
      this.transporter = {
        sendMail: async (mailOptions) => {
          logger.info('G·ª≠i email gi·∫£ l·∫≠p:');
          logger.info(`ƒê·∫øn: ${mailOptions.to}`);
          logger.info(`Ch·ªß ƒë·ªÅ: ${mailOptions.subject}`);
          logger.info(`N·ªôi dung: ${mailOptions.text || mailOptions.html}`);

          return { messageId: `mock_${Date.now()}` };
        },
      };
    }
  }

  /**
   * ƒê·ªçc v√† compile template email
   * @param {string} templateName - T√™n template
   * @returns {Promise<Function>} - Template ƒë√£ compile
   */
  async getTemplate(templateName) {
    // Ki·ªÉm tra cache
    if (this.templateCache[templateName]) {
      return this.templateCache[templateName];
    }

    try {
      // ƒê·ªçc file template
      const templatePath = path.join(this.templatesDir, `${templateName}.hbs`);
      const templateSource = await fs.readFile(templatePath, 'utf8');

      // Compile template
      const template = handlebars.compile(templateSource);

      // L∆∞u v√†o cache
      this.templateCache[templateName] = template;

      return template;
    } catch (error) {
      logger.error(`Kh√¥ng th·ªÉ ƒë·ªçc template email '${templateName}': ${error.message}`);
      throw error;
    }
  }

  /**
   * G·ª≠i email
   * @param {Object} options - T√πy ch·ªçn email
   * @param {string} options.to - Ng∆∞·ªùi nh·∫≠n
   * @param {string} options.subject - Ch·ªß ƒë·ªÅ
   * @param {string} options.template - T√™n template (kh√¥ng c√≥ ph·∫ßn m·ªü r·ªông)
   * @param {Object} options.context - D·ªØ li·ªáu cho template
   * @returns {Promise<Object>} - K·∫øt qu·∫£ g·ª≠i email
   */
  async sendEmail(options) {
    try {
      const { to, subject, template, context } = options;

      // L·∫•y template
      const compiledTemplate = await this.getTemplate(template);

      // Th√™m v√†o c√°c bi·∫øn to√†n c·ª•c
      const enhancedContext = {
        ...context,
        appName: environment.app.name,
        signature: environment.app.signature,
        year: new Date().getFullYear(),
        logoUrl: process.env.APP_LOGO_URL || 'https://example.com/logo.png',
      };

      // Render HTML t·ª´ template
      const html = compiledTemplate(enhancedContext);

      // Thi·∫øt l·∫≠p mail options
      const mailOptions = {
        from: process.env.EMAIL_FROM || `"${environment.app.name}" <no-reply@example.com>`,
        to,
        subject,
        html,
      };

      // G·ª≠i email
      const info = await this.transporter.sendMail(mailOptions);

      // Log URL ƒë·ªÉ xem email (ch·ªâ trong m√¥i tr∆∞·ªùng development v·ªõi Ethereal)
      if (environment.app.environment === 'development' && info.messageId) {
        logger.info(`URL xem email: ${nodemailer.getTestMessageUrl(info)}`);
      }

      return info;
    } catch (error) {
      logger.error(`L·ªói g·ª≠i email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new EmailService();

// Helper function ƒë·ªÉ s·ª≠ d·ª•ng service d·ªÖ d√†ng h∆°n
module.exports.sendEmail = (options) => module.exports.sendEmail(options);


--- File: server/src/services/order/orderService.js ---
/**
 * Order Service
 * X·ª≠ l√Ω logic nghi·ªáp v·ª• cho ƒë∆°n h√†ng
 */

const { ApiError } = require('../../common/errors/apiError');
const orderRepository = require('../../data/repositories/orderRepository');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const emailService = require('../email/emailService');
const { generateOrderNumber } = require('../../utils/orderUtils');
const VNPayService = require('./vnpayService');

/**
 * L·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng (admin)
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Object>} Danh s√°ch ƒë∆°n h√†ng v√† th√¥ng tin ph√¢n trang
 */
const getAllOrders = async (features = {}) => {
  return await orderRepository.findAll(features);
};

/**
 * L·∫•y ƒë∆°n h√†ng theo ID
 * @param {string} id - ID c·ªßa ƒë∆°n h√†ng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng ƒëang y√™u c·∫ßu
 * @param {boolean} isAdmin - Ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng
 * @returns {Promise<Object>} Th√¥ng tin ƒë∆°n h√†ng
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c kh√¥ng c√≥ quy·ªÅn truy c·∫≠p
 */
const getOrderById = async (id, userId, isAdmin) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
  }

  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ƒë∆°n h√†ng n√†y');
  }

  return order;
};

/**
 * L·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng c·ªßa m·ªôt ng∆∞·ªùi d√πng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Object>} Danh s√°ch ƒë∆°n h√†ng v√† th√¥ng tin ph√¢n trang
 */
const getOrdersByUserId = async (userId, features = {}) => {
  // Th√™m filter cho user
  const userFilter = { ...features };
  userFilter.filter = { ...userFilter.filter, user: userId };

  return await orderRepository.findAll(userFilter);
};

/**
 * T·∫°o ƒë∆°n h√†ng m·ªõi
 * @param {Object} orderData - D·ªØ li·ªáu ƒë∆°n h√†ng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng ƒë·∫∑t h√†ng
 * @returns {Promise<Object>} ƒê∆°n h√†ng ƒë√£ t·∫°o
 * @throws {ApiError} N·∫øu c√≥ l·ªói khi t·∫°o ƒë∆°n h√†ng
 */
const createOrder = async (orderData, userId) => {
  // Kh·ªüi t·∫°o ƒë∆°n h√†ng
  const orderInfo = {
    orderNumber: await generateOrderNumber(),
    user: userId,
    customerInfo: orderData.customerInfo,
    shippingAddress: orderData.shippingAddress,
    shippingMethod: orderData.shippingMethod,
    paymentMethod: orderData.paymentMethod,
    customerNotes: orderData.customerNotes,
    status: 'pending',
    statusHistory: [
      {
        status: 'pending',
        date: new Date(),
        note: 'ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o',
      },
    ],
  };

  let items = [];
  let subtotal = 0;

  // Tr∆∞·ªùng h·ª£p 1: T·∫°o ƒë∆°n h√†ng t·ª´ gi·ªè h√†ng
  if (orderData.cartId) {
    const cart = await cartRepository.findById(orderData.cartId);

    if (!cart) {
      throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y gi·ªè h√†ng');
    }

    // Ki·ªÉm tra quy·ªÅn truy c·∫≠p gi·ªè h√†ng
    if (cart.user.toString() !== userId) {
      throw new ApiError(403, 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p gi·ªè h√†ng n√†y');
    }

    // Chuy·ªÉn t·ª´ cart items sang order items
    items = await Promise.all(
      cart.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ${item.product}`);
        }

        // Ki·ªÉm tra t·ªìn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `S·∫£n ph·∫©m ${product.name} ch·ªâ c√≤n ${product.stock} s·∫£n ph·∫©m trong kho`
          );
        }

        return {
          product: item.product,
          name: product.name,
          price: item.price,
          quantity: item.quantity,
          totalPrice: item.price * item.quantity,
          attributes: item.attributes,
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // T√≠nh t·ªïng ti·ªÅn
    subtotal = cart.subtotal;

    // L·∫•y th√¥ng tin khuy·∫øn m√£i t·ª´ gi·ªè h√†ng
    if (cart.coupon) {
      orderInfo.discount = {
        amount: cart.coupon.discount,
        code: cart.coupon.code,
      };
    }

    // ƒê√°nh d·∫•u gi·ªè h√†ng ƒë√£ chuy·ªÉn th√†nh ƒë∆°n h√†ng
    await cartRepository.update(cart._id, { status: 'converted' });
  }
  // Tr∆∞·ªùng h·ª£p 2: T·∫°o ƒë∆°n h√†ng t·ª´ danh s√°ch s·∫£n ph·∫©m tr·ª±c ti·∫øp
  else if (orderData.items && orderData.items.length > 0) {
    items = await Promise.all(
      orderData.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ${item.product}`);
        }

        // Ki·ªÉm tra t·ªìn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `S·∫£n ph·∫©m ${product.name} ch·ªâ c√≤n ${product.stock} s·∫£n ph·∫©m trong kho`
          );
        }

        const itemPrice = product.salePrice || product.price;
        const totalPrice = itemPrice * item.quantity;
        subtotal += totalPrice;

        return {
          product: item.product,
          name: product.name,
          price: itemPrice,
          quantity: item.quantity,
          totalPrice,
          attributes: item.attributes || {},
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // √Åp d·ª•ng m√£ gi·∫£m gi√° n·∫øu c√≥
    if (orderData.couponCode) {
      // TODO: Tri·ªÉn khai logic √°p d·ª•ng m√£ gi·∫£m gi√°
    }
  } else {
    throw new ApiError(400, 'ƒê∆°n h√†ng ph·∫£i c√≥ √≠t nh·∫•t m·ªôt s·∫£n ph·∫©m');
  }

  // T√≠nh gi√° v·∫≠n chuy·ªÉn
  const shippingCost = calculateShippingCost(
    orderData.shippingMethod,
    orderData.shippingAddress.country
  );

  // T√≠nh thu·∫ø (n·∫øu c√≥)
  const tax = 0; // TODO: Tri·ªÉn khai t√≠nh thu·∫ø

  // T√≠nh t·ªïng ti·ªÅn cu·ªëi c√πng
  const discount = orderInfo.discount ? orderInfo.discount.amount : 0;
  const totalAmount = subtotal + shippingCost + tax - discount;

  // Ho√†n thi·ªán th√¥ng tin ƒë∆°n h√†ng
  orderInfo.items = items;
  orderInfo.subtotal = subtotal;
  orderInfo.shippingCost = shippingCost;
  orderInfo.tax = tax;
  orderInfo.totalAmount = totalAmount;
  orderInfo.paymentStatus = orderData.paymentMethod === 'cod' ? 'pending' : 'pending';

  // L∆∞u ƒë∆°n h√†ng v√†o database
  let newOrder;
  try {
    newOrder = await orderRepository.create(orderInfo);
  } catch (error) {
    throw new ApiError(500, 'L·ªói khi t·∫°o ƒë∆°n h√†ng: ' + error.message);
  }

  // C·∫≠p nh·∫≠t t·ªìn kho
  try {
    await updateInventory(items);
  } catch (error) {
    // N·∫øu c·∫≠p nh·∫≠t t·ªìn kho th·∫•t b·∫°i, x√≥a ƒë∆°n h√†ng ƒë√£ t·∫°o
    try {
      await orderRepository.delete(newOrder._id);
    } catch (deleteError) {
      console.error('Kh√¥ng th·ªÉ x√≥a ƒë∆°n h√†ng sau khi c·∫≠p nh·∫≠t t·ªìn kho th·∫•t b·∫°i:', deleteError);
    }
    throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t t·ªìn kho: ' + error.message);
  }

  // T·∫°o URL thanh to√°n n·∫øu ph∆∞∆°ng th·ª©c l√† vnpay
  if (orderData.paymentMethod === 'vnpay') {
    try {
      const paymentUrl = await VNPayService.createPaymentUrl({
        orderId: newOrder._id,
        amount: totalAmount,
        orderInfo: `Thanh to√°n ƒë∆°n h√†ng ${newOrder.orderNumber}`,
      });

      // Tr·∫£ v·ªÅ URL thanh to√°n c√πng v·ªõi ƒë∆°n h√†ng
      return { order: newOrder, paymentUrl };
    } catch (error) {
      // N·∫øu t·∫°o URL thanh to√°n th·∫•t b·∫°i, kh√¥ng c·∫ßn x√≥a ƒë∆°n h√†ng
      // Ch·ªâ ghi log v√† tr·∫£ v·ªÅ ƒë∆°n h√†ng m√† kh√¥ng c√≥ URL thanh to√°n
      console.error('L·ªói khi t·∫°o URL thanh to√°n VNPay:', error);
      return newOrder;
    }
  }

  // G·ª≠i email x√°c nh·∫≠n ƒë∆°n h√†ng
  try {
    await sendOrderConfirmationEmail(newOrder);
  } catch (error) {
    // N·∫øu g·ª≠i email th·∫•t b·∫°i, ch·ªâ ghi log l·ªói nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác t·∫°o ƒë∆°n h√†ng
    console.error('L·ªói khi g·ª≠i email x√°c nh·∫≠n ƒë∆°n h√†ng:', error);
  }

  return newOrder;
};

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
 * @param {string} id - ID c·ªßa ƒë∆°n h√†ng
 * @param {string} status - Tr·∫°ng th√°i m·ªõi
 * @param {string} note - Ghi ch√∫ khi c·∫≠p nh·∫≠t tr·∫°ng th√°i
 * @param {string} adminId - ID c·ªßa admin th·ª±c hi·ªán c·∫≠p nh·∫≠t
 * @returns {Promise<Object>} ƒê∆°n h√†ng ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá
 */
const updateOrderStatus = async (id, status, note, adminId) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
  }

  // Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i v√† tr·∫°ng th√°i m·ªõi
  const validStatusTransitions = {
    pending: ['processing', 'cancelled'],
    processing: ['packed', 'cancelled'],
    packed: ['shipped', 'cancelled'],
    shipped: ['delivered', 'returned'],
    delivered: ['returned'],
    cancelled: [],
    returned: [],
  };

  if (!validStatusTransitions[order.status].includes(status)) {
    throw new ApiError(400, `Kh√¥ng th·ªÉ chuy·ªÉn t·ª´ tr·∫°ng th√°i ${order.status} sang ${status}`);
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
  const statusHistory = {
    status,
    date: new Date(),
    note: note || `ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c chuy·ªÉn sang tr·∫°ng th√°i ${status}`,
    updatedBy: adminId,
  };

  const updateData = {
    status,
    statusHistory: [...order.statusHistory, statusHistory],
  };

  // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng kh√°c t√πy theo tr·∫°ng th√°i
  if (status === 'delivered') {
    updateData.completedAt = new Date();

    // N·∫øu thanh to√°n l√† COD, c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n
    if (order.paymentMethod === 'cod') {
      updateData.paymentStatus = 'paid';
      updateData.paymentDetails = {
        ...order.paymentDetails,
        paymentDate: new Date(),
      };
    }
  } else if (status === 'cancelled') {
    updateData.cancelledAt = new Date();

    // Ho√†n tr·∫£ s·∫£n ph·∫©m v√†o kho
    await restoreInventory(order.items);
  } else if (status === 'returned') {
    // Ho√†n tr·∫£ s·∫£n ph·∫©m v√†o kho
    await restoreInventory(order.items);
  }

  // C·∫≠p nh·∫≠t ƒë∆°n h√†ng
  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, updateData);
  } catch (error) {
    throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t ƒë∆°n h√†ng: ' + error.message);
  }

  // G·ª≠i email th√¥ng b√°o thay ƒë·ªïi tr·∫°ng th√°i
  try {
    await sendOrderStatusUpdateEmail(updatedOrder);
  } catch (error) {
    // N·∫øu g·ª≠i email th·∫•t b·∫°i, ch·ªâ ghi log l·ªói
    console.error('L·ªói khi g·ª≠i email th√¥ng b√°o thay ƒë·ªïi tr·∫°ng th√°i:', error);
  }

  return updatedOrder;
};

/**
 * H·ªßy ƒë∆°n h√†ng
 * @param {string} id - ID c·ªßa ƒë∆°n h√†ng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng y√™u c·∫ßu h·ªßy
 * @param {boolean} isAdmin - Ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng
 * @param {string} reason - L√Ω do h·ªßy ƒë∆°n h√†ng
 * @returns {Promise<Object>} ƒê∆°n h√†ng ƒë√£ h·ªßy
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c kh√¥ng th·ªÉ h·ªßy
 */
const cancelOrder = async (id, userId, isAdmin, reason) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
  }

  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'B·∫°n kh√¥ng c√≥ quy·ªÅn h·ªßy ƒë∆°n h√†ng n√†y');
  }

  // Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i
  if (!['pending', 'processing'].includes(order.status)) {
    throw new ApiError(400, 'Ch·ªâ c√≥ th·ªÉ h·ªßy ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i ƒëang x·ª≠ l√Ω ho·∫∑c ch·ªù x·ª≠ l√Ω');
  }

  // N·∫øu ƒë∆°n h√†ng ƒë√£ thanh to√°n, ki·ªÉm tra xem c√≥ th·ªÉ ho√†n ti·ªÅn kh√¥ng
  if (order.paymentStatus === 'paid') {
    // TODO: X·ª≠ l√Ω ho√†n ti·ªÅn
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
  const statusHistory = {
    status: 'cancelled',
    date: new Date(),
    note: reason || 'ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy b·ªüi ng∆∞·ªùi d√πng',
    updatedBy: isAdmin ? userId : null,
  };

  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, {
      status: 'cancelled',
      statusHistory: [...order.statusHistory, statusHistory],
      cancelledAt: new Date(),
    });
  } catch (error) {
    throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng: ' + error.message);
  }

  // Ho√†n tr·∫£ s·∫£n ph·∫©m v√†o kho
  try {
    await restoreInventory(order.items);
  } catch (error) {
    // N·∫øu ho√†n tr·∫£ s·∫£n ph·∫©m th·∫•t b·∫°i, ghi log l·ªói nh∆∞ng v·∫´n gi·ªØ tr·∫°ng th√°i ƒë∆°n h√†ng ƒë√£ h·ªßy
    console.error('L·ªói khi ho√†n tr·∫£ s·∫£n ph·∫©m v√†o kho:', error);
  }

  // G·ª≠i email th√¥ng b√°o h·ªßy ƒë∆°n h√†ng
  try {
    await sendOrderCancelledEmail(updatedOrder, reason);
  } catch (error) {
    // N·∫øu g·ª≠i email th·∫•t b·∫°i, ch·ªâ ghi log l·ªói
    console.error('L·ªói khi g·ª≠i email th√¥ng b√°o h·ªßy ƒë∆°n h√†ng:', error);
  }

  return updatedOrder;
};

/**
 * X·ª≠ l√Ω webhook t·ª´ c·ªïng thanh to√°n VNPay
 * @param {Object} paymentData - D·ªØ li·ªáu t·ª´ VNPay
 * @returns {Promise<void>}
 */
const processPaymentWebhook = async (paymentData) => {
  // X√°c th·ª±c d·ªØ li·ªáu t·ª´ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'D·ªØ li·ªáu thanh to√°n kh√¥ng h·ª£p l·ªá');
  }

  // L·∫•y th√¥ng tin ƒë∆°n h√†ng t·ª´ vnp_OrderInfo ho·∫∑c vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n d·ª±a v√†o response code
  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh to√°n th√†nh c√¥ng
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });
    } catch (error) {
      throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n: ' + error.message);
    }

    // G·ª≠i email x√°c nh·∫≠n thanh to√°n
    try {
      const updatedOrder = await orderRepository.findById(orderId);
      await sendPaymentConfirmationEmail(updatedOrder);
    } catch (error) {
      // N·∫øu g·ª≠i email th·∫•t b·∫°i, ch·ªâ ghi log l·ªói
      console.error('L·ªói khi g·ª≠i email x√°c nh·∫≠n thanh to√°n:', error);
    }
  } else {
    // Thanh to√°n th·∫•t b·∫°i
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });
    } catch (error) {
      throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n: ' + error.message);
    }
  }
};

/**
 * X·ª≠ l√Ω redirect URL t·ª´ c·ªïng thanh to√°n VNPay
 * @param {Object} paymentData - D·ªØ li·ªáu t·ª´ VNPay
 * @returns {Promise<Object>} K·∫øt qu·∫£ thanh to√°n
 */
const processPaymentReturn = async (paymentData) => {
  // X√°c th·ª±c d·ªØ li·ªáu t·ª´ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'D·ªØ li·ªáu thanh to√°n kh√¥ng h·ª£p l·ªá');
  }

  // L·∫•y th√¥ng tin ƒë∆°n h√†ng t·ª´ vnp_OrderInfo ho·∫∑c vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n d·ª±a v√†o response code
  let result = {};

  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh to√°n th√†nh c√¥ng
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });

      // G·ª≠i email x√°c nh·∫≠n thanh to√°n
      try {
        await sendPaymentConfirmationEmail(updatedOrder);
      } catch (emailError) {
        console.error('L·ªói khi g·ª≠i email x√°c nh·∫≠n thanh to√°n:', emailError);
      }

      result = {
        success: true,
        message: 'Thanh to√°n th√†nh c√¥ng',
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n: ' + error.message);
    }
  } else {
    // Thanh to√°n th·∫•t b·∫°i
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });

      result = {
        success: false,
        message: 'Thanh to√°n th·∫•t b·∫°i',
        errorCode: paymentData.vnp_ResponseCode,
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n: ' + error.message);
    }
  }

  return result;
};

/**
 * T√≠nh ph√≠ v·∫≠n chuy·ªÉn d·ª±a tr√™n ph∆∞∆°ng th·ª©c v√† ƒë·ªãa ch·ªâ
 * @param {string} method - Ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn
 * @param {string} country - Qu·ªëc gia giao h√†ng
 * @returns {number} Ph√≠ v·∫≠n chuy·ªÉn
 */
const calculateShippingCost = (method, country) => {
  // TODO: Tri·ªÉn khai t√≠nh ph√≠ v·∫≠n chuy·ªÉn th·ª±c t·∫ø
  const baseCost = method === 'express' ? 50000 : 30000;

  // T√≠nh ph√≠ v·∫≠n chuy·ªÉn d·ª±a tr√™n qu·ªëc gia
  if (country !== 'Vi·ªát Nam') {
    return baseCost * 3;
  }

  return baseCost;
};

/**
 * C·∫≠p nh·∫≠t t·ªìn kho sau khi t·∫°o ƒë∆°n h√†ng
 * @param {Array} items - Danh s√°ch s·∫£n ph·∫©m trong ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const updateInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, -item.quantity);
  }
};

/**
 * Ho√†n tr·∫£ s·∫£n ph·∫©m v√†o kho khi h·ªßy ƒë∆°n h√†ng
 * @param {Array} items - Danh s√°ch s·∫£n ph·∫©m trong ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const restoreInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, item.quantity);
  }
};

/**
 * G·ª≠i email x√°c nh·∫≠n ƒë∆°n h√†ng
 * @param {Object} order - Th√¥ng tin ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const sendOrderConfirmationEmail = async (order) => {
  await emailService.sendOrderConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderDate: order.createdAt,
    orderItems: order.items,
    subtotal: order.subtotal,
    shippingCost: order.shippingCost,
    discount: order.discount ? order.discount.amount : 0,
    tax: order.tax,
    totalAmount: order.totalAmount,
    shippingAddress: order.shippingAddress,
    paymentMethod: order.paymentMethod,
  });
};

/**
 * G·ª≠i email th√¥ng b√°o thay ƒë·ªïi tr·∫°ng th√°i ƒë∆°n h√†ng
 * @param {Object} order - Th√¥ng tin ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const sendOrderStatusUpdateEmail = async (order) => {
  await emailService.sendOrderStatusUpdate(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderStatus: order.status,
    statusNote: order.statusHistory[order.statusHistory.length - 1].note,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * G·ª≠i email th√¥ng b√°o h·ªßy ƒë∆°n h√†ng
 * @param {Object} order - Th√¥ng tin ƒë∆°n h√†ng
 * @param {string} reason - L√Ω do h·ªßy ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const sendOrderCancelledEmail = async (order, reason) => {
  await emailService.sendOrderCancelled(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    cancelReason: reason,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * G·ª≠i email x√°c nh·∫≠n thanh to√°n
 * @param {Object} order - Th√¥ng tin ƒë∆°n h√†ng
 * @returns {Promise<void>}
 */
const sendPaymentConfirmationEmail = async (order) => {
  await emailService.sendPaymentConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    paymentMethod: order.paymentMethod,
    paymentDate: order.paymentDetails.paymentDate,
    totalAmount: order.totalAmount,
    transactionId: order.paymentDetails.transactionId,
  });
};

module.exports = {
  getAllOrders,
  getOrderById,
  getOrdersByUserId,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processPaymentWebhook,
  processPaymentReturn,
};


--- File: server/src/services/product/productService.js ---
/**
 * Product Service
 * X·ª≠ l√Ω t·∫•t c·∫£ logic nghi·ªáp v·ª• li√™n quan ƒë·∫øn s·∫£n ph·∫©m
 */

const productRepository = require('../../data/repositories/productRepository');
const categoryRepository = require('../../data/repositories/categoryRepository');
const reviewRepository = require('../../data/repositories/reviewRepository');
const ProductDTO = require('../../data/dto/productDTO');
const ApiFeatures = require('../../utils/apiFeatures');
const AppError = require('../../common/errors/apiError');
const redisClient = require('../cache/redisCache');
const { formatProductResponse } = require('../../common/utils/formatters');
const { validateProductData } = require('../../common/validators/productValidator');

class ProductService {
  constructor() {
    this.productRepository = productRepository;
    this.categoryRepository = categoryRepository;
    this.reviewRepository = reviewRepository;
    this.cacheExpiry = 3600; // 1 gi·ªù
  }

  /**
   * X·ª≠ l√Ω l·ªói chung cho t·∫•t c·∫£ c√°c ph∆∞∆°ng th·ª©c
   * @param {Error} error - L·ªói c·∫ßn x·ª≠ l√Ω
   * @param {string} defaultMessage - Th√¥ng b√°o m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ph·∫£i AppError
   * @throws {AppError} - N√©m l·ªói ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
   */
  handleError(error, defaultMessage) {
    console.error(`Error in ProductService: ${error.message}`, error);
    if (error instanceof AppError) throw error;
    throw new AppError(defaultMessage, 500);
  }

  /**
   * Qu·∫£n l√Ω cache
   * @param {string} key - Kh√≥a cache
   * @param {number} expiry - Th·ªùi gian h·∫øt h·∫°n (gi√¢y)
   * @param {Function} dataFn - H√†m l·∫•y d·ªØ li·ªáu n·∫øu cache miss
   * @returns {Promise<any>} - D·ªØ li·ªáu t·ª´ cache ho·∫∑c t·ª´ h√†m dataFn
   */
  async withCache(key, expiry, dataFn) {
    try {
      // Ki·ªÉm tra cache
      const cachedData = await redisClient.get(key);
      if (cachedData) {
        console.log(`Cache hit for ${key}`);
        return JSON.parse(cachedData);
      }

      // Cache miss, l·∫•y d·ªØ li·ªáu m·ªõi
      const data = await dataFn();

      // L∆∞u v√†o cache
      await redisClient.setex(key, expiry || this.cacheExpiry, JSON.stringify(data));

      return data;
    } catch (error) {
      console.error(`Cache error for ${key}:`, error);
      // N·∫øu c√≥ l·ªói cache, v·∫´n tr·∫£ v·ªÅ d·ªØ li·ªáu
      return await dataFn();
    }
  }

  /**
   * X√≥a cache theo pattern
   * @param {string} pattern - Pattern c·ªßa kh√≥a cache c·∫ßn x√≥a
   */
  async invalidateCache(pattern) {
    try {
      if (pattern.includes('*')) {
        // X√≥a theo pattern
        const keys = await redisClient.keys(pattern);
        if (keys.length > 0) {
          await redisClient.del(keys);
          console.log(`Invalidated ${keys.length} cache keys matching ${pattern}`);
        }
      } else {
        // X√≥a m·ªôt kh√≥a c·ª• th·ªÉ
        await redisClient.del(pattern);
        console.log(`Invalidated cache key: ${pattern}`);
      }
    } catch (error) {
      console.error(`Error invalidating cache ${pattern}:`, error);
      // Kh√¥ng n√©m l·ªói, ch·ªâ ghi log
    }
  }

  /**
   * L·∫•y danh s√°ch s·∫£n ph·∫©m v·ªõi b·ªô l·ªçc v√† ph√¢n trang
   * @param {Object} queryParams - C√°c tham s·ªë truy v·∫•n
   * @returns {Promise<{products: Array, totalCount: Number, pagination: Object}>}
   */
  async getProducts(queryParams) {
    try {
      // T·∫°o kh√≥a cache d·ª±a tr√™n tham s·ªë truy v·∫•n
      const cacheKey = `products:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // T·∫°o ƒë·ªëi t∆∞·ª£ng ApiFeatures ƒë·ªÉ x·ª≠ l√Ω ph√¢n trang, s·∫Øp x·∫øp v√† l·ªçc
        const features = new ApiFeatures(this.productRepository.query(), queryParams)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Th·ª±c hi·ªán truy v·∫•n
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuy·ªÉn ƒë·ªïi th√†nh DTO
        const productDTOs = products.map((product) => new ProductDTO(product).toJSON());

        // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi s·∫£n ph·∫©m tr∆∞·ªõc khi tr·∫£ v·ªÅ
        const formattedProducts = productDTOs.map((product) => formatProductResponse(product));

        // K·∫øt qu·∫£ tr·∫£ v·ªÅ
        return {
          products: formattedProducts,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m');
    }
  }

  /**
   * L·∫•y chi ti·∫øt s·∫£n ph·∫©m theo ID
   * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
   * @returns {Promise<Object>} - Th√¥ng tin chi ti·∫øt s·∫£n ph·∫©m
   */
  async getProductById(productId) {
    try {
      const cacheKey = `product:${productId}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // L·∫•y th√¥ng tin s·∫£n ph·∫©m t·ª´ repository
        const product = await this.productRepository.findById(productId);

        if (!product) {
          throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
        }

        // L·∫•y th√™m th√¥ng tin ƒë√°nh gi√°
        const reviews = await this.reviewRepository.findByProductId(productId);

        // K·∫øt h·ª£p th√¥ng tin
        const productDTO = new ProductDTO(product).toJSON();
        productDTO.reviews = reviews;
        productDTO.averageRating =
          reviews.length > 0
            ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
            : 0;

        // L·∫•y th√¥ng tin danh m·ª•c
        if (product.categories && product.categories.length) {
          productDTO.categoryDetails = await this.categoryRepository.findByIds(product.categories);
        }

        // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi s·∫£n ph·∫©m tr∆∞·ªõc khi tr·∫£ v·ªÅ
        return formatProductResponse(productDTO);
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin chi ti·∫øt s·∫£n ph·∫©m');
    }
  }

  /**
   * T·∫°o s·∫£n ph·∫©m m·ªõi
   * @param {Object} productData - D·ªØ li·ªáu s·∫£n ph·∫©m
   * @param {String} userId - ID c·ªßa ng∆∞·ªùi d√πng t·∫°o s·∫£n ph·∫©m
   * @returns {Promise<Object>} - S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c t·∫°o
   */
  async createProduct(productData, userId) {
    try {
      // X√°c th·ª±c d·ªØ li·ªáu
      const { error } = validateProductData(productData);
      if (error) {
        throw new AppError(400, `D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá: ${error.message}`);
      }

      // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i
      if (productData.categories && productData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(productData.categories);
        if (validCategories.length !== productData.categories.length) {
          throw new AppError(400, 'M·ªôt ho·∫∑c nhi·ªÅu danh m·ª•c kh√¥ng t·ªìn t·∫°i');
        }
      }

      // T·∫°o slug t·ª´ t√™n s·∫£n ph·∫©m
      productData.slug = this.createSlugFromName(productData.name);

      // Th√™m th√¥ng tin ng∆∞·ªùi t·∫°o v√† ng√†y t·∫°o
      productData.createdBy = userId;
      productData.createdAt = new Date();
      productData.updatedAt = new Date();

      // L∆∞u v√†o c∆° s·ªü d·ªØ li·ªáu
      const newProduct = await this.productRepository.create(productData);

      // X√≥a c√°c cache li√™n quan
      await this.invalidateCache('products:*');

      // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi s·∫£n ph·∫©m tr∆∞·ªõc khi tr·∫£ v·ªÅ
      return formatProductResponse(new ProductDTO(newProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ t·∫°o s·∫£n ph·∫©m m·ªõi');
    }
  }

  /**
   * C·∫≠p nh·∫≠t s·∫£n ph·∫©m
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @param {Object} updateData - D·ªØ li·ªáu c·∫≠p nh·∫≠t
   * @param {String} userId - ID ng∆∞·ªùi d√πng th·ª±c hi·ªán c·∫≠p nh·∫≠t
   * @returns {Promise<Object>} - S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
   */
  async updateProduct(productId, updateData, userId) {
    try {
      // Ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // X√°c th·ª±c d·ªØ li·ªáu c·∫≠p nh·∫≠t
      if (Object.keys(updateData).length > 0) {
        const { error } = validateProductData(updateData, true);
        if (error) {
          throw new AppError(400, `D·ªØ li·ªáu c·∫≠p nh·∫≠t kh√¥ng h·ª£p l·ªá: ${error.message}`);
        }
      }

      // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i n·∫øu ƒë∆∞·ª£c c·∫≠p nh·∫≠t
      if (updateData.categories && updateData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(updateData.categories);
        if (validCategories.length !== updateData.categories.length) {
          throw new AppError(400, 'M·ªôt ho·∫∑c nhi·ªÅu danh m·ª•c kh√¥ng t·ªìn t·∫°i');
        }
      }

      // C·∫≠p nh·∫≠t slug n·∫øu t√™n ƒë∆∞·ª£c thay ƒë·ªïi
      if (updateData.name) {
        updateData.slug = this.createSlugFromName(updateData.name);
      }

      // Th√™m th√¥ng tin ng∆∞·ªùi c·∫≠p nh·∫≠t v√† ng√†y c·∫≠p nh·∫≠t
      updateData.updatedBy = userId;
      updateData.updatedAt = new Date();

      // C·∫≠p nh·∫≠t trong c∆° s·ªü d·ªØ li·ªáu
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, updateData);

      // X√≥a cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi s·∫£n ph·∫©m tr∆∞·ªõc khi tr·∫£ v·ªÅ
      return formatProductResponse(new ProductDTO(updatedProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·∫£n ph·∫©m');
    }
  }

  /**
   * X√≥a s·∫£n ph·∫©m
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @returns {Promise<Boolean>} - K·∫øt qu·∫£ x√≥a
   */
  async deleteProduct(productId) {
    try {
      // Ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // Ki·ªÉm tra s·∫£n ph·∫©m c√≥ trong ƒë∆°n h√†ng kh√¥ng
      // TODO: Add this check when OrderRepository is available

      // X√≥a s·∫£n ph·∫©m
      await this.productRepository.findByIdAndDelete(productId);

      // X√≥a c√°c ƒë√°nh gi√° c·ªßa s·∫£n ph·∫©m
      await this.reviewRepository.deleteByProductId(productId);

      // X√≥a cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      return true;
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ x√≥a s·∫£n ph·∫©m');
    }
  }

  /**
   * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng t·ªìn kho
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @param {number} quantity - S·ªë l∆∞·ª£ng c·∫≠p nh·∫≠t
   * @returns {Promise<Object>} - Th√¥ng tin t·ªìn kho ƒë√£ c·∫≠p nh·∫≠t
   */
  async updateStock(productId, quantity) {
    try {
      if (isNaN(quantity)) {
        throw new AppError(400, 'S·ªë l∆∞·ª£ng t·ªìn kho kh√¥ng h·ª£p l·ªá');
      }

      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // C·∫≠p nh·∫≠t t·ªìn kho
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, {
        stock: quantity,
        updatedAt: new Date(),
      });

      // X√≥a cache
      await this.invalidateCache(`product:${productId}`);

      // S·ª≠ d·ª•ng updatedProduct ƒë·ªÉ tr·∫£ v·ªÅ th√¥ng tin c·∫≠p nh·∫≠t
      const stockInfo = {
        productId,
        name: updatedProduct.name,
        stock: updatedProduct.stock,
        status: updatedProduct.stock > 0 ? 'C√≤n h√†ng' : 'H·∫øt h√†ng',
      };

      // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi tr∆∞·ªõc khi tr·∫£ v·ªÅ
      return formatProductResponse(stockInfo);
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t t·ªìn kho');
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t
   * @param {number} limit - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m tr·∫£ v·ªÅ
   * @returns {Promise<Array>} - Danh s√°ch s·∫£n ph·∫©m n·ªïi b·∫≠t
   */
  async getTrendingProducts(limit = 10) {
    try {
      const cacheKey = `products:trending:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Th·ª±c hi·ªán truy v·∫•n
        const trending = await this.productRepository.getTrendingProducts(limit);

        // Chuy·ªÉn ƒë·ªïi th√†nh DTO v√† ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi
        return trending.map((product) => formatProductResponse(new ProductDTO(product).toJSON()));
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m n·ªïi b·∫≠t');
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m theo danh m·ª•c
   * @param {string} categoryId - ID danh m·ª•c
   * @param {Object} queryParams - C√°c tham s·ªë truy v·∫•n
   * @returns {Promise<Object>} - Danh s√°ch s·∫£n ph·∫©m v√† th√¥ng tin ph√¢n trang
   */
  async getProductsByCategory(categoryId, queryParams) {
    try {
      // Ki·ªÉm tra danh m·ª•c t·ªìn t·∫°i
      const category = await this.categoryRepository.findById(categoryId);
      if (!category) {
        throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y danh m·ª•c');
      }

      // T·∫°o kh√≥a cache
      const cacheKey = `products:category:${categoryId}:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Th√™m b·ªô l·ªçc danh m·ª•c
        const categoryFilter = { categories: categoryId };
        const mergedQuery = { ...queryParams, ...categoryFilter };

        // T·∫°o ƒë·ªëi t∆∞·ª£ng ApiFeatures
        const features = new ApiFeatures(this.productRepository.query(), mergedQuery)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Th·ª±c hi·ªán truy v·∫•n
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuy·ªÉn ƒë·ªïi th√†nh DTO v√† ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi
        const productDTOs = products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // Th√™m th√¥ng tin danh m·ª•c
        return {
          category: {
            id: category._id,
            name: category.name,
            description: category.description,
          },
          products: productDTOs,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m theo danh m·ª•c');
    }
  }

  /**
   * T√¨m ki·∫øm s·∫£n ph·∫©m
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @param {Object} options - C√°c t√πy ch·ªçn t√¨m ki·∫øm
   * @returns {Promise<Object>} - K·∫øt qu·∫£ t√¨m ki·∫øm
   */
  async searchProducts(query, options = {}) {
    try {
      if (!query || query.trim() === '') {
        throw new AppError(400, 'T·ª´ kh√≥a t√¨m ki·∫øm kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
      }

      // T·∫°o kh√≥a cache
      const cacheKey = `products:search:${query}:${JSON.stringify(options)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // T·∫°o truy v·∫•n t√¨m ki·∫øm
        const searchOptions = {
          query,
          limit: options.limit || 10,
          page: options.page || 1,
          sort: options.sort || { relevance: -1 },
          filters: options.filters || {},
        };

        // Th·ª±c hi·ªán t√¨m ki·∫øm
        const searchResults = await this.productRepository.search(searchOptions);

        // Chuy·ªÉn ƒë·ªïi th√†nh DTO v√† ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi
        const productDTOs = searchResults.products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // K·∫øt qu·∫£ t√¨m ki·∫øm
        return {
          products: productDTOs,
          totalCount: searchResults.total,
          pagination: {
            currentPage: searchOptions.page,
            pageSize: searchOptions.limit,
            totalPages: Math.ceil(searchResults.total / searchOptions.limit),
          },
        };
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ t√¨m ki·∫øm s·∫£n ph·∫©m');
    }
  }

  /**
   * L·∫•y th·ªëng k√™ s·∫£n ph·∫©m
   * @returns {Promise<Object>} Th·ªëng k√™ s·∫£n ph·∫©m
   */
  async getProductStats() {
    try {
      const cacheKey = 'products:stats';

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // T·ªïng s·ªë s·∫£n ph·∫©m
        const totalProducts = await this.productRepository.countDocuments();

        // S·ªë s·∫£n ph·∫©m theo tr·∫°ng th√°i
        const activeProducts = await this.productRepository.countDocuments({ status: 'active' });
        const draftProducts = await this.productRepository.countDocuments({ status: 'draft' });
        const discontinuedProducts = await this.productRepository.countDocuments({
          status: 'discontinued',
        });

        // S·ªë s·∫£n ph·∫©m c√≥ gi·∫£m gi√°
        const productsOnSale = await this.productRepository.countDocuments({
          salePrice: { $gt: 0 },
        });

        // S·ªë s·∫£n ph·∫©m h·∫øt h√†ng
        const outOfStockProducts = await this.productRepository.countDocuments({
          stock: 0,
          status: 'active',
        });

        // S·ªë s·∫£n ph·∫©m theo danh m·ª•c
        const categoryCounts = await this.productRepository.aggregateByCategoryWithCount();

        // S·ªë s·∫£n ph·∫©m theo th∆∞∆°ng hi·ªáu
        const brandCounts = await this.productRepository.aggregateByBrandWithCount();

        // S·∫£n ph·∫©m ƒë∆∞·ª£c xem nhi·ªÅu nh·∫•t
        const mostViewedProducts = await this.productRepository.findMostViewed(5);

        return {
          totalProducts,
          byStatus: {
            active: activeProducts,
            draft: draftProducts,
            discontinued: discontinuedProducts,
          },
          productsOnSale,
          outOfStockProducts,
          byCategory: categoryCounts,
          byBrand: brandCounts,
          mostViewed: mostViewedProducts,
        };
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™ s·∫£n ph·∫©m');
    }
  }

  /**
   * T·∫°o slug t·ª´ t√™n s·∫£n ph·∫©m
   * @param {string} name - T√™n s·∫£n ph·∫©m
   * @returns {string} - Slug ƒë√£ t·∫°o
   */
  createSlugFromName(name) {
    return name
      .toLowerCase()
      .replace(/[^\w ]+/g, '')
      .replace(/ +/g, '-');
  }

  /**
   * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng xem s·∫£n ph·∫©m
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @returns {Promise<void>}
   */
  async incrementViewCount(productId) {
    try {
      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
      }

      // TƒÉng s·ªë l∆∞·ª£t xem
      await this.productRepository.findByIdAndUpdate(productId, {
        $inc: { viewCount: 1 },
        updatedAt: new Date(),
      });

      // Kh√¥ng c·∫ßn x√≥a cache v√¨ th√¥ng tin n√†y kh√¥ng quan tr·ªçng ƒë·ªÉ invalidate cache ngay l·∫≠p t·ª©c
    } catch (error) {
      // Ch·ªâ ghi log l·ªói, kh√¥ng n√©m l·ªói v√¨ ƒë√¢y kh√¥ng ph·∫£i thao t√°c quan tr·ªçng
      console.error(`Error incrementing view count for product ${productId}:`, error);
    }
  }

  /**
   * L·∫•y s·∫£n ph·∫©m li√™n quan
   * @param {string} productId - ID s·∫£n ph·∫©m
   * @param {number} limit - S·ªë l∆∞·ª£ng s·∫£n ph·∫©m tr·∫£ v·ªÅ
   * @returns {Promise<Array>} - Danh s√°ch s·∫£n ph·∫©m li√™n quan
   */
  async getRelatedProducts(productId, limit = 5) {
    try {
      const cacheKey = `products:related:${productId}:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // L·∫•y th√¥ng tin s·∫£n ph·∫©m
        const product = await this.productRepository.findById(productId);
        if (!product) {
          throw new AppError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
        }

        // L·∫•y s·∫£n ph·∫©m c√πng danh m·ª•c
        const relatedProducts = await this.productRepository.findRelated(
          productId,
          product.categories,
          limit
        );

        // Chuy·ªÉn ƒë·ªïi th√†nh DTO v√† ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi
        return relatedProducts.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );
      });
    } catch (error) {
      this.handleError(error, 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch s·∫£n ph·∫©m li√™n quan');
    }
  }
}

module.exports = new ProductService();


--- File: server/src/services/review/reviewService.js ---
/**
 * Review Service
 * X·ª≠ l√Ω logic nghi·ªáp v·ª• cho ƒë√°nh gi√° s·∫£n ph·∫©m
 */

const { ApiError } = require('../../common/errors/apiError');
const reviewRepository = require('../../data/repositories/reviewRepository');
const productRepository = require('../../data/repositories/productRepository');
const orderRepository = require('../../data/repositories/orderRepository');
const userRepository = require('../../data/repositories/userRepository');

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° (c√≥ th·ªÉ l·ªçc, s·∫Øp x·∫øp, ph√¢n trang)
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Object>} Danh s√°ch ƒë√°nh gi√° v√† th√¥ng tin ph√¢n trang
 */
const getAllReviews = async (features = {}) => {
  return await reviewRepository.findAll(features);
};

/**
 * L·∫•y ƒë√°nh gi√° theo ID
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @returns {Promise<Object>} Th√¥ng tin ƒë√°nh gi√°
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°
 */
const getReviewById = async (id) => {
  const review = await reviewRepository.findById(id);
  if (!review) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°');
  }
  return review;
};

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° cho m·ªôt s·∫£n ph·∫©m
 * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Object>} Danh s√°ch ƒë√°nh gi√° v√† th√¥ng tin ph√¢n trang
 */
const getProductReviews = async (productId, features = {}) => {
  // Ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
  }

  // Th√™m filter cho product v√†o features
  const productFilter = { ...features };
  productFilter.filter = {
    ...productFilter.filter,
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  };

  return await reviewRepository.findAll(productFilter);
};

/**
 * L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° c·ªßa m·ªôt ng∆∞·ªùi d√πng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng
 * @param {Object} features - C√°c tham s·ªë truy v·∫•n (filter, sort, pagination)
 * @returns {Promise<Object>} Danh s√°ch ƒë√°nh gi√° v√† th√¥ng tin ph√¢n trang
 */
const getUserReviews = async (userId, features = {}) => {
  // Ki·ªÉm tra ng∆∞·ªùi d√πng t·ªìn t·∫°i
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng');
  }

  // Th√™m filter cho user v√†o features
  const userFilter = { ...features };
  userFilter.filter = {
    ...userFilter.filter,
    user: userId,
  };

  return await reviewRepository.findAll(userFilter);
};

/**
 * T·∫°o ƒë√°nh gi√° m·ªõi
 * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng ƒë√°nh gi√°
 * @param {Object} reviewData - D·ªØ li·ªáu ƒë√°nh gi√°
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ t·∫°o
 * @throws {ApiError} N·∫øu c√≥ l·ªói khi t·∫°o ƒë√°nh gi√°
 */
const createReview = async (productId, userId, reviewData) => {
  // Ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m');
  }

  // Ki·ªÉm tra ng∆∞·ªùi d√πng t·ªìn t·∫°i
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng');
  }

  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y ch∆∞a
  const existingReview = await reviewRepository.findOne({
    product: productId,
    user: userId,
  });

  if (existingReview) {
    throw new ApiError(400, 'B·∫°n ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y r·ªìi');
  }

  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ mua s·∫£n ph·∫©m n√†y ch∆∞a
  const verificationResult = await verifyPurchase(userId, productId);

  // Kh·ªüi t·∫°o ƒë√°nh gi√°
  const newReview = {
    product: productId,
    user: userId,
    rating: reviewData.rating,
    title: reviewData.title,
    review: reviewData.review,
    images: reviewData.images || [],
    isVerifiedPurchase: verificationResult.isVerified,
    ratings: {
      average: 0,
      count: 0,
    },
  };

  // N·∫øu c√≥ ƒë∆°n h√†ng v√† l√† mua h√†ng ƒë√£ x√°c minh, th√™m th√¥ng tin ƒë∆°n h√†ng
  if (verificationResult.isVerified && verificationResult.orderId) {
    newReview.order = verificationResult.orderId;
    newReview.purchaseDate = verificationResult.purchaseDate;
  }

  // Ki·ªÉm tra n·∫øu c·∫ßn ki·ªÉm duy·ªát
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration) {
    newReview.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = false;
  } else {
    newReview.moderation = {
      status: 'approved',
      moderatedAt: new Date(),
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = true;
  }

  // T·∫°o ƒë√°nh gi√° m·ªõi
  const createdReview = await reviewRepository.create(newReview);

  // N·∫øu kh√¥ng c·∫ßn ki·ªÉm duy·ªát, c·∫≠p nh·∫≠t rating c·ªßa s·∫£n ph·∫©m
  if (!needModeration) {
    await updateProductRating(productId);
  }

  return createdReview;
};

/**
 * C·∫≠p nh·∫≠t ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng y√™u c·∫ßu c·∫≠p nh·∫≠t
 * @param {Object} reviewData - D·ªØ li·ªáu c·∫≠p nh·∫≠t
 * @param {boolean} isAdmin - Ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√° ho·∫∑c kh√¥ng c√≥ quy·ªÅn
 */
const updateReview = async (id, userId, reviewData, isAdmin) => {
  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Ki·ªÉm tra quy·ªÅn c·∫≠p nh·∫≠t
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t ƒë√°nh gi√° n√†y');
  }

  // D·ªØ li·ªáu c·∫ßn c·∫≠p nh·∫≠t
  const updateData = {};

  // Ch·ªâ c·∫≠p nh·∫≠t c√°c tr∆∞·ªùng ƒë∆∞·ª£c ph√©p
  if (reviewData.rating !== undefined) updateData.rating = reviewData.rating;
  if (reviewData.title !== undefined) updateData.title = reviewData.title;
  if (reviewData.review !== undefined) updateData.review = reviewData.review;
  if (reviewData.images !== undefined) updateData.images = reviewData.images;

  // C·∫≠p nh·∫≠t th·ªùi gian
  updateData.updatedAt = new Date();

  // N·∫øu c·∫ßn ki·ªÉm duy·ªát, ƒë∆∞a v·ªÅ tr·∫°ng th√°i ch·ªù ki·ªÉm duy·ªát l·∫°i
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration && !isAdmin) {
    updateData.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    updateData.isVisible = false;
  }

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  const updatedReview = await reviewRepository.update(id, updateData);

  // N·∫øu kh√¥ng c·∫ßn ki·ªÉm duy·ªát ho·∫∑c l√† admin, c·∫≠p nh·∫≠t rating c·ªßa s·∫£n ph·∫©m
  if (!needModeration || isAdmin) {
    await updateProductRating(review.product);
  }

  return updatedReview;
};

/**
 * X√≥a ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng y√™u c·∫ßu x√≥a
 * @param {boolean} isAdmin - Ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng
 * @returns {Promise<void>}
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√° ho·∫∑c kh√¥ng c√≥ quy·ªÅn
 */
const deleteReview = async (id, userId, isAdmin) => {
  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Ki·ªÉm tra quy·ªÅn x√≥a
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a ƒë√°nh gi√° n√†y');
  }

  // L∆∞u ID s·∫£n ph·∫©m ƒë·ªÉ c·∫≠p nh·∫≠t rating sau
  const productId = review.product;

  // X√≥a ƒë√°nh gi√°
  await reviewRepository.delete(id);

  // C·∫≠p nh·∫≠t rating c·ªßa s·∫£n ph·∫©m
  await updateProductRating(productId);
};

/**
 * Vote (upvote/downvote) ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng vote
 * @param {number} vote - Lo·∫°i vote (1: upvote, -1: downvote)
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ c·∫≠p nh·∫≠t
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°
 */
const voteReview = async (id, userId, vote) => {
  // Ki·ªÉm tra vote h·ª£p l·ªá
  if (vote !== 1 && vote !== -1) {
    throw new ApiError(400, 'Vote kh√¥ng h·ª£p l·ªá');
  }

  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Ng∆∞·ªùi d√πng kh√¥ng th·ªÉ vote ƒë√°nh gi√° c·ªßa ch√≠nh m√¨nh
  if (review.user.toString() === userId) {
    throw new ApiError(400, 'B·∫°n kh√¥ng th·ªÉ vote ƒë√°nh gi√° c·ªßa ch√≠nh m√¨nh');
  }

  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ vote ch∆∞a
  const existingVoteIndex = review.helpfulness.voters.findIndex(
    (voter) => voter.user.toString() === userId
  );

  // N·∫øu ƒë√£ vote, c·∫≠p nh·∫≠t vote
  if (existingVoteIndex > -1) {
    const existingVote = review.helpfulness.voters[existingVoteIndex];

    // N·∫øu vote gi·ªëng nhau, h·ªßy vote
    if (existingVote.vote === vote) {
      // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes -= 1;
      } else {
        review.helpfulness.downvotes -= 1;
      }

      // X√≥a vote kh·ªèi danh s√°ch
      review.helpfulness.voters.splice(existingVoteIndex, 1);
    }
    // N·∫øu vote kh√°c nhau, c·∫≠p nh·∫≠t vote
    else {
      // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes += 1;
        review.helpfulness.downvotes -= 1;
      } else {
        review.helpfulness.upvotes -= 1;
        review.helpfulness.downvotes += 1;
      }

      // C·∫≠p nh·∫≠t vote
      review.helpfulness.voters[existingVoteIndex] = {
        user: userId,
        vote: vote,
        votedAt: new Date(),
      };
    }
  }
  // N·∫øu ch∆∞a vote, th√™m vote m·ªõi
  else {
    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng upvote/downvote
    if (vote === 1) {
      review.helpfulness.upvotes += 1;
    } else {
      review.helpfulness.downvotes += 1;
    }

    // Th√™m vote m·ªõi
    review.helpfulness.voters.push({
      user: userId,
      vote: vote,
      votedAt: new Date(),
    });
  }

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  return await reviewRepository.update(review._id, {
    helpfulness: review.helpfulness,
  });
};

/**
 * Ki·ªÉm duy·ªát ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} action - H√†nh ƒë·ªông (approve/reject)
 * @param {string} reason - L√Ω do t·ª´ ch·ªëi (n·∫øu reject)
 * @param {string} adminId - ID c·ªßa admin th·ª±c hi·ªán ki·ªÉm duy·ªát
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ ki·ªÉm duy·ªát
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√° ho·∫∑c action kh√¥ng h·ª£p l·ªá
 */
const moderateReview = async (id, action, reason, adminId) => {
  // Ki·ªÉm tra action h·ª£p l·ªá
  if (action !== 'approve' && action !== 'reject') {
    throw new ApiError(400, 'Action kh√¥ng h·ª£p l·ªá');
  }

  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Ki·ªÉm tra n·∫øu ƒë√£ ki·ªÉm duy·ªát v·ªõi c√πng action
  if (review.moderation.status === action) {
    throw new ApiError(400, `ƒê√°nh gi√° ƒë√£ ƒë∆∞·ª£c ${action === 'approve' ? 'duy·ªát' : 't·ª´ ch·ªëi'} r·ªìi`);
  }

  // D·ªØ li·ªáu c·∫≠p nh·∫≠t
  const updateData = {
    moderation: {
      status: action,
      moderatedAt: new Date(),
      moderatedBy: adminId,
      reason: action === 'reject' ? reason : null,
    },
    isVisible: action === 'approve',
  };

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  const moderatedReview = await reviewRepository.update(id, updateData);

  // C·∫≠p nh·∫≠t rating c·ªßa s·∫£n ph·∫©m
  await updateProductRating(review.product);

  return moderatedReview;
};

/**
 * B√°o c√°o ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng b√°o c√°o
 * @param {string} reason - L√Ω do b√°o c√°o
 * @param {string} description - M√¥ t·∫£ chi ti·∫øt
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ b√°o c√°o
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√° ho·∫∑c ƒë√£ b√°o c√°o
 */
const reportReview = async (id, userId, reason, description) => {
  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Ki·ªÉm tra ng∆∞·ªùi d√πng ƒë√£ b√°o c√°o ch∆∞a
  const alreadyReported = review.reports.some((report) => report.user.toString() === userId);

  if (alreadyReported) {
    throw new ApiError(400, 'B·∫°n ƒë√£ b√°o c√°o ƒë√°nh gi√° n√†y r·ªìi');
  }

  // Th√™m b√°o c√°o m·ªõi
  const newReport = {
    user: userId,
    reason,
    description,
    createdAt: new Date(),
    status: 'pending',
  };

  review.reports.push(newReport);

  // N·∫øu c√≥ qu√° nhi·ªÅu b√°o c√°o, t·ª± ƒë·ªông ·∫©n ƒë√°nh gi√° ch·ªù ki·ªÉm duy·ªát
  if (review.reports.length >= 3 && review.isVisible) {
    review.isVisible = false;
    review.moderation.status = 'pending';
  }

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  return await reviewRepository.update(review._id, {
    reports: review.reports,
    isVisible: review.isVisible,
    moderation: review.moderation,
  });
};

/**
 * Th√™m ph·∫£n h·ªìi cho ƒë√°nh gi√°
 * @param {string} id - ID c·ªßa ƒë√°nh gi√°
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng th√™m ph·∫£n h·ªìi
 * @param {string} content - N·ªôi dung ph·∫£n h·ªìi
 * @param {boolean} isAdmin - Ng∆∞·ªùi d√πng c√≥ ph·∫£i admin kh√¥ng
 * @returns {Promise<Object>} ƒê√°nh gi√° ƒë√£ th√™m ph·∫£n h·ªìi
 * @throws {ApiError} N·∫øu kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°
 */
const addReviewResponse = async (id, userId, content, isAdmin) => {
  // L·∫•y ƒë√°nh gi√° theo ID
  const review = await getReviewById(id);

  // Th√™m ph·∫£n h·ªìi m·ªõi
  const newResponse = {
    user: userId,
    isAdmin,
    content,
    createdAt: new Date(),
  };

  // N·∫øu ch∆∞a c√≥ ph·∫£n h·ªìi, kh·ªüi t·∫°o m·∫£ng
  if (!review.responses) {
    review.responses = [];
  }

  review.responses.push(newResponse);

  // C·∫≠p nh·∫≠t ƒë√°nh gi√°
  return await reviewRepository.update(review._id, {
    responses: review.responses,
  });
};

/**
 * Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ mua s·∫£n ph·∫©m hay ch∆∞a
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng
 * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
 * @returns {Promise<Object>} K·∫øt qu·∫£ x√°c minh
 */
const verifyPurchase = async (userId, productId) => {
  // T√¨m ƒë∆°n h√†ng ƒë√£ ho√†n th√†nh ch·ª©a s·∫£n ph·∫©m
  const orders = await orderRepository.find({
    user: userId,
    status: { $in: ['delivered', 'completed'] },
    'items.product': productId,
  });

  if (!orders || orders.length === 0) {
    return { isVerified: false };
  }

  // S·∫Øp x·∫øp theo th·ªùi gian ƒë·ªÉ l·∫•y ƒë∆°n h√†ng g·∫ßn nh·∫•t
  orders.sort((a, b) => b.createdAt - a.createdAt);
  const latestOrder = orders[0];

  return {
    isVerified: true,
    orderId: latestOrder._id,
    purchaseDate: latestOrder.createdAt,
  };
};

/**
 * C·∫≠p nh·∫≠t rating trung b√¨nh c·ªßa s·∫£n ph·∫©m
 * @param {string} productId - ID c·ªßa s·∫£n ph·∫©m
 * @returns {Promise<void>}
 */
const updateProductRating = async (productId) => {
  // L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát v√† hi·ªÉn th·ªã
  const reviews = await reviewRepository.find({
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  });

  // N·∫øu kh√¥ng c√≥ ƒë√°nh gi√°, ƒë·∫∑t rating v·ªÅ 0
  if (!reviews || reviews.length === 0) {
    await productRepository.update(productId, {
      'ratings.average': 0,
      'ratings.count': 0,
    });
    return;
  }

  // T√≠nh rating trung b√¨nh
  const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
  const averageRating = Number((totalRating / reviews.length).toFixed(1));

  // C·∫≠p nh·∫≠t s·∫£n ph·∫©m
  await productRepository.update(productId, {
    'ratings.average': averageRating,
    'ratings.count': reviews.length,
  });
};

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse,
  verifyPurchase,
  updateProductRating,
};


--- File: server/src/services/user/userService.js ---
/**
 * User Service - x·ª≠ l√Ω logic qu·∫£n l√Ω ng∆∞·ªùi d√πng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const BaseService = require('../base/baseService');
const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * Class UserService x·ª≠ l√Ω logic qu·∫£n l√Ω ng∆∞·ªùi d√πng
 * K·∫ø th·ª´a t·ª´ BaseService ƒë·ªÉ c√≥ c√°c ph∆∞∆°ng th·ª©c CRUD c∆° b·∫£n
 */
class UserService extends BaseService {
  constructor() {
    super(User, 'User');
  }

  /**
   * T·∫°o ng∆∞·ªùi d√πng m·ªõi
   * @override
   * @param {Object} userData - Th√¥ng tin ng∆∞·ªùi d√πng
   * @returns {Promise<Object>} - Ng∆∞·ªùi d√πng ƒë√£ t·∫°o
   */
  async create(userData) {
    try {
      // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingUser = await User.findOne({ email: userData.email });
      if (existingUser) {
        throw new ApiError(409, 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng');
      }

      // Ng∆∞·ªùi d√πng ƒë∆∞·ª£c t·∫°o b·ªüi admin m·∫∑c ƒë·ªãnh ƒë√£ x√°c th·ª±c email
      const newUserData = {
        ...userData,
        emailVerified: true,
      };

      // T·∫°o ng∆∞·ªùi d√πng m·ªõi
      const newUser = await super.create(newUserData);

      // Lo·∫°i b·ªè password kh·ªèi response
      const userObj = newUser.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`L·ªói t·∫°o ng∆∞·ªùi d√πng: ${error.message}`);
      throw error;
    }
  }

  /**
   * C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
   * @override
   * @param {string} id - ID ng∆∞·ªùi d√πng
   * @param {Object} updateData - Th√¥ng tin c·∫≠p nh·∫≠t
   * @param {Object} options - T√πy ch·ªçn
   * @returns {Promise<Object>} - Ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t
   */
  async update(id, updateData, options = {}) {
    try {
      // T·∫°o b·∫£n sao c·ªßa ƒë·ªëi t∆∞·ª£ng updateData
      const safeUpdateData = { ...updateData };

      // Danh s√°ch c√°c tr∆∞·ªùng nh·∫°y c·∫£m c·∫ßn lo·∫°i b·ªè
      const sensitiveFields = [
        'password',
        'emailVerified',
        'loginCount',
        'lastLogin',
        'resetPasswordToken',
        'resetPasswordExpires',
        'emailVerificationToken',
        'emailVerificationExpires',
      ];

      // Lo·∫°i b·ªè c√°c tr∆∞·ªùng nh·∫°y c·∫£m
      sensitiveFields.forEach((field) => {
        delete safeUpdateData[field];
      });

      // X·ª≠ l√Ω ri√™ng tr∆∞·ªùng role
      const { role } = updateData;
      delete safeUpdateData.role;

      // Admin c√≥ th·ªÉ c·∫≠p nh·∫≠t role
      if (options.isAdmin && role) {
        safeUpdateData.role = role;
      }

      // C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
      const updatedUser = await super.update(id, safeUpdateData);

      return updatedUser;
    } catch (error) {
      logger.error(`L·ªói c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Thay ƒë·ªïi m·∫≠t kh·∫©u
   * @param {string} userId - ID ng∆∞·ªùi d√πng
   * @param {string} currentPassword - M·∫≠t kh·∫©u hi·ªán t·∫°i
   * @param {string} newPassword - M·∫≠t kh·∫©u m·ªõi
   * @returns {Promise<Object>} - Ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t
   */
  async changePassword(userId, currentPassword, newPassword) {
    try {
      // L·∫•y user v·ªõi password
      const user = await User.findById(userId).select('+password');

      if (!user) {
        throw new ApiError(404, 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i');
      }

      // Ki·ªÉm tra m·∫≠t kh·∫©u hi·ªán t·∫°i
      if (!(await user.correctPassword(currentPassword, user.password))) {
        throw new ApiError(401, 'M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng');
      }

      // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
      user.password = newPassword;
      await user.save();

      // Lo·∫°i b·ªè password kh·ªèi response
      const userObj = user.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`L·ªói thay ƒë·ªïi m·∫≠t kh·∫©u: ${error.message}`);
      throw error;
    }
  }

  /**
   * V√¥ hi·ªáu h√≥a t√†i kho·∫£n
   * @param {string} userId - ID ng∆∞·ªùi d√πng
   * @returns {Promise<Object>} - Ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t
   */
  async deactivateUser(userId) {
    try {
      const user = await this.findById(userId);

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i active
      user.isActive = false;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`L·ªói v√¥ hi·ªáu h√≥a t√†i kho·∫£n: ${error.message}`);
      throw error;
    }
  }

  /**
   * K√≠ch ho·∫°t l·∫°i t√†i kho·∫£n
   * @param {string} userId - ID ng∆∞·ªùi d√πng
   * @returns {Promise<Object>} - Ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t
   */
  async activateUser(userId) {
    try {
      const user = await this.findById(userId);

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i active
      user.isActive = true;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`L·ªói k√≠ch ho·∫°t t√†i kho·∫£n: ${error.message}`);
      throw error;
    }
  }

  /**
   * T√¨m ki·∫øm ng∆∞·ªùi d√πng v·ªõi c√°c ti√™u ch√≠ n√¢ng cao
   * @param {Object} criteria - Ti√™u ch√≠ t√¨m ki·∫øm
   * @param {Object} options - T√πy ch·ªçn (pagination, sort)
   * @returns {Promise<Object>} - K·∫øt qu·∫£ t√¨m ki·∫øm v·ªõi ph√¢n trang
   */
  async search(criteria, options = {}) {
    try {
      const filter = {};

      // X·ª≠ l√Ω c√°c ti√™u ch√≠ t√¨m ki·∫øm
      if (criteria.name) {
        filter.name = { $regex: criteria.name, $options: 'i' };
      }

      if (criteria.email) {
        filter.email = { $regex: criteria.email, $options: 'i' };
      }

      if (criteria.phone) {
        filter.phone = { $regex: criteria.phone, $options: 'i' };
      }

      if (criteria.role) {
        filter.role = criteria.role;
      }

      if (criteria.isActive !== undefined) {
        filter.isActive = criteria.isActive;
      }

      if (criteria.emailVerified !== undefined) {
        filter.emailVerified = criteria.emailVerified;
      }

      // T√¨m ki·∫øm k·∫øt h·ª£p theo text
      if (criteria.search) {
        filter.$or = [
          { name: { $regex: criteria.search, $options: 'i' } },
          { email: { $regex: criteria.search, $options: 'i' } },
          { phone: { $regex: criteria.search, $options: 'i' } },
        ];
      }

      // T√¨m ki·∫øm theo kho·∫£ng th·ªùi gian ƒëƒÉng k√Ω
      if (criteria.createdFrom || criteria.createdTo) {
        filter.createdAt = {};

        if (criteria.createdFrom) {
          filter.createdAt.$gte = new Date(criteria.createdFrom);
        }

        if (criteria.createdTo) {
          filter.createdAt.$lte = new Date(criteria.createdTo);
        }
      }

      // L·∫•y k·∫øt qu·∫£ v·ªõi ph√¢n trang
      return await this.findAll(filter, {
        ...options,
        select: '-password',
      });
    } catch (error) {
      logger.error(`L·ªói t√¨m ki·∫øm ng∆∞·ªùi d√πng: ${error.message}`);
      throw error;
    }
  }

  /**
   * X√≥a ng∆∞·ªùi d√πng v√† d·ªØ li·ªáu li√™n quan
   * @override
   * @param {string} userId - ID ng∆∞·ªùi d√πng
   * @returns {Promise<Object>} - Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ x√≥a
   */
  async delete(userId) {
    try {
      // X√≥a d·ªØ li·ªáu li√™n quan ƒë·∫øn ng∆∞·ªùi d√πng tr∆∞·ªõc (n·∫øu c·∫ßn)
      // TODO: X√≥a d·ªØ li·ªáu li√™n quan nh∆∞ gi·ªè h√†ng, ƒë∆°n h√†ng, ƒë√°nh gi√°

      // X√≥a ng∆∞·ªùi d√πng
      const user = await super.delete(userId);

      return user;
    } catch (error) {
      logger.error(`L·ªói x√≥a ng∆∞·ªùi d√πng: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new UserService();


--- File: server/src/types/express.d.ts ---
import { Document } from 'mongoose';

declare global {
  namespace Express {
    interface Request {
      user?: Document & {
        id: string;
        name: string;
        email: string;
        role: string;
        changedPasswordAfter?: (timestamp: number) => boolean;
        [key: string]: any;
      };
      resource?: Document & {
        user?: any;
        [key: string]: any;
      };
    }
  }
}

// ƒê·∫£m b·∫£o file n√†y ƒë∆∞·ª£c coi l√† m·ªôt module
export {};

--- File: server/src/utils/apiFeatures.js ---
/**
 * API Features Utility - x·ª≠ l√Ω c√°c t√≠nh nƒÉng API ph·ªï bi·∫øn nh∆∞ filtering, sorting, pagination
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('mongoose').Query<any, any>} MongooseQuery
 */

class APIFeatures {
  /**
   * Kh·ªüi t·∫°o class v·ªõi query v√† queryString
   * @param {MongooseQuery} query - Mongoose query ban ƒë·∫ßu
   * @param {Object} queryString - Query parameters t·ª´ request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * L·ªçc d·ªØ li·ªáu theo c√°c tr∆∞·ªùng
   * @returns {APIFeatures} - Instance c·ªßa class ƒë·ªÉ chaining
   */
  filter() {
    // T·∫°o b·∫£n sao c·ªßa query string
    const queryObj = { ...this.queryString };

    // C√°c tr∆∞·ªùng lo·∫°i tr·ª´ kh·ªèi filtering
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'search'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // X·ª≠ l√Ω advanced filtering (gt, gte, lt, lte, in, nin)
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in|nin)\b/g, (match) => `$${match}`);

    // √Åp d·ª•ng filter v√†o query
    this.query = this.query.find(JSON.parse(queryStr));

    return this;
  }

  /**
   * Th√™m t√¨m ki·∫øm text
   * @returns {APIFeatures} - Instance c·ªßa class ƒë·ªÉ chaining
   */
  search() {
    if (this.queryString.search) {
      // T·∫°o ƒëi·ªÅu ki·ªán t√¨m ki·∫øm
      const searchQuery = {
        $or: [
          { name: { $regex: this.queryString.search, $options: 'i' } },
          { description: { $regex: this.queryString.search, $options: 'i' } },
        ],
      };

      // √Åp d·ª•ng t√¨m ki·∫øm v√†o query
      this.query = this.query.find(searchQuery);
    }

    return this;
  }

  /**
   * S·∫Øp x·∫øp k·∫øt qu·∫£
   * @returns {APIFeatures} - Instance c·ªßa class ƒë·ªÉ chaining
   */
  sort() {
    if (this.queryString.sort) {
      // Chuy·ªÉn ƒë·ªïi chu·ªói sort th√†nh format cho MongoDB
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // M·∫∑c ƒë·ªãnh s·∫Øp x·∫øp theo th·ªùi gian t·∫°o gi·∫£m d·∫ßn
      this.query = this.query.sort('-createdAt');
    }

    return this;
  }

  /**
   * Gi·ªõi h·∫°n c√°c tr∆∞·ªùng ƒë∆∞·ª£c tr·∫£ v·ªÅ
   * @returns {APIFeatures} - Instance c·ªßa class ƒë·ªÉ chaining
   */
  limitFields() {
    if (this.queryString.fields) {
      // Chuy·ªÉn ƒë·ªïi chu·ªói fields th√†nh format cho MongoDB
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // M·∫∑c ƒë·ªãnh lo·∫°i b·ªè tr∆∞·ªùng __v
      this.query = this.query.select('-__v');
    }

    return this;
  }

  /**
   * Ph√¢n trang k·∫øt qu·∫£
   * @returns {APIFeatures} - Instance c·ªßa class ƒë·ªÉ chaining
   */
  paginate() {
    // Chuy·ªÉn ƒë·ªïi page v√† limit th√†nh s·ªë
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    // √Åp d·ª•ng skip v√† limit v√†o query
    this.query = this.query.skip(skip).limit(limit);

    return this;
  }

  /**
   * √Åp d·ª•ng t·∫•t c·∫£ c√°c t√≠nh nƒÉng v√†o query
   * @returns {MongooseQuery} - Query ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
   */
  build() {
    return this.filter().search().sort().limitFields().paginate().query;
  }
}

module.exports = APIFeatures;


--- File: server/src/utils/catchAsync.js ---
/**
 * Utility wrapper ƒë·ªÉ x·ª≠ l√Ω l·ªói async cho controllers
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * B·ªçc h√†m async ƒë·ªÉ x·ª≠ l√Ω l·ªói m√† kh√¥ng c·∫ßn try-catch trong m·ªói controller
 * @param {Function} fn - H√†m async c·∫ßn ƒë∆∞·ª£c b·ªçc
 * @returns {Function} - Middleware function v·ªõi x·ª≠ l√Ω l·ªói
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

module.exports = catchAsync;


--- File: server/src/utils/logger.js ---
/**
 * Module logger s·ª≠ d·ª•ng Winston
 * Cung c·∫•p c√°c ph∆∞∆°ng th·ª©c ƒë·ªÉ ghi log v·ªõi c√°c c·∫•p ƒë·ªô kh√°c nhau
 */
const winston = require('winston');
const path = require('path');
const fs = require('fs');

// T·∫°o th∆∞ m·ª•c logs n·∫øu ch∆∞a t·ªìn t·∫°i
const logDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

// ƒê·ªãnh d·∫°ng th·ªùi gian cho log
const timeFormat = () => {
  return new Date().toLocaleString('vi-VN', {
    timeZone: 'Asia/Ho_Chi_Minh',
  });
};

// T·∫°o logger v·ªõi Winston
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp({ format: timeFormat }),
    winston.format.printf(({ timestamp, level, message }) => {
      return `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    })
  ),
  transports: [
    // Ghi log ra console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ timestamp, level, message }) => {
          return `[${timestamp}] ${level}: ${message}`;
        })
      ),
    }),
    // Ghi log l·ªói v√†o file
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
    }),
    // Ghi t·∫•t c·∫£ log v√†o file
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
    }),
  ],
  exitOnError: false,
});

// Th√™m stream ƒë·ªÉ s·ª≠ d·ª•ng v·ªõi Morgan (n·∫øu c·∫ßn)
logger.stream = {
  write: function (message) {
    logger.info(message.trim());
  },
};

module.exports = { logger };


--- File: server/src/utils/queryAnalyzer.js ---
// src/utils/queryAnalyzer.js
// const mongoose = require('mongoose');
const fs = require('fs').promises;
const path = require('path');

/**
 * L·ªõp QueryAnalyzer cung c·∫•p c√°c c√¥ng c·ª• ƒë·ªÉ ph√¢n t√≠ch v√† t·ªëi ∆∞u h√≥a truy v·∫•n MongoDB
 */
class QueryAnalyzer {
  /**
   * Ph√¢n t√≠ch truy v·∫•n find() v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt v·ªÅ hi·ªáu su·∫•t
   * @param {mongoose.Model} model - Model Mongoose c·∫ßn ph√¢n t√≠ch
   * @param {Object} query - ƒêi·ªÅu ki·ªán truy v·∫•n
   * @param {Object} options - T√πy ch·ªçn b·ªï sung (projection, sort, skip, limit)
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch truy v·∫•n
   */
  static async analyzeQuery(model, query, options = {}) {
    // Ghi l·∫°i th·ªùi gian b·∫Øt ƒë·∫ßu
    const startTime = Date.now();

    // L·∫•y explain plan cho truy v·∫•n
    const explain = await model
      .find(query, options.projection)
      .sort(options.sort || {})
      .skip(options.skip || 0)
      .limit(options.limit || 10)
      .explain('executionStats');

    // Tr√≠ch xu·∫•t th·ªëng k√™ th·ª±c thi
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Ph√¢n t√≠ch k·∫øt qu·∫£
    const result = {
      collection: model.collection.name,
      queryShape: JSON.stringify(query),
      executionTimeMs: executionStats.executionTimeMillis,
      totalDocsExamined: executionStats.totalDocsExamined,
      totalKeysExamined: executionStats.totalKeysExamined,
      docsReturned: executionStats.nReturned,
      indexesUsed: this._getIndexesUsed(queryPlanner.winningPlan),
      isOptimal: this._isQueryOptimal(executionStats),
      recommendations: this.generateRecommendations(explain),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log n·∫øu truy v·∫•n ch·∫≠m
    if (result.executionTimeMs > 100) {
      await this.logSlowQuery(result);
    }

    return result;
  }

  /**
   * Ph√¢n t√≠ch truy v·∫•n aggregate v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt v·ªÅ hi·ªáu su·∫•t
   * @param {mongoose.Model} model - Model Mongoose c·∫ßn ph√¢n t√≠ch
   * @param {Array} pipeline - Pipeline aggregation
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch truy v·∫•n
   */
  static async analyzeAggregate(model, pipeline) {
    const startTime = Date.now();

    // Th√™m stage $explain v√†o cu·ªëi pipeline
    const explainPipeline = [...pipeline, { $explain: true }];
    const explainResults = await model.aggregate(explainPipeline).exec();

    // Ph√¢n t√≠ch k·∫øt qu·∫£ t·ª´ explain
    const result = {
      collection: model.collection.name,
      pipeline: JSON.stringify(pipeline),
      executionTimeMs: explainResults[0]?.executionStats?.executionTimeMillis || 0,
      stages: this._analyzeAggregateStages(explainResults[0]),
      recommendations: this._generateAggregateRecommendations(explainResults[0]),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log n·∫øu truy v·∫•n ch·∫≠m
    if (result.executionTimeMs > 200) {
      await this.logSlowQuery(result, 'aggregate');
    }

    return result;
  }

  /**
   * Ph√¢n t√≠ch c√°c stage trong aggregate pipeline
   * @private
   * @param {Object} explainResult - K·∫øt qu·∫£ t·ª´ explain
   * @returns {Array} Th√¥ng tin v·ªÅ c√°c stage
   */
  static _analyzeAggregateStages(explainResult) {
    if (!explainResult || !explainResult.stages) {
      return [];
    }

    return explainResult.stages.map((stage) => {
      const stageName = Object.keys(stage)[0];
      return {
        name: stageName,
        timeMs: stage[stageName]?.executionTimeMillisEstimate || 0,
      };
    });
  }

  /**
   * T·∫°o khuy·∫øn ngh·ªã cho truy v·∫•n aggregate
   * @private
   * @param {Object} explainResult - K·∫øt qu·∫£ t·ª´ explain
   * @returns {Array} Danh s√°ch khuy·∫øn ngh·ªã
   */
  static _generateAggregateRecommendations(explainResult) {
    const recommendations = [];

    if (!explainResult) return recommendations;

    // Ki·ªÉm tra c√°c stage t·ªën nhi·ªÅu th·ªùi gian
    if (explainResult.stages) {
      const expensiveStages = explainResult.stages
        .filter((stage) => {
          const stageName = Object.keys(stage)[0];
          return stage[stageName]?.executionTimeMillisEstimate > 100;
        })
        .map((stage) => Object.keys(stage)[0]);

      if (expensiveStages.length > 0) {
        recommendations.push(
          `C√°c stage t·ªën nhi·ªÅu th·ªùi gian: ${expensiveStages.join(', ')}. Xem x√©t t·ªëi ∆∞u h√≥a ho·∫∑c th√™m ch·ªâ m·ª•c.`
        );
      }
    }

    // Ki·ªÉm tra s·ª≠ d·ª•ng $match s·ªõm
    const pipelineStr = JSON.stringify(explainResult);
    if (
      !pipelineStr.includes('"$match"') ||
      pipelineStr.indexOf('"$match"') > pipelineStr.indexOf('"$project"')
    ) {
      recommendations.push(
        'ƒê·∫∑t $match c√†ng s·ªõm c√†ng t·ªët trong pipeline ƒë·ªÉ l·ªçc d·ªØ li·ªáu tr∆∞·ªõc khi x·ª≠ l√Ω.'
      );
    }

    return recommendations;
  }

  /**
   * L·∫•y danh s√°ch c√°c ch·ªâ m·ª•c ƒë∆∞·ª£c s·ª≠ d·ª•ng
   * @private
   * @param {Object} plan - K·∫ø ho·∫°ch th·ª±c thi
   * @returns {String} T√™n ch·ªâ m·ª•c ho·∫∑c th√¥ng b√°o kh√¥ng s·ª≠ d·ª•ng ch·ªâ m·ª•c
   */
  static _getIndexesUsed(plan) {
    if (!plan) return 'Kh√¥ng c√≥ th√¥ng tin k·∫ø ho·∫°ch';

    // Ki·ªÉm tra n·∫øu k·∫ø ho·∫°ch tr·ª±c ti·∫øp c√≥ ch·ªâ m·ª•c
    if (plan.indexName) {
      return plan.indexName;
    }

    // Ki·ªÉm tra trong inputStage
    if (plan.inputStage?.indexName) {
      return plan.inputStage.indexName;
    }

    // Ki·ªÉm tra ƒë·ªá quy trong inputStages (cho tr∆∞·ªùng h·ª£p OR ho·∫∑c AND)
    if (plan.inputStages) {
      const indexNames = plan.inputStages
        .map((stage) => this._getIndexesUsed(stage))
        .filter((name) => name !== 'No index used (COLLSCAN)');

      if (indexNames.length > 0) {
        return indexNames.join(', ');
      }
    }

    return 'No index used (COLLSCAN)';
  }

  /**
   * Ki·ªÉm tra xem truy v·∫•n c√≥ t·ªëi ∆∞u kh√¥ng
   * @private
   * @param {Object} stats - Th·ªëng k√™ th·ª±c thi
   * @returns {Boolean} Truy v·∫•n c√≥ t·ªëi ∆∞u kh√¥ng
   */
  static _isQueryOptimal(stats) {
    // Truy v·∫•n ƒë∆∞·ª£c coi l√† t·ªëi ∆∞u n·∫øu:
    // 1. S·ªë l∆∞·ª£ng t√†i li·ªáu ki·ªÉm tra g·∫ßn v·ªõi s·ªë l∆∞·ª£ng t√†i li·ªáu tr·∫£ v·ªÅ
    // 2. Th·ªùi gian th·ª±c thi d∆∞·ªõi ng∆∞·ª°ng (v√≠ d·ª•: 50ms)
    return stats.totalDocsExamined <= stats.nReturned * 1.2 && stats.executionTimeMillis < 50;
  }

  /**
   * T·∫°o khuy·∫øn ngh·ªã d·ª±a tr√™n k·∫øt qu·∫£ explain
   * @param {Object} explain - K·∫øt qu·∫£ t·ª´ explain()
   * @returns {Array} Danh s√°ch khuy·∫øn ngh·ªã
   */
  static generateRecommendations(explain) {
    const recommendations = [];
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Ki·ªÉm tra vi·ªác s·ª≠ d·ª•ng ch·ªâ m·ª•c
    const indexesUsed = this._getIndexesUsed(queryPlanner.winningPlan);
    if (indexesUsed === 'No index used (COLLSCAN)') {
      recommendations.push(
        'Truy v·∫•n kh√¥ng s·ª≠ d·ª•ng ch·ªâ m·ª•c n√†o. Xem x√©t th√™m ch·ªâ m·ª•c cho m·∫´u truy v·∫•n n√†y.'
      );

      // ƒê·ªÅ xu·∫•t ch·ªâ m·ª•c c·ª• th·ªÉ
      const suggestedIndex = this.suggestIndex(queryPlanner.parsedQuery);
      if (suggestedIndex) {
        recommendations.push(`Ch·ªâ m·ª•c ƒë·ªÅ xu·∫•t: ${suggestedIndex}`);
      }
    }

    // Ki·ªÉm tra n·∫øu ki·ªÉm tra qu√° nhi·ªÅu t√†i li·ªáu
    if (executionStats.totalDocsExamined > executionStats.nReturned * 3) {
      recommendations.push(
        'Truy v·∫•n ƒëang ki·ªÉm tra qu√° nhi·ªÅu t√†i li·ªáu so v·ªõi s·ªë l∆∞·ª£ng tr·∫£ v·ªÅ. Xem x√©t s·ª≠ d·ª•ng ch·ªâ m·ª•c ch·ªçn l·ªçc h∆°n.'
      );
    }

    // Ki·ªÉm tra th·ªùi gian th·ª±c thi
    if (executionStats.executionTimeMillis > 100) {
      recommendations.push(
        'Th·ªùi gian th·ª±c thi truy v·∫•n cao. Xem x√©t t·ªëi ∆∞u h√≥a truy v·∫•n ho·∫∑c th√™m ch·ªâ m·ª•c.'
      );
    }

    // Ki·ªÉm tra s·∫Øp x·∫øp
    const sortStage = this._findSortStage(queryPlanner.winningPlan);
    if (sortStage && sortStage.sortPattern) {
      const sortFields = Object.keys(sortStage.sortPattern);
      if (
        indexesUsed === 'No index used (COLLSCAN)' ||
        !this._isSortCoveredByIndex(sortFields, indexesUsed)
      ) {
        recommendations.push(
          `S·∫Øp x·∫øp kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi ch·ªâ m·ª•c. Xem x√©t th√™m ch·ªâ m·ª•c bao g·ªìm c√°c tr∆∞·ªùng s·∫Øp x·∫øp: ${sortFields.join(', ')}`
        );
      }
    }

    return recommendations;
  }

  /**
   * T√¨m stage s·∫Øp x·∫øp trong k·∫ø ho·∫°ch truy v·∫•n
   * @private
   * @param {Object} plan - K·∫ø ho·∫°ch truy v·∫•n
   * @returns {Object|null} Stage s·∫Øp x·∫øp ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
   */
  static _findSortStage(plan) {
    if (!plan) return null;

    if (plan.stage === 'SORT') {
      return plan;
    }

    if (plan.inputStage) {
      return this._findSortStage(plan.inputStage);
    }

    if (plan.inputStages) {
      for (const stage of plan.inputStages) {
        const sortStage = this._findSortStage(stage);
        if (sortStage) return sortStage;
      }
    }

    return null;
  }

  /**
   * Ki·ªÉm tra xem s·∫Øp x·∫øp c√≥ ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi ch·ªâ m·ª•c kh√¥ng
   * @private
   * @param {Array} sortFields - C√°c tr∆∞·ªùng s·∫Øp x·∫øp
   * @param {String} indexName - T√™n ch·ªâ m·ª•c
   * @returns {Boolean} S·∫Øp x·∫øp c√≥ ƒë∆∞·ª£c h·ªó tr·ª£ kh√¥ng
   */
  static _isSortCoveredByIndex(sortFields, indexName) {
    // Ph∆∞∆°ng th·ª©c n√†y c·∫ßn th√¥ng tin v·ªÅ c·∫•u tr√∫c ch·ªâ m·ª•c
    // Trong th·ª±c t·∫ø, b·∫°n c·∫ßn truy v·∫•n th√¥ng tin ch·ªâ m·ª•c t·ª´ MongoDB
    // ƒê√¢y l√† m·ªôt tri·ªÉn khai ƒë∆°n gi·∫£n
    if (indexName === 'No index used (COLLSCAN)') {
      return false;
    }

    // Gi·∫£ ƒë·ªãnh r·∫±ng t√™n ch·ªâ m·ª•c c√≥ d·∫°ng: collection_field1_field2_...
    const indexFields = indexName.split('_').slice(1);

    // Ki·ªÉm tra xem t·∫•t c·∫£ c√°c tr∆∞·ªùng s·∫Øp x·∫øp c√≥ trong ch·ªâ m·ª•c kh√¥ng
    return sortFields.every((field) => indexFields.includes(field));
  }

  /**
   * ƒê·ªÅ xu·∫•t ch·ªâ m·ª•c d·ª±a tr√™n truy v·∫•n
   * @param {Object} parsedQuery - Truy v·∫•n ƒë√£ ph√¢n t√≠ch
   * @returns {String} ƒê·ªÅ xu·∫•t ch·ªâ m·ª•c
   */
  static suggestIndex(parsedQuery) {
    if (!parsedQuery) return null;

    const fields = [];

    // Ph√¢n t√≠ch c√°c tr∆∞·ªùng trong truy v·∫•n
    for (const field in parsedQuery) {
      // B·ªè qua c√°c to√°n t·ª≠ ƒë·∫∑c bi·ªát
      if (field.startsWith('$')) continue;

      fields.push(field);
    }

    if (fields.length === 0) return null;

    // T·∫°o chu·ªói ƒë·ªÅ xu·∫•t ch·ªâ m·ª•c
    return `{ ${fields.map((f) => `"${f}": 1`).join(', ')} }`;
  }

  /**
   * Ghi log truy v·∫•n ch·∫≠m
   * @param {Object} queryInfo - Th√¥ng tin truy v·∫•n
   * @param {String} queryType - Lo·∫°i truy v·∫•n (find, aggregate, ...)
   * @returns {Promise<void>}
   */
  static async logSlowQuery(queryInfo, queryType = 'find') {
    try {
      const logDir = path.join(process.cwd(), 'logs');

      // T·∫°o th∆∞ m·ª•c logs n·∫øu ch∆∞a t·ªìn t·∫°i
      try {
        await fs.mkdir(logDir, { recursive: true });
      } catch (err) {
        if (err.code !== 'EEXIST') throw err;
      }

      const logFile = path.join(logDir, 'slow-queries.log');
      const timestamp = new Date().toISOString();

      const logEntry = {
        timestamp,
        queryType,
        ...queryInfo,
      };

      await fs.appendFile(logFile, JSON.stringify(logEntry) + '\n', 'utf8');
    } catch (error) {
      console.error('L·ªói khi ghi log truy v·∫•n ch·∫≠m:', error);
    }
  }

  /**
   * Ph√¢n t√≠ch t·∫•t c·∫£ c√°c ch·ªâ m·ª•c trong collection
   * @param {mongoose.Model} model - Model Mongoose
   * @returns {Promise<Array>} Danh s√°ch ch·ªâ m·ª•c v√† th√¥ng tin
   */
  static async analyzeIndexes(model) {
    // L·∫•y th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c ch·ªâ m·ª•c
    const indexes = await model.collection.indexes();

    // Ph√¢n t√≠ch t·ª´ng ch·ªâ m·ª•c
    return Promise.all(
      indexes.map(async (index) => {
        // L·∫•y th·ªëng k√™ s·ª≠ d·ª•ng ch·ªâ m·ª•c
        const stats = await model.collection.stats();

        return {
          name: index.name,
          fields: index.key,
          unique: !!index.unique,
          sparse: !!index.sparse,
          size: stats.indexSizes?.[index.name] || 0,
          usage: await this._getIndexUsageStats(model, index.name),
        };
      })
    );
  }

  /**
   * L·∫•y th·ªëng k√™ s·ª≠ d·ª•ng ch·ªâ m·ª•c
   * @private
   * @param {mongoose.Model} model - Model Mongoose
   * @param {String} indexName - T√™n ch·ªâ m·ª•c
   * @returns {Promise<Object>} Th·ªëng k√™ s·ª≠ d·ª•ng
   */
  static async _getIndexUsageStats(model, indexName) {
    try {
      // S·ª≠ d·ª•ng aggregation ƒë·ªÉ l·∫•y th√¥ng tin s·ª≠ d·ª•ng ch·ªâ m·ª•c
      const result = await model.db.db.command({
        aggregate: model.collection.collectionName,
        pipeline: [{ $indexStats: {} }, { $match: { name: indexName } }],
        cursor: {},
      });

      if (result?.cursor?.firstBatch?.length > 0) {
        const stats = result.cursor.firstBatch[0];
        return {
          operations: stats.accesses.ops,
          since: stats.accesses.since,
        };
      }

      return { operations: 0, since: new Date() };
    } catch (error) {
      console.error(`L·ªói khi l·∫•y th·ªëng k√™ s·ª≠ d·ª•ng ch·ªâ m·ª•c ${indexName}:`, error);
      return { operations: 0, since: new Date(), error: error.message };
    }
  }

  /**
   * T·∫°o b√°o c√°o hi·ªáu su·∫•t truy v·∫•n
   * @param {mongoose.Model} model - Model Mongoose
   * @param {Number} days - S·ªë ng√†y ƒë·ªÉ ph√¢n t√≠ch
   * @returns {Promise<Object>} B√°o c√°o hi·ªáu su·∫•t
   */
  static async generatePerformanceReport(model, days = 7) {
    try {
      // Ph√¢n t√≠ch ch·ªâ m·ª•c
      const indexes = await this.analyzeIndexes(model);

      // ƒê·ªçc log truy v·∫•n ch·∫≠m
      const slowQueries = await this._readSlowQueriesLog(days);

      // L·ªçc c√°c truy v·∫•n li√™n quan ƒë·∫øn collection n√†y
      const collectionQueries = slowQueries.filter((q) => q.collection === model.collection.name);

      // Ph√¢n t√≠ch c√°c m·∫´u truy v·∫•n ph·ªï bi·∫øn
      const queryPatterns = this._analyzeQueryPatterns(collectionQueries);

      // T·∫°o b√°o c√°o
      return {
        collection: model.collection.name,
        indexes,
        slowQueriesCount: collectionQueries.length,
        averageExecutionTime: this._calculateAverage(
          collectionQueries.map((q) => q.executionTimeMs)
        ),
        commonQueryPatterns: queryPatterns,
        indexRecommendations: this._generateIndexRecommendations(queryPatterns, indexes),
      };
    } catch (error) {
      console.error('L·ªói khi t·∫°o b√°o c√°o hi·ªáu su·∫•t:', error);
      return { error: error.message };
    }
  }

  /**
   * ƒê·ªçc log truy v·∫•n ch·∫≠m
   * @private
   * @param {Number} days - S·ªë ng√†y ƒë·ªÉ ƒë·ªçc
   * @returns {Promise<Array>} Danh s√°ch truy v·∫•n ch·∫≠m
   */
  static async _readSlowQueriesLog(days) {
    try {
      const logFile = path.join(process.cwd(), 'logs', 'slow-queries.log');

      // Ki·ªÉm tra xem file log c√≥ t·ªìn t·∫°i kh√¥ng
      try {
        await fs.access(logFile);
      } catch (err) {
        return []; // File kh√¥ng t·ªìn t·∫°i
      }

      // ƒê·ªçc file log
      const content = await fs.readFile(logFile, 'utf8');
      const lines = content.split('\n').filter((line) => line.trim());

      // Ph√¢n t√≠ch t·ª´ng d√≤ng
      const queries = lines
        .map((line) => {
          try {
            return JSON.parse(line);
          } catch (err) {
            return null;
          }
        })
        .filter((q) => q !== null);

      // L·ªçc theo ng√†y
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      return queries.filter((q) => {
        const queryDate = new Date(q.timestamp);
        return queryDate >= cutoffDate;
      });
    } catch (error) {
      console.error('L·ªói khi ƒë·ªçc log truy v·∫•n ch·∫≠m:', error);
      return [];
    }
  }

  /**
   * Ph√¢n t√≠ch c√°c m·∫´u truy v·∫•n ph·ªï bi·∫øn
   * @private
   * @param {Array} queries - Danh s√°ch truy v·∫•n
   * @returns {Array} C√°c m·∫´u truy v·∫•n ph·ªï bi·∫øn
   */
  static _analyzeQueryPatterns(queries) {
    const patterns = {};

    // Nh√≥m c√°c truy v·∫•n theo m·∫´u
    queries.forEach((query) => {
      if (!query.queryShape) return;

      if (!patterns[query.queryShape]) {
        patterns[query.queryShape] = {
          pattern: query.queryShape,
          count: 0,
          totalTime: 0,
          examples: [],
        };
      }

      patterns[query.queryShape].count++;
      patterns[query.queryShape].totalTime += query.executionTimeMs;

      // L∆∞u t·ªëi ƒëa 3 v√≠ d·ª•
      if (patterns[query.queryShape].examples.length < 3) {
        patterns[query.queryShape].examples.push({
          timestamp: query.timestamp,
          executionTimeMs: query.executionTimeMs,
        });
      }
    });

    // Chuy·ªÉn ƒë·ªïi th√†nh m·∫£ng v√† s·∫Øp x·∫øp theo s·ªë l∆∞·ª£ng
    return Object.values(patterns)
      .map((p) => ({
        ...p,
        averageTime: p.totalTime / p.count,
      }))
      .sort((a, b) => b.count - a.count);
  }

  /**
   * T·∫°o ƒë·ªÅ xu·∫•t ch·ªâ m·ª•c d·ª±a tr√™n m·∫´u truy v·∫•n
   * @private
   * @param {Array} queryPatterns - C√°c m·∫´u truy v·∫•n
   * @param {Array} existingIndexes - C√°c ch·ªâ m·ª•c hi·ªán c√≥
   * @returns {Array} ƒê·ªÅ xu·∫•t ch·ªâ m·ª•c
   */
  static _generateIndexRecommendations(queryPatterns, existingIndexes) {
    const recommendations = [];

    queryPatterns.forEach((pattern) => {
      try {
        // Ph√¢n t√≠ch m·∫´u truy v·∫•n
        const queryObj = JSON.parse(pattern.pattern);

        // L·∫•y c√°c tr∆∞·ªùng trong truy v·∫•n
        const queryFields = Object.keys(queryObj).filter((key) => !key.startsWith('$'));

        if (queryFields.length === 0) return;

        // Ki·ªÉm tra xem ƒë√£ c√≥ ch·ªâ m·ª•c n√†o bao g·ªìm c√°c tr∆∞·ªùng n√†y ch∆∞a
        const hasMatchingIndex = existingIndexes.some((index) => {
          const indexFields = Object.keys(index.fields);
          return queryFields.every((field) => indexFields.includes(field));
        });

        if (!hasMatchingIndex) {
          recommendations.push({
            queryPattern: pattern.pattern,
            suggestedIndex: `{ ${queryFields.map((f) => `"${f}": 1`).join(', ')} }`,
            queryCount: pattern.count,
            averageTime: pattern.averageTime,
          });
        }
      } catch (error) {
        // B·ªè qua c√°c m·∫´u kh√¥ng h·ª£p l·ªá
      }
    });

    return recommendations;
  }

  /**
   * T√≠nh gi√° tr·ªã trung b√¨nh c·ªßa m·ªôt m·∫£ng s·ªë
   * @private
   * @param {Array} values - M·∫£ng c√°c gi√° tr·ªã
   * @returns {Number} Gi√° tr·ªã trung b√¨nh
   */
  static _calculateAverage(values) {
    if (values.length === 0) return 0;
    return values.reduce((sum, val) => sum + val, 0) / values.length;
  }
}

module.exports = QueryAnalyzer;


--- File: server/src/utils/responseHandler.js ---
/**
 * Response Handler Utility - ƒë·ªãnh d·∫°ng chu·∫©n h√≥a cho responses
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * G·ª≠i response th√†nh c√¥ng
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Th√¥ng b√°o th√†nh c√¥ng
 * @param {*} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
 */
exports.sendSuccess = (res, statusCode = 200, message = 'Success', data = null) => {
  const response = {
    status: 'success',
    message,
  };

  if (data !== null) {
    response.data = data;
  }

  res.status(statusCode).json(response);
};

/**
 * G·ª≠i response l·ªói
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Th√¥ng b√°o l·ªói
 * @param {Object} errors - Chi ti·∫øt l·ªói (optional)
 */
exports.sendError = (res, statusCode = 500, message = 'Error', errors = null) => {
  const response = {
    status: 'error',
    message,
  };

  if (errors !== null) {
    response.errors = errors;
  }

  res.status(statusCode).json(response);
};

/**
 * G·ª≠i response v·ªõi d·ªØ li·ªáu ph√¢n trang
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Th√¥ng b√°o
 * @param {Array} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
 * @param {Object} pagination - Th√¥ng tin ph√¢n trang
 */
exports.sendPaginated = (
  res,
  statusCode = 200,
  message = 'Success',
  data = [],
  pagination = {}
) => {
  const response = {
    status: 'success',
    message,
    data,
    pagination,
  };

  res.status(statusCode).json(response);
};

/**
 * G·ª≠i response cho created
 * @param {Object} res - Express response object
 * @param {string} message - Th√¥ng b√°o
 * @param {*} data - D·ªØ li·ªáu tr·∫£ v·ªÅ
 */
exports.sendCreated = (res, message = 'Created successfully', data = null) => {
  exports.sendSuccess(res, 201, message, data);
};

/**
 * G·ª≠i response kh√¥ng c√≥ n·ªôi dung
 * @param {Object} res - Express response object
 */
exports.sendNoContent = (res) => {
  res.status(204).end();
};


--- File: server/src/utils/validatorUtils.js ---
/**
 * Validator Utilities - C√°c h√†m h·ªó tr·ª£ validate d·ªØ li·ªáu
 * @author Steve
 * @project RunOut-Biliard
 */

const mongoose = require('mongoose');

/**
 * Ki·ªÉm tra ID MongoDB h·ª£p l·ªá
 * @param {string} id - ID c·∫ßn ki·ªÉm tra
 * @returns {boolean} - true n·∫øu h·ª£p l·ªá, false n·∫øu kh√¥ng
 */
exports.isValidMongoId = (id) => {
  return mongoose.Types.ObjectId.isValid(id);
};

/**
 * Ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam h·ª£p l·ªá
 * @param {string} phone - S·ªë ƒëi·ªán tho·∫°i c·∫ßn ki·ªÉm tra
 * @returns {boolean} - true n·∫øu h·ª£p l·ªá, false n·∫øu kh√¥ng
 */
exports.isValidVNPhone = (phone) => {
  return /^(0|\+84)[3|5|7|8|9][0-9]{8}$/.test(phone);
};

/**
 * Ki·ªÉm tra m·∫≠t kh·∫©u ƒë·ªß m·∫°nh
 * Y√™u c·∫ßu:
 * - √çt nh·∫•t 8 k√Ω t·ª±
 * - C√≥ √≠t nh·∫•t 1 ch·ªØ hoa
 * - C√≥ √≠t nh·∫•t 1 ch·ªØ th∆∞·ªùng
 * - C√≥ √≠t nh·∫•t 1 ch·ªØ s·ªë
 * @param {string} password - M·∫≠t kh·∫©u c·∫ßn ki·ªÉm tra
 * @returns {boolean} - true n·∫øu h·ª£p l·ªá, false n·∫øu kh√¥ng
 */
exports.isStrongPassword = (password) => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /[0-9]/.test(password);

  return password.length >= minLength && hasUpperCase && hasLowerCase && hasNumbers;
};

/**
 * M√£ h√≥a m·ªôt chu·ªói th√†nh slug
 * @param {string} text - Chu·ªói c·∫ßn m√£ h√≥a
 * @returns {string} - Slug ƒë√£ t·∫°o
 */
exports.slugify = (text) => {
  return text
    .toString()
    .normalize('NFD') // t√°ch d·∫•u th√†nh c√°c k√Ω t·ª± ri√™ng bi·ªát
    .replace(/[\u0300-\u036f]/g, '') // lo·∫°i b·ªè d·∫•u
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // thay kho·∫£ng tr·∫Øng b·∫±ng d·∫•u g·∫°ch
    .replace(/[^\w-]+/g, '') // lo·∫°i b·ªè c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát
    .replace(/--+/g, '-'); // thay nhi·ªÅu d·∫•u g·∫°ch li√™n ti·∫øp b·∫±ng m·ªôt d·∫•u
};

/**
 * Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát
 * @param {string} str - Chu·ªói c·∫ßn x·ª≠ l√Ω
 * @returns {string} - Chu·ªói ƒë√£ lo·∫°i b·ªè d·∫•u
 */
exports.removeVietnameseAccents = (str) => {
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/ƒë/g, 'd')
    .replace(/ƒê/g, 'D');
};

/**
 * Ki·ªÉm tra m·ªôt gi√° tr·ªã c√≥ thu·ªôc m·ªôt enum kh√¥ng
 * @param {*} value - Gi√° tr·ªã c·∫ßn ki·ªÉm tra
 * @param {Array} enumValues - M·∫£ng c√°c gi√° tr·ªã h·ª£p l·ªá
 * @returns {boolean} - true n·∫øu h·ª£p l·ªá, false n·∫øu kh√¥ng
 */
exports.isInEnum = (value, enumValues) => {
  return enumValues.includes(value);
};

/**
 * T·∫°o m·ªôt m√£ ng·∫´u nhi√™n
 * @param {number} length - ƒê·ªô d√†i m√£
 * @returns {string} - M√£ ng·∫´u nhi√™n
 */
exports.generateRandomCode = (length = 6) => {
  const characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let result = '';

  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
};

/**
 * Chu·∫©n h√≥a s·ªë ƒëi·ªán tho·∫°i v·ªÅ ƒë·ªãnh d·∫°ng 0xxxxxxxxx
 * @param {string} phone - S·ªë ƒëi·ªán tho·∫°i c·∫ßn chu·∫©n h√≥a
 * @returns {string} - S·ªë ƒëi·ªán tho·∫°i ƒë√£ chu·∫©n h√≥a
 */
exports.normalizePhone = (phone) => {
  if (!phone) return '';

  // Lo·∫°i b·ªè c√°c k√Ω t·ª± kh√¥ng ph·∫£i s·ªë
  let normalized = phone.replace(/\D/g, '');

  // ƒê·ªïi +84 th√†nh 0
  if (normalized.startsWith('84')) {
    normalized = '0' + normalized.substring(2);
  }

  return normalized;
};


--- File: server/tests/integration/repositories/repositoryConsistency.test.js ---
// server/src/tests/repositories/repositoryConsistency.test.js
const UserRepository = require('../../../src/data/repositories/userRepository');
const ProductRepository = require('../../../src/data/repositories/productRepository');
const CategoryRepository = require('../../../src/data/repositories/categoryRepository');
const OrderRepository = require('../../../src/data/repositories/orderRepository');
const CartRepository = require('../../../src/data/repositories/cartRepository');
const ReviewRepository = require('../../../src/data/repositories/reviewRepository');

describe('Repository Consistency', () => {
  const repositories = [
    { name: 'UserRepository', repo: new UserRepository() },
    { name: 'ProductRepository', repo: new ProductRepository() },
    { name: 'CategoryRepository', repo: new CategoryRepository() },
    { name: 'OrderRepository', repo: new OrderRepository() },
    { name: 'CartRepository', repo: new CartRepository() },
    { name: 'ReviewRepository', repo: new ReviewRepository() },
  ];

  test('All repositories should have the same base methods', () => {
    const requiredMethods = ['findAll', 'findById', 'create', 'update', 'delete'];

    repositories.forEach(({ name, repo }) => {
      requiredMethods.forEach((method) => {
        expect(typeof repo[method]).toBe('function', `${name} should have method ${method}`);
      });
    });
  });

  test('Repositories should have consistent parameter patterns', () => {
    repositories.forEach(({ name, repo }) => {
      // Check if constructor exists
      expect(repo.constructor).toBeDefined(`${name} should have a constructor`);

      // Check method parameter count
      const findByIdParameterCount = repo.findById.length;
      expect(findByIdParameterCount).toBe(1, `${name}.findById should accept 1 parameter (id)`);

      const updateParameterCount = repo.update.length;
      expect(updateParameterCount).toBe(2, `${name}.update should accept 2 parameters (id, data)`);
    });
  });
});


--- File: server/tests/integration/repositories/userRepository.test.js ---
// server/tests/repositories/userRepository.test.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const User = require('../../../src/data/models/user.model');
const UserRepository = require('../../../src/data/repositories/userRepository');

let mongoServer;
const userRepository = new UserRepository();

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  await mongoose.connect(mongoServer.getUri(), {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

beforeEach(async () => {
  await User.deleteMany({});
});

describe('UserRepository', () => {
  describe('create', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'user',
      };

      const user = await userRepository.create(userData);

      expect(user).toBeDefined();
      expect(user.name).toBe(userData.name);
      expect(user.email).toBe(userData.email);
      expect(user.role).toBe(userData.role);
    });
  });

  describe('findById', () => {
    it('should find a user by id', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'user',
      };

      const createdUser = await userRepository.create(userData);
      const foundUser = await userRepository.findById(createdUser.id);

      expect(foundUser).toBeDefined();
      expect(foundUser.id).toBe(createdUser.id);
      expect(foundUser.name).toBe(userData.name);
    });

    it('should return null if user not found', async () => {
      const foundUser = await userRepository.findById(mongoose.Types.ObjectId());
      expect(foundUser).toBeNull();
    });

    it('should return a user if found by valid id', async () => {
      const userData = {
        name: 'Another User',
        email: 'another@example.com',
        password: 'password456',
        role: 'admin',
      };

      const createdUser = await userRepository.create(userData);
      const foundUser = await userRepository.findById(createdUser.id);

      expect(foundUser).toBeDefined();
      expect(foundUser.id).toBe(createdUser.id);
      expect(foundUser.name).toBe(userData.name);
    });
  });

  // Th√™m c√°c test cases kh√°c cho c√°c ph∆∞∆°ng th·ª©c c√≤n l·∫°i
});


--- File: server/tests/setup.js ---
// Load bi·∫øn m√¥i tr∆∞·ªùng t·ª´ .env.test n·∫øu t·ªìn t·∫°i
require('dotenv').config({ path: '.env.test' });

// Thi·∫øt l·∫≠p cho MongoDB Memory Server n·∫øu s·ª≠ d·ª•ng cho testing
// Uncomment n·∫øu s·ª≠ d·ª•ng mongodb-memory-server cho test
// const { MongoMemoryServer } = require('mongodb-memory-server');
// const mongoose = require('mongoose');

// let mongoServer;

// H√†m thi·∫øt l·∫≠p tr∆∞·ªõc khi ch·∫°y t·∫•t c·∫£ tests
beforeAll(async () => {
  // Thi·∫øt l·∫≠p c√°c bi·∫øn m√¥i tr∆∞·ªùng c·∫ßn thi·∫øt cho tests
  process.env.NODE_ENV = 'test';

  // N·∫øu s·ª≠ d·ª•ng MongoDB Memory Server
  /*
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  process.env.MONGODB_URI_TEST = mongoUri;
  
  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  */

  // C√°c thi·∫øt l·∫≠p kh√°c tr∆∞·ªõc tests
  console.log('Test suite started');
});

// H√†m d·ªçn d·∫πp sau m·ªói test
afterEach(async () => {
  // D·ªçn d·∫πp mocks ho·∫∑c spy functions
  jest.clearAllMocks();

  // X√≥a t·∫•t c·∫£ collections sau m·ªói test
  /*
  if (mongoose.connection.readyState === 1) {
    const collections = mongoose.connection.collections;
    for (const key in collections) {
      await collections[key].deleteMany({});
    }
  }
  */
});

// H√†m d·ªçn d·∫πp sau khi ch·∫°y t·∫•t c·∫£ tests
afterAll(async () => {
  // ƒê√≥ng k·∫øt n·ªëi MongoDB n·∫øu ƒëang m·ªü
  /*
  await mongoose.connection.close();
  if (mongoServer) {
    await mongoServer.stop();
  }
  */

  // C√°c d·ªçn d·∫πp kh√°c
  console.log('Test suite completed');
});

// Global matchers t√πy ch·ªânh
expect.extend({
  // V√≠ d·ª• v·ªÅ custom matcher
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

