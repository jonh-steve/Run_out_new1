--- Folder Structure ---
[.qodo]
README.md
cautructhumuc.md
[client]
    ├── .eslintrc.js
    ├── .prettierrc
    ├── [.qodo]
    ├── README.md
    ├── cau_truc_du_an.md
    ├── [docs]
    ├── jsconfig.json
    ├── package.json
    ├── [public]
        └── index.html
    ├── [src]
        ├── App.js
        ├── [api]
            ├── [controllers]
                └── productController.js
        ├── [assets]
            ├── [css]
                └── index.css
            └── [images]
        ├── [components]
            ├── [common]
                ├── [Button]
                    ├── Button.js
                    └── Button.test.js
                ├── [Card]
                    └── Card.js
                ├── [Input]
                    └── Input.js
                ├── [LoadingSpiner]
                    └── index.js
                ├── [Modal]
                    └── index.js
                ├── [Pagination]
                    └── index.js
                ├── [Toast]
                    └── index.js
                └── [Watermark]
                    └── index.js
            ├── [feature]
                ├── [Admin]
                    ├── [Dashboard]
                        ├── DashboardStats.js
                        ├── RecentOrders.js
                        └── SalesChart.js
                    ├── [OrderManager]
                        ├── OrderDetail.js
                        └── OrderTable.js
                    ├── [ProductManager]
                        ├── ProductForm.js
                        └── ProductTable.js
                    └── [UserManager]
                        └── UserTable.js
                ├── [Cart]
                    ├── AddToCart.js
                    ├── CartItem.js
                    ├── CartList.js
                    └── CartSummary.js
                ├── [Category]
                    └── CategoryBreadcrumb.js
                ├── [Product]
                    ├── ProductCard.js
                    ├── ProductFilter.js
                    ├── ProductList.js
                    └── ProductList.test.js
                ├── [Review]
                    ├── ReviewForm.js
                    ├── ReviewItem.js
                    ├── ReviewList.js
                    └── ReviewStats.js
                ├── [Search]
                    ├── RecentSearches.js
                    └── SearchBar.js
                └── [User]
                    ├── OrderDetail.js
                    ├── ProfileSidebar.js
                    ├── UserOrders.js
                    └── UserProfile.js
        ├── [hooks]
            ├── useDebounce.js
            ├── useForm.js
            ├── useLocalStorage.js
            └── useOutsideClick.js
        ├── index.js
        ├── [pages]
            ├── [Admin]
                └── [Dashboard]
                    └── index.js
            ├── [Auth]
                ├── [Login]
                    └── index.js
                └── [Register]
                    └── index.js
            ├── [Cart]
                └── index.js
            ├── [Home]
                ├── [NotFound]
                └── index.js
            ├── [Info]
                ├── Contact.js
                ├── FAQ.js
                ├── Privacy.js
                ├── Return.js
                ├── Shipping.js
                └── Terms.js
            ├── [NotFound]
                └── index.js
            ├── [ProductDetail]
                └── index.js
            ├── [Products]
                └── index.js
            ├── [Profile]
                ├── OrderDetail.js
                ├── Orders.js
                └── index.js
            └── [Search]
                └── index.js
        ├── [services]
            ├── adminService.js
            ├── api.js
            ├── authService.js
            ├── cartService.js
            ├── notificationService.js
            ├── orderService.js
            ├── paymentService.js
            ├── productService.js
            ├── reviewService.js
            ├── userService.js
            └── wishlistService.js
        ├── [store]
            ├── hooks.js
            ├── index.js
            └── [slices]
                ├── adminSlice.js
                ├── authSlice.js
                ├── cartSlice.js
                ├── notificationSlice.js
                ├── orderSlice.js
                ├── productSlice.js
                ├── reviewSlice.js
                ├── searchSlice.js
                ├── uiSlice.js
                ├── userSlice.js
                └── wishlistSlice.js
        └── [utils]
            ├── authToken.js
            └── formatters.js
    ├── tailwind.config.js
    └── webpack.config.md
[docker]
    ├── Dockerfile.client
    ├── Dockerfile.server
    └── docker-compose.yml
docker-compose.prod.yml
[docs]
    └── CI-CD-Guide.md
[nginx]
    └── [conf.d]
        └── default.conf
[prometheus]
    └── prometheus.yml
[scripts]
    ├── init-structure.sh
    ├── mongodb-backup.sh
    └── setup-directory-structure.sh
[server]
    ├── .eslintrc.js
    ├── .prettierrc
    ├── [.qodo]
    ├── README.md
    ├── jest.config.js
    ├── jsconfig.json
    ├── package.json
    ├── [src]
        ├── [api]
            ├── [controllers]
                ├── authController.js
                ├── cartController.js
                ├── categoryController.js
                ├── orderController.js
                ├── productController.js
                ├── reviewController.js
                └── userController.js
            ├── [middleware]
                ├── authMiddleware.js
                ├── errorHandler.js
                ├── errorMiddleware.js
                ├── loggingMiddleware.js
                └── validationMiddleware.js
        ├── app.js
        ├── [common]
            ├── [errors]
                └── apiError.js
            ├── [middleware]
                ├── errorHandler.js
                ├── rateLimiter.js
                ├── requestLogger.js
                └── validate.js
            ├── readme.md
            ├── [types]
                ├── auth.types.js
                ├── common.types.js
                ├── express.d.ts
                ├── order.types.js
                └── product.types.js
            ├── [utils]
                ├── apiFeatures.js
                ├── catchAsync.js
                ├── dateUtils.js
                ├── fileUtils.js
                ├── formatters.js
                ├── responseHandler.js
                ├── securityUtils.js
                └── validatorUtils.js
            └── [validators]
                ├── authValidator.js
                ├── cartValidator.js
                ├── categoryValidator.js
                ├── orderValidator.js
                ├── productValidator.js
                ├── reviewValidator.js
                └── userValidator.js
        ├── [config]
            ├── database.js
            ├── environment.js
            ├── fix-indexes.js
            ├── indexes.js
            ├── logger.js
            ├── middleware.js
            └── monitoring.js
        ├── [data]
            ├── [dto]
                ├── cartDTO.js
                ├── categoryDTO.js
                ├── orderDTO.js
                ├── productDTO.js
                ├── reviewDTO.js
                └── userDTO.js
            ├── [models]
                ├── cart.model.js
                ├── category.model.js
                ├── order.model.js
                ├── product.model.js
                ├── review.model.js
                └── user.model.js
            └── [repositories]
                ├── cartRepository.js
                ├── categoryRepository.js
                ├── orderRepository.js
                ├── productRepository.js
                ├── reviewRepository.js
                └── userRepository.js
        ├── [migrations]
            ├── config.js
            ├── index.js
            ├── migrationFramework.js
            ├── migrationRunner.js
            └── [scripts]
                ├── 001-initial-categories.js
                ├── 002-add-indexes.js
                └── 003-add-admin-user.js
        ├── [seeds]
            ├── [data]
                ├── carts.js
                ├── categories.js
                ├── orders.js
                ├── products.js
                ├── reviews.js
                └── users.js
            ├── index.js
            ├── runner.js
            └── [scripts]
                ├── cartSeeder.js
                ├── categorySeeder.js
                ├── orderSeeder.js
                ├── productSeeder.js
                ├── reviewSeeder.js
                └── userSeeder.js
        ├── server.js
        ├── [services]
            ├── [auth]
                └── authService.js
            ├── [base]
                └── baseService.js
            ├── [cache]
                └── redisCache.js
            ├── [cart]
                └── cartService.js
            ├── [category]
                └── categoryService.js
            ├── [email]
                ├── emailService.js
            ├── [order]
                └── orderService.js
            ├── [product]
                └── productService.js
            ├── [review]
                └── reviewService.js
            └── [user]
                └── userService.js
        ├── [types]
            └── express.d.ts
        └── [utils]
            ├── apiFeatures.js
            ├── catchAsync.js
            ├── logger.js
            ├── queryAnalyzer.js
            ├── responseHandler.js
            └── validatorUtils.js
    └── [tests]
        ├── [integration]
            ├── [api]
            └── [repositories]
                ├── repositoryConsistency.test.js
                └── userRepository.test.js
        ├── setup.js
        └── [unit]
            ├── [controllers]
            ├── [repositories]
            └── [services]

--- File Contents ---

--- File: README.md ---


--- File: cautructhumuc.md ---
```
runout-biliard/
├── server/                   # Backend Node.js/Express
│   ├── src/
│   │   ├── api/
│   │   ├── services/
│   │   ├── data/
│   │   ├── common/
│   │   ├── config/
│   │   ├── app.js
│   │   └── server.js
│   ├── tests/
│   ├── .eslintrc.js
│   ├── .prettierrc
│   ├── jest.config.js
│   ├── package.json
│   └── README.md
├── client/                   # Frontend React
│   ├── public/
│   ├── src/
│   │   ├── assets/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── pages/
│   │   ├── services/
│   │   ├── store/
│   │   ├── utils/
│   │   ├── routes/
│   │   ├── App.js
│   │   └── index.js
│   ├── .eslintrc.js
│   ├── .prettierrc
│   ├── package.json
│   └── README.md
├── docker/
│   ├── docker-compose.yml
│   ├── Dockerfile.server
│   └── Dockerfile.client
├── .github/
│   └── workflows/
│       ├── ci.yml
│       └── deploy.yml
├── .gitignore
└── README.md
```


--- File: client/.eslintrc.js ---
module.exports = {
    env: {
      browser: true,
      es2021: true,
      node: true,
      jest: true,
    },
    extends: [
      'eslint:recommended',
      'plugin:react/recommended',
      'plugin:react-hooks/recommended',
      'plugin:prettier/recommended',
    ],
    parserOptions: {
      ecmaFeatures: {
        jsx: true,
      },
      ecmaVersion: 12,
      sourceType: 'module',
    },
    plugins: ['react', 'react-hooks', 'prettier'],
    rules: {
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
      'prettier/prettier': 'error',
      'no-unused-vars': 'warn',
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
  };

--- File: client/.prettierrc ---
{
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "printWidth": 100,
    "bracketSpacing": true,
    "endOfLine": "auto"
  }

--- File: client/README.md ---
1. Tổng quan cấu trúc
client/
├── public/                # Static files
│   ├── index.html         # HTML template
│   ├── favicon.ico        # Website icon
│   ├── manifest.json      # PWA manifest
│   └── assets/            # Static assets
├── src/                   # Source code
│   ├── index.js           # Entry point
│   ├── App.js             # Main component
│   ├── assets/            # Assets (images, fonts, etc.)
│   ├── components/        # Reusable components
│   ├── hooks/             # Custom React hooks
│   ├── pages/             # Page components
│   ├── routes/            # Route definitions
│   ├── services/          # API services
│   ├── store/             # Redux state management
│   └── utils/             # Utility functions
├── .env                   # Environment variables
├── .eslintrc.js           # ESLint configuration
├── .prettierrc            # Prettier configuration
├── jsconfig.json          # JavaScript configuration
├── package.json           # Dependencies & scripts
├── tailwind.config.js     # Tailwind CSS configuration
└── README.md              # Project documentation
2. Cấu trúc chi tiết từng thành phần
2.1. /src/components/
Components được chia thành 3 loại chính:
components/
├── common/                # Các components dùng chung
│   ├── Button/
│   │   ├── Button.js      # Component chính
│   │   └── Button.test.js # Unit tests
│   ├── Card/
│   ├── Input/
│   ├── Modal/
│   ├── Dropdown/
│   ├── Pagination/
│   ├── Alert/
│   ├── Badge/
│   ├── Breadcrumb/
│   ├── LoadingSpinner/
│   ├── Empty/
│   ├── ErrorMessage/
│   ├── Tag/
│   ├── Tooltip/
│   ├── Tabs/
│   ├── Avatar/
│   ├── Rating/
│   ├── Toast/
│   └── Watermark/
│
├── layout/                # Components liên quan đến layout
│   ├── Header/
│   │   ├── index.js
│   │   ├── Logo.js
│   │   ├── Navigation.js
│   │   └── UserMenu.js
│   ├── Footer/
│   │   ├── index.js
│   │   ├── FooterLinks.js
│   │   └── Copyright.js
│   ├── Sidebar/
│   │   ├── index.js
│   │   └── SidebarItem.js
│   ├── MainLayout/
│   │   └── index.js
│   └── AuthLayout/
│       └── index.js
│
└── feature/               # Components cho các tính năng cụ thể
    ├── Auth/
    │   ├── LoginForm.js
    │   ├── RegisterForm.js
    │   ├── ForgotPasswordForm.js
    │   └── ResetPasswordForm.js
    │
    ├── User/
    │   ├── UserProfile.js
    │   ├── UserAvatar.js
    │   ├── UserSettings.js
    │   └── UserOrders.js
    │
    ├── Product/
    │   ├── ProductCard.js
    │   ├── ProductList.js
    │   ├── ProductDetail.js
    │   ├── ProductImages.js
    │   ├── ProductInfo.js
    │   ├── ProductFilter.js
    │   ├── ProductSort.js
    │   ├── ProductPagination.js
    │   └── RelatedProducts.js
    │
    ├── Category/
    │   ├── CategoryList.js
    │   ├── CategoryItem.js
    │   └── CategoryBreadcrumb.js
    │
    ├── Cart/
    │   ├── CartItem.js
    │   ├── CartList.js
    │   ├── CartSummary.js
    │   ├── AddToCart.js
    │   └── MiniCart.js
    │
    ├── Checkout/
    │   ├── CheckoutForm.js
    │   ├── ShippingForm.js
    │   ├── PaymentForm.js
    │   ├── OrderSummary.js
    │   └── OrderConfirmation.js
    │
    ├── Review/
    │   ├── ReviewForm.js
    │   ├── ReviewList.js
    │   ├── ReviewItem.js
    │   └── ReviewStats.js
    │
    ├── Search/
    │   ├── SearchBar.js
    │   ├── SearchResults.js
    │   ├── SearchFilters.js
    │   └── RecentSearches.js
    │
    └── Admin/
        ├── Dashboard/
        │   ├── DashboardStats.js
        │   ├── RecentOrders.js
        │   └── SalesChart.js
        ├── ProductManager/
        │   ├── ProductTable.js
        │   ├── ProductForm.js
        │   └── ProductBulkActions.js
        ├── OrderManager/
        │   ├── OrderTable.js
        │   ├── OrderDetail.js
        │   └── OrderStatusUpdate.js
        └── UserManager/
            ├── UserTable.js
            └── UserForm.js
2.2. /src/pages/
pages/
├── Home/
│   └── index.js
│
├── Auth/
│   ├── Login/
│   │   └── index.js
│   ├── Register/
│   │   └── index.js
│   ├── ForgotPassword/
│   │   └── index.js
│   └── ResetPassword/
│       └── index.js
│
├── Products/
│   └── index.js
│
├── ProductDetail/
│   └── index.js
│
├── Cart/
│   └── index.js
│
├── Checkout/
│   ├── index.js
│   └── Success.js
│
├── Search/
│   └── index.js
│
├── Profile/
│   ├── index.js
│   ├── Settings.js
│   ├── Orders.js
│   └── Reviews.js
│
├── Admin/
│   ├── Dashboard/
│   │   └── index.js
│   ├── Products/
│   │   ├── index.js
│   │   └── Edit.js
│   ├── Orders/
│   │   ├── index.js
│   │   └── Detail.js
│   └── Users/
│       ├── index.js
│       └── Edit.js
│
└── NotFound/
    └── index.js
2.3. /src/routes/
routes/
├── index.js           # Cấu hình tất cả routes
├── paths.js           # Constants cho path URLs
├── PrivateRoute.js    # Higher-order component bảo vệ routes
└── PublicRoute.js     # Higher-order component cho public routes
2.4. /src/hooks/
hooks/
├── useAuth.js         # Hook xử lý authentication
├── useCart.js         # Hook quản lý giỏ hàng
├── useDebounce.js     # Hook debounce giá trị
├── useForm.js         # Hook quản lý form
├── useLocalStorage.js # Hook tương tác với localStorage
├── useOutsideClick.js # Hook phát hiện click bên ngoài element
├── usePayment.js      # Hook xử lý thanh toán
├── useProduct.js      # Hook lấy thông tin sản phẩm
├── useSearch.js       # Hook xử lý tìm kiếm
└── useWindowSize.js   # Hook lấy kích thước cửa sổ
2.5. /src/services/
services/
├── api.js             # Cấu hình Axios/Fetch
├── authService.js     # API cho authentication
├── cartService.js     # API cho cart operations
├── categoryService.js # API cho category operations
├── orderService.js    # API cho order operations
├── paymentService.js  # API cho payment integration
├── productService.js  # API cho product operations
├── reviewService.js   # API cho review operations
├── searchService.js   # API cho search functionality
└── userService.js     # API cho user operations
2.6. /src/store/
store/
├── index.js           # Cấu hình Redux store
├── hooks.js           # Custom Redux hooks (useAppDispatch, useAppSelector)
│
└── slices/
    ├── authSlice.js   # State management cho authentication
    ├── cartSlice.js   # State management cho shopping cart
    ├── productSlice.js # State management cho products
    ├── categorySlice.js # State management cho categories
    ├── orderSlice.js  # State management cho orders
    ├── reviewSlice.js # State management cho reviews
    ├── searchSlice.js # State management cho search
    ├── uiSlice.js     # State management cho UI (modals, sidebars, etc.)
    └── userSlice.js   # State management cho user profile
2.7. /src/utils/
utils/
├── authToken.js       # Utilities xử lý JWT tokens
├── formatters.js      # Formatting functions (dates, currency, etc.)
├── validators.js      # Validation functions
├── storage.js         # Local/session storage helpers
├── errorHandler.js    # Error handling utilities
├── analytics.js       # Analytics helpers
├── constants.js       # Application constants
└── helpers.js         # Các helper functions khác
2.8. /src/assets/
assets/
├── css/
│   └── index.css      # Global CSS
│
├── images/
│   ├── logo.png
│   ├── banners/
│   ├── icons/
│   └── products/
│
└── fonts/
    └── ...


--- File: client/cau_truc_du_an.md ---

1. Tổng quan cấu trúc client/
├── public/ # Static files
│ ├── index.html # HTML template
│ ├── favicon.ico # Website icon
│ ├── manifest.json # PWA manifest
│ └── assets/ # Static assets
├── src/ # Source code
│ ├── index.js # Entry point
│ ├── App.js # Main component
│ ├── assets/ # Assets (images, fonts, etc.)
│ ├── components/ # Reusable components
│ ├── hooks/ # Custom React hooks
│ ├── pages/ # Page components
│ ├── routes/ # Route definitions
│ ├── services/ # API services
│ ├── store/ # Redux state management
│ └── utils/ # Utility functions
├── .env # Environment variables
├── .eslintrc.js # ESLint configuration
├── .prettierrc # Prettier configuration
├── jsconfig.json # JavaScript configuration
├── package.json # Dependencies & scripts
├── tailwind.config.js # Tailwind CSS configuration
└── README.md # Project documentation

2. /src/components/

components/
├── common/ # Các components dùng chung
│ ├── Button/
│ │ ├── Button.js # Component chính
│ │ └── Button.test.js # Unit tests
│ ├── Card/
│ ├── Input/
│ ├── Modal/
│ ├── Dropdown/
│ ├── Pagination/
│ ├── Alert/
│ ├── Badge/
│ ├── Breadcrumb/
│ ├── LoadingSpinner/
│ ├── Empty/
│ ├── ErrorMessage/
│ ├── Tag/
│ ├── Tooltip/
│ ├── Tabs/
│ ├── Avatar/
│ ├── Rating/
│ ├── Toast/
│ └── Watermark/
│
├── layout/ # Components liên quan đến layout
│ ├── Header/
│ │ ├── index.js
│ │ ├── Logo.js
│ │ ├── Navigation.js
│ │ └── UserMenu.js
│ ├── Footer/
│ │ ├── index.js
│ │ ├── FooterLinks.js
│ │ └── Copyright.js
│ ├── Sidebar/
│ │ ├── index.js
│ │ └── SidebarItem.js
│ ├── MainLayout/
│ │ └── index.js
│ └── AuthLayout/
│ └── index.js
│
└── feature/ # Components cho các tính năng cụ thể
                ├── Auth/
                │ ├── LoginForm.js
                │ ├── RegisterForm.js
                │ ├── ForgotPasswordForm.js
                │ └── ResetPasswordForm.js
                │
                ├── User/
                │ ├── UserProfile.js
                │ ├── UserAvatar.js
                │ ├── UserSettings.js
                │ └── UserOrders.js
                │
                ├── Product/
                │ ├── ProductCard.js
                │ ├── ProductList.js
                │ ├── ProductDetail.js
                │ ├── ProductImages.js
                │ ├── ProductInfo.js
                │ ├── ProductFilter.js
                │ ├── ProductSort.js
                │ ├── ProductPagination.js
                │ └── RelatedProducts.js
                │
                ├── Category/
                │ ├── CategoryList.js
                │ ├── CategoryItem.js
                │ └── CategoryBreadcrumb.js
                │
                ├── Cart/
                │ ├── CartItem.js
                │ ├── CartList.js
                │ ├── CartSummary.js
                │ ├── AddToCart.js
                │ └── MiniCart.js
                │
                ├── Checkout/
                │ ├── CheckoutForm.js
                │ ├── ShippingForm.js
                │ ├── PaymentForm.js
                │ ├── OrderSummary.js
                │ └── OrderConfirmation.js
                │
                ├── Review/
                │ ├── ReviewForm.js
                │ ├── ReviewList.js
                │ ├── ReviewItem.js
                │ └── ReviewStats.js
                │
                ├── Search/
                │ ├── SearchBar.js
                │ ├── SearchResults.js
                │ ├── SearchFilters.js
                │ └── RecentSearches.js
                │
                └── Admin/
                                ├── Dashboard/
                                │ ├── DashboardStats.js
                                │ ├── RecentOrders.js
                                │ └── SalesChart.js
                                ├── ProductManager/
                                │ ├── ProductTable.js
                                │ ├── ProductForm.js
                                │ └── ProductBulkActions.js
                                ├── OrderManager/
                                │ ├── OrderTable.js
                                │ ├── OrderDetail.js
                                │ └── OrderStatusUpdate.js
                                └── UserManager/
                                                ├── UserTable.js
                                                └── UserForm.js

2.2. /src/pages/

pages/
├── Home/
│   └── index.js
│
├── Auth/
│   ├── Login/
│   │   └── index.js
│   ├── Register/
│   │   └── index.js
│   ├── ForgotPassword/
│   │   └── index.js
│   └── ResetPassword/
│       └── index.js
│
├── Products/
│   └── index.js
│
├── ProductDetail/
│   └── index.js
│
├── Cart/
│   └── index.js
│
├── Checkout/
│   ├── index.js
│   └── Success.js
│
├── Search/
│   └── index.js
│
├── Profile/
│   ├── index.js
│   ├── Settings.js
│   ├── Orders.js
│   └── Reviews.js
│
├── Admin/
│   ├── Dashboard/
│   │   └── index.js
│   ├── Products/
│   │   ├── index.js
│   │   └── Edit.js
│   ├── Orders/
│   │   ├── index.js
│   │   └── Detail.js
│   └── Users/
│       ├── index.js
│       └── Edit.js
│
└── NotFound/
    └── index.js
2.3. /src/routes/
routes/
├── index.js           # Cấu hình tất cả routes
├── paths.js           # Constants cho path URLs
├── PrivateRoute.js    # Higher-order component bảo vệ routes
└── PublicRoute.js     # Higher-order component cho public routes
2.4. /src/hooks/
hooks/
├── useAuth.js         # Hook xử lý authentication
├── useCart.js         # Hook quản lý giỏ hàng
├── useDebounce.js     # Hook debounce giá trị
├── useForm.js         # Hook quản lý form
├── useLocalStorage.js # Hook tương tác với localStorage
├── useOutsideClick.js # Hook phát hiện click bên ngoài element
├── usePayment.js      # Hook xử lý thanh toán
├── useProduct.js      # Hook lấy thông tin sản phẩm
├── useSearch.js       # Hook xử lý tìm kiếm
└── useWindowSize.js   # Hook lấy kích thước cửa sổ
2.5. /src/services/
services/
├── api.js             # Cấu hình Axios/Fetch
├── authService.js     # API cho authentication
├── cartService.js     # API cho cart operations
├── categoryService.js # API cho category operations
├── orderService.js    # API cho order operations
├── paymentService.js  # API cho payment integration
├── productService.js  # API cho product operations
├── reviewService.js   # API cho review operations
├── searchService.js   # API cho search functionality
└── userService.js     # API cho user operations
2.6. /src/store/
store/
├── index.js           # Cấu hình Redux store
├── hooks.js           # Custom Redux hooks (useAppDispatch, useAppSelector)
│
└── slices/
    ├── authSlice.js   # State management cho authentication
    ├── cartSlice.js   # State management cho shopping cart
    ├── productSlice.js # State management cho products
    ├── categorySlice.js # State management cho categories
    ├── orderSlice.js  # State management cho orders
    ├── reviewSlice.js # State management cho reviews
    ├── searchSlice.js # State management cho search
    ├── uiSlice.js     # State management cho UI (modals, sidebars, etc.)
    └── userSlice.js   # State management cho user profile
2.7. /src/utils/
utils/
├── authToken.js       # Utilities xử lý JWT tokens
├── formatters.js      # Formatting functions (dates, currency, etc.)
├── validators.js      # Validation functions
├── storage.js         # Local/session storage helpers
├── errorHandler.js    # Error handling utilities
├── analytics.js       # Analytics helpers
├── constants.js       # Application constants
└── helpers.js         # Các helper functions khác
2.8. /src/assets/
assets/
├── css/
│   └── index.css      # Global CSS
│
├── images/
│   ├── logo.png
│   ├── banners/
│   ├── icons/
│   └── products/
│
└── fonts/


--- File: client/jsconfig.json ---
{
    "compilerOptions": {
      "baseUrl": "src",
      "paths": {
        "components/*": ["components/*"],
        "hooks/*": ["hooks/*"],
        "pages/*": ["pages/*"],
        "services/*": ["services/*"],
        "store/*": ["store/*"],
        "utils/*": ["utils/*"],
        "routes/*": ["routes/*"],
        "assets/*": ["assets/*"]
      },
      "checkJs": true,
      "jsx": "react-jsx"
    },
    "include": ["src"]
  }

--- File: client/package.json ---
{
    "name": "runout-biliard-client",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
        "@reduxjs/toolkit": "^2.0.1",
        "@tailwindcss/forms": "^0.5.10",
        "axios": "^1.6.2",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-hook-form": "^7.49.0",
        "react-query": "^3.39.3",
        "react-redux": "^9.0.2",
        "react-router-dom": "^6.20.1",
        "tailwindcss": "^3.4.17",
        "yup": "^1.3.2"
    },
    "devDependencies": {
        "@testing-library/jest-dom": "^6.1.5",
        "@testing-library/react": "^14.1.2",
        "@testing-library/user-event": "^14.5.1",
        "@types/jest": "^29.5.14",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "eslint-plugin-react": "^7.33.2",
        "eslint-plugin-react-hooks": "^4.6.0",
        "postcss": "^8.4.32",
        "prettier": "^3.1.0",
        "react-scripts": "5.0.1"
    },
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject",
        "lint": "eslint src",
        "lint:fix": "eslint src --fix",
        "format": "prettier --write \"src/**/*.{js,jsx}\""
    },
    "eslintConfig": {
        "extends": [
            "react-app",
            "react-app/jest"
        ]
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    },
    "proxy": "http://localhost:5000"
}


--- File: client/public/index.html ---
<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="RunOut-Biliard - Cửa hàng Bi-a chuyên nghiệp"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>RunOut-Biliard</title>
    <meta name="copyright" content="© 2025 RunOut-Biliard. Tất cả các quyền thuộc về Steve." />
  </head>
  <body>
    <noscript>Bạn cần bật JavaScript để chạy ứng dụng này.</noscript>
    <div id="root"></div>
  </body>
</html>

--- File: client/src/App.js ---
// File: client/src/App.js
import React, { Suspense } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import MainLayout from './components/layout/MainLayout';
import AuthLayout from './components/layout/AuthLayout';
import LoadingSpinner from './components/common/LoadingSpiner/index.js';
import { selectIsAuthenticated } from './store/slices/authSlice';
import { ROUTES } from './routes/paths';
// Lazy-loaded pages
const HomePage = React.lazy(() => import('./pages/Home'));
const LoginPage = React.lazy(() => import('./pages/Auth/Login'));
const RegisterPage = React.lazy(() => import('./pages/Auth/Register'));
const NotFoundPage = React.lazy(() => import('./pages/NotFound'));

// Watermark
const Watermark = ({ children }) => {
  return (
    <div className="relative">
      {children}
      <div className="absolute bottom-4 right-4 opacity-30 text-gray-500 font-bold rotate-330 select-none pointer-events-none">
        &copy; Steve
      </div>
    </div>
  );
};

function App() {
  const isAuthenticated = useSelector(selectIsAuthenticated);

  return (
    <Watermark>
      <Suspense fallback={<LoadingSpinner fullScreen />}>
        <Routes>
          {/* Public routes */}
          <Route element={<MainLayout />}>
            <Route path={ROUTES.HOME} element={<HomePage />} />
          </Route>

          {/* Auth routes */}
          <Route element={<AuthLayout />}>
            <Route
              path={ROUTES.LOGIN}
              element={isAuthenticated ? <Navigate to="/" replace /> : <LoginPage />}
            />
            <Route
              path={ROUTES.REGISTER}
              element={isAuthenticated ? <Navigate to="/" replace /> : <RegisterPage />}
            />
          </Route>

          {/* 404 route */}
          <Route path={ROUTES.NOT_FOUND} element={<NotFoundPage />} />
          <Route path="*" element={<Navigate to={ROUTES.NOT_FOUND} replace />} />
        </Routes>
      </Suspense>
    </Watermark>
  );
}

export default App;


--- File: client/src/api/controllers/productController.js ---
// server/src/api/controllers/productController.js

const { Product } = require('../../data/models/product.model');
const productRepository = require('../../data/repositories/productRepository');
const ApiError = require('../../middleware/apiError');
const catchAsync = require('../../utils/catchAsync');
const responseHandler = require('../../utils/responseHandler');

/**
 * Lấy danh sách sản phẩm với pagination và filter
 */
exports.getProducts = catchAsync(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  const sort = req.query.sort || '-createdAt';
  
  // Xây dựng filter từ query params
  const filter = {};
  
  // Lọc theo danh mục
  if (req.query.category) {
    filter.category = req.query.category;
  }
  
  // Lọc theo giá
  if (req.query.minPrice || req.query.maxPrice) {
    filter.price = {};
    if (req.query.minPrice) filter.price.$gte = parseFloat(req.query.minPrice);
    if (req.query.maxPrice) filter.price.$lte = parseFloat(req.query.maxPrice);
  }
  
  // Lọc theo thương hiệu
  if (req.query.brand) {
    filter.brand = req.query.brand;
  }
  
  // Lọc theo tình trạng tồn kho
  if (req.query.inStock === 'true') {
    filter.stock = { $gt: 0 };
  }
  
  // Mặc định chỉ hiển thị sản phẩm active
  filter.isActive = true;
  
  const result = await productRepository.findAll(filter, {
    page,
    limit,
    sort,
    populate: 'category'
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

/**
 * Lấy chi tiết sản phẩm theo ID
 */
exports.getProductById = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  
  const product = await productRepository.findById(id, {
    populate: 'category'
  });
  
  if (!product) {
    return next(new ApiError(404, 'Không tìm thấy sản phẩm'));
  }
  
  responseHandler.success(res, product);
});

/**
 * Lấy sản phẩm theo danh mục
 */
exports.getProductsByCategory = catchAsync(async (req, res) => {
  const { categoryId } = req.params;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  const sort = req.query.sort || '-createdAt';
  
  const filter = {
    category: categoryId,
    isActive: true
  };
  
  // Áp dụng các filter khác nếu có
  if (req.query.minPrice || req.query.maxPrice) {
    filter.price = {};
    if (req.query.minPrice) filter.price.$gte = parseFloat(req.query.minPrice);
    if (req.query.maxPrice) filter.price.$lte = parseFloat(req.query.maxPrice);
  }
  
  const result = await productRepository.findAll(filter, {
    page,
    limit,
    sort
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

/**
 * Tìm kiếm sản phẩm
 */
exports.searchProducts = catchAsync(async (req, res) => {
  const { q } = req.query;
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 12;
  
  if (!q) {
    return responseHandler.success(res, {
      data: [],
      totalPages: 0,
      currentPage: page,
      totalItems: 0
    });
  }
  
  const result = await productRepository.search(q, {
    page,
    limit
  });
  
  responseHandler.success(res, {
    data: result.data,
    totalPages: result.totalPages,
    currentPage: result.currentPage,
    totalItems: result.totalItems
  });
});

--- File: client/src/assets/css/index.css ---
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.content-wrapper {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

--- File: client/src/components/common/Button/Button.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {'primary'|'secondary'|'outline'|'danger'} [props.variant='primary']
 * @param {'sm'|'md'|'lg'} [props.size='md']
 * @param {boolean} [props.isLoading=false]
 * @param {React.ReactNode} [props.leftIcon]
 * @param {React.ReactNode} [props.rightIcon]
 */
const Button = ({
  children,
  variant = 'primary',
  size = 'md',
  isLoading = false,
  leftIcon,
  rightIcon,
  className = '',
  disabled = false,
  ...rest
}) => {
  const baseClasses = 'font-medium rounded focus:outline-none transition-colors';

  const variantClasses = {
    primary: 'bg-blue-600 hover:bg-blue-700 text-white',
    secondary: 'bg-gray-600 hover:bg-gray-700 text-white',
    outline: 'bg-transparent border border-blue-600 text-blue-600 hover:bg-blue-50',
    danger: 'bg-red-600 hover:bg-red-700 text-white',
  };

  const sizeClasses = {
    sm: 'py-1 px-3 text-sm',
    md: 'py-2 px-4 text-base',
    lg: 'py-3 px-5 text-lg',
  };

  const buttonClasses = `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`;

  return (
    <button className={buttonClasses} disabled={isLoading || disabled} {...rest}>
      {isLoading ? (
        <span className="flex items-center justify-center">
          <svg
            className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          Đang xử lý...
        </span>
      ) : (
        <span className="flex items-center justify-center">
          {leftIcon && <span className="mr-2">{leftIcon}</span>}
          {children}
          {rightIcon && <span className="ml-2">{rightIcon}</span>}
        </span>
      )}
    </button>
  );
};

export default Button;


--- File: client/src/components/common/Button/Button.test.js ---
// src/components/common/Button/Button.test.js
// File test cho component Button trong thư mục src/components/common/Button

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

describe('Button component', () => {
  test('renders button with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  describe('variant tests', () => {
    test('applies the correct primary variant class', () => {
      const { container } = render(<Button variant="primary">Primary Button</Button>);
      expect(container.firstChild).toHaveClass('bg-blue-600');
    });

    test('applies the correct secondary variant class', () => {
      const { container } = render(<Button variant="secondary">Secondary Button</Button>);
      expect(container.firstChild).toHaveClass('bg-gray-600');
    });

    test('applies the correct outline variant class', () => {
      const { container } = render(<Button variant="outline">Outline Button</Button>);
      expect(container.firstChild).toHaveClass('bg-transparent');
      expect(container.firstChild).toHaveClass('border-blue-600');
    });

    test('applies the correct danger variant class', () => {
      const { container } = render(<Button variant="danger">Danger Button</Button>);
      expect(container.firstChild).toHaveClass('bg-red-600');
    });
  });

  describe('size tests', () => {
    test('applies the correct small size class', () => {
      const { container } = render(<Button size="sm">Small Button</Button>);
      expect(container.firstChild).toHaveClass('py-1 px-3 text-sm');
    });

    test('applies the correct medium size class', () => {
      const { container } = render(<Button size="md">Medium Button</Button>);
      expect(container.firstChild).toHaveClass('py-2 px-4 text-base');
    });

    test('applies the correct large size class', () => {
      const { container } = render(<Button size="lg">Large Button</Button>);
      expect(container.firstChild).toHaveClass('py-3 px-5 text-lg');
    });
  });

  test('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('is disabled when isLoading is true', () => {
    render(<Button isLoading>Loading</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  test('shows loading spinner when isLoading is true', () => {
    render(<Button isLoading>Loading</Button>);
    // Tìm SVG loading spinner thay vì sử dụng data-testid
    const loadingSpinner = document.querySelector('svg.animate-spin');
    expect(loadingSpinner).toBeInTheDocument();
  });

  test('renders with left icon when provided', () => {
    const leftIcon = <span>🔍</span>;
    render(<Button leftIcon={leftIcon}>Search</Button>);
    expect(screen.getByText('🔍')).toBeInTheDocument();
  });

  test('renders with right icon when provided', () => {
    const rightIcon = <span>→</span>;
    render(<Button rightIcon={rightIcon}>Next</Button>);
    expect(screen.getByText('→')).toBeInTheDocument();
  });

  test('applies custom className when provided', () => {
    const { container } = render(<Button className="custom-class">Custom Button</Button>);
    expect(container.firstChild).toHaveClass('custom-class');
  });

  test('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled Button</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});


--- File: client/src/components/common/Card/Card.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {React.ReactNode} props.children
 * @param {React.ReactNode} [props.header]
 * @param {React.ReactNode} [props.footer]
 * @param {string} [props.className]
 */
const Card = ({ children, header, footer, className = '', ...rest }) => {
  return (
    <div className={`bg-white rounded-lg shadow-md overflow-hidden ${className}`} {...rest}>
      {header && <div className="px-6 py-4 border-b border-gray-200">{header}</div>}
      <div className="p-6">{children}</div>
      {footer && <div className="px-6 py-4 border-t border-gray-200">{footer}</div>}
    </div>
  );
};

export default Card;


--- File: client/src/components/common/Input/Input.js ---
import React, { forwardRef } from 'react';

/**
 * @param {Object} props
 * @param {string} [props.id]
 * @param {string} [props.label]
 * @param {string} [props.error]
 * @param {string} [props.helperText]
 * @param {React.ReactNode} [props.leftIcon]
 * @param {React.ReactNode} [props.rightIcon]
 */
const Input = forwardRef(
  ({ id, label, error, helperText, leftIcon, rightIcon, className = '', ...rest }, ref) => {
    const inputId = id || `input-${Math.random().toString(36).substring(2, 9)}`;

    return (
      <div className="mb-4">
        {label && (
          <label htmlFor={inputId} className="block text-sm font-medium text-gray-700 mb-1">
            {label}
          </label>
        )}

        <div className="relative">
          {leftIcon && (
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              {leftIcon}
            </div>
          )}

          <input
            id={inputId}
            ref={ref}
            className={`
            block w-full rounded-md shadow-sm 
            ${leftIcon ? 'pl-10' : 'pl-3'} 
            ${rightIcon ? 'pr-10' : 'pr-3'} 
            py-2 border 
            ${error ? 'border-red-500 focus:ring-red-500 focus:border-red-500' : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500'} 
            ${className}
          `}
            {...rest}
          />

          {rightIcon && (
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
              {rightIcon}
            </div>
          )}
        </div>

        {error && <p className="mt-1 text-sm text-red-600">{error}</p>}

        {helperText && !error && <p className="mt-1 text-sm text-gray-500">{helperText}</p>}
      </div>
    );
  }
);

Input.displayName = 'Input';

export default Input;


--- File: client/src/components/common/LoadingSpiner/index.js ---
import React from 'react';

/**
 * @param {Object} props
 * @param {boolean} [props.fullScreen=false]
 * @param {string} [props.size='md']
 * @param {string} [props.className]
 */
const LoadingSpinner = ({ fullScreen = false, size = 'md', className = '' }) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12',
    xl: 'h-16 w-16',
  };

  const spinnerSize = sizeClasses[size] || sizeClasses.md;

  const spinner = (
    <svg
      className={`animate-spin text-blue-600 ${spinnerSize} ${className}`}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      ></circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
  );

  if (fullScreen) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-white bg-opacity-75 z-50">
        {spinner}
      </div>
    );
  }

  return spinner;
};

export default LoadingSpinner;


--- File: client/src/components/common/Modal/index.js ---
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { CSSTransition } from 'react-transition-group';
import { useOutsideClick } from '../../../hooks/useOutsideClick';

const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  size = 'md',
  closeOnOverlayClick = true,
  showCloseButton = true,
  footer = null,
}) => {
  const modalRef = useRef(null);
  const nodeRef = useRef(null);

  // Handle outside click
  useOutsideClick(modalRef, () => {
    if (closeOnOverlayClick) {
      onClose();
    }
  });

  // Handle escape key press
  useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEsc);
      document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
    }

    return () => {
      document.removeEventListener('keydown', handleEsc);
      document.body.style.overflow = ''; // Re-enable scrolling when modal is closed
    };
  }, [isOpen, onClose]);

  // Determine modal width based on size
  const getModalWidth = () => {
    switch (size) {
      case 'sm':
        return 'max-w-md';
      case 'lg':
        return 'max-w-3xl';
      case 'xl':
        return 'max-w-5xl';
      case 'full':
        return 'max-w-full mx-4';
      default:
        return 'max-w-xl';
    }
  };

  return createPortal(
    <CSSTransition
      in={isOpen}
      timeout={300}
      classNames={{
        enter: 'opacity-0',
        enterActive: 'opacity-100 transition-opacity duration-300',
        exit: 'opacity-100',
        exitActive: 'opacity-0 transition-opacity duration-300',
      }}
      unmountOnExit
      nodeRef={nodeRef}
    >
      <div
        ref={nodeRef}
        className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"
      >
        <div
          ref={modalRef}
          className={`bg-white rounded-lg shadow-xl w-full ${getModalWidth()} max-h-[90vh] flex flex-col`}
        >
          {/* Modal header */}
          <div className="px-6 py-4 border-b flex justify-between items-center">
            <h3 className="text-lg font-medium text-gray-900">{title}</h3>
            {showCloseButton && (
              <button type="button" className="text-gray-400 hover:text-gray-500" onClick={onClose}>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  className="h-6 w-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            )}
          </div>

          {/* Modal body */}
          <div className="px-6 py-4 overflow-y-auto flex-1">{children}</div>

          {/* Modal footer */}
          {footer && <div className="px-6 py-4 border-t">{footer}</div>}
        </div>
      </div>
    </CSSTransition>,
    document.body
  );
};

export default Modal;


--- File: client/src/components/common/Pagination/index.js ---
import React from 'react';
import classNames from 'classnames';

const Pagination = ({ currentPage, totalPages, onPageChange, siblingCount = 1 }) => {
  // Generate page numbers
  const getPageNumbers = () => {
    const totalPageNumbers = siblingCount + 5; // Current + first + last + 2 ellipsis + siblings

    // If total pages is less than total page numbers, show all pages
    if (totalPages <= totalPageNumbers) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    // Calculate left and right bounds
    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);
    const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPages);

    // Show ellipsis
    const shouldShowLeftDots = leftSiblingIndex > 2;
    const shouldShowRightDots = rightSiblingIndex < totalPages - 1;

    // Always show first and last pages
    const firstPageIndex = 1;
    const lastPageIndex = totalPages;

    // Handle edge cases
    if (!shouldShowLeftDots && shouldShowRightDots) {
      // Show more pages on the left
      const leftItemCount = 3 + 2 * siblingCount;
      const leftRange = Array.from({ length: leftItemCount }, (_, i) => i + 1);

      return [...leftRange, '...', lastPageIndex];
    }

    if (shouldShowLeftDots && !shouldShowRightDots) {
      // Show more pages on the right
      const rightItemCount = 3 + 2 * siblingCount;
      const rightRange = Array.from(
        { length: rightItemCount },
        (_, i) => totalPages - rightItemCount + i + 1
      );

      return [firstPageIndex, '...', ...rightRange];
    }

    if (shouldShowLeftDots && shouldShowRightDots) {
      // Show pages around current page with dots on both sides
      const middleRange = Array.from(
        { length: rightSiblingIndex - leftSiblingIndex + 1 },
        (_, i) => leftSiblingIndex + i
      );

      return [firstPageIndex, '...', ...middleRange, '...', lastPageIndex];
    }
  };

  const pageNumbers = getPageNumbers();

  return (
    <div className="flex justify-center mt-8">
      <nav className="inline-flex">
        {/* Previous button */}
        <button
          className={classNames('px-3 py-1 rounded-l-md border border-gray-300', {
            'bg-gray-100 text-gray-500 cursor-not-allowed': currentPage === 1,
            'bg-white hover:bg-gray-50 text-gray-700': currentPage !== 1,
          })}
          onClick={() => currentPage > 1 && onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          Trước
        </button>

        {/* Page numbers */}
        {pageNumbers.map((pageNumber, index) => (
          <button
            key={index}
            className={classNames('px-3 py-1 border-t border-b border-gray-300', {
              'bg-blue-500 text-white': pageNumber === currentPage,
              'bg-white hover:bg-gray-50 text-gray-700':
                pageNumber !== currentPage && pageNumber !== '...',
              'bg-white text-gray-500': pageNumber === '...',
            })}
            onClick={() => pageNumber !== '...' && onPageChange(pageNumber)}
            disabled={pageNumber === '...'}
          >
            {pageNumber}
          </button>
        ))}

        {/* Next button */}
        <button
          className={classNames('px-3 py-1 rounded-r-md border border-gray-300', {
            'bg-gray-100 text-gray-500 cursor-not-allowed': currentPage === totalPages,
            'bg-white hover:bg-gray-50 text-gray-700': currentPage !== totalPages,
          })}
          onClick={() => currentPage < totalPages && onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          Sau
        </button>
      </nav>
    </div>
  );
};

export default Pagination;


--- File: client/src/components/common/Toast/index.js ---
import React, { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import classNames from 'classnames';

// Toast component
const Toast = ({ message, type = 'info', duration = 3000, onClose }) => {
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    if (!duration) return;

    const timer = setTimeout(() => {
      setIsVisible(false);
      setTimeout(onClose, 300); // Wait for animation to complete
    }, duration);

    return () => clearTimeout(timer);
  }, [duration, onClose]);

  // Icon based on type
  const getIcon = () => {
    switch (type) {
      case 'success':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-green-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        );
      case 'error':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-red-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        );
      case 'warning':
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-yellow-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
            />
          </svg>
        );
      default:
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-6 w-6 text-blue-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
        );
    }
  };

  return (
    <div
      className={classNames(
        'fixed top-4 right-4 z-50 flex items-center bg-white rounded-lg shadow-lg border-l-4 p-4 transition-all duration-300',
        {
          'translate-x-0 opacity-100': isVisible,
          'translate-x-full opacity-0': !isVisible,
          'border-green-500': type === 'success',
          'border-red-500': type === 'error',
          'border-yellow-500': type === 'warning',
          'border-blue-500': type === 'info',
        }
      )}
    >
      <div className="mr-3">{getIcon()}</div>
      <div className="flex-1">
        <p className="text-sm text-gray-700">{message}</p>
      </div>
      <button
        className="ml-4 text-gray-400 hover:text-gray-500"
        onClick={() => {
          setIsVisible(false);
          setTimeout(onClose, 300);
        }}
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M6 18L18 6M6 6l12 12"
          />
        </svg>
      </button>
    </div>
  );
};

// ToastContainer component
const ToastContainer = () => {
  const [toasts, setToasts] = useState([]);

  // Add toast
  const addToast = (toast) => {
    const id = Date.now();
    setToasts((prevToasts) => [...prevToasts, { ...toast, id }]);
    return id;
  };

  // Remove toast
  const removeToast = (id) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  };

  // Expose methods globally
  useEffect(() => {
    window.toast = {
      success: (message, duration) => addToast({ message, type: 'success', duration }),
      error: (message, duration) => addToast({ message, type: 'error', duration }),
      warning: (message, duration) => addToast({ message, type: 'warning', duration }),
      info: (message, duration) => addToast({ message, type: 'info', duration }),
    };
  }, []);

  return createPortal(
    <div>
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={() => removeToast(toast.id)}
        />
      ))}
    </div>,
    document.body
  );
};

export default ToastContainer;


--- File: client/src/components/common/Watermark/index.js ---
// client/src/components/common/Watermark/index.js

import React from 'react';

const Watermark = ({ children }) => {
  return (
    <div className="relative">
      {children}
      <div className="absolute bottom-4 right-4 opacity-30 text-gray-500 font-bold rotate-330 select-none pointer-events-none">
        © Steve
      </div>
    </div>
  );
};

export default Watermark;


--- File: client/src/components/feature/Admin/Dashboard/DashboardStats.js ---
// src/components/feature/Admin/Dashboard/DashboardStats.js
// Vị trí: Component hiển thị các thống kê tổng quan trên Dashboard Admin

import React from 'react';
import { Link } from 'react-router-dom';
import {
  ShoppingBagIcon,
  CurrencyDollarIcon,
  UserGroupIcon,
  ShoppingCartIcon,
  ArrowUpIcon,
  ArrowDownIcon,
} from '@heroicons/react/24/outline';

/**
 * Component hiển thị một thẻ thống kê đơn lẻ
 */
const StatCard = ({ title, value, icon: Icon, color, bgColor, change, linkTo }) => {
  const isPositive = change >= 0;

  return (
    <Link
      to={linkTo}
      className="bg-white rounded-lg shadow-md p-6 transition-all duration-300 hover:shadow-lg"
    >
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm text-gray-500 font-medium">{title}</p>
          <p className="text-2xl font-bold mt-1">{value}</p>

          {change !== undefined && (
            <div
              className={`flex items-center mt-2 text-sm ${isPositive ? 'text-green-600' : 'text-red-600'}`}
            >
              {isPositive ? (
                <ArrowUpIcon className="h-4 w-4 mr-1" />
              ) : (
                <ArrowDownIcon className="h-4 w-4 mr-1" />
              )}
              <span>{Math.abs(change)}% so với tháng trước</span>
            </div>
          )}
        </div>

        <div className={`p-3 rounded-full ${bgColor}`}>
          <Icon className={`h-6 w-6 ${color}`} />
        </div>
      </div>
    </Link>
  );
};

/**
 * Component hiển thị tất cả các thống kê tổng quan trên Dashboard
 */
const DashboardStats = ({ stats = {} }) => {
  // Định nghĩa các thẻ thống kê
  const statsItems = [
    {
      title: 'Tổng doanh thu',
      value: new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(
        stats?.totalRevenue || 0
      ),
      icon: CurrencyDollarIcon,
      color: 'text-green-700',
      bgColor: 'bg-green-100',
      change: stats?.revenueChange,
      linkTo: '/admin/orders',
    },
    {
      title: 'Đơn hàng',
      value: stats?.totalOrders || 0,
      icon: ShoppingCartIcon,
      color: 'text-blue-700',
      bgColor: 'bg-blue-100',
      change: stats?.ordersChange,
      linkTo: '/admin/orders',
    },
    {
      title: 'Sản phẩm',
      value: stats?.totalProducts || 0,
      icon: ShoppingBagIcon,
      color: 'text-purple-700',
      bgColor: 'bg-purple-100',
      change: stats?.productsChange,
      linkTo: '/admin/products',
    },
    {
      title: 'Khách hàng',
      value: stats?.totalCustomers || 0,
      icon: UserGroupIcon,
      color: 'text-orange-700',
      bgColor: 'bg-orange-100',
      change: stats?.customersChange,
      linkTo: '/admin/users',
    },
  ];

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-medium text-gray-900">Tổng quan</h3>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        {statsItems.map((item, index) => (
          <StatCard
            key={index}
            title={item.title}
            value={item.value}
            icon={item.icon}
            color={item.color}
            bgColor={item.bgColor}
            change={item.change}
            linkTo={item.linkTo}
          />
        ))}
      </div>
    </div>
  );
};

export default DashboardStats;


--- File: client/src/components/feature/Admin/Dashboard/RecentOrders.js ---
// src/components/feature/Admin/Dashboard/RecentOrders.js
// Vị trí: Component hiển thị danh sách đơn hàng gần đây trên Dashboard Admin

import React from 'react';
import { Link } from 'react-router-dom';
import { formatDate, formatPrice } from '../../../../utils/formatters';
import { Button, LoadingSpinner } from '../../../common';

/**
 * Component hiển thị trạng thái đơn hàng dưới dạng badge
 */
const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Chờ xác nhận', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'Đang xử lý', color: 'bg-blue-100 text-blue-800' },
    shipped: { text: 'Đang giao hàng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'Đã giao hàng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'Đã hủy', color: 'bg-red-100 text-red-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

/**
 * Component hiển thị danh sách đơn hàng gần đây
 */
const RecentOrders = ({ orders = [], isLoading = false, onViewAllClick }) => {
  // Xử lý sự kiện khi nhấp vào nút "Xem tất cả"
  const handleViewAllClick = (e) => {
    if (onViewAllClick) {
      e.preventDefault();
      onViewAllClick();
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden h-full flex flex-col">
      <div className="p-4 border-b flex justify-between items-center">
        <h2 className="text-lg font-semibold text-gray-900">Đơn hàng gần đây</h2>
      </div>

      {isLoading ? (
        <div className="flex-grow flex items-center justify-center p-8">
          <LoadingSpinner size="medium" />
        </div>
      ) : (
        <div className="overflow-x-auto flex-grow">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Mã đơn hàng
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Khách hàng
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Ngày đặt
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Tổng tiền
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Trạng thái
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {orders.length > 0 ? (
                orders.map((order) => (
                  <tr key={order._id || order.id} className="hover:bg-gray-50">
                    <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-blue-600">
                      <Link to={`/admin/orders/${order._id || order.id}`}>{order.orderNumber}</Link>
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                      {order.customerInfo.name}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500">
                      {formatDate(order.createdAt)}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                      {formatPrice(order.totalAmount)}
                    </td>
                    <td className="px-4 py-3 whitespace-nowrap">
                      <OrderStatusBadge status={order.status} />
                    </td>
                  </tr>
                ))
              ) : (
                <tr>
                  <td colSpan="5" className="px-4 py-8 text-center text-sm text-gray-500">
                    Không có đơn hàng nào gần đây
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )}

      <div className="p-4 border-t bg-gray-50">
        <Link to="/admin/orders" onClick={handleViewAllClick}>
          <Button variant="secondary" size="sm" fullWidth>
            Xem tất cả đơn hàng
          </Button>
        </Link>
      </div>
    </div>
  );
};

export default RecentOrders;


--- File: client/src/components/feature/Admin/Dashboard/SalesChart.js ---
// src/components/feature/Admin/Dashboard/SalesChart.js
// Vị trí: Component biểu đồ doanh số bán hàng trên Dashboard Admin, hiển thị doanh thu theo các khoảng thời gian khác nhau

import React, { useState, useEffect } from 'react';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from 'recharts';
import { LoadingSpinner, ErrorAlert } from '../../../common';

/**
 * Component hiển thị biểu đồ doanh số bán hàng
 * @param {Object} props - Props của component
 * @param {Array} props.data - Dữ liệu doanh số
 * @param {string} props.period - Khoảng thời gian hiện tại (today, week, month, year)
 * @param {boolean} props.isLoading - Trạng thái đang tải dữ liệu
 * @param {string} props.error - Thông báo lỗi (nếu có)
 * @param {Function} props.onPeriodChange - Hàm xử lý khi thay đổi khoảng thời gian
 */
const SalesChart = ({
  data = [],
  period = 'month',
  isLoading = false,
  error = null,
  onPeriodChange = () => {},
}) => {
  // Định dạng số tiền cho trục Y
  const formatYAxis = (value) => {
    if (value >= 1000000000) {
      return `${(value / 1000000000).toFixed(1)}B`;
    }
    if (value >= 1000000) {
      return `${(value / 1000000).toFixed(1)}M`;
    }
    if (value >= 1000) {
      return `${(value / 1000).toFixed(0)}K`;
    }
    return value;
  };

  // Định dạng số tiền cho tooltip
  const formatTooltipValue = (value) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      maximumFractionDigits: 0,
    }).format(value);
  };

  // Lấy tổng doanh thu từ dữ liệu
  const totalRevenue = data.reduce((sum, item) => sum + (item.revenue || 0), 0);

  // Định dạng tổng doanh thu
  const formattedTotalRevenue = new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    maximumFractionDigits: 0,
  }).format(totalRevenue);

  // Các tùy chọn khoảng thời gian
  const periodOptions = [
    { value: 'today', label: 'Hôm nay' },
    { value: 'week', label: 'Tuần' },
    { value: 'month', label: 'Tháng' },
    { value: 'year', label: 'Năm' },
  ];

  // Xử lý thay đổi khoảng thời gian
  const handlePeriodChange = (newPeriod) => {
    if (period !== newPeriod) {
      onPeriodChange(newPeriod);
    }
  };

  // Hiển thị trạng thái loading
  if (isLoading) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6 h-80 flex items-center justify-center">
        <LoadingSpinner size="large" />
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden h-full flex flex-col">
      <div className="p-4 border-b flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h2 className="text-lg font-semibold text-gray-900">Doanh thu</h2>
          <p className="text-sm text-gray-500 mt-1">
            Tổng doanh thu: <span className="font-medium">{formattedTotalRevenue}</span>
          </p>
        </div>

        <div className="flex flex-wrap gap-2">
          {periodOptions.map((option) => (
            <button
              key={option.value}
              className={`px-3 py-1 text-sm rounded-md transition-colors ${
                period === option.value
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
              }`}
              onClick={() => handlePeriodChange(option.value)}
            >
              {option.label}
            </button>
          ))}
        </div>
      </div>

      {error ? (
        <div className="p-4 flex-grow">
          <ErrorAlert message={error} />
        </div>
      ) : data.length === 0 ? (
        <div className="p-4 flex-grow flex items-center justify-center">
          <p className="text-gray-500">Không có dữ liệu doanh thu cho khoảng thời gian này</p>
        </div>
      ) : (
        <div className="p-4 h-80 flex-grow">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
              <defs>
                <linearGradient id="colorRevenue" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="#3B82F6" stopOpacity={0} />
                </linearGradient>
                <linearGradient id="colorProfit" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#10B981" stopOpacity={0.8} />
                  <stop offset="95%" stopColor="#10B981" stopOpacity={0} />
                </linearGradient>
              </defs>

              <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f0f0f0" />

              <XAxis
                dataKey="name"
                tickMargin={10}
                axisLine={false}
                tickLine={false}
                tick={{ fill: '#6B7280', fontSize: 12 }}
              />

              <YAxis
                tickFormatter={formatYAxis}
                axisLine={false}
                tickLine={false}
                tickMargin={10}
                tick={{ fill: '#6B7280', fontSize: 12 }}
              />

              <Tooltip
                formatter={(value, name) => {
                  const labels = {
                    revenue: 'Doanh thu',
                    profit: 'Lợi nhuận',
                  };
                  return [formatTooltipValue(value), labels[name] || name];
                }}
                labelFormatter={(label) => `Thời gian: ${label}`}
                contentStyle={{
                  backgroundColor: 'rgba(255, 255, 255, 0.9)',
                  border: '1px solid #e2e8f0',
                  borderRadius: '0.375rem',
                  boxShadow: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
                }}
              />

              <Legend
                verticalAlign="top"
                height={36}
                formatter={(value) => {
                  const labels = {
                    revenue: 'Doanh thu',
                    profit: 'Lợi nhuận',
                  };
                  return labels[value] || value;
                }}
              />

              <Area
                type="monotone"
                dataKey="revenue"
                stroke="#3B82F6"
                strokeWidth={2}
                fillOpacity={1}
                fill="url(#colorRevenue)"
                activeDot={{ r: 6 }}
              />

              {data.some((item) => 'profit' in item) && (
                <Area
                  type="monotone"
                  dataKey="profit"
                  stroke="#10B981"
                  strokeWidth={2}
                  fillOpacity={1}
                  fill="url(#colorProfit)"
                  activeDot={{ r: 6 }}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        </div>
      )}
    </div>
  );
};

export default SalesChart;


--- File: client/src/components/feature/Admin/OrderManager/OrderDetail.js ---
// src/components/feature/Admin/OrderManager/OrderDetail.js
import React from 'react';
import { formatDate, formatPrice } from '../../../../utils/formatters';
import { Button } from '../../../common/Button/Button';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Chờ xác nhận', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'Đang xử lý', color: 'bg-blue-100 text-blue-800' },
    packed: { text: 'Đóng gói', color: 'bg-indigo-100 text-indigo-800' },
    shipped: { text: 'Đang giao hàng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'Đã giao hàng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'Đã hủy', color: 'bg-red-100 text-red-800' },
    returned: { text: 'Đã trả hàng', color: 'bg-gray-100 text-gray-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const OrderStatusFlow = ({ currentStatus, onChangeStatus }) => {
  const statuses = [
    { key: 'pending', label: 'Chờ xác nhận' },
    { key: 'processing', label: 'Đang xử lý' },
    { key: 'packed', label: 'Đã đóng gói' },
    { key: 'shipped', label: 'Đang giao hàng' },
    { key: 'delivered', label: 'Đã giao hàng' },
  ];

  // Tìm vị trí status hiện tại
  const currentIndex = statuses.findIndex((s) => s.key === currentStatus);

  return (
    <div className="my-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-medium text-gray-900">Trạng thái đơn hàng</h3>

        {/* Nút cập nhật trạng thái */}
        {currentStatus !== 'cancelled' &&
          currentStatus !== 'delivered' &&
          currentStatus !== 'returned' && (
            <div className="flex space-x-2">
              <select
                className="block w-40 pl-3 pr-10 py-1.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                defaultValue=""
              >
                <option value="" disabled>
                  Cập nhật trạng thái
                </option>
                {statuses.map((status, index) => {
                  // Chỉ cho phép đổi sang trạng thái tiếp theo
                  if (index === currentIndex + 1) {
                    return (
                      <option key={status.key} value={status.key}>
                        {status.label}
                      </option>
                    );
                  }
                  return null;
                })}
                <option value="cancelled">Hủy đơn hàng</option>
              </select>

              <Button size="sm">Cập nhật</Button>
            </div>
          )}
      </div>

      <div className="relative">
        {/* Progress line */}
        <div className="absolute top-4 left-4 right-4 h-0.5 bg-gray-200">
          <div
            className={`h-0.5 bg-blue-500 ${
              currentStatus === 'cancelled' || currentStatus === 'returned'
                ? 'w-0' // Không có progress nếu đơn hàng bị hủy hoặc trả lại
                : `w-${(currentIndex * 100) / (statuses.length - 1)}%`
            }`}
          ></div>
        </div>

        <div className="flex justify-between relative">
          {statuses.map((status, index) => {
            const isCompleted =
              index <= currentIndex &&
              currentStatus !== 'cancelled' &&
              currentStatus !== 'returned';
            const isCurrent = status.key === currentStatus;

            return (
              <div key={status.key} className="flex flex-col items-center z-10">
                <div
                  className={`w-8 h-8 rounded-full flex items-center justify-center ${
                    isCompleted
                      ? 'bg-blue-500 text-white'
                      : currentStatus === 'cancelled' && index === 0
                        ? 'bg-red-500 text-white'
                        : currentStatus === 'returned' && index === statuses.length - 1
                          ? 'bg-gray-500 text-white'
                          : 'bg-gray-200'
                  } ${isCurrent ? 'ring-2 ring-blue-300' : ''}`}
                >
                  {isCompleted ? '✓' : index + 1}
                </div>
                <p className={`text-xs mt-2 ${isCompleted ? 'font-medium' : 'text-gray-500'}`}>
                  {status.label}
                </p>
              </div>
            );
          })}
        </div>
      </div>

      {/* Trạng thái đặc biệt */}
      {(currentStatus === 'cancelled' || currentStatus === 'returned') && (
        <div
          className={`mt-6 p-4 rounded-md ${
            currentStatus === 'cancelled' ? 'bg-red-50 text-red-800' : 'bg-gray-50 text-gray-800'
          }`}
        >
          <div className="flex">
            <div className="flex-shrink-0">{currentStatus === 'cancelled' ? '⚠️' : '↩️'}</div>
            <div className="ml-3">
              <h3 className="text-sm font-medium">
                {currentStatus === 'cancelled' ? 'Đơn hàng đã bị hủy' : 'Đơn hàng đã được trả lại'}
              </h3>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const OrderDetail = ({ order, onChangeStatus }) => {
  return (
    <div className="bg-white shadow-sm rounded-lg divide-y divide-gray-200">
      {/* Header */}
      <div className="px-6 py-4">
        <div className="flex justify-between items-start">
          <div>
            <h2 className="text-lg font-medium text-gray-900">Đơn hàng #{order.orderNumber}</h2>
            <p className="text-sm text-gray-500 mt-1">Ngày đặt: {formatDate(order.createdAt)}</p>
          </div>
          <OrderStatusBadge status={order.status} />
        </div>
      </div>

      {/* Order Status Flow */}
      <div className="px-6 py-4">
        <OrderStatusFlow currentStatus={order.status} onChangeStatus={onChangeStatus} />
      </div>

      {/* Customer & Shipping Info */}
      <div className="px-6 py-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-3">Thông tin khách hàng</h3>
            <p className="text-sm text-gray-700">{order.customerInfo.name}</p>
            <p className="text-sm text-gray-700">{order.customerInfo.email}</p>
            <p className="text-sm text-gray-700">{order.customerInfo.phone}</p>
          </div>

          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-3">Thông tin giao hàng</h3>
            <p className="text-sm text-gray-700">{order.shippingAddress.name}</p>
            <p className="text-sm text-gray-700">{order.shippingAddress.phone}</p>
            <p className="text-sm text-gray-700">{order.shippingAddress.street}</p>
            <p className="text-sm text-gray-700">
              {order.shippingAddress.city}, {order.shippingAddress.zipCode}
            </p>
            {order.shippingAddress.notes && (
              <p className="text-sm text-gray-700 mt-2">
                <span className="font-medium">Ghi chú:</span> {order.shippingAddress.notes}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* Payment Info */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Thông tin thanh toán</h3>
        <div className="flex items-center">
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              order.paymentStatus === 'paid'
                ? 'bg-green-100 text-green-800'
                : 'bg-yellow-100 text-yellow-800'
            }`}
          >
            {order.paymentStatus === 'paid' ? 'Đã thanh toán' : 'Chưa thanh toán'}
          </span>

          <span className="ml-4 text-sm text-gray-700">
            Phương thức:{' '}
            {order.paymentMethod === 'cod'
              ? 'Thanh toán khi nhận hàng (COD)'
              : 'Thanh toán qua VNPay'}
          </span>
        </div>

        {order.paymentDetails && order.paymentDetails.transactionId && (
          <p className="text-sm text-gray-700 mt-2">
            Mã giao dịch: {order.paymentDetails.transactionId}
          </p>
        )}
      </div>

      {/* Order Items */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Chi tiết đơn hàng</h3>

        <div className="mt-4 border rounded-lg overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Sản phẩm
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Đơn giá
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Số lượng
                </th>
                <th
                  scope="col"
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Thành tiền
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {order.items.map((item) => (
                <tr key={item._id || item.product}>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center">
                      {item.image && (
                        <div className="flex-shrink-0 h-10 w-10 mr-3">
                          <img
                            className="h-10 w-10 rounded-md object-cover"
                            src={item.image}
                            alt={item.name}
                          />
                        </div>
                      )}
                      <div>
                        <div className="text-sm font-medium text-gray-900">{item.name}</div>
                        {item.sku && <div className="text-sm text-gray-500">SKU: {item.sku}</div>}
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {formatPrice(item.price)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {item.quantity}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {formatPrice(item.price * item.quantity)}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Order Summary */}
      <div className="px-6 py-4">
        <div className="flex flex-col space-y-2 sm:w-64 sm:ml-auto">
          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Tạm tính:</span>
            <span className="font-medium">{formatPrice(order.subtotal)}</span>
          </div>

          {order.discount && order.discount.amount > 0 && (
            <div className="flex justify-between text-sm text-green-600">
              <span>Giảm giá:</span>
              <span>-{formatPrice(order.discount.amount)}</span>
            </div>
          )}

          <div className="flex justify-between text-sm">
            <span className="text-gray-600">Phí vận chuyển:</span>
            <span>{formatPrice(order.shippingCost)}</span>
          </div>

          {order.tax > 0 && (
            <div className="flex justify-between text-sm">
              <span className="text-gray-600">Thuế:</span>
              <span>{formatPrice(order.tax)}</span>
            </div>
          )}

          <div className="flex justify-between text-base font-medium pt-2 border-t mt-2">
            <span>Tổng cộng:</span>
            <span>{formatPrice(order.totalAmount)}</span>
          </div>
        </div>
      </div>

      {/* Order History */}
      {order.statusHistory && order.statusHistory.length > 0 && (
        <div className="px-6 py-4">
          <h3 className="text-lg font-medium text-gray-900 mb-3">Lịch sử đơn hàng</h3>

          <div className="flow-root">
            <ul className="-mb-8">
              {order.statusHistory.map((history, index) => (
                <li key={index}>
                  <div className="relative pb-8">
                    {index !== order.statusHistory.length - 1 ? (
                      <span
                        className="absolute top-4 left-4 -ml-px h-full w-0.5 bg-gray-200"
                        aria-hidden="true"
                      ></span>
                    ) : null}
                    <div className="relative flex space-x-3">
                      <div>
                        <span className="h-8 w-8 rounded-full bg-blue-500 flex items-center justify-center ring-8 ring-white">
                          <svg
                            className="h-4 w-4 text-white"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                            />
                          </svg>
                        </span>
                      </div>
                      <div className="min-w-0 flex-1 pt-1.5 flex justify-between space-x-4">
                        <div>
                          <p className="text-sm text-gray-900">
                            <OrderStatusBadge status={history.status} />
                            {history.note && <span className="ml-2">{history.note}</span>}
                          </p>
                        </div>
                        <div className="text-sm text-gray-500 whitespace-nowrap">
                          {formatDate(history.date)}
                        </div>
                      </div>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          </div>
        </div>
      )}

      {/* Admin Notes */}
      <div className="px-6 py-4">
        <h3 className="text-lg font-medium text-gray-900 mb-3">Ghi chú quản trị</h3>

        <div className="mt-1">
          <textarea
            rows={3}
            className="shadow-sm block w-full sm:text-sm border-gray-300 rounded-md"
            placeholder="Thêm ghi chú về đơn hàng này..."
            defaultValue={order.adminNotes || ''}
          />
        </div>

        <div className="mt-2 flex justify-end">
          <Button size="sm">Lưu ghi chú</Button>
        </div>
      </div>
    </div>
  );
};

export default OrderDetail;


--- File: client/src/components/feature/Admin/OrderManager/OrderTable.js ---
// src/components/feature/Admin/OrderManager/OrderTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatDate, formatPrice } from '../../../../utils/formatters';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Chờ xác nhận', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'Đang xử lý', color: 'bg-blue-100 text-blue-800' },
    packed: { text: 'Đóng gói', color: 'bg-indigo-100 text-indigo-800' },
    shipped: { text: 'Đang giao hàng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'Đã giao hàng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'Đã hủy', color: 'bg-red-100 text-red-800' },
    returned: { text: 'Đã trả hàng', color: 'bg-gray-100 text-gray-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const PaymentStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Chờ thanh toán', color: 'bg-yellow-100 text-yellow-800' },
    authorized: { text: 'Đã ủy quyền', color: 'bg-blue-100 text-blue-800' },
    paid: { text: 'Đã thanh toán', color: 'bg-green-100 text-green-800' },
    failed: { text: 'Thất bại', color: 'bg-red-100 text-red-800' },
    refunded: { text: 'Đã hoàn tiền', color: 'bg-gray-100 text-gray-800' },
    partially_refunded: { text: 'Hoàn tiền một phần', color: 'bg-orange-100 text-orange-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.color}`}
    >
      {config.text}
    </span>
  );
};

const OrderTable = ({ orders, onChangeStatus }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const ordersPerPage = 10;

  // Phân trang
  const indexOfLastOrder = currentPage * ordersPerPage;
  const indexOfFirstOrder = indexOfLastOrder - ordersPerPage;
  const currentOrders = orders.slice(indexOfFirstOrder, indexOfLastOrder);
  const totalPages = Math.ceil(orders.length / ordersPerPage);

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Mã đơn hàng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Khách hàng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Ngày đặt
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Tổng tiền
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Trạng thái đơn hàng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Thanh toán
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">Chi tiết</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentOrders.map((order) => (
                    <tr key={order._id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {order.orderNumber}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <div>{order.customerInfo.name}</div>
                        <div className="text-xs">{order.customerInfo.email}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatDate(order.createdAt)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatPrice(order.totalAmount)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <OrderStatusBadge status={order.status} />
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <PaymentStatusBadge status={order.paymentStatus} />
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/orders/${order._id}`}
                          className="text-blue-600 hover:text-blue-900"
                        >
                          Chi tiết
                        </Link>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hiển thị <span className="font-medium">{indexOfFirstOrder + 1}</span> đến{' '}
              <span className="font-medium">{Math.min(indexOfLastOrder, orders.length)}</span> của{' '}
              <span className="font-medium">{orders.length}</span> đơn hàng
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default OrderTable;


--- File: client/src/components/feature/Admin/ProductManager/ProductForm.js ---
// src/components/feature/Admin/ProductManager/ProductForm.js
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Button } from '../../../common/Button/Button';
import { Input } from '../../../common/Input/Input';

const schema = yup.object({
  name: yup.string().required('Tên sản phẩm không được để trống'),
  description: yup.object({
    short: yup.string().required('Mô tả ngắn không được để trống'),
    long: yup.string().required('Mô tả chi tiết không được để trống'),
  }),
  category: yup.string().required('Danh mục không được để trống'),
  brand: yup.string().required('Thương hiệu không được để trống'),
  price: yup.number().required('Giá không được để trống').min(0, 'Giá không được âm'),
  stock: yup.number().required('Số lượng không được để trống').min(0, 'Số lượng không được âm'),
  sku: yup.string(),
  features: yup.array().of(yup.string()),
  specifications: yup.object(),
});

const ProductForm = ({ product, categories, onSubmit, isSubmitting }) => {
  const [features, setFeatures] = useState(product?.features || ['']);
  const [imageUrls, setImageUrls] = useState(product?.images?.map((img) => img.url) || ['']);
  const [specificationFields, setSpecificationFields] = useState(
    product?.specifications
      ? Object.entries(product.specifications).map(([key, value]) => ({ key, value }))
      : [{ key: '', value: '' }]
  );

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      name: product?.name || '',
      description: {
        short: product?.description?.short || '',
        long: product?.description?.long || '',
      },
      category: product?.category || '',
      brand: product?.brand || '',
      price: product?.price || 0,
      salePrice: product?.salePrice || 0,
      stock: product?.stock || 0,
      sku: product?.sku || '',
      isActive: product?.isActive ?? true,
      isPromoted: product?.isPromoted ?? false,
      isFeatured: product?.isFeatured ?? false,
      features: product?.features || [''],
      specifications: product?.specifications || {},
    },
  });

  // Cập nhật features và specifications vào form data
  useEffect(() => {
    setValue('features', features.filter(Boolean));

    const specsObject = {};
    specificationFields.forEach((field) => {
      if (field.key && field.value) {
        specsObject[field.key] = field.value;
      }
    });
    setValue('specifications', specsObject);
  }, [features, specificationFields, setValue]);

  // Xử lý thêm/xóa feature
  const handleAddFeature = () => {
    setFeatures([...features, '']);
  };

  const handleRemoveFeature = (index) => {
    const newFeatures = [...features];
    newFeatures.splice(index, 1);
    setFeatures(newFeatures);
  };

  const handleFeatureChange = (index, value) => {
    const newFeatures = [...features];
    newFeatures[index] = value;
    setFeatures(newFeatures);
  };

  // Xử lý thêm/xóa specification
  const handleAddSpecification = () => {
    setSpecificationFields([...specificationFields, { key: '', value: '' }]);
  };

  const handleRemoveSpecification = (index) => {
    const newFields = [...specificationFields];
    newFields.splice(index, 1);
    setSpecificationFields(newFields);
  };

  const handleSpecificationChange = (index, field, value) => {
    const newFields = [...specificationFields];
    newFields[index][field] = value;
    setSpecificationFields(newFields);
  };

  // Xử lý thêm/xóa hình ảnh
  const handleAddImage = () => {
    setImageUrls([...imageUrls, '']);
  };

  const handleRemoveImage = (index) => {
    const newUrls = [...imageUrls];
    newUrls.splice(index, 1);
    setImageUrls(newUrls);
  };

  const handleImageChange = (index, value) => {
    const newUrls = [...imageUrls];
    newUrls[index] = value;
    setImageUrls(newUrls);
  };

  // Xử lý submit form
  const onFormSubmit = (data) => {
    // Thêm hình ảnh vào data
    const images = imageUrls.filter(Boolean).map((url, index) => ({
      url,
      alt: `${data.name} - Hình ${index + 1}`,
      isPrimary: index === 0,
    }));

    // Submit with images
    onSubmit({ ...data, images });
  };

  return (
    <form onSubmit={handleSubmit(onFormSubmit)} className="space-y-8">
      {/* Thông tin cơ bản */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Thông tin cơ bản</h3>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="md:col-span-2">
            <Input
              label="Tên sản phẩm"
              {...register('name')}
              error={errors.name?.message}
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Danh mục <span className="text-red-500">*</span>
            </label>
            <select
              {...register('category')}
              className={`mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md ${
                errors.category ? 'border-red-300' : ''
              }`}
            >
              <option value="">Chọn danh mục</option>
              {categories.map((category) => (
                <option key={category._id} value={category._id}>
                  {category.name}
                </option>
              ))}
            </select>
            {errors.category && (
              <p className="mt-1 text-sm text-red-600">{errors.category.message}</p>
            )}
          </div>

          <div>
            <Input
              label="Thương hiệu"
              {...register('brand')}
              error={errors.brand?.message}
              required
            />
          </div>

          <div>
            <Input
              label="Giá (VND)"
              type="number"
              {...register('price')}
              error={errors.price?.message}
              required
            />
          </div>

          <div>
            <Input
              label="Giá khuyến mãi (VND)"
              type="number"
              {...register('salePrice')}
              error={errors.salePrice?.message}
            />
          </div>

          <div>
            <Input
              label="Số lượng tồn kho"
              type="number"
              {...register('stock')}
              error={errors.stock?.message}
              required
            />
          </div>

          <div>
            <Input label="SKU" {...register('sku')} error={errors.sku?.message} />
          </div>

          <div className="md:col-span-2">
            <Input
              label="Mô tả ngắn"
              {...register('description.short')}
              error={errors.description?.short?.message}
              required
              multiline
              rows={2}
            />
          </div>

          <div className="md:col-span-2">
            <Input
              label="Mô tả chi tiết"
              {...register('description.long')}
              error={errors.description?.long?.message}
              required
              multiline
              rows={6}
            />
          </div>
        </div>

        <div className="mt-6 space-y-4">
          <div className="flex items-center">
            <input
              type="checkbox"
              id="isActive"
              {...register('isActive')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isActive" className="ml-2 block text-sm text-gray-900">
              Sản phẩm đang bán
            </label>
          </div>

          <div className="flex items-center">
            <input
              type="checkbox"
              id="isPromoted"
              {...register('isPromoted')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isPromoted" className="ml-2 block text-sm text-gray-900">
              Sản phẩm được quảng bá
            </label>
          </div>

          <div className="flex items-center">
            <input
              type="checkbox"
              id="isFeatured"
              {...register('isFeatured')}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="isFeatured" className="ml-2 block text-sm text-gray-900">
              Sản phẩm nổi bật
            </label>
          </div>
        </div>
      </div>

      {/* Tính năng sản phẩm */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Tính năng sản phẩm</h3>

        <div className="space-y-4">
          {features.map((feature, index) => (
            <div key={index} className="flex items-center space-x-2">
              <Input
                placeholder={`Tính năng ${index + 1}`}
                value={feature}
                onChange={(e) => handleFeatureChange(index, e.target.value)}
                className="flex-1"
              />

              <button
                type="button"
                onClick={() => handleRemoveFeature(index)}
                className="text-red-500 hover:text-red-700"
              >
                Xóa
              </button>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddFeature}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Thêm tính năng
          </button>
        </div>
      </div>

      {/* Thông số kỹ thuật */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Thông số kỹ thuật</h3>

        <div className="space-y-4">
          {specificationFields.map((field, index) => (
            <div key={index} className="grid grid-cols-2 gap-4">
              <Input
                placeholder="Tên thông số"
                value={field.key}
                onChange={(e) => handleSpecificationChange(index, 'key', e.target.value)}
              />

              <div className="flex items-center space-x-2">
                <Input
                  placeholder="Giá trị"
                  value={field.value}
                  onChange={(e) => handleSpecificationChange(index, 'value', e.target.value)}
                  className="flex-1"
                />

                <button
                  type="button"
                  onClick={() => handleRemoveSpecification(index)}
                  className="text-red-500 hover:text-red-700"
                >
                  Xóa
                </button>
              </div>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddSpecification}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Thêm thông số
          </button>
        </div>
      </div>

      {/* Hình ảnh sản phẩm */}
      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Hình ảnh sản phẩm</h3>

        <div className="space-y-4">
          {imageUrls.map((url, index) => (
            <div key={index} className="flex items-center space-x-2">
              <Input
                placeholder="URL hình ảnh"
                value={url}
                onChange={(e) => handleImageChange(index, e.target.value)}
                className="flex-1"
              />

              <button
                type="button"
                onClick={() => handleRemoveImage(index)}
                className="text-red-500 hover:text-red-700"
              >
                Xóa
              </button>
            </div>
          ))}

          <button
            type="button"
            onClick={handleAddImage}
            className="text-blue-600 hover:text-blue-800 text-sm font-medium"
          >
            + Thêm hình ảnh
          </button>
        </div>
      </div>

      {/* Submit button */}
      <div className="flex justify-end space-x-3">
        <Button type="button" variant="outline" onClick={() => window.history.back()}>
          Hủy
        </Button>
        <Button type="submit" isLoading={isSubmitting}>
          {product ? 'Cập nhật sản phẩm' : 'Thêm sản phẩm'}
        </Button>
      </div>
    </form>
  );
};

export default ProductForm;


--- File: client/src/components/feature/Admin/ProductManager/ProductTable.js ---
// src/components/feature/Admin/ProductManager/ProductTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatPrice } from '../../../../utils/formatters';

const ProductTable = ({ products, onDelete }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const productsPerPage = 10;

  // Phân trang
  const indexOfLastProduct = currentPage * productsPerPage;
  const indexOfFirstProduct = indexOfLastProduct - productsPerPage;
  const currentProducts = products.slice(indexOfFirstProduct, indexOfLastProduct);
  const totalPages = Math.ceil(products.length / productsPerPage);

  // Xử lý xóa sản phẩm
  const handleDelete = (productId) => {
    if (window.confirm('Bạn có chắc chắn muốn xóa sản phẩm này?')) {
      onDelete(productId);
    }
  };

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Sản phẩm
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Danh mục
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Giá
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Tồn kho
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Trạng thái
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">Hành động</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentProducts.map((product) => (
                    <tr key={product._id}>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <div className="flex-shrink-0 h-10 w-10">
                            <img
                              className="h-10 w-10 rounded-md object-cover"
                              src={product.images[0] || '/placeholder.jpg'}
                              alt={product.name}
                            />
                          </div>
                          <div className="ml-4">
                            <div className="text-sm font-medium text-gray-900">{product.name}</div>
                            <div className="text-sm text-gray-500">SKU: {product.sku || 'N/A'}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{product.category.name}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{formatPrice(product.price)}</div>
                        {product.salePrice && (
                          <div className="text-xs text-gray-500 line-through">
                            {formatPrice(product.salePrice)}
                          </div>
                        )}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{product.stock}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            product.isActive
                              ? 'bg-green-100 text-green-800'
                              : 'bg-red-100 text-red-800'
                          }`}
                        >
                          {product.isActive ? 'Đang bán' : 'Ngừng bán'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/products/edit/${product._id}`}
                          className="text-blue-600 hover:text-blue-900 mr-4"
                        >
                          Sửa
                        </Link>
                        <button
                          onClick={() => handleDelete(product._id)}
                          className="text-red-600 hover:text-red-900"
                        >
                          Xóa
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hiển thị <span className="font-medium">{indexOfFirstProduct + 1}</span> đến{' '}
              <span className="font-medium">{Math.min(indexOfLastProduct, products.length)}</span>{' '}
              của <span className="font-medium">{products.length}</span> sản phẩm
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default ProductTable;


--- File: client/src/components/feature/Admin/UserManager/UserTable.js ---
// src/components/feature/Admin/UserManager/UserTable.js
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { formatDate } from '../../../../utils/formatters';

const UserTable = ({ users, onChangeStatus }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const usersPerPage = 10;

  // Phân trang
  const indexOfLastUser = currentPage * usersPerPage;
  const indexOfFirstUser = indexOfLastUser - usersPerPage;
  const currentUsers = users.slice(indexOfFirstUser, indexOfLastUser);
  const totalPages = Math.ceil(users.length / usersPerPage);

  return (
    <div className="mt-4">
      <div className="flex flex-col">
        <div className="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div className="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div className="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Người dùng
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Vai trò
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Trạng thái
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Ngày đăng ký
                    </th>
                    <th
                      scope="col"
                      className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                    >
                      Đơn hàng
                    </th>
                    <th scope="col" className="relative px-6 py-3">
                      <span className="sr-only">Hành động</span>
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentUsers.map((user) => (
                    <tr key={user._id}>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <div className="flex-shrink-0 h-10 w-10">
                            {user.avatar ? (
                              <img
                                className="h-10 w-10 rounded-full"
                                src={user.avatar}
                                alt={user.name}
                              />
                            ) : (
                              <div className="h-10 w-10 rounded-full bg-blue-500 flex items-center justify-center text-white font-semibold">
                                {user.name.charAt(0).toUpperCase()}
                              </div>
                            )}
                          </div>
                          <div className="ml-4">
                            <div className="text-sm font-medium text-gray-900">{user.name}</div>
                            <div className="text-sm text-gray-500">{user.email}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            user.role === 'admin'
                              ? 'bg-purple-100 text-purple-800'
                              : user.role === 'staff'
                                ? 'bg-blue-100 text-blue-800'
                                : 'bg-green-100 text-green-800'
                          }`}
                        >
                          {user.role === 'admin'
                            ? 'Admin'
                            : user.role === 'staff'
                              ? 'Nhân viên'
                              : 'Người dùng'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                            user.isActive
                              ? 'bg-green-100 text-green-800'
                              : 'bg-red-100 text-red-800'
                          }`}
                        >
                          {user.isActive ? 'Hoạt động' : 'Đã khóa'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatDate(user.createdAt)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {user.orderCount || 0}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <Link
                          to={`/admin/users/${user._id}`}
                          className="text-blue-600 hover:text-blue-900 mr-4"
                        >
                          Chi tiết
                        </Link>
                        <button
                          onClick={() => onChangeStatus(user._id, !user.isActive)}
                          className={`${
                            user.isActive
                              ? 'text-red-600 hover:text-red-900'
                              : 'text-green-600 hover:text-green-900'
                          }`}
                        >
                          {user.isActive ? 'Khóa' : 'Kích hoạt'}
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 mt-4 rounded-lg">
          <div>
            <p className="text-sm text-gray-700">
              Hiển thị <span className="font-medium">{indexOfFirstUser + 1}</span> đến{' '}
              <span className="font-medium">{Math.min(indexOfLastUser, users.length)}</span> của{' '}
              <span className="font-medium">{users.length}</span> người dùng
            </p>
          </div>
          <div>
            <nav
              className="isolate inline-flex -space-x-px rounded-md shadow-sm"
              aria-label="Pagination"
            >
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className={`relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &laquo;
              </button>

              {[...Array(totalPages).keys()].map((number) => (
                <button
                  key={number + 1}
                  onClick={() => setCurrentPage(number + 1)}
                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                    currentPage === number + 1
                      ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                      : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                  }`}
                >
                  {number + 1}
                </button>
              ))}

              <button
                onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={`relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 ${
                  currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''
                }`}
              >
                &raquo;
              </button>
            </nav>
          </div>
        </div>
      )}
    </div>
  );
};

export default UserTable;


--- File: client/src/components/feature/Cart/AddToCart.js ---
// src/components/feature/Cart/AddToCart.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { addToCart } from '../../../store/slices/cartSlice';
import { Button } from '../../common/Button/Button';

const AddToCart = ({ product }) => {
  const dispatch = useDispatch();
  const [quantity, setQuantity] = useState(1);
  const { loading } = useSelector((state) => state.cart);

  const handleQuantityChange = (newQuantity) => {
    if (newQuantity < 1 || newQuantity > product.stock) return;
    setQuantity(newQuantity);
  };

  const handleAddToCart = () => {
    dispatch(
      addToCart({
        productId: product._id,
        quantity,
      })
    );
  };

  if (product.stock < 1) {
    return (
      <div className="mt-6">
        <p className="text-red-500 mb-2">Hết hàng</p>
        <Button variant="outline" disabled className="w-full">
          Hết hàng
        </Button>
      </div>
    );
  }

  return (
    <div className="mt-6">
      <div className="flex items-center mb-4">
        <span className="mr-3">Số lượng:</span>
        <div className="flex items-center border rounded">
          <button
            className="px-3 py-1 text-gray-500"
            onClick={() => handleQuantityChange(quantity - 1)}
            disabled={quantity <= 1}
          >
            -
          </button>
          <span className="px-4 py-1">{quantity}</span>
          <button
            className="px-3 py-1 text-gray-500"
            onClick={() => handleQuantityChange(quantity + 1)}
            disabled={quantity >= product.stock}
          >
            +
          </button>
        </div>
        <span className="ml-3 text-sm text-gray-500">{product.stock} sản phẩm có sẵn</span>
      </div>

      <Button onClick={handleAddToCart} isLoading={loading} className="w-full">
        Thêm vào giỏ hàng
      </Button>
    </div>
  );
};

export default AddToCart;


--- File: client/src/components/feature/Cart/CartItem.js ---
// src/components/feature/Cart/CartItem.js
import React from 'react';
import { useDispatch } from 'react-redux';
import { updateCartItem, removeFromCart } from '../../../store/slices/cartSlice';
import { Button } from '../../common/Button/Button';
import { formatPrice } from '../../../utils/formatters';

const CartItem = ({ item }) => {
  const dispatch = useDispatch();

  const handleQuantityChange = (newQuantity) => {
    if (newQuantity < 1) return;
    dispatch(
      updateCartItem({
        productId: item.product._id,
        quantity: newQuantity,
      })
    );
  };

  const handleRemove = () => {
    dispatch(removeFromCart(item.product._id));
  };

  return (
    <div className="flex items-center justify-between p-4 border-b">
      <div className="flex items-center space-x-4">
        <img
          src={item.product.images[0] || '/assets/placeholder.jpg'}
          alt={item.product.name}
          className="w-16 h-16 object-cover"
        />

        <div>
          <h3 className="font-medium">{item.product.name}</h3>
          <p className="text-gray-500 text-sm">{formatPrice(item.price)}</p>
        </div>
      </div>

      <div className="flex items-center space-x-4">
        <div className="flex items-center border rounded">
          <button
            className="px-2 py-1 text-gray-500"
            onClick={() => handleQuantityChange(item.quantity - 1)}
          >
            -
          </button>
          <span className="px-3 py-1">{item.quantity}</span>
          <button
            className="px-2 py-1 text-gray-500"
            onClick={() => handleQuantityChange(item.quantity + 1)}
          >
            +
          </button>
        </div>

        <div className="text-right">
          <p className="font-bold">{formatPrice(item.price * item.quantity)}</p>
        </div>

        <Button onClick={handleRemove} variant="outline" size="sm">
          Xóa
        </Button>
      </div>
    </div>
  );
};

export default CartItem;


--- File: client/src/components/feature/Cart/CartList.js ---
// src/components/feature/Cart/CartList.js
import React from 'react';
import { useSelector } from 'react-redux';
import CartItem from './CartItem';
import { Empty } from '../../common/Empty';

const CartList = () => {
  const { items } = useSelector((state) => state.cart);

  if (!items.length) {
    return <Empty message="Giỏ hàng của bạn đang trống" />;
  }

  return (
    <div className="rounded-lg border bg-white">
      <div className="p-4 border-b bg-gray-50">
        <h2 className="font-semibold">Giỏ hàng của bạn</h2>
      </div>
      <div>
        {items.map((item) => (
          <CartItem key={item.product._id} item={item} />
        ))}
      </div>
    </div>
  );
};

export default CartList;


--- File: client/src/components/feature/Cart/CartSummary.js ---
// src/components/feature/Cart/CartSummary.js
import React from 'react';
import { useSelector } from 'react-redux';
import { Link } from 'react-router-dom';
import { Button } from '../../common/Button/Button';
import { formatPrice } from '../../../utils/formatters';

const CartSummary = () => {
  const { items, subtotal, discount } = useSelector((state) => state.cart);
  const totalItems = items.reduce((acc, item) => acc + item.quantity, 0);
  const total = subtotal - (discount || 0);

  return (
    <div className="rounded-lg border bg-white p-4">
      <h2 className="font-semibold mb-4">Tổng đơn hàng</h2>

      <div className="space-y-2 border-b pb-3 mb-3">
        <div className="flex justify-between">
          <span className="text-gray-600">Số lượng sản phẩm:</span>
          <span>{totalItems}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">Tạm tính:</span>
          <span>{formatPrice(subtotal)}</span>
        </div>
        {discount > 0 && (
          <div className="flex justify-between text-green-600">
            <span>Giảm giá:</span>
            <span>-{formatPrice(discount)}</span>
          </div>
        )}
      </div>

      <div className="flex justify-between font-bold mb-6">
        <span>Tổng cộng:</span>
        <span>{formatPrice(total)}</span>
      </div>

      <Link to="/checkout">
        <Button className="w-full">Tiến hành thanh toán</Button>
      </Link>
    </div>
  );
};

export default CartSummary;


--- File: client/src/components/feature/Category/CategoryBreadcrumb.js ---
// client/src/components/feature/Category/CategoryBreadcrumb.js

import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { fetchCategoryById } from '../../../store/slices/categorySlice';
import { PATHS } from '../../../routes/paths';

const CategoryBreadcrumb = ({ categoryId }) => {
  const dispatch = useDispatch();
  const { categories } = useSelector(state => state.categories);
  const [breadcrumbs, setBreadcrumbs] = useState([]);
  
  useEffect(() => {
    if (categoryId) {
      dispatch(fetchCategoryById(categoryId));
    }
  }, [dispatch, categoryId]);
  
  useEffect(() => {
    if (categoryId && categories[categoryId]) {
      const category = categories[categoryId];
      
      // Tạo breadcrumb từ ancestors
      const breadcrumbItems = [
        { name: 'Trang Chủ', path: PATHS.HOME },
        { name: 'Sản Phẩm', path: PATHS.PRODUCTS }
      ];
      
      // Thêm ancestors nếu có
      if (category.ancestors && category.ancestors.length > 0) {
        category.ancestors.forEach(ancestor => {
          breadcrumbItems.push({
            name: ancestor.name,
            path: `${PATHS.PRODUCTS}?category=${ancestor._id}`
          });
        });
      }
      
      // Thêm category hiện tại
      breadcrumbItems.push({
        name: category.name,
        path: `${PATHS.PRODUCTS}?category=${category._id}`,
        active: true
      });
      
      setBreadcrumbs(breadcrumbItems);
    } else {
      // Default breadcrumb nếu không có category
      setBreadcrumbs([
        { name: 'Trang Chủ', path: PATHS.HOME },
        { name: 'Sản Phẩm', path: PATHS.PRODUCTS, active: true }
      ]);
    }
  }, [categoryId, categories]);
  
  return (
    <nav className="flex py-3 px-5 text-gray-700 bg-gray-50 rounded-lg mb-6" aria-label="Breadcrumb">
      <ol className="inline-flex items-center space-x-1 md:space-x-3">
        {breadcrumbs.map((item, index) => (
          <li key={index} className="inline-flex items-center">
            {index > 0 && (
              <svg className="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd"></path>
              </svg>
            )}
            
            {item.active ? (
              <span className="ml-1 md:ml-2 text-sm font-medium text-gray-500">
                {item.name}
              </span>
            ) : (
              <Link
                to={item.path}
                className={`ml-1 md:ml-2 text-sm font-medium text-blue-600 hover:text-blue-800 ${index === 0 ? '' : 'ml-2'}`}
              >
                {item.name}
              </Link>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
};

export default CategoryBreadcrumb;

--- File: client/src/components/feature/Product/ProductCard.js ---
// src/components/feature/Product/ProductCard.js
// Component hiển thị thông tin sản phẩm trong trang danh sách sản phẩm

import React from 'react';
import { Link } from 'react-router-dom';
import Button from '../../../components/common/Button/Button';
import Card from '../../../components/common/Card/Card';
import { formatPrice } from '../../../utils/formatters';
import { useDispatch } from 'react-redux';
import { addToCart } from '../../../store/slices/cartSlice';

const ProductCard = ({ product }) => {
  const dispatch = useDispatch();

  const handleAddToCart = () => {
    dispatch(
      addToCart({
        productId: product.id,
        quantity: 1,
      })
    );
  };

  return (
    <Card className="product-card">
      <Link to={`/products/${product.id}`} className="block relative">
        <img
          src={product.images[0]?.url || '/placeholder.png'}
          alt={product.name}
          className="w-full h-48 object-cover rounded-t-lg"
        />
        {product.isPromoted && (
          <span className="absolute top-2 right-2 bg-red-500 text-white px-2 py-1 text-xs font-bold rounded">
            Khuyến mãi
          </span>
        )}
      </Link>
      <div className="p-4">
        <h3 className="text-lg font-semibold mb-1">{product.name}</h3>
        <p className="text-gray-600 text-sm mb-2">{product.brand}</p>
        <p className="text-gray-800 font-bold mb-3">{formatPrice(product.price)}</p>
        <Button variant="primary" size="sm" onClick={handleAddToCart} className="w-full">
          Thêm vào giỏ hàng
        </Button>
      </div>
    </Card>
  );
};

// Sử dụng React.memo để tránh re-render không cần thiết
export default React.memo(ProductCard);


--- File: client/src/components/feature/Product/ProductFilter.js ---
// client/src/components/feature/Product/ProductFilter.js

import React, { useState } from 'react';
import { useDebounce } from '../../../hooks/useDebounce';

const ProductFilter = ({ onFilterChange }) => {
  const [filters, setFilters] = useState({
    minPrice: '',
    maxPrice: '',
    brand: '',
    inStock: false,
  });

  const debouncedFilters = useDebounce(filters, 500);

  // Gọi onFilterChange khi filters thay đổi
  React.useEffect(() => {
    onFilterChange(debouncedFilters);
  }, [debouncedFilters, onFilterChange]);

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFilters((prev) => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value,
    }));
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow mb-6">
      <h3 className="text-lg font-bold mb-4">Lọc Sản Phẩm</h3>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Khoảng Giá</label>
        <div className="flex space-x-2">
          <input
            type="number"
            name="minPrice"
            placeholder="Từ"
            value={filters.minPrice}
            onChange={handleChange}
            className="w-1/2 p-2 border rounded"
          />
          <input
            type="number"
            name="maxPrice"
            placeholder="Đến"
            value={filters.maxPrice}
            onChange={handleChange}
            className="w-1/2 p-2 border rounded"
          />
        </div>
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Thương Hiệu</label>
        <select
          name="brand"
          value={filters.brand}
          onChange={handleChange}
          className="w-full p-2 border rounded"
        >
          <option value="">Tất cả</option>
          <option value="ProCue">ProCue</option>
          <option value="StarterCue">StarterCue</option>
          <option value="MasterBall">MasterBall</option>
        </select>
      </div>

      <div className="mb-4">
        <label className="flex items-center">
          <input
            type="checkbox"
            name="inStock"
            checked={filters.inStock}
            onChange={handleChange}
            className="mr-2"
          />
          <span className="text-sm">Chỉ hiển thị sản phẩm còn hàng</span>
        </label>
      </div>
    </div>
  );
};

export default ProductFilter;


--- File: client/src/components/feature/Product/ProductList.js ---
// client/src/components/feature/Product/ProductList.js

import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchProducts } from '../../../store/slices/productSlice';
import { addToCart } from '../../../store/slices/cartSlice';
import ProductCard from './ProductCard';
import { LoadingSpinner } from '../../../components/common';

const ProductList = ({ categoryId, filters = {} }) => {
  const dispatch = useDispatch();
  const { products, loading, error } = useSelector((state) => state.products);
  const [filteredProducts, setFilteredProducts] = useState([]);

  useEffect(() => {
    dispatch(fetchProducts({ categoryId, ...filters }));
  }, [dispatch, categoryId, filters]);

  useEffect(() => {
    setFilteredProducts(products);
  }, [products]);

  const handleAddToCart = (productId) => {
    dispatch(addToCart({ productId, quantity: 1 }));
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <div className="text-red-500">Error: {error}</div>;
  }

  if (!filteredProducts.length) {
    return <div className="text-center py-8">Không tìm thấy sản phẩm phù hợp.</div>;
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {filteredProducts.map((product) => (
        <ProductCard key={product.id} product={product} onAddToCart={handleAddToCart} />
      ))}
    </div>
  );
};

export default ProductList;


--- File: client/src/components/feature/Product/ProductList.test.js ---
// src/components/feature/Product/ProductList.test.js

import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import ProductList from './ProductList';
import { configureStore } from '@reduxjs/toolkit';
import productReducer from '../../../store/slices/productSlice';
import cartReducer from '../../../store/slices/cartSlice';

// Mock data
const mockProducts = [
  {
    id: '1',
    name: 'Gậy Billiard Pro Series X1',
    brand: 'ProCue',
    price: 1500000,
    images: ['/assets/products/cue1.jpg'],
  },
  {
    id: '2',
    name: 'Bộ bi-a Pro Tournament',
    brand: 'GameMaster',
    price: 850000,
    images: ['/assets/products/balls1.jpg'],
  },
];

// Test store
const testStore = configureStore({
  reducer: {
    products: productReducer,
    cart: cartReducer,
  },
  preloadedState: {
    products: {
      products: [],
      isLoading: false,
      error: null,
      filters: {},
    },
    cart: {
      items: [],
      total: 0,
    },
  },
});

// Test wrapper
const TestWrapper = ({ children }) => (
  <Provider store={testStore}>
    <BrowserRouter>{children}</BrowserRouter>
  </Provider>
);

describe('ProductList component', () => {
  test('renders empty state when no products', () => {
    render(<ProductList products={[]} />, { wrapper: TestWrapper });
    expect(screen.getByText('Không có sản phẩm')).toBeInTheDocument();
  });

  test('renders correct number of products', () => {
    render(<ProductList products={mockProducts} />, { wrapper: TestWrapper });
    expect(screen.getAllByRole('article')).toHaveLength(2);
  });

  test('displays product names correctly', () => {
    render(<ProductList products={mockProducts} />, { wrapper: TestWrapper });
    expect(screen.getByText('Gậy Billiard Pro Series X1')).toBeInTheDocument();
    expect(screen.getByText('Bộ bi-a Pro Tournament')).toBeInTheDocument();
  });
});


--- File: client/src/components/feature/Review/ReviewForm.js ---
// src/components/feature/Review/ReviewForm.js
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Button } from '../../common/Button/Button';
import { Input } from '../../common/Input/Input';

const schema = yup.object({
  rating: yup.number().required('Vui lòng chọn số sao').min(1, 'Vui lòng chọn số sao'),
  title: yup.string().required('Vui lòng nhập tiêu đề'),
  content: yup.string().required('Vui lòng nhập nội dung đánh giá'),
});

const ReviewForm = ({ productId, onSubmit, isSubmitting }) => {
  const [selectedRating, setSelectedRating] = useState(0);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      rating: 0,
      title: '',
      content: '',
    },
  });

  const handleRatingClick = (rating) => {
    setSelectedRating(rating);
  };

  const submitHandler = (data) => {
    onSubmit({ ...data, productId });
  };

  return (
    <form onSubmit={handleSubmit(submitHandler)} className="bg-white p-6 rounded-lg border">
      <h3 className="text-lg font-semibold mb-4">Viết đánh giá</h3>

      <div className="mb-4">
        <label className="block mb-2">Đánh giá của bạn</label>
        <div className="flex items-center mb-1">
          {[1, 2, 3, 4, 5].map((rating) => (
            <button
              key={rating}
              type="button"
              onClick={() => handleRatingClick(rating)}
              className="text-2xl text-yellow-400 focus:outline-none"
            >
              {rating <= selectedRating ? '★' : '☆'}
            </button>
          ))}
          <input type="hidden" value={selectedRating} {...register('rating')} />
        </div>
        {errors.rating && <p className="text-red-500 text-sm">{errors.rating.message}</p>}
      </div>

      <div className="mb-4">
        <Input label="Tiêu đề" {...register('title')} error={errors.title?.message} />
      </div>

      <div className="mb-6">
        <Input
          label="Nội dung đánh giá"
          {...register('content')}
          error={errors.content?.message}
          multiline
          rows={4}
        />
      </div>

      <Button type="submit" isLoading={isSubmitting}>
        Gửi đánh giá
      </Button>
    </form>
  );
};

export default ReviewForm;


--- File: client/src/components/feature/Review/ReviewItem.js ---
// src/components/feature/Review/ReviewItem.js
import React from 'react';
import { formatDate } from '../../../utils/formatters';

const ReviewItem = ({ review }) => {
  const renderStars = (rating) => {
    return Array.from({ length: 5 }).map((_, index) => (
      <span key={index} className="text-yellow-400">
        {index < rating ? '★' : '☆'}
      </span>
    ));
  };

  return (
    <div className="border-b pb-4 mb-4 last:border-b-0 last:mb-0 last:pb-0">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center">
          <div className="font-semibold mr-3">{review.user.name}</div>
          <div className="text-yellow-400">{renderStars(review.rating)}</div>
        </div>
        <div className="text-gray-500 text-sm">{formatDate(review.createdAt)}</div>
      </div>

      <h4 className="font-medium mb-1">{review.title}</h4>
      <p className="text-gray-700">{review.content}</p>

      {review.response && (
        <div className="mt-3 pl-4 border-l-2 border-gray-300">
          <p className="text-sm font-semibold">Phản hồi từ cửa hàng:</p>
          <p className="text-sm text-gray-700">{review.response.content}</p>
        </div>
      )}
    </div>
  );
};

export default ReviewItem;


--- File: client/src/components/feature/Review/ReviewList.js ---
// src/components/feature/Review/ReviewList.js
import React from 'react';
import ReviewItem from './ReviewItem';
import { Empty } from '../../common/Empty';

const ReviewList = ({ reviews, loading, error }) => {
  if (loading) {
    return <div className="text-center p-4">Đang tải đánh giá...</div>;
  }

  if (error) {
    return <div className="text-center text-red-500 p-4">{error}</div>;
  }

  if (!reviews || reviews.length === 0) {
    return <Empty message="Chưa có đánh giá nào" />;
  }

  return (
    <div className="bg-white p-6 rounded-lg border">
      <h3 className="text-lg font-semibold mb-4">Đánh giá ({reviews.length})</h3>

      <div>
        {reviews.map((review) => (
          <ReviewItem key={review._id} review={review} />
        ))}
      </div>
    </div>
  );
};

export default ReviewList;


--- File: client/src/components/feature/Review/ReviewStats.js ---
// src/components/feature/Review/ReviewStats.js
import React from 'react';

const ReviewStats = ({ stats }) => {
  const { average, count, distribution } = stats;

  const renderStars = (rating) => {
    return Array.from({ length: 5 }).map((_, index) => (
      <span key={index} className="text-yellow-400 text-lg">
        {index < Math.floor(rating) ? '★' : '☆'}
      </span>
    ));
  };

  const renderDistribution = () => {
    return [5, 4, 3, 2, 1].map((rating) => {
      const count = distribution[rating] || 0;
      const percentage = count > 0 ? (count / stats.count) * 100 : 0;

      return (
        <div key={rating} className="flex items-center mb-1">
          <div className="w-12 text-sm">{rating} sao</div>
          <div className="w-full mx-4 bg-gray-200 rounded-full h-2.5">
            <div
              className="bg-yellow-400 h-2.5 rounded-full"
              style={{ width: `${percentage}%` }}
            ></div>
          </div>
          <div className="w-12 text-sm text-right">{count}</div>
        </div>
      );
    });
  };

  return (
    <div className="bg-white p-6 rounded-lg border mb-6">
      <div className="flex flex-col md:flex-row md:items-center mb-4">
        <div className="flex flex-col items-center mr-6 mb-4 md:mb-0">
          <div className="text-4xl font-bold text-center">
            {average ? average.toFixed(1) : '0.0'}
          </div>
          <div className="mb-1">{renderStars(average || 0)}</div>
          <div className="text-sm text-gray-500">({count} đánh giá)</div>
        </div>

        <div className="flex-1">{renderDistribution()}</div>
      </div>
    </div>
  );
};

export default ReviewStats;


--- File: client/src/components/feature/Search/RecentSearches.js ---
import React from 'react';

const RecentSearches = ({ searches, onSelect }) => {
  if (searches.length === 0) return null;

  return (
    <div className="absolute z-10 w-full mt-1 bg-white shadow-lg rounded-md border border-gray-200 max-h-60 overflow-y-auto">
      <div className="p-2 text-sm text-gray-500 border-b">Tìm kiếm gần đây</div>
      <ul>
        {searches.map((term, index) => (
          <li key={index}>
            <button
              className="w-full px-4 py-2 text-left hover:bg-gray-100 text-gray-700 flex items-center"
              onClick={() => onSelect(term)}
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-4 w-4 mr-2 text-gray-400"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              {term}
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default RecentSearches;


--- File: client/src/components/feature/Search/SearchBar.js ---
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { setKeyword, clearResults, searchProducts } from '../../../store/slices/searchSlice';
import { useDebounce } from '../../../hooks/useDebounce';
import { Input } from '../../common/Input';
import { Button } from '../../common/Button';
import RecentSearches from './RecentSearches';
import { useOutsideClick } from '../../../hooks/useOutsideClick';

const SearchBar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const [inputValue, setInputValue] = useState('');
  const [showRecent, setShowRecent] = useState(false);
  const searchRef = useRef(null);
  const { recentSearches } = useSelector((state) => state.search);

  // Debounce input to avoid too many API calls
  const debouncedValue = useDebounce(inputValue, 300);

  // Close dropdown when clicking outside
  useOutsideClick(searchRef, () => {
    setShowRecent(false);
  });

  // Perform search when debounced value changes
  useEffect(() => {
    if (debouncedValue && debouncedValue.length > 2) {
      dispatch(searchProducts(debouncedValue));
    } else {
      dispatch(clearResults());
    }
  }, [debouncedValue, dispatch]);

  // Handle input change
  const handleChange = (e) => {
    const value = e.target.value;
    setInputValue(value);

    // Show recent searches dropdown when typing
    if (value.length > 0) {
      setShowRecent(true);
    } else {
      setShowRecent(false);
      dispatch(clearResults());
    }
  };

  // Handle search submission
  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      dispatch(setKeyword(inputValue));
      navigate(`/search?q=${encodeURIComponent(inputValue)}`);
      setShowRecent(false);
    }
  };

  // Select recent search
  const handleSelectRecent = (term) => {
    setInputValue(term);
    dispatch(setKeyword(term));
    navigate(`/search?q=${encodeURIComponent(term)}`);
    setShowRecent(false);
  };

  return (
    <div ref={searchRef} className="relative">
      <form onSubmit={handleSubmit} className="flex">
        <Input
          type="text"
          placeholder="Tìm kiếm sản phẩm..."
          value={inputValue}
          onChange={handleChange}
          onFocus={() => inputValue && setShowRecent(true)}
          className="w-full rounded-r-none"
        />
        <Button type="submit" variant="primary" className="rounded-l-none">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-5 w-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            />
          </svg>
        </Button>
      </form>

      {/* Recent searches dropdown */}
      {showRecent && recentSearches.length > 0 && (
        <RecentSearches searches={recentSearches} onSelect={handleSelectRecent} />
      )}
    </div>
  );
};

export default SearchBar;


--- File: client/src/components/feature/User/OrderDetail.js ---
// src/components/feature/User/OrderDetail.js
import React, { useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { fetchOrderDetail } from '../../../store/slices/orderSlice';
import { formatDate, formatPrice } from '../../../utils/formatters';
import { LoadingSpinner } from '../../common/LoadingSpinner';

const OrderStatus = ({ status, statusHistory }) => {
  const statusSteps = [
    { key: 'pending', label: 'Chờ xác nhận' },
    { key: 'processing', label: 'Đang xử lý' },
    { key: 'shipped', label: 'Đang giao hàng' },
    { key: 'delivered', label: 'Đã giao hàng' },
  ];

  // Find current status index
  const currentIndex = statusSteps.findIndex((step) => step.key === status);

  // Handle cancelled order
  if (status === 'cancelled') {
    return (
      <div className="mb-6">
        <div className="flex items-center">
          <div className="w-8 h-8 bg-red-500 rounded-full flex items-center justify-center text-white">
            ✕
          </div>
          <div className="ml-3">
            <p className="font-medium">Đơn hàng đã bị hủy</p>
            <p className="text-sm text-gray-500">
              {statusHistory &&
                statusHistory.length > 0 &&
                `Ngày hủy: ${formatDate(statusHistory[statusHistory.length - 1].date)}`}
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="mb-6">
      <h3 className="font-medium mb-4">Trạng thái đơn hàng</h3>
      <div className="relative">
        {/* Progress line */}
        <div className="absolute top-4 left-4 right-4 h-0.5 bg-gray-200">
          <div
            className="h-0.5 bg-green-500"
            style={{ width: `${(currentIndex * 100) / (statusSteps.length - 1)}%` }}
          ></div>
        </div>

        {/* Status steps */}
        <div className="flex justify-between relative">
          {statusSteps.map((step, index) => {
            const isCompleted = index <= currentIndex;
            const isCurrent = index === currentIndex;

            return (
              <div key={step.key} className="flex flex-col items-center">
                <div
                  className={`w-8 h-8 rounded-full flex items-center justify-center z-10 ${
                    isCompleted ? 'bg-green-500 text-white' : 'bg-gray-200'
                  } ${isCurrent ? 'ring-2 ring-green-300' : ''}`}
                >
                  {isCompleted ? '✓' : index + 1}
                </div>
                <p className={`text-sm mt-2 ${isCompleted ? 'font-medium' : 'text-gray-500'}`}>
                  {step.label}
                </p>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
};

const OrderDetail = () => {
  const { orderId } = useParams();
  const dispatch = useDispatch();
  const { currentOrder, loading, error } = useSelector((state) => state.order);

  useEffect(() => {
    if (orderId) {
      dispatch(fetchOrderDetail(orderId));
    }
  }, [dispatch, orderId]);

  if (loading) {
    return (
      <div className="flex justify-center items-center py-8">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (!currentOrder) {
    return <div className="text-center py-4">Không tìm thấy thông tin đơn hàng</div>;
  }

  return (
    <div className="bg-white rounded-lg border p-6">
      <div className="flex justify-between items-start mb-6">
        <div>
          <h2 className="text-xl font-semibold">Đơn hàng #{currentOrder.orderNumber}</h2>
          <p className="text-gray-500">Ngày đặt: {formatDate(currentOrder.createdAt)}</p>
        </div>
        <div className="font-bold text-lg">{formatPrice(currentOrder.totalAmount)}</div>
      </div>

      <OrderStatus status={currentOrder.status} statusHistory={currentOrder.statusHistory} />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <h3 className="font-medium mb-2">Thông tin giao hàng</h3>
          <div className="border rounded-lg p-4">
            <p>{currentOrder.shippingAddress.name}</p>
            <p>{currentOrder.shippingAddress.phone}</p>
            <p>{currentOrder.shippingAddress.street}</p>
            <p>
              {currentOrder.shippingAddress.city}, {currentOrder.shippingAddress.zipCode}
            </p>
          </div>
        </div>

        <div>
          <h3 className="font-medium mb-2">Phương thức thanh toán</h3>
          <div className="border rounded-lg p-4">
            <p>
              {currentOrder.paymentMethod === 'cod'
                ? 'Thanh toán khi nhận hàng (COD)'
                : 'Thanh toán qua VNPay'}
            </p>
            <p className="text-sm mt-1">
              Trạng thái:
              <span
                className={
                  currentOrder.paymentStatus === 'paid' ? 'text-green-600' : 'text-yellow-600'
                }
              >
                {currentOrder.paymentStatus === 'paid' ? ' Đã thanh toán' : ' Chưa thanh toán'}
              </span>
            </p>
          </div>
        </div>
      </div>

      <h3 className="font-medium mb-2">Chi tiết đơn hàng</h3>
      <div className="border rounded-lg">
        <div className="divide-y">
          {currentOrder.items.map((item) => (
            <div key={item._id} className="p-4 flex justify-between items-center">
              <div className="flex items-center">
                {item.image && (
                  <img
                    src={item.image}
                    alt={item.name}
                    className="w-12 h-12 object-cover rounded mr-3"
                  />
                )}
                <div>
                  <p className="font-medium">{item.name}</p>
                  <p className="text-sm text-gray-500">
                    Số lượng: {item.quantity} x {formatPrice(item.price)}
                  </p>
                </div>
              </div>
              <div className="font-medium">{formatPrice(item.price * item.quantity)}</div>
            </div>
          ))}
        </div>

        <div className="border-t p-4">
          <div className="flex justify-between mb-2">
            <span className="text-gray-600">Tạm tính:</span>
            <span>{formatPrice(currentOrder.subtotal)}</span>
          </div>
          {currentOrder.discount && currentOrder.discount.amount > 0 && (
            <div className="flex justify-between mb-2 text-green-600">
              <span>Giảm giá:</span>
              <span>-{formatPrice(currentOrder.discount.amount)}</span>
            </div>
          )}
          <div className="flex justify-between mb-2">
            <span className="text-gray-600">Phí vận chuyển:</span>
            <span>{formatPrice(currentOrder.shippingCost)}</span>
          </div>
          <div className="flex justify-between font-bold text-lg pt-2 border-t mt-2">
            <span>Tổng cộng:</span>
            <span>{formatPrice(currentOrder.totalAmount)}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default OrderDetail;


--- File: client/src/components/feature/User/ProfileSidebar.js ---
// src/components/feature/User/ProfileSidebar.js
import React from 'react';
import { NavLink, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';

const ProfileSidebar = () => {
  const location = useLocation();
  const { user } = useSelector((state) => state.user);

  const menuItems = [
    {
      path: '/profile',
      label: 'Thông tin tài khoản',
      icon: '👤',
      exact: true,
    },
    {
      path: '/profile/orders',
      label: 'Đơn hàng của tôi',
      icon: '📦',
      exact: false,
    },
    {
      path: '/profile/reviews',
      label: 'Đánh giá của tôi',
      icon: '⭐',
      exact: true,
    },
    {
      path: '/profile/wishlist',
      label: 'Sản phẩm yêu thích',
      icon: '❤️',
      exact: true,
    },
    {
      path: '/profile/settings',
      label: 'Cài đặt tài khoản',
      icon: '⚙️',
      exact: true,
    },
  ];

  return (
    <div className="bg-white rounded-lg border overflow-hidden">
      {user && (
        <div className="p-6 border-b">
          <div className="flex items-center">
            <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 font-semibold mr-3">
              {user.name.charAt(0).toUpperCase()}
            </div>
            <div>
              <p className="font-medium">{user.name}</p>
              <p className="text-sm text-gray-500">{user.email}</p>
            </div>
          </div>
        </div>
      )}

      <div className="py-2">
        {menuItems.map((item) => {
          const isActive = item.exact
            ? location.pathname === item.path
            : location.pathname.startsWith(item.path);

          return (
            <NavLink
              key={item.path}
              to={item.path}
              className={`flex items-center px-6 py-3 hover:bg-gray-50 ${
                isActive ? 'text-blue-600 bg-blue-50 font-medium' : 'text-gray-700'
              }`}
            >
              <span className="mr-3">{item.icon}</span>
              {item.label}
            </NavLink>
          );
        })}
      </div>
    </div>
  );
};

export default ProfileSidebar;


--- File: client/src/components/feature/User/UserOrders.js ---
// src/components/feature/User/UserOrders.js
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Link } from 'react-router-dom';
import { fetchUserOrders } from '../../../store/slices/orderSlice';
import { LoadingSpinner } from '../../common/LoadingSpinner';
import { formatDate, formatPrice } from '../../../utils/formatters';
import { Empty } from '../../common/Empty';

const OrderStatusBadge = ({ status }) => {
  const statusConfig = {
    pending: { text: 'Chờ xác nhận', color: 'bg-yellow-100 text-yellow-800' },
    processing: { text: 'Đang xử lý', color: 'bg-blue-100 text-blue-800' },
    shipped: { text: 'Đang giao hàng', color: 'bg-purple-100 text-purple-800' },
    delivered: { text: 'Đã giao hàng', color: 'bg-green-100 text-green-800' },
    cancelled: { text: 'Đã hủy', color: 'bg-red-100 text-red-800' },
  };

  const config = statusConfig[status] || { text: status, color: 'bg-gray-100 text-gray-800' };

  return (
    <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${config.color}`}>
      {config.text}
    </span>
  );
};

const UserOrders = () => {
  const dispatch = useDispatch();
  const { orders, loading, error } = useSelector((state) => state.order);

  useEffect(() => {
    dispatch(fetchUserOrders());
  }, [dispatch]);

  if (loading) {
    return (
      <div className="flex justify-center items-center py-8">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (!orders || orders.length === 0) {
    return <Empty message="Bạn chưa có đơn hàng nào" />;
  }

  return (
    <div className="bg-white rounded-lg border">
      <h2 className="text-xl font-semibold p-6 border-b">Đơn hàng của tôi</h2>

      <div className="divide-y">
        {orders.map((order) => (
          <div key={order._id} className="p-6">
            <div className="flex justify-between items-start mb-4">
              <div>
                <p className="font-medium mb-1">Đơn hàng #{order.orderNumber}</p>
                <p className="text-sm text-gray-500">Ngày đặt: {formatDate(order.createdAt)}</p>
              </div>
              <div className="flex flex-col items-end">
                <OrderStatusBadge status={order.status} />
                <p className="font-bold mt-2">{formatPrice(order.totalAmount)}</p>
              </div>
            </div>

            <div className="space-y-2 mb-4">
              {order.items.map((item) => (
                <div key={item._id} className="flex items-center">
                  <span className="text-gray-500 mr-2">{item.quantity}x</span>
                  <span>{item.name}</span>
                </div>
              ))}
            </div>

            <Link
              to={`/profile/orders/${order._id}`}
              className="text-blue-600 hover:text-blue-800 text-sm font-medium"
            >
              Xem chi tiết
            </Link>
          </div>
        ))}
      </div>
    </div>
  );
};

export default UserOrders;


--- File: client/src/components/feature/User/UserProfile.js ---
// src/components/feature/User/UserProfile.js
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { updateUserProfile } from '../../../store/slices/userSlice';
import { Button } from '../../common/Button/Button';
import { Input } from '../../common/Input/Input';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object({
  name: yup.string().required('Vui lòng nhập họ tên'),
  email: yup.string().email('Email không hợp lệ').required('Vui lòng nhập email'),
  phone: yup.string(),
  address: yup.string(),
});

const UserProfile = () => {
  const dispatch = useDispatch();
  const { user, loading } = useSelector((state) => state.user);
  const [isEditing, setIsEditing] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: yupResolver(schema),
    defaultValues: {
      name: user?.name || '',
      email: user?.email || '',
      phone: user?.phone || '',
      address: user?.address?.street || '',
    },
  });

  const onSubmit = async (data) => {
    try {
      await dispatch(updateUserProfile(data)).unwrap();
      setIsEditing(false);
    } catch (error) {
      console.error('Failed to update profile:', error);
    }
  };

  if (!user) {
    return <div className="text-center p-4">Đang tải thông tin...</div>;
  }

  return (
    <div className="bg-white p-6 rounded-lg border">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-semibold">Thông tin cá nhân</h2>
        {!isEditing && (
          <Button variant="outline" size="sm" onClick={() => setIsEditing(true)}>
            Chỉnh sửa
          </Button>
        )}
      </div>

      {isEditing ? (
        <form onSubmit={handleSubmit(onSubmit)}>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <Input label="Họ tên" {...register('name')} error={errors.name?.message} />
            </div>
            <div>
              <Input label="Email" {...register('email')} error={errors.email?.message} disabled />
            </div>
            <div>
              <Input label="Số điện thoại" {...register('phone')} error={errors.phone?.message} />
            </div>
            <div>
              <Input label="Địa chỉ" {...register('address')} error={errors.address?.message} />
            </div>
          </div>

          <div className="flex justify-end space-x-3">
            <Button type="button" variant="outline" onClick={() => setIsEditing(false)}>
              Hủy
            </Button>
            <Button type="submit" isLoading={loading}>
              Lưu thay đổi
            </Button>
          </div>
        </form>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <p className="text-gray-500 mb-1">Họ tên</p>
            <p className="font-medium">{user.name}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">Email</p>
            <p className="font-medium">{user.email}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">Số điện thoại</p>
            <p className="font-medium">{user.phone || 'Chưa cập nhật'}</p>
          </div>
          <div>
            <p className="text-gray-500 mb-1">Địa chỉ</p>
            <p className="font-medium">{user.address?.street || 'Chưa cập nhật'}</p>
          </div>
        </div>
      )}
    </div>
  );
};

export default UserProfile;


--- File: client/src/hooks/useDebounce.js ---
import { useState, useEffect } from 'react';

/**
 * Custom hook để debounce một giá trị
 * @param {any} value - Giá trị cần debounce
 * @param {number} delay - Thời gian delay (ms)
 * @returns {any} - Giá trị đã debounce
 */
const useDebounce = (value, delay) => {
  // State và setter cho giá trị debounced
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // Cập nhật giá trị debounced sau một khoảng thời gian delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Hủy timeout nếu value thay đổi hoặc unmount
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

export default useDebounce;

--- File: client/src/hooks/useForm.js ---
import { useState } from 'react';

/**
 * Custom hook để quản lý form state
 * @param {Object} initialValues - Giá trị ban đầu của form
 * @param {Function} [validate] - Hàm validate form (optional)
 * @param {Function} [onSubmit] - Hàm xử lý submit form (optional)
 * @returns {Object} - Form state và các hàm xử lý
 */
const useForm = (initialValues, validate, onSubmit) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Xử lý thay đổi input
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;

    // Xử lý giá trị dựa trên loại input
    const inputValue = type === 'checkbox' ? checked : value;

    setValues({
      ...values,
      [name]: inputValue,
    });

    // Nếu field đã được touched, chạy validate khi thay đổi
    if (touched[name] && validate) {
      const validationErrors = validate({ ...values, [name]: inputValue });
      setErrors(validationErrors);
    }
  };

  // Xử lý khi blur khỏi field
  const handleBlur = (e) => {
    const { name } = e.target;

    setTouched({
      ...touched,
      [name]: true,
    });

    // Chạy validate khi blur
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
    }
  };

  // Xử lý submit form
  const handleSubmit = async (e) => {
    e.preventDefault();

    // Đánh dấu tất cả các field là touched
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});

    setTouched(allTouched);

    // Validate form trước khi submit
    let validationErrors = {};
    if (validate) {
      validationErrors = validate(values);
      setErrors(validationErrors);
    }

    // Nếu không có lỗi và có hàm onSubmit
    if (Object.keys(validationErrors).length === 0 && onSubmit) {
      setIsSubmitting(true);

      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Form submission error:', error);
      } finally {
        setIsSubmitting(false);
      }
    }
  };

  // Reset form
  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  };

  // Cập nhật giá trị form từ bên ngoài
  const setFieldValue = (name, value) => {
    setValues({
      ...values,
      [name]: value,
    });
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setFieldValue,
  };
};

export default useForm;


--- File: client/src/hooks/useLocalStorage.js ---
import { useState, useEffect } from 'react';

/**
 * Custom hook để sử dụng localStorage
 * @param {string} key - Key để lưu trong localStorage
 * @param {any} initialValue - Giá trị ban đầu
 * @returns {Array} [storedValue, setValue]
 */
const useLocalStorage = (key, initialValue) => {
  // Tạo state ban đầu
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // Lấy giá trị từ localStorage
      const item = window.localStorage.getItem(key);
      // Parse stored json or return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // Nếu có lỗi, trả về giá trị ban đầu
      console.error(`Error getting localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Hàm để cập nhật localStorage và state
  const setValue = (value) => {
    try {
      // Cho phép value là một function
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      // Lưu state
      setStoredValue(valueToStore);
      // Lưu vào localStorage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  // Đồng bộ với các tab khác
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.error(`Error parsing localStorage key "${key}":`, error);
        }
      }
    };

    // Lắng nghe sự kiện storage
    window.addEventListener('storage', handleStorageChange);

    // Cleanup
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [key]);

  return [storedValue, setValue];
};

export default useLocalStorage;

--- File: client/src/hooks/useOutsideClick.js ---
import { useEffect, useRef } from 'react';

/**
 * Custom hook để phát hiện click bên ngoài một element
 * @param {Function} callback - Hàm sẽ được gọi khi click bên ngoài
 * @returns {React.MutableRefObject} - Ref để gắn vào element cần theo dõi
 */
const useOutsideClick = (callback) => {
  const ref = useRef();

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    };

    // Thêm event listener
    document.addEventListener('mousedown', handleClickOutside);
    
    // Cleanup
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [callback]);

  return ref;
};

export default useOutsideClick;

--- File: client/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import { QueryClient, QueryClientProvider } from 'react-query';
import { store } from './store';
import App from './App';
import './assets/css/index.css';

// Khởi tạo React Query client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 phút
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </QueryClientProvider>
    </Provider>
  </React.StrictMode>
);


--- File: client/src/pages/Admin/Dashboard/index.js ---
// src/pages/Admin/Dashboard/index.js
// Vị trí: Trang Dashboard chính cho Admin, hiển thị thống kê, biểu đồ và đơn hàng gần đây

import React, { useEffect, useState, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../../../store/hooks';
import {
  fetchDashboardStats,
  fetchRecentOrders,
  resetDashboardErrors,
} from '../../../store/slices/adminSlice';
import {
  DashboardStats,
  RecentOrders,
  SalesChart,
  TimeFilter,
} from '../../../components/feature/Admin/Dashboard';
import { LoadingSpinner, ErrorAlert, RefreshButton } from '../../../components/common';

const TIME_PERIODS = {
  TODAY: 'today',
  WEEK: 'week',
  MONTH: 'month',
  YEAR: 'year',
};

const AdminDashboardPage = () => {
  const dispatch = useAppDispatch();
  const { stats, recentOrders, isLoading, error } = useAppSelector((state) => state.admin);

  const [timePeriod, setTimePeriod] = useState(TIME_PERIODS.WEEK);

  const fetchDashboardData = useCallback(() => {
    dispatch(fetchDashboardStats(timePeriod));
    dispatch(fetchRecentOrders(timePeriod));
  }, [dispatch, timePeriod]);

  useEffect(() => {
    fetchDashboardData();

    // Cleanup function để reset errors khi unmount
    return () => {
      dispatch(resetDashboardErrors());
    };
  }, [fetchDashboardData, dispatch]);

  const handleRefresh = () => {
    fetchDashboardData();
  };

  const handleTimeFilterChange = (period) => {
    setTimePeriod(period);
  };

  const handleDismissError = () => {
    dispatch(resetDashboardErrors());
  };

  return (
    <div className="space-y-6 px-4 py-6 sm:px-6 lg:px-8">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
        <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>

        <div className="mt-3 sm:mt-0 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
          <TimeFilter
            currentPeriod={timePeriod}
            onChange={handleTimeFilterChange}
            options={TIME_PERIODS}
          />
          <RefreshButton onClick={handleRefresh} isLoading={isLoading} />
        </div>
      </div>

      {error && <ErrorAlert message={error} onDismiss={handleDismissError} />}

      {isLoading ? (
        <div className="flex justify-center items-center h-64">
          <LoadingSpinner size="large" />
        </div>
      ) : (
        <>
          <DashboardStats stats={stats} />

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Doanh số bán hàng</h2>
              <SalesChart data={stats?.salesData || []} period={timePeriod} />
            </div>

            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Đơn hàng gần đây</h2>
              <RecentOrders
                orders={recentOrders}
                isLoading={isLoading}
                onViewAllClick={() => {
                  /* Navigate to orders page */
                }}
              />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Sản phẩm bán chạy</h2>
              {/* Component hiển thị sản phẩm bán chạy */}
            </div>

            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-lg font-medium text-gray-900 mb-4">Hoạt động gần đây</h2>
              {/* Component hiển thị hoạt động gần đây */}
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default AdminDashboardPage;


--- File: client/src/pages/Auth/Login/index.js ---
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { login, clearError, selectAuth } from '../../../store/slices/authSlice';
import { ROUTES } from '../../../routes/paths';
import Button from '../../../components/common/Button/Button';
import Input from '../../../components/common/Input/Input';
import useForm from '../../../hooks/useForm';

const Login = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { isAuthenticated, error, loading } = useSelector(selectAuth);
  const [showPassword, setShowPassword] = useState(false);

  // Lấy redirect path từ location state hoặc mặc định về trang chủ
  const from = location.state?.from?.pathname || ROUTES.HOME;

  // Nếu đã đăng nhập, chuyển hướng
  useEffect(() => {
    if (isAuthenticated) {
      navigate(from, { replace: true });
    }

    // Xóa error khi unmount
    return () => {
      dispatch(clearError());
    };
  }, [isAuthenticated, navigate, from, dispatch]);

  // Validate form
  const validateForm = (values) => {
    const errors = {};

    if (!values.email) {
      errors.email = 'Email là bắt buộc';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email không hợp lệ';
    }

    if (!values.password) {
      errors.password = 'Mật khẩu là bắt buộc';
    }

    return errors;
  };

  // Xử lý submit form
  const handleSubmit = async (values) => {
    await dispatch(login(values));
  };

  // Khởi tạo form với useForm hook
  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit: submitForm,
  } = useForm({ email: '', password: '' }, validateForm, handleSubmit);

  return (
    <div className="max-w-md mx-auto">
      <h2 className="text-center text-2xl font-extrabold mb-6">Đăng Nhập</h2>

      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <form onSubmit={submitForm}>
        <Input
          type="email"
          id="email"
          name="email"
          label="Email"
          placeholder="Nhập email của bạn"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.email && errors.email}
          leftIcon={
            <svg
              className="h-5 w-5 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
              ></path>
            </svg>
          }
        />

        <Input
          type={showPassword ? 'text' : 'password'}
          id="password"
          name="password"
          label="Mật khẩu"
          placeholder="Nhập mật khẩu của bạn"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.password && errors.password}
          leftIcon={
            <svg
              className="h-5 w-5 text-gray-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
              ></path>
            </svg>
          }
          rightIcon={
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="focus:outline-none"
            >
              {showPassword ? (
                <svg
                  className="h-5 w-5 text-gray-400"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"
                  ></path>
                </svg>
              ) : (
                <svg
                  className="h-5 w-5 text-gray-400"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                  ></path>
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                  ></path>
                </svg>
              )}
            </button>
          }
        />

        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center">
            <input
              id="remember-me"
              name="remember-me"
              type="checkbox"
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
              Ghi nhớ đăng nhập
            </label>
          </div>

          <div className="text-sm">
            <Link
              to={ROUTES.FORGOT_PASSWORD}
              className="font-medium text-blue-600 hover:text-blue-500"
            >
              Quên mật khẩu?
            </Link>
          </div>
        </div>

        <Button type="submit" variant="primary" className="w-full" isLoading={loading}>
          Đăng Nhập
        </Button>
      </form>

      <div className="text-center mt-6">
        <p className="text-sm text-gray-600">
          Chưa có tài khoản?{' '}
          <Link to={ROUTES.REGISTER} className="font-medium text-blue-600 hover:text-blue-500">
            Đăng ký ngay
          </Link>
        </p>
      </div>
    </div>
  );
};

export default Login;


--- File: client/src/pages/Auth/Register/index.js ---


--- File: client/src/pages/Cart/index.js ---
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Link } from 'react-router-dom';
import { updateCartItem, removeFromCart, clearCart, fetchCart } from '../../store/slices/cartSlice';
import CartList from '../../components/feature/Cart/CartList';
import CartSummary from '../../components/feature/Cart/CartSummary';
import EmptyState from '../../components/common/Empty';
import Breadcrumb from '../../components/common/Breadcrumb';
import { Button } from '../../components/common/Button';
import { LoadingSpinner } from '../../components/common/LoadingSpinner';
import MainLayout from '../../components/layout/MainLayout';
import { PATHS } from '../../routes/paths';

const CartPage = () => {
  const dispatch = useDispatch();
  const { items, loading, error } = useSelector((state) => state.cart);

  useEffect(() => {
    dispatch(fetchCart());
  }, [dispatch]);

  // Handle quantity change
  const handleQuantityChange = (productId, quantity) => {
    dispatch(updateCartItem({ productId, quantity }));
  };

  // Handle remove item
  const handleRemoveItem = (productId) => {
    dispatch(removeFromCart(productId));
  };

  // Handle clear cart
  const handleClearCart = () => {
    if (window.confirm('Bạn có chắc muốn xóa tất cả sản phẩm khỏi giỏ hàng?')) {
      dispatch(clearCart());
    }
  };

  // Render loading state
  if (loading) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang chủ', path: '/' },
              { label: 'Giỏ hàng', path: '/cart' },
            ]}
          />
          <div className="flex justify-center items-center h-64">
            <LoadingSpinner />
          </div>
        </div>
      </MainLayout>
    );
  }

  // Render error state
  if (error) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang chủ', path: '/' },
              { label: 'Giỏ hàng', path: '/cart' },
            ]}
          />
          <div className="text-center text-red-500 mt-8">
            <p>Đã xảy ra lỗi: {error}</p>
            <Button variant="primary" className="mt-4" onClick={() => dispatch(fetchCart())}>
              Thử lại
            </Button>
          </div>
        </div>
      </MainLayout>
    );
  }

  // Render empty state if cart is empty
  if (items.length === 0) {
    return (
      <MainLayout>
        <div className="container mx-auto px-4 py-8">
          <Breadcrumb
            items={[
              { label: 'Trang chủ', path: '/' },
              { label: 'Giỏ hàng', path: '/cart' },
            ]}
          />

          <EmptyState
            message="Giỏ hàng của bạn đang trống"
            icon={
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-16 w-16 text-gray-400"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"
                />
              </svg>
            }
            action={
              <Link to={PATHS.PRODUCTS}>
                <Button variant="primary">Tiếp tục mua sắm</Button>
              </Link>
            }
          />
        </div>
      </MainLayout>
    );
  }

  // Render cart with items
  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <Breadcrumb
          items={[
            { label: 'Trang chủ', path: '/' },
            { label: 'Giỏ hàng', path: '/cart' },
          ]}
        />

        <h1 className="text-2xl font-bold mb-6">Giỏ hàng của bạn</h1>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Cart Items */}
          <div className="lg:col-span-2">
            <CartList
              items={items}
              onQuantityChange={handleQuantityChange}
              onRemoveItem={handleRemoveItem}
              loading={loading}
            />

            <div className="mt-4 flex justify-between items-center">
              <Button variant="outline" onClick={handleClearCart} disabled={items.length === 0}>
                Xóa tất cả
              </Button>

              <Link to={PATHS.PRODUCTS}>
                <Button variant="link">Tiếp tục mua sắm</Button>
              </Link>
            </div>
          </div>

          {/* Cart Summary */}
          <div className="lg:col-span-1">
            <CartSummary items={items} checkoutLink={PATHS.CHECKOUT} />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default CartPage;


--- File: client/src/pages/Home/index.js ---
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Link } from 'react-router-dom';
import { fetchProducts, fetchCategories } from '../../store/slices/productSlice';
import { ROUTES } from '../../routes/paths';
import LoadingSpinner from '../../components/common/LoadingSpiner';
import Card from '../../components/common/Card/Card';
import Button from '../../components/common/Button/Button';
import { formatPrice } from '../../utils/formatters';

const HomePage = () => {
  const dispatch = useDispatch();
  const { products, categories, loading } = useSelector((state) => state.product);

  useEffect(() => {
    // Lấy sản phẩm nổi bật
    dispatch(fetchProducts({ limit: 8, featured: true }));

    // Lấy danh mục
    dispatch(fetchCategories());
  }, [dispatch]);

  if (loading && products.length === 0) {
    return <LoadingSpinner fullScreen />;
  }

  return (
    <div>
      {/* Hero Section */}
      <section className="bg-blue-900 text-white py-16 mb-12 rounded-lg">
        <div className="container mx-auto px-4 text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-6">RunOut-Biliard</h1>
          <p className="text-xl mb-8 max-w-3xl mx-auto">
            Chuyên cung cấp các sản phẩm Bi-a chất lượng cao, đa dạng mẫu mã, phù hợp với mọi nhu
            cầu từ người chơi nghiệp dư đến chuyên nghiệp.
          </p>
          <div className="flex justify-center space-x-4">
            <Link to={ROUTES.PRODUCTS}>
              <Button variant="primary" size="lg">
                Mua Ngay
              </Button>
            </Link>
            <Link to={ROUTES.ABOUT}>
              <Button variant="outline" size="lg">
                Tìm Hiểu Thêm
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* Categories Section */}
      <section className="mb-16">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold mb-8 text-center">Danh Mục Sản Phẩm</h2>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            {categories.slice(0, 4).map((category) => (
              <Link
                key={category._id}
                to={`${ROUTES.PRODUCTS}?category=${category.slug}`}
                className="block"
              >
                <div className="bg-gray-100 rounded-lg p-6 transition-transform hover:transform hover:scale-105 hover:shadow-lg text-center">
                  {category.image && (
                    <img
                      src={category.image.url}
                      alt={category.name}
                      className="w-16 h-16 mx-auto mb-4"
                    />
                  )}
                  <h3 className="text-xl font-semibold mb-2">{category.name}</h3>
                  <p className="text-gray-600 mb-4">
                    {category.description
                      ? category.description.substring(0, 100)
                      : 'Xem các sản phẩm'}
                  </p>
                  <span className="text-blue-600 hover:text-blue-800 font-medium">
                    Xem sản phẩm →
                  </span>
                </div>
              </Link>
            ))}
          </div>
        </div>
      </section>

      {/* Featured Products Section */}
      <section className="mb-16">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold mb-8 text-center">Sản Phẩm Nổi Bật</h2>

          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            {products.map((product) => (
              <Link key={product._id} to={`${ROUTES.PRODUCTS}/${product._id}`}>
                <Card className="h-full flex flex-col transition-all hover:shadow-lg">
                  <div className="relative pb-[75%] overflow-hidden rounded-t-lg">
                    <img
                      src={product.images[0]?.url || '/placeholder.png'}
                      alt={product.name}
                      className="absolute top-0 left-0 w-full h-full object-cover"
                    />
                  </div>
                  <div className="p-4 flex-grow flex flex-col">
                    <h3 className="text-lg font-semibold mb-2">{product.name}</h3>
                    <p className="text-gray-600 text-sm mb-4 flex-grow">
                      {product.description?.short?.substring(0, 100) || 'Không có mô tả'}
                    </p>
                    <div className="flex justify-between items-center">
                      <span className="text-lg font-bold text-blue-700">
                        {formatPrice(product.price)}
                      </span>
                      <span className="text-sm text-gray-500">
                        {product.ratings?.average > 0 ? (
                          <span className="flex items-center">
                            <svg
                              className="w-4 h-4 text-yellow-500 mr-1"
                              fill="currentColor"
                              viewBox="0 0 20 20"
                            >
                              <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                            </svg>
                            {product.ratings.average.toFixed(1)}
                          </span>
                        ) : (
                          'Chưa có đánh giá'
                        )}
                      </span>
                    </div>
                  </div>
                </Card>
              </Link>
            ))}
          </div>

          <div className="text-center mt-10">
            <Link to={ROUTES.PRODUCTS}>
              <Button variant="outline" size="lg">
                Xem Tất Cả Sản Phẩm
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* About Section */}
      <section className="mb-16 bg-gray-100 py-16 rounded-lg">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row items-center">
            <div className="md:w-1/2 mb-8 md:mb-0 md:pr-8">
              <h2 className="text-3xl font-bold mb-6">Về RunOut-Biliard</h2>
              <p className="text-lg mb-6">
                RunOut-Biliard là nhà cung cấp hàng đầu các sản phẩm Bi-a chất lượng cao tại Việt
                Nam. Chúng tôi tự hào mang đến cho khách hàng những sản phẩm chính hãng với giá cả
                hợp lý.
              </p>
              <p className="text-lg mb-6">
                Với đội ngũ nhân viên nhiều kinh nghiệm và am hiểu về Bi-a, chúng tôi cam kết mang
                đến sự tư vấn tận tâm và chuyên nghiệp cho khách hàng.
              </p>
              <Link to={ROUTES.ABOUT}>
                <Button variant="primary">Xem Thêm</Button>
              </Link>
            </div>
            <div className="md:w-1/2">
              <img
                src="/assets/about.jpg"
                alt="RunOut-Biliard Store"
                className="rounded-lg shadow-lg"
              />
            </div>
          </div>
        </div>
      </section>
    </div>
  );
};

export default HomePage;


--- File: client/src/pages/Info/Contact.js ---


--- File: client/src/pages/Info/FAQ.js ---


--- File: client/src/pages/Info/Privacy.js ---


--- File: client/src/pages/Info/Return.js ---


--- File: client/src/pages/Info/Shipping.js ---


--- File: client/src/pages/Info/Terms.js ---


--- File: client/src/pages/NotFound/index.js ---
import React from 'react';
import { Link } from 'react-router-dom';
import { ROUTES } from '../../routes/paths';
import Button from '../../components/common/Button/Button';

const NotFoundPage = () => {
  return (
    <div className="min-h-[70vh] flex flex-col items-center justify-center text-center px-4">
      <h1 className="text-9xl font-bold text-blue-600 mb-4">404</h1>
      <h2 className="text-3xl font-semibold mb-6">Trang Không Tìm Thấy</h2>
      <p className="text-lg text-gray-600 max-w-md mb-8">
        Xin lỗi, trang bạn đang tìm kiếm không tồn tại hoặc đã được di chuyển.
      </p>
      <div className="flex flex-col sm:flex-row gap-4">
        <Link to={ROUTES.HOME}>
          <Button variant="primary" size="lg">
            Quay Lại Trang Chủ
          </Button>
        </Link>
        <Link to={ROUTES.PRODUCTS}>
          <Button variant="outline" size="lg">
            Xem Sản Phẩm
          </Button>
        </Link>
      </div>
    </div>
  );
};

export default NotFoundPage;


--- File: client/src/pages/ProductDetail/index.js ---
// src/pages/ProductDetail/index.js
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { fetchProductById } from '../../store/slices/productSlice';
import { fetchProductReviews, submitProductReview } from '../../store/slices/reviewSlice';
import { addToCart } from '../../store/slices/cartSlice';
import MainLayout from '../../components/layout/MainLayout';
import { Button, LoadingSpinner } from '../../components/common';
import { formatPrice } from '../../utils/formatters';
import ReviewForm from '../../components/feature/Review/ReviewForm';
import ReviewList from '../../components/feature/Review/ReviewList';
import ReviewStats from '../../components/feature/Review/ReviewStats';
import { toast } from 'react-toastify';

const ProductDetailPage = () => {
  const { id } = useParams();
  const dispatch = useDispatch();
  const { product, loading, error } = useSelector((state) => state.products);
  const {
    reviews,
    stats: reviewStats,
    loading: reviewsLoading,
    error: reviewsError,
  } = useSelector((state) => state.review);
  const { isAuthenticated, user } = useSelector((state) => state.auth);
  const [quantity, setQuantity] = useState(1);
  const [selectedImage, setSelectedImage] = useState(0);
  const [isSubmittingReview, setIsSubmittingReview] = useState(false);

  useEffect(() => {
    if (id) {
      dispatch(fetchProductById(id));
      dispatch(fetchProductReviews(id));
    }

    // Scroll to top when component mounts
    window.scrollTo(0, 0);
  }, [dispatch, id]);

  const handleQuantityChange = (e) => {
    const value = parseInt(e.target.value);
    if (!isNaN(value) && value > 0 && value <= (product?.stock || 1)) {
      setQuantity(value);
    }
  };

  const handleAddToCart = () => {
    if (product) {
      dispatch(
        addToCart({
          productId: product.id,
          quantity,
          name: product.name,
          price: product.price,
          image: product.images[0]?.url || '/placeholder.png',
        })
      );
      toast.success('Đã thêm sản phẩm vào giỏ hàng!');
    }
  };

  const handleSubmitReview = async (reviewData) => {
    try {
      setIsSubmittingReview(true);
      await dispatch(submitProductReview({ ...reviewData, productId: id })).unwrap();
      toast.success('Đánh giá của bạn đã được gửi thành công!');
      // Refresh reviews
      dispatch(fetchProductReviews(id));
    } catch (error) {
      toast.error(error || 'Không thể gửi đánh giá. Vui lòng thử lại sau.');
    } finally {
      setIsSubmittingReview(false);
    }
  };

  const handleImageClick = (index) => {
    setSelectedImage(index);
  };

  if (loading) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4 flex justify-center">
          <LoadingSpinner />
        </div>
      </MainLayout>
    );
  }

  if (error) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4">
          <div className="text-red-500">Lỗi: {error}</div>
        </div>
      </MainLayout>
    );
  }

  if (!product) {
    return (
      <MainLayout>
        <div className="container mx-auto py-8 px-4">
          <div className="text-center">Không tìm thấy sản phẩm.</div>
        </div>
      </MainLayout>
    );
  }

  // Kiểm tra xem người dùng đã đánh giá sản phẩm này chưa
  const hasUserReviewed = isAuthenticated && reviews.some((review) => review.userId === user?.id);

  return (
    <MainLayout>
      <div className="container mx-auto py-8 px-4">
        {/* Breadcrumb */}
        <div className="mb-6 text-sm text-gray-600">
          <a href="/" className="hover:text-blue-600">
            Trang chủ
          </a>{' '}
          &gt;
          <a href="/products" className="hover:text-blue-600">
            {' '}
            Sản phẩm
          </a>{' '}
          &gt;
          <span className="text-gray-800"> {product.name}</span>
        </div>

        <div className="flex flex-col md:flex-row gap-8">
          {/* Hình ảnh sản phẩm */}
          <div className="w-full md:w-1/2">
            <div className="bg-white rounded-lg overflow-hidden shadow-md">
              <img
                src={product.images[selectedImage]?.url || '/placeholder.png'}
                alt={product.name}
                className="w-full h-auto object-contain"
                style={{ maxHeight: '500px' }}
              />
            </div>

            {/* Hình ảnh phụ */}
            {product.images.length > 1 && (
              <div className="grid grid-cols-5 gap-2 mt-4">
                {product.images.map((image, index) => (
                  <div
                    key={index}
                    className={`border rounded cursor-pointer overflow-hidden ${selectedImage === index ? 'border-blue-500 border-2' : ''}`}
                    onClick={() => handleImageClick(index)}
                  >
                    <img
                      src={image.url}
                      alt={image.alt || `${product.name} - Ảnh ${index + 1}`}
                      className="w-full h-20 object-cover"
                    />
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Thông tin sản phẩm */}
          <div className="w-full md:w-1/2">
            <h1 className="text-3xl font-bold mb-2">{product.name}</h1>
            <p className="text-gray-600 mb-2">Thương hiệu: {product.brand}</p>

            {/* Đánh giá sao */}
            <div className="flex items-center mb-4">
              <div className="flex text-yellow-400 mr-2">
                {'★'.repeat(Math.floor(product.ratings?.average || 0))}
                {'☆'.repeat(5 - Math.floor(product.ratings?.average || 0))}
              </div>
              <p className="text-gray-600">({product.ratings?.count || 0} đánh giá)</p>
            </div>

            <div className="text-2xl font-bold text-blue-700 mb-4">
              {formatPrice(product.price)}
              {product.salePrice && product.salePrice < product.price && (
                <span className="text-gray-500 line-through ml-2 text-lg">
                  {formatPrice(product.salePrice)}
                </span>
              )}
            </div>

            {/* Tình trạng kho */}
            <div className="mb-4">
              <span className="font-semibold">Tình trạng: </span>
              {product.stock > 0 ? (
                <span className="text-green-600">Còn hàng ({product.stock})</span>
              ) : (
                <span className="text-red-600">Hết hàng</span>
              )}
            </div>

            {/* Mô tả ngắn */}
            <div className="mb-6">
              <p>{product.description.short}</p>
            </div>

            {/* Số lượng và thêm vào giỏ hàng */}
            <div className="flex items-center mb-6">
              <div className="mr-4">
                <label htmlFor="quantity" className="block mb-1">
                  Số lượng:
                </label>
                <div className="flex items-center border rounded">
                  <button
                    className="px-3 py-2 bg-gray-100 hover:bg-gray-200"
                    onClick={() => quantity > 1 && setQuantity(quantity - 1)}
                    disabled={quantity <= 1}
                  >
                    -
                  </button>
                  <input
                    type="number"
                    id="quantity"
                    min="1"
                    max={product.stock}
                    value={quantity}
                    onChange={handleQuantityChange}
                    className="w-16 border-x p-2 text-center"
                  />
                  <button
                    className="px-3 py-2 bg-gray-100 hover:bg-gray-200"
                    onClick={() => quantity < product.stock && setQuantity(quantity + 1)}
                    disabled={quantity >= product.stock}
                  >
                    +
                  </button>
                </div>
              </div>

              <Button
                variant="primary"
                size="lg"
                onClick={handleAddToCart}
                disabled={product.stock <= 0}
                className="flex-1"
              >
                {product.stock > 0 ? 'Thêm vào giỏ hàng' : 'Hết hàng'}
              </Button>
            </div>

            {/* Tính năng sản phẩm */}
            {product.features && product.features.length > 0 && (
              <div className="mb-6">
                <h3 className="text-lg font-semibold mb-2">Tính năng nổi bật:</h3>
                <ul className="list-disc pl-5">
                  {product.features.map((feature, index) => (
                    <li key={index} className="mb-1">
                      {feature}
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* Chính sách bán hàng */}
            <div className="mt-6 bg-gray-50 p-4 rounded-lg">
              <h3 className="font-semibold mb-2">Chính sách mua hàng:</h3>
              <ul className="space-y-2">
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  Giao hàng toàn quốc
                </li>
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  Đổi trả trong vòng 7 ngày
                </li>
                <li className="flex items-center">
                  <svg
                    className="w-5 h-5 mr-2 text-green-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M5 13l4 4L19 7"
                    ></path>
                  </svg>
                  Bảo hành chính hãng 12 tháng
                </li>
              </ul>
            </div>
          </div>
        </div>

        {/* Tabs cho mô tả và thông số kỹ thuật */}
        <div className="mt-12">
          <div className="border-b border-gray-200">
            <nav className="-mb-px flex space-x-8">
              <a
                href="#description"
                className="border-b-2 border-blue-500 py-4 px-1 text-sm font-medium text-blue-600"
              >
                Mô tả sản phẩm
              </a>
              <a
                href="#specifications"
                className="border-b-2 border-transparent py-4 px-1 text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300"
              >
                Thông số kỹ thuật
              </a>
              <a
                href="#reviews"
                className="border-b-2 border-transparent py-4 px-1 text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300"
              >
                Đánh giá ({product.ratings?.count || 0})
              </a>
            </nav>
          </div>

          {/* Mô tả chi tiết */}
          <div id="description" className="mt-6">
            <div className="bg-white p-6 rounded-lg shadow">
              <p className="whitespace-pre-line">{product.description.long}</p>
            </div>
          </div>

          {/* Thông số kỹ thuật */}
          {product.specifications && Object.keys(product.specifications).length > 0 && (
            <div id="specifications" className="mt-10">
              <h2 className="text-2xl font-bold mb-4">Thông số kỹ thuật</h2>
              <div className="bg-white rounded-lg shadow overflow-hidden">
                <table className="w-full border-collapse">
                  <tbody>
                    {Object.entries(product.specifications).map(([key, value]) => (
                      <tr key={key} className="border-b">
                        <td className="py-3 px-6 bg-gray-50 font-medium capitalize w-1/3">
                          {key.replace(/([A-Z])/g, ' $1').toLowerCase()}
                        </td>
                        <td className="py-3 px-6">{value}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {/* Đánh giá sản phẩm */}
          <div id="reviews" className="mt-10">
            <h2 className="text-2xl font-bold mb-6">Đánh giá sản phẩm</h2>

            {/* Thống kê đánh giá */}
            <ReviewStats stats={reviewStats} />

            {/* Form đánh giá - chỉ hiển thị cho người dùng đã đăng nhập và chưa đánh giá */}
            {isAuthenticated && !hasUserReviewed && (
              <div className="mb-8 mt-6">
                <h3 className="text-lg font-semibold mb-3">Viết đánh giá của bạn</h3>
                <ReviewForm
                  productId={product.id}
                  onSubmit={handleSubmitReview}
                  isSubmitting={isSubmittingReview}
                />
              </div>
            )}

            {/* Danh sách đánh giá */}
            <ReviewList reviews={reviews} loading={reviewsLoading} error={reviewsError} />
          </div>
        </div>

        {/* Sản phẩm liên quan */}
        <div className="mt-16">
          <h2 className="text-2xl font-bold mb-6">Sản phẩm liên quan</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {/* Placeholder cho sản phẩm liên quan - sẽ được thay thế bằng dữ liệu thực */}
            {[1, 2, 3, 4].map((item) => (
              <div key={item} className="bg-white rounded-lg shadow overflow-hidden">
                <div className="p-4">
                  <div className="aspect-w-1 aspect-h-1 bg-gray-200 mb-3"></div>
                  <h3 className="font-medium">Sản phẩm liên quan {item}</h3>
                  <p className="text-blue-600 font-bold mt-2">1.000.000₫</p>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProductDetailPage;


--- File: client/src/pages/Products/index.js ---
// src/pages/Products/index.js
// Trang hiển thị danh sách sản phẩm, bao gồm bộ lọc và breadcrumb

import React, { useEffect, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import { useAppSelector, useAppDispatch } from '../../store/hooks';
import { fetchProducts } from '../../store/slices/productSlice';
import ProductList from '../../components/feature/Product/ProductList';
import ProductFilter from '../../components/feature/Product/ProductFilter';
import CategoryBreadcrumb from '../../components/feature/Category/CategoryBreadcrumb';
import MainLayout from '../../components/layout/MainLayout';
import LoadingSpinner from '../../components/common/LoadingSpiner';

const ProductsPage = () => {
  const { categoryId } = useParams();
  const dispatch = useAppDispatch();
  const { products, isLoading, filters } = useAppSelector((state) => state.products);

  // Fetch sản phẩm khi component mount hoặc categoryId thay đổi
  useEffect(() => {
    dispatch(fetchProducts({ categoryId }));
  }, [dispatch, categoryId]);

  // Sử dụng useMemo để tối ưu hóa filtering
  const filteredProducts = useMemo(() => {
    if (!products.length) return [];

    return products.filter((product) => {
      // Filter by price range
      if (filters.minPrice && product.price < filters.minPrice) {
        return false;
      }
      if (filters.maxPrice && product.price > filters.maxPrice) {
        return false;
      }

      // Filter by brand
      if (filters.brand && product.brand !== filters.brand) {
        return false;
      }

      // Filter by stock
      if (filters.inStock && !product.inStock) {
        return false;
      }

      return true;
    });
  }, [products, filters]);

  return (
    <MainLayout>
      <div className="container mx-auto py-8 px-4">
        <CategoryBreadcrumb categoryId={categoryId} />
        <h1 className="text-3xl font-bold mb-6">Sản Phẩm Billiard</h1>

        <div className="flex flex-col md:flex-row gap-6">
          <div className="w-full md:w-1/4">
            <ProductFilter />
          </div>

          <div className="w-full md:w-3/4">
            {isLoading ? (
              <div className="flex justify-center py-12">
                <LoadingSpinner />
              </div>
            ) : (
              <ProductList products={filteredProducts} />
            )}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProductsPage;


--- File: client/src/pages/Profile/OrderDetail.js ---
// src/pages/Profile/OrderDetail.js
import React from 'react';
import { Link, useParams } from 'react-router-dom';
import MainLayout from '../../components/layout/MainLayout';
import OrderDetail from '../../components/feature/User/OrderDetail';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const OrderDetailPage = () => {
  const { orderId } = useParams();

  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center mb-6">
          <Link to="/profile/orders" className="text-blue-600 hover:text-blue-800 mr-2">
            ← Quay lại
          </Link>
          <h1 className="text-2xl font-bold">Chi tiết đơn hàng</h1>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            <OrderDetail />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default OrderDetailPage;


--- File: client/src/pages/Profile/Orders.js ---
// src/pages/Profile/Orders.js
import React from 'react';
import MainLayout from '../../components/layout/MainLayout';
import UserOrders from '../../components/feature/User/UserOrders';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const OrdersPage = () => {
  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">Đơn hàng của tôi</h1>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            <UserOrders />
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default OrdersPage;


--- File: client/src/pages/Profile/index.js ---
// src/pages/Profile/index.js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUserProfile } from '../../store/slices/userSlice';
import MainLayout from '../../components/layout/MainLayout';
import UserProfile from '../../components/feature/User/UserProfile';
import { LoadingSpinner } from '../../components/common/LoadingSpinner';
import ProfileSidebar from '../../components/feature/User/ProfileSidebar';

const ProfilePage = () => {
  const dispatch = useDispatch();
  const { loading, error } = useSelector((state) => state.user);

  useEffect(() => {
    dispatch(fetchUserProfile());
  }, [dispatch]);

  if (loading) {
    return (
      <MainLayout>
        <div className="flex justify-center items-center py-12">
          <LoadingSpinner />
        </div>
      </MainLayout>
    );
  }

  return (
    <MainLayout>
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">Tài khoản của tôi</h1>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          <div className="lg:col-span-1">
            <ProfileSidebar />
          </div>
          <div className="lg:col-span-3">
            {error ? (
              <div className="bg-red-100 text-red-700 p-4 rounded">{error}</div>
            ) : (
              <UserProfile />
            )}
          </div>
        </div>
      </div>
    </MainLayout>
  );
};

export default ProfilePage;


--- File: client/src/pages/Search/index.js ---
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useLocation } from 'react-router-dom';
import { searchProducts, setKeyword } from '../../store/slices/searchSlice';
import ProductCard from '../../components/feature/Product/ProductCard';
import SearchFilters from '../../components/feature/Search/SearchFilters';
import Breadcrumb from '../../components/common/Breadcrumb';
import LoadingSpinner from '../../components/common/LoadingSpinner';
import EmptyState from '../../components/common/Empty';
import ErrorMessage from '../../components/common/ErrorMessage';

const SearchPage = () => {
  const dispatch = useDispatch();
  const location = useLocation();
  const { results, loading, error, keyword } = useSelector((state) => state.search);

  // Extract search query from URL
  useEffect(() => {
    const searchParams = new URLSearchParams(location.search);
    const queryParam = searchParams.get('q');

    if (queryParam) {
      dispatch(setKeyword(queryParam));
      dispatch(searchProducts(queryParam));
    }
  }, [dispatch, location.search]);

  return (
    <div className="container mx-auto px-4 py-8">
      <Breadcrumb
        items={[
          { label: 'Trang chủ', path: '/' },
          { label: 'Tìm kiếm', path: '/search' },
          { label: keyword, path: `/search?q=${encodeURIComponent(keyword)}` },
        ]}
      />

      <h1 className="text-2xl font-bold mb-6">Kết quả tìm kiếm cho `{keyword}`</h1>

      <div className="flex flex-col md:flex-row gap-6">
        {/* Sidebar with filters */}
        <div className="w-full md:w-1/4 lg:w-1/5">
          <SearchFilters />
        </div>

        {/* Search results */}
        <div className="w-full md:w-3/4 lg:w-4/5">
          {loading ? (
            <LoadingSpinner />
          ) : error ? (
            <ErrorMessage message={error} />
          ) : results.length === 0 ? (
            <EmptyState message={`Không tìm thấy sản phẩm nào phù hợp với "${keyword}"`} />
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {results.map((product) => (
                <ProductCard key={product.id} product={product} />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default SearchPage;


--- File: client/src/services/adminService.js ---
// src/services/adminService.js

import api from './api';

const adminService = {
  // Dashboard Stats
  getDashboardStats: async () => {
    try {
      const response = await api.get('/admin/dashboard/stats');
      return response.data;
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      throw error;
    }
  },

  // Recent Orders
  getRecentOrders: async () => {
    try {
      const response = await api.get('/admin/orders/recent');
      return response.data;
    } catch (error) {
      console.error('Error fetching recent orders:', error);
      throw error;
    }
  },

  // Sales Data
  getSalesData: async (period = 'monthly') => {
    try {
      const response = await api.get(`/admin/dashboard/sales?period=${period}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching sales data:', error);
      throw error;
    }
  },

  // Product Management
  getProducts: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/products?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching products:', error);
      throw error;
    }
  },

  // Order Management
  getOrders: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/orders?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching orders:', error);
      throw error;
    }
  },

  // User Management
  getUsers: async (page = 1, limit = 10, filters = {}) => {
    try {
      const queryParams = new URLSearchParams({
        page,
        limit,
        ...filters,
      }).toString();

      const response = await api.get(`/admin/users?${queryParams}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching users:', error);
      throw error;
    }
  },
};

export default adminService;


--- File: client/src/services/api.js ---
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { refreshToken } from '../utils/authToken';

// URL cơ sở của API
const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Truy vấn cơ sở tùy chỉnh với khả năng làm mới token
const baseQueryWithReauth = async (args, api, extraOptions) => {
  const baseQuery = fetchBaseQuery({
    baseUrl,
    prepareHeaders: (headers, { getState }) => {
      // Lấy token từ state
      const token = getState().auth.token;

      // Nếu có token, thêm vào header
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }

      return headers;
    },
  });

  // Thử nghiệm đầu tiên với token hiện tại
  let result = await baseQuery(args, api, extraOptions);

  // Nếu nhận được phản hồi 401 Unauthorized, thử làm mới token
  if (result.error && result.error.status === 401) {
    try {
      // Cố gắng lấy token mới
      const newToken = await refreshToken();

      // Lưu trữ token mới
      api.dispatch({
        type: 'auth/tokenRefreshed',
        payload: newToken,
      });

      // Thử lại truy vấn ban đầu với token mới
      result = await baseQuery(args, api, extraOptions);
    } catch (refreshError) {
      // Xử lý khi làm mới token thất bại - chuyển hướng đến trang đăng nhập
      window.location.href = '/login';
    }
  }

  return result;
};

// RTK Query API
export const api = createApi({
  reducerPath: 'api',
  baseQuery: baseQueryWithReauth,
  tagTypes: ['Product', 'Category', 'User', 'Cart', 'Order', 'Review'],
  endpoints: () => ({}),
});

export default api;


--- File: client/src/services/authService.js ---
import axios from 'axios';
import { api } from './api';

// API base URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
const AUTH_URL = `${API_URL}/auth`;

// Auth API endpoints
export const authApi = api.injectEndpoints({
  endpoints: (builder) => ({
    login: builder.mutation({
      query: (credentials) => ({
        url: '/auth/login',
        method: 'POST',
        body: credentials,
      }),
    }),
    register: builder.mutation({
      query: (userData) => ({
        url: '/auth/register',
        method: 'POST',
        body: userData,
      }),
    }),
    forgotPassword: builder.mutation({
      query: (email) => ({
        url: '/auth/forgot-password',
        method: 'POST',
        body: { email },
      }),
    }),
    resetPassword: builder.mutation({
      query: ({ token, password }) => ({
        url: '/auth/reset-password',
        method: 'POST',
        body: { token, password },
      }),
    }),
    getCurrentUser: builder.query({
      query: () => '/auth/me',
      providesTags: ['User'],
    }),
  }),
});

// Export hooks
export const {
  useLoginMutation,
  useRegisterMutation,
  useForgotPasswordMutation,
  useResetPasswordMutation,
  useGetCurrentUserQuery,
} = authApi;

// Regular API service for use with Redux Thunk
const authService = {
  // Đăng nhập
  login: async (credentials) => {
    return await axios.post(`${AUTH_URL}/login`, credentials);
  },

  // Đăng ký
  register: async (userData) => {
    return await axios.post(`${AUTH_URL}/register`, userData);
  },

  // Quên mật khẩu
  forgotPassword: async (email) => {
    return await axios.post(`${AUTH_URL}/forgot-password`, { email });
  },

  // Đặt lại mật khẩu
  resetPassword: async (token, password) => {
    return await axios.post(`${AUTH_URL}/reset-password`, { token, password });
  },

  // Lấy thông tin người dùng hiện tại
  getCurrentUser: async () => {
    return await axios.get(`${AUTH_URL}/me`);
  },

  // Cập nhật thông tin người dùng
  updateProfile: async (userData) => {
    return await axios.put(`${API_URL}/users/profile`, userData);
  },

  // Đổi mật khẩu
  changePassword: async (passwordData) => {
    return await axios.put(`${API_URL}/users/password`, passwordData);
  },
};

export default authService;


--- File: client/src/services/cartService.js ---
import api from './api';
import { isAuthenticated } from '../utils/authToken';

export const cartService = {
  // Get cart (for authenticated users)
  async getCart() {
    if (!isAuthenticated()) {
      // Return local cart for guest users
      return this.getLocalCart();
    }

    try {
      const { data } = await api.get('/carts/me');
      return data;
    } catch (error) {
      console.error('Error fetching cart:', error);
      throw error;
    }
  },

  // Add item to cart
  async addToCart(productId, quantity = 1) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.addToLocalCart(productId, quantity);
    }

    try {
      const { data } = await api.post('/carts/items', { productId, quantity });
      return data;
    } catch (error) {
      console.error('Error adding item to cart:', error);
      throw error;
    }
  },

  // Update cart item
  async updateCartItem(productId, quantity) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.updateLocalCartItem(productId, quantity);
    }

    try {
      const { data } = await api.put(`/carts/items/${productId}`, { quantity });
      return data;
    } catch (error) {
      console.error('Error updating cart item:', error);
      throw error;
    }
  },

  // Remove item from cart
  async removeFromCart(productId) {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.removeFromLocalCart(productId);
    }

    try {
      const { data } = await api.delete(`/carts/items/${productId}`);
      return data;
    } catch (error) {
      console.error('Error removing item from cart:', error);
      throw error;
    }
  },

  // Clear cart
  async clearCart() {
    if (!isAuthenticated()) {
      // Use local cart for guest users
      return this.clearLocalCart();
    }

    try {
      const { data } = await api.delete('/carts/items');
      return data;
    } catch (error) {
      console.error('Error clearing cart:', error);
      throw error;
    }
  },

  // Local cart methods (for guest users)
  getLocalCart() {
    const cartJson = localStorage.getItem('guest_cart');
    return cartJson ? JSON.parse(cartJson) : { items: [] };
  },

  saveLocalCart(cart) {
    localStorage.setItem('guest_cart', JSON.stringify(cart));
    return cart;
  },

  async addToLocalCart(productId, quantity) {
    // Fetch product details first
    const { data: product } = await api.get(`/products/${productId}`);

    // Get current cart
    const cart = this.getLocalCart();

    // Check if product already exists in cart
    const existingItemIndex = cart.items.findIndex((item) => item.product.id === productId);

    if (existingItemIndex !== -1) {
      // Update quantity if product already exists
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item to cart
      cart.items.push({
        product,
        quantity,
      });
    }

    // Save updated cart
    return this.saveLocalCart(cart);
  },

  updateLocalCartItem(productId, quantity) {
    // Get current cart
    const cart = this.getLocalCart();

    // Find item in cart
    const itemIndex = cart.items.findIndex((item) => item.product.id === productId);

    if (itemIndex !== -1) {
      // Update quantity
      cart.items[itemIndex].quantity = quantity;

      // Save updated cart
      return this.saveLocalCart(cart);
    }

    return cart;
  },

  removeFromLocalCart(productId) {
    // Get current cart
    const cart = this.getLocalCart();

    // Remove item from cart
    cart.items = cart.items.filter((item) => item.product.id !== productId);

    // Save updated cart
    return this.saveLocalCart(cart);
  },

  clearLocalCart() {
    // Clear cart
    const emptyCart = { items: [] };

    // Save empty cart
    return this.saveLocalCart(emptyCart);
  },
};


--- File: client/src/services/notificationService.js ---
// services/notificationService.js
import api from './api';

/**
 * Service for notification-related API calls
 */
const notificationService = {
  /**
   * Get all notifications for current user
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Object>} Notifications with pagination data
   */
  async getNotifications(params = {}) {
    try {
      const response = await api.get('/notifications', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching notifications:', error);
      throw error;
    }
  },

  /**
   * Get unread notifications count
   * @returns {Promise<number>} Number of unread notifications
   */
  async getUnreadCount() {
    try {
      const response = await api.get('/notifications/unread/count');
      return response.data.count;
    } catch (error) {
      console.error('Error fetching unread count:', error);
      throw error;
    }
  },

  /**
   * Mark notification as read
   * @param {string} notificationId - ID of the notification
   * @returns {Promise<Object>} Updated notification
   */
  async markAsRead(notificationId) {
    try {
      const response = await api.put(`/notifications/${notificationId}/read`);
      return response.data;
    } catch (error) {
      console.error(`Error marking notification ${notificationId} as read:`, error);
      throw error;
    }
  },

  /**
   * Mark all notifications as read
   * @returns {Promise<Object>} Success message
   */
  async markAllAsRead() {
    try {
      const response = await api.put('/notifications/read-all');
      return response.data;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      throw error;
    }
  },

  /**
   * Delete a notification
   * @param {string} notificationId - ID of the notification
   * @returns {Promise<Object>} Success message
   */
  async deleteNotification(notificationId) {
    try {
      const response = await api.delete(`/notifications/${notificationId}`);
      return response.data;
    } catch (error) {
      console.error(`Error deleting notification ${notificationId}:`, error);
      throw error;
    }
  },

  /**
   * Delete all notifications
   * @returns {Promise<Object>} Success message
   */
  async deleteAllNotifications() {
    try {
      const response = await api.delete('/notifications');
      return response.data;
    } catch (error) {
      console.error('Error deleting all notifications:', error);
      throw error;
    }
  },

  /**
   * Update notification preferences
   * @param {Object} preferences - Notification preferences
   * @returns {Promise<Object>} Updated preferences
   */
  async updatePreferences(preferences) {
    try {
      const response = await api.put('/notifications/preferences', preferences);
      return response.data;
    } catch (error) {
      console.error('Error updating notification preferences:', error);
      throw error;
    }
  },

  /**
   * Get notification preferences
   * @returns {Promise<Object>} Current notification preferences
   */
  async getPreferences() {
    try {
      const response = await api.get('/notifications/preferences');
      return response.data;
    } catch (error) {
      console.error('Error fetching notification preferences:', error);
      throw error;
    }
  },

  /**
   * Initialize WebSocket connection for real-time notifications
   * @returns {WebSocket} WebSocket connection
   */
  initializeWebSocket() {
    const token = localStorage.getItem('token');
    if (!token) {
      console.warn('No authentication token available for WebSocket connection');
      return null;
    }

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = process.env.REACT_APP_WS_HOST || window.location.host;
    const wsUrl = `${wsProtocol}//${wsHost}/ws/notifications?token=${token}`;

    try {
      const socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log('WebSocket connection established for notifications');
      };

      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      socket.onclose = (event) => {
        console.log('WebSocket connection closed:', event.code, event.reason);

        // Attempt to reconnect after 5 seconds if connection was closed unexpectedly
        if (event.code !== 1000) {
          setTimeout(() => {
            console.log('Attempting to reconnect WebSocket...');
            this.initializeWebSocket();
          }, 5000);
        }
      };

      return socket;
    } catch (error) {
      console.error('Error initializing WebSocket:', error);
      return null;
    }
  },
};

export default notificationService;


--- File: client/src/services/orderService.js ---
// src/services/orderService.js
import api from './api';

export const orderService = {
  // Tạo đơn hàng mới
  async createOrder(orderData) {
    try {
      const response = await api.post('/orders', orderData);
      return response.data.data;
    } catch (error) {
      console.error('Error creating order:', error);
      throw error;
    }
  },

  // Lấy danh sách đơn hàng của người dùng
  async getUserOrders() {
    try {
      const response = await api.get('/orders');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user orders:', error);
      throw error;
    }
  },

  // Lấy thông tin chi tiết đơn hàng
  async getOrderById(orderId) {
    try {
      const response = await api.get(`/orders/${orderId}`);
      return response.data.data;
    } catch (error) {
      console.error(`Error fetching order ${orderId}:`, error);
      throw error;
    }
  },

  // Hủy đơn hàng
  async cancelOrder(orderId) {
    try {
      const response = await api.post(`/orders/${orderId}/cancel`);
      return response.data.data;
    } catch (error) {
      console.error(`Error cancelling order ${orderId}:`, error);
      throw error;
    }
  },
};


--- File: client/src/services/paymentService.js ---
// src/services/paymentService.js
// File này chứa các dịch vụ liên quan đến thanh toán trong ứng dụng
// Hỗ trợ nhiều cổng thanh toán như VNPay, Momo, v.v.

import api from './api';

const paymentService = {
  // === VNPay Payment Methods ===

  // Tạo URL thanh toán VNPay
  createVnpayPaymentUrl: async (orderId, amount, orderInfo) => {
    try {
      const response = await api.post('/payments/vnpay/create-payment-url', {
        orderId,
        amount,
        orderInfo,
      });
      return response.data;
    } catch (error) {
      console.error('Error creating VNPay payment URL:', error);
      throw error;
    }
  },

  // Xác thực kết quả thanh toán từ VNPay
  verifyVnpayReturn: async (vnpParams) => {
    try {
      const response = await api.post('/payments/vnpay/verify-return', vnpParams);
      return response.data;
    } catch (error) {
      console.error('Error verifying VNPay return:', error);
      throw error;
    }
  },

  // === Momo Payment Methods ===

  // Tạo URL thanh toán Momo
  createMomoPaymentUrl: async (orderId, amount, orderInfo) => {
    try {
      const response = await api.post('/payments/momo/create-payment-url', {
        orderId,
        amount,
        orderInfo,
      });
      return response.data;
    } catch (error) {
      console.error('Error creating Momo payment URL:', error);
      throw error;
    }
  },

  // Xác thực kết quả thanh toán từ Momo
  verifyMomoReturn: async (momoParams) => {
    try {
      const response = await api.post('/payments/momo/verify-return', momoParams);
      return response.data;
    } catch (error) {
      console.error('Error verifying Momo return:', error);
      throw error;
    }
  },

  // === Generic Payment Methods ===

  // Lấy lịch sử thanh toán của người dùng hiện tại
  getPaymentHistory: async () => {
    try {
      const response = await api.get('/payments/history');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching payment history:', error);
      throw error;
    }
  },

  // Lấy chi tiết một giao dịch thanh toán
  getPaymentDetail: async (paymentId) => {
    try {
      const response = await api.get(`/payments/${paymentId}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching payment detail:', error);
      throw error;
    }
  },

  // Hủy một giao dịch thanh toán
  cancelPayment: async (paymentId, reason) => {
    try {
      const response = await api.post(`/payments/${paymentId}/cancel`, { reason });
      return response.data.data;
    } catch (error) {
      console.error('Error canceling payment:', error);
      throw error;
    }
  },
};

export default paymentService;


--- File: client/src/services/productService.js ---
import axios from 'axios';
import { api } from './api';

// API base URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
const PRODUCTS_URL = `${API_URL}/products`;
const CATEGORIES_URL = `${API_URL}/categories`;

// Products API endpoints
export const productApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: (params) => ({
        url: '/products',
        params,
      }),
      providesTags: (result) =>
        result
          ? [
              ...result.products.map(({ id }) => ({ type: 'Product', id })),
              { type: 'Product', id: 'LIST' },
            ]
          : [{ type: 'Product', id: 'LIST' }],
    }),
    getProductById: builder.query({
      query: (id) => `/products/${id}`,
      providesTags: (result, error, id) => [{ type: 'Product', id }],
    }),
    getCategories: builder.query({
      query: () => '/categories',
      providesTags: [{ type: 'Category', id: 'LIST' }],
    }),
    getProductReviews: builder.query({
      query: (id) => `/products/${id}/reviews`,
      providesTags: (result, error, id) => [{ type: 'Review', id: `product-${id}` }],
    }),
  }),
});

// Export hooks
export const {
  useGetProductsQuery,
  useGetProductByIdQuery,
  useGetCategoriesQuery,
  useGetProductReviewsQuery,
} = productApi;

// Regular API service for use with Redux Thunk
const productService = {
  /**
   * Lấy danh sách sản phẩm
   * @param {Object} params - Tham số lọc và phân trang
   * @returns {Promise<Object>} Danh sách sản phẩm và thông tin phân trang
   */
  getProducts: async (params = {}) => {
    const response = await api.get('/products', { params });
    return response.data;
  },

  /**
   * Lấy chi tiết sản phẩm theo ID
   * @param {string} id - ID sản phẩm
   * @returns {Promise<Object>} Thông tin chi tiết sản phẩm
   */
  getProductById: async (id) => {
    const response = await api.get(`/products/${id}`);
    return response.data;
  },

  /**
   * Lấy sản phẩm theo danh mục
   * @param {string} categoryId - ID danh mục
   * @param {Object} params - Tham số lọc và phân trang
   * @returns {Promise<Object>} Danh sách sản phẩm và thông tin phân trang
   */
  getProductsByCategory: async (categoryId, params = {}) => {
    const response = await api.get(`/categories/${categoryId}/products`, { params });
    return response.data;
  },

  /**
   * Tìm kiếm sản phẩm
   * @param {string} query - Từ khóa tìm kiếm
   * @param {Object} params - Tham số lọc và phân trang
   * @returns {Promise<Object>} Kết quả tìm kiếm
   */
  searchProducts: async (query, params = {}) => {
    const response = await api.get('/products/search', {
      params: {
        q: query,
        ...params,
      },
    });
    return response.data;
  },
};

export default productService;


--- File: client/src/services/reviewService.js ---
// src/services/reviewService.js
import api from './api';

export const reviewService = {
  // Lấy đánh giá của sản phẩm
  async getProductReviews(productId) {
    try {
      const response = await api.get(`/products/${productId}/reviews`);
      return response.data.data;
    } catch (error) {
      console.error(`Error fetching reviews for product ${productId}:`, error);
      throw error;
    }
  },

  // Tạo đánh giá mới
  async createReview(reviewData) {
    try {
      const response = await api.post(`/products/${reviewData.productId}/reviews`, reviewData);
      return response.data.data;
    } catch (error) {
      console.error('Error creating review:', error);
      throw error;
    }
  },

  // Lấy đánh giá của người dùng
  async getUserReviews() {
    try {
      const response = await api.get('/reviews/user');
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user reviews:', error);
      throw error;
    }
  },

  // Cập nhật đánh giá
  async updateReview(reviewId, reviewData) {
    try {
      const response = await api.put(`/reviews/${reviewId}`, reviewData);
      return response.data.data;
    } catch (error) {
      console.error(`Error updating review ${reviewId}:`, error);
      throw error;
    }
  },

  // Xóa đánh giá
  async deleteReview(reviewId) {
    try {
      const response = await api.delete(`/reviews/${reviewId}`);
      return response.data.data;
    } catch (error) {
      console.error(`Error deleting review ${reviewId}:`, error);
      throw error;
    }
  },
};


--- File: client/src/services/userService.js ---
// services/userService.js
import api from './api';

/**
 * Service for user-related API calls
 */
const userService = {
  /**
   * Get current user profile
   * @returns {Promise<Object>} User profile data
   */
  async getCurrentUser() {
    try {
      const response = await api.get('/users/me');
      return response.data;
    } catch (error) {
      console.error('Error fetching user profile:', error);
      throw error;
    }
  },

  /**
   * Update user profile
   * @param {Object} userData - User data to update
   * @returns {Promise<Object>} Updated user data
   */
  async updateProfile(userData) {
    try {
      const response = await api.put('/users/me', userData);
      return response.data;
    } catch (error) {
      console.error('Error updating user profile:', error);
      throw error;
    }
  },

  /**
   * Change user password
   * @param {Object} passwordData - Contains current and new password
   * @returns {Promise<Object>} Success message
   */
  async changePassword(passwordData) {
    try {
      const response = await api.put('/users/change-password', passwordData);
      return response.data;
    } catch (error) {
      console.error('Error changing password:', error);
      throw error;
    }
  },

  /**
   * Get user order history
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Array>} List of user orders
   */
  async getOrders(params = {}) {
    try {
      const response = await api.get('/users/orders', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching user orders:', error);
      throw error;
    }
  },

  /**
   * Get specific order details
   * @param {string} orderId - ID of the order
   * @returns {Promise<Object>} Order details
   */
  async getOrderDetails(orderId) {
    try {
      const response = await api.get(`/users/orders/${orderId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching order details for order ${orderId}:`, error);
      throw error;
    }
  },

  /**
   * Get user reviews
   * @param {Object} params - Query parameters for pagination/filtering
   * @returns {Promise<Array>} List of user reviews
   */
  async getReviews(params = {}) {
    try {
      const response = await api.get('/users/reviews', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching user reviews:', error);
      throw error;
    }
  },

  /**
   * Upload user avatar
   * @param {FormData} formData - Form data containing the avatar image
   * @returns {Promise<Object>} Updated user data with new avatar URL
   */
  async uploadAvatar(formData) {
    try {
      const response = await api.post('/users/avatar', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading avatar:', error);
      throw error;
    }
  },

  /**
   * Get user shipping addresses
   * @returns {Promise<Array>} List of user addresses
   */
  async getAddresses() {
    try {
      const response = await api.get('/users/addresses');
      return response.data;
    } catch (error) {
      console.error('Error fetching addresses:', error);
      throw error;
    }
  },

  /**
   * Add new shipping address
   * @param {Object} addressData - Address information
   * @returns {Promise<Object>} Created address
   */
  async addAddress(addressData) {
    try {
      const response = await api.post('/users/addresses', addressData);
      return response.data;
    } catch (error) {
      console.error('Error adding address:', error);
      throw error;
    }
  },

  /**
   * Update existing shipping address
   * @param {string} addressId - ID of the address
   * @param {Object} addressData - Updated address information
   * @returns {Promise<Object>} Updated address
   */
  async updateAddress(addressId, addressData) {
    try {
      const response = await api.put(`/users/addresses/${addressId}`, addressData);
      return response.data;
    } catch (error) {
      console.error(`Error updating address ${addressId}:`, error);
      throw error;
    }
  },

  /**
   * Delete shipping address
   * @param {string} addressId - ID of the address
   * @returns {Promise<Object>} Success message
   */
  async deleteAddress(addressId) {
    try {
      const response = await api.delete(`/users/addresses/${addressId}`);
      return response.data;
    } catch (error) {
      console.error(`Error deleting address ${addressId}:`, error);
      throw error;
    }
  },
};

export default userService;


--- File: client/src/services/wishlistService.js ---
// services/wishlistService.js
import api from './api';

/**
 * Service for wishlist-related API calls
 */
const wishlistService = {
  /**
   * Get all wishlist items
   * @returns {Promise<Array>} List of wishlist items
   */
  async getWishlist() {
    try {
      const response = await api.get('/wishlist');
      return response.data;
    } catch (error) {
      console.error('Error fetching wishlist:', error);
      throw error;
    }
  },

  /**
   * Add product to wishlist
   * @param {string} productId - Product ID to add to wishlist
   * @returns {Promise<Object>} Added wishlist item or success message
   */
  async addToWishlist(productId) {
    try {
      const response = await api.post('/wishlist', { productId });
      return response.data;
    } catch (error) {
      console.error('Error adding to wishlist:', error);
      throw error;
    }
  },

  /**
   * Remove product from wishlist
   * @param {string} productId - Product ID to remove from wishlist
   * @returns {Promise<Object>} Success message
   */
  async removeFromWishlist(productId) {
    try {
      const response = await api.delete(`/wishlist/${productId}`);
      return response.data;
    } catch (error) {
      console.error('Error removing from wishlist:', error);
      throw error;
    }
  },

  /**
   * Check if product is in wishlist
   * @param {string} productId - Product ID to check
   * @returns {Promise<boolean>} True if product is in wishlist
   */
  async checkInWishlist(productId) {
    try {
      const response = await api.get(`/wishlist/check/${productId}`);
      return response.data.inWishlist;
    } catch (error) {
      console.error('Error checking wishlist status:', error);
      throw error;
    }
  },

  /**
   * Clear entire wishlist
   * @returns {Promise<Object>} Success message
   */
  async clearWishlist() {
    try {
      const response = await api.delete('/wishlist');
      return response.data;
    } catch (error) {
      console.error('Error clearing wishlist:', error);
      throw error;
    }
  },

  /**
   * Move all wishlist items to cart
   * @returns {Promise<Object>} Success message and cart information
   */
  async moveAllToCart() {
    try {
      const response = await api.post('/wishlist/move-to-cart');
      return response.data;
    } catch (error) {
      console.error('Error moving wishlist to cart:', error);
      throw error;
    }
  },

  /**
   * Move a single wishlist item to cart
   * @param {string} productId - Product ID to move to cart
   * @returns {Promise<Object>} Success message and cart information
   */
  async moveToCart(productId) {
    try {
      const response = await api.post(`/wishlist/move-to-cart/${productId}`);
      return response.data;
    } catch (error) {
      console.error('Error moving item to cart:', error);
      throw error;
    }
  },
};

export default wishlistService;


--- File: client/src/store/hooks.js ---
import { useDispatch, useSelector } from 'react-redux';

// Sử dụng hooks này thay vì useDispatch và useSelector thông thường
export const useAppDispatch = () => useDispatch();
export const useAppSelector = useSelector;


--- File: client/src/store/index.js ---
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import authReducer, { authMiddleware } from './slices/authSlice';
import cartReducer from './slices/cartSlice';
import productReducer from './slices/productSlice';
import uiReducer, { uiMiddleware } from './slices/uiSlice';
import orderReducer from './slices/orderSlice';
import reviewReducer from './slices/reviewSlice';
import checkoutReducer from './slices/checkoutSlice';
import userReducer from './slices/userSlice';
import wishlistReducer from './slices/wishlistSlice';
import notificationReducer from './slices/notificationSlice';
import { api } from '../services/api';

// Hàm tiện ích để thao tác với localStorage an toàn
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`Lỗi khi đọc ${key} từ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`Lỗi khi lưu ${key} vào localStorage:`, error);
      return false;
    }
  },
  removeItem: (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`Lỗi khi xóa ${key} từ localStorage:`, error);
      return false;
    }
  },
};

// Middleware tùy chỉnh để ghi log các actions (chỉ trong môi trường development)
const loggerMiddleware = (store) => (next) => (action) => {
  if (process.env.NODE_ENV !== 'production') {
    console.group(action.type);
    console.info('dispatching', action);
    const result = next(action);
    console.log('next state', store.getState());
    console.groupEnd();
    return result;
  }
  return next(action);
};

// Middleware để lưu state vào localStorage - đã cải tiến với xử lý lỗi
const persistStateMiddleware = (store) => (next) => (action) => {
  const result = next(action);
  try {
    const stateToPersist = {
      cart: store.getState().cart,
      auth: {
        isAuthenticated: store.getState().auth.isAuthenticated,
        user: store.getState().auth.user,
      },
      wishlist: store.getState().wishlist,
    };
    safeLocalStorage.setItem('reduxState', JSON.stringify(stateToPersist));
  } catch (error) {
    console.error('Lỗi khi lưu state vào localStorage:', error);
  }
  return result;
};

// Lấy state từ localStorage khi khởi động - đã cải tiến với safeLocalStorage
const loadState = () => {
  try {
    const serializedState = safeLocalStorage.getItem('reduxState');
    if (serializedState === null) {
      return undefined;
    }
    return JSON.parse(serializedState);
  } catch (err) {
    console.error('Không thể load state từ localStorage:', err);
    return undefined;
  }
};

const preloadedState = loadState();

export const store = configureStore({
  reducer: {
    auth: authReducer,
    cart: cartReducer,
    product: productReducer,
    ui: uiReducer,
    order: orderReducer,
    review: reviewReducer,
    checkout: checkoutReducer,
    user: userReducer,
    wishlist: wishlistReducer,
    notification: notificationReducer,
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Bỏ qua các actions và paths không serializable
        ignoredActions: [
          'checkout/createOrder/fulfilled',
          'auth/login/fulfilled',
          'auth/register/fulfilled',
        ],
        ignoredPaths: ['checkout.paymentUrl', 'auth.user.token', 'ui.modalContent'],
      },
    }).concat(
      api.middleware,
      loggerMiddleware,
      persistStateMiddleware,
      uiMiddleware, // Thêm middleware cho UI
      authMiddleware // Thêm middleware cho Auth
    ),
  preloadedState,
  devTools: process.env.NODE_ENV !== 'production',
});

// Áp dụng theme ban đầu khi ứng dụng khởi động
const initialTheme = store.getState().ui.theme;
if (initialTheme) {
  document.documentElement.classList.add(initialTheme);
}

// Cấu hình listeners cho RTK Query
setupListeners(store.dispatch);

// Hàm tiện ích để dispatch nhiều actions cùng lúc
export const batchDispatch = (actions) => {
  actions.forEach((action) => store.dispatch(action));
};

// Hàm tiện ích để reset toàn bộ state (ví dụ: khi logout)
export const resetStore = () => {
  // Danh sách các actions để reset từng phần của state
  const resetActions = [
    { type: 'auth/logout' },
    { type: 'cart/clearCart' },
    { type: 'ui/resetUI' },
    { type: 'wishlist/clearWishlist' },
    { type: 'notification/clearAll' },
  ];

  batchDispatch(resetActions);
  safeLocalStorage.removeItem('reduxState');
};

// Hooks typing
export * from './hooks';


--- File: client/src/store/slices/adminSlice.js ---
// src/store/slices/adminSlice.js
// File này nằm trong thư mục src/store/slices của dự án React Redux

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import adminService from '../../services/adminService';

// Async thunk actions
export const fetchDashboardStats = createAsyncThunk(
  'admin/fetchDashboardStats',
  async (_, { rejectWithValue }) => {
    try {
      return await adminService.getDashboardStats();
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy thống kê dashboard');
    }
  }
);

export const fetchRecentOrders = createAsyncThunk(
  'admin/fetchRecentOrders',
  async (_, { rejectWithValue }) => {
    try {
      return await adminService.getRecentOrders();
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy đơn hàng gần đây');
    }
  }
);

export const fetchSalesData = createAsyncThunk(
  'admin/fetchSalesData',
  async (period, { rejectWithValue }) => {
    try {
      return await adminService.getSalesData(period);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy dữ liệu doanh thu');
    }
  }
);

// Thêm thunk action quản lý sản phẩm
export const fetchProducts = createAsyncThunk(
  'admin/fetchProducts',
  async ({ page = 1, limit = 10, search = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getProducts(page, limit, search);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy danh sách sản phẩm');
    }
  }
);

export const createProduct = createAsyncThunk(
  'admin/createProduct',
  async (productData, { rejectWithValue, dispatch }) => {
    try {
      const response = await adminService.createProduct(productData);
      // Sau khi tạo sản phẩm thành công, cập nhật lại danh sách
      dispatch(fetchProducts({ page: 1 }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi tạo sản phẩm mới');
    }
  }
);

export const updateProduct = createAsyncThunk(
  'admin/updateProduct',
  async ({ id, productData }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateProduct(id, productData);
      // Sau khi cập nhật sản phẩm thành công, cập nhật lại danh sách
      const { currentPage } = getState().admin;
      dispatch(fetchProducts({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi cập nhật sản phẩm');
    }
  }
);

export const deleteProduct = createAsyncThunk(
  'admin/deleteProduct',
  async (id, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.deleteProduct(id);
      // Sau khi xóa sản phẩm thành công, cập nhật lại danh sách
      const { currentPage } = getState().admin;
      dispatch(fetchProducts({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi xóa sản phẩm');
    }
  }
);

// Thêm thunk action quản lý đơn hàng
export const fetchOrders = createAsyncThunk(
  'admin/fetchOrders',
  async ({ page = 1, limit = 10, status = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getOrders(page, limit, status);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy danh sách đơn hàng');
    }
  }
);

export const updateOrderStatus = createAsyncThunk(
  'admin/updateOrderStatus',
  async ({ id, status }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateOrderStatus(id, status);
      // Sau khi cập nhật trạng thái đơn hàng, cập nhật lại danh sách
      const { currentPage } = getState().admin;
      dispatch(fetchOrders({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Lỗi khi cập nhật trạng thái đơn hàng'
      );
    }
  }
);

// Thêm thunk action quản lý người dùng
export const fetchUsers = createAsyncThunk(
  'admin/fetchUsers',
  async ({ page = 1, limit = 10, search = '' }, { rejectWithValue }) => {
    try {
      return await adminService.getUsers(page, limit, search);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Lỗi khi lấy danh sách người dùng');
    }
  }
);

export const updateUserStatus = createAsyncThunk(
  'admin/updateUserStatus',
  async ({ id, status }, { rejectWithValue, dispatch, getState }) => {
    try {
      const response = await adminService.updateUserStatus(id, status);
      // Sau khi cập nhật trạng thái người dùng, cập nhật lại danh sách
      const { currentPage } = getState().admin;
      dispatch(fetchUsers({ page: currentPage }));
      return response;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Lỗi khi cập nhật trạng thái người dùng'
      );
    }
  }
);

const initialState = {
  stats: null,
  recentOrders: [],
  salesData: [],
  productList: [],
  orderList: [],
  userList: [],
  totalPages: 1,
  currentPage: 1,
  isLoading: false,
  isLoadingSales: false,
  isLoadingProducts: false,
  isLoadingOrders: false,
  isLoadingUsers: false,
  error: null,
};

const adminSlice = createSlice({
  name: 'admin',
  initialState,
  reducers: {
    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Dashboard Stats
      .addCase(fetchDashboardStats.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchDashboardStats.fulfilled, (state, action) => {
        state.isLoading = false;
        state.stats = action.payload;
      })
      .addCase(fetchDashboardStats.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      })

      // Recent Orders
      .addCase(fetchRecentOrders.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchRecentOrders.fulfilled, (state, action) => {
        state.isLoading = false;
        state.recentOrders = action.payload;
      })
      .addCase(fetchRecentOrders.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
      })

      // Sales Data
      .addCase(fetchSalesData.pending, (state) => {
        state.isLoadingSales = true;
      })
      .addCase(fetchSalesData.fulfilled, (state, action) => {
        state.isLoadingSales = false;
        state.salesData = action.payload;
      })
      .addCase(fetchSalesData.rejected, (state, action) => {
        state.isLoadingSales = false;
        state.error = action.payload;
      })

      // Products
      .addCase(fetchProducts.pending, (state) => {
        state.isLoadingProducts = true;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.isLoadingProducts = false;
        state.productList = action.payload.products;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.isLoadingProducts = false;
        state.error = action.payload;
      })

      // Không cần thêm case cho createProduct, updateProduct, deleteProduct
      // vì chúng đã dispatch fetchProducts để cập nhật lại danh sách

      // Orders
      .addCase(fetchOrders.pending, (state) => {
        state.isLoadingOrders = true;
      })
      .addCase(fetchOrders.fulfilled, (state, action) => {
        state.isLoadingOrders = false;
        state.orderList = action.payload.orders;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchOrders.rejected, (state, action) => {
        state.isLoadingOrders = false;
        state.error = action.payload;
      })

      // Users
      .addCase(fetchUsers.pending, (state) => {
        state.isLoadingUsers = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.isLoadingUsers = false;
        state.userList = action.payload.users;
        state.totalPages = action.payload.totalPages;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoadingUsers = false;
        state.error = action.payload;
      });
  },
});

export const { setCurrentPage, clearError } = adminSlice.actions;

export default adminSlice.reducer;


--- File: client/src/store/slices/authSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from '../../services/authService';
import { setAuthToken, removeAuthToken } from '../../utils/authToken';

// Hàm tiện ích để thao tác với localStorage an toàn
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`Lỗi khi đọc ${key} từ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`Lỗi khi lưu ${key} vào localStorage:`, error);
      return false;
    }
  },
  removeItem: (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`Lỗi khi xóa ${key} từ localStorage:`, error);
      return false;
    }
  },
};

// Async thunks
export const login = createAsyncThunk('auth/login', async (credentials, { rejectWithValue }) => {
  try {
    const response = await authService.login(credentials);
    return response.data;
  } catch (error) {
    return rejectWithValue(error.response?.data?.message || 'Đăng nhập thất bại');
  }
});

export const register = createAsyncThunk('auth/register', async (userData, { rejectWithValue }) => {
  try {
    const response = await authService.register(userData);
    return response.data;
  } catch (error) {
    return rejectWithValue(error.response?.data?.message || 'Đăng ký thất bại');
  }
});

export const fetchCurrentUser = createAsyncThunk(
  'auth/fetchCurrentUser',
  async (_, { rejectWithValue }) => {
    try {
      const response = await authService.getCurrentUser();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy thông tin người dùng');
    }
  }
);

// Initial state
const initialState = {
  user: null,
  token: safeLocalStorage.getItem('token'),
  isAuthenticated: !!safeLocalStorage.getItem('token'),
  loading: false,
  error: null,
};

// Slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      // Không thao tác với localStorage và removeAuthToken ở đây nữa
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Login
      .addCase(login.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Không thao tác với localStorage và setAuthToken ở đây nữa
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Register
      .addCase(register.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Không thao tác với localStorage và setAuthToken ở đây nữa
      })
      .addCase(register.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch current user
      .addCase(fetchCurrentUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCurrentUser.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(fetchCurrentUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
        // Nếu token không hợp lệ, đăng xuất người dùng
        if (action.payload === 'Unauthorized' || action.payload === 'Invalid token') {
          state.user = null;
          state.token = null;
          state.isAuthenticated = false;
          // Không thao tác với localStorage và removeAuthToken ở đây nữa
        }
      });
  },
});

// Actions
export const { logout, clearError } = authSlice.actions;

// Selectors
export const selectAuth = (state) => state.auth;
export const selectIsAuthenticated = (state) => state.auth.isAuthenticated;
export const selectUser = (state) => state.auth.user;
export const selectAuthLoading = (state) => state.auth.loading;
export const selectAuthError = (state) => state.auth.error;

// Middleware để xử lý side effects (như localStorage và authToken)
export const authMiddleware = (store) => (next) => (action) => {
  // Xử lý trước khi action được dispatch
  const result = next(action);

  // Xử lý sau khi action đã được dispatch
  if (login.fulfilled.match(action) || register.fulfilled.match(action)) {
    // Lưu token vào localStorage và thiết lập header cho axios
    safeLocalStorage.setItem('token', action.payload.token);
    setAuthToken(action.payload.token);
  } else if (
    logout.match(action) ||
    (fetchCurrentUser.rejected.match(action) &&
      (action.payload === 'Unauthorized' || action.payload === 'Invalid token'))
  ) {
    // Xóa token khỏi localStorage và header
    safeLocalStorage.removeItem('token');
    removeAuthToken();
  }

  return result;
};

// Reducer
export default authSlice.reducer;


--- File: client/src/store/slices/cartSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { cartService } from '../../services/cartService';

// Async thunks
export const fetchCart = createAsyncThunk('cart/fetchCart', async (_, { rejectWithValue }) => {
  try {
    return await cartService.getCart();
  } catch (error) {
    return rejectWithValue(error.message);
  }
});

export const addToCartAsync = createAsyncThunk(
  'cart/addToCartAsync',
  async ({ productId, quantity }, { rejectWithValue }) => {
    try {
      return await cartService.addToCart(productId, quantity);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateCartItemAsync = createAsyncThunk(
  'cart/updateCartItemAsync',
  async ({ productId, quantity }, { rejectWithValue }) => {
    try {
      return await cartService.updateCartItem(productId, quantity);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const removeFromCartAsync = createAsyncThunk(
  'cart/removeFromCartAsync',
  async (productId, { rejectWithValue }) => {
    try {
      return await cartService.removeFromCart(productId);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const clearCartAsync = createAsyncThunk(
  'cart/clearCartAsync',
  async (_, { rejectWithValue }) => {
    try {
      return await cartService.clearCart();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Helper functions
const calculateTotals = (items) => {
  return items.reduce(
    (totals, item) => {
      const itemTotal = item.product.price * item.quantity;
      return {
        itemsCount: totals.itemsCount + item.quantity,
        subtotal: totals.subtotal + itemTotal,
      };
    },
    { itemsCount: 0, subtotal: 0 }
  );
};

// Initial state
const initialState = {
  items: [],
  itemsCount: 0,
  subtotal: 0,
  loading: false,
  error: null,
};

// Slice
const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    // Local cart actions (for guest users)
    addToCart: (state, action) => {
      const { product, quantity = 1 } = action.payload;

      // Check if product already exists in cart
      const existingItem = state.items.find((item) => item.product.id === product.id);

      if (existingItem) {
        // Update quantity if product already exists
        existingItem.quantity += quantity;
      } else {
        // Add new item to cart
        state.items.push({
          product,
          quantity,
        });
      }

      // Update totals
      const { itemsCount, subtotal } = calculateTotals(state.items);
      state.itemsCount = itemsCount;
      state.subtotal = subtotal;
    },

    updateCartItem: (state, action) => {
      const { productId, quantity } = action.payload;

      // Find item in cart
      const item = state.items.find((item) => item.product.id === productId);

      if (item) {
        // Update quantity
        item.quantity = quantity;

        // Update totals
        const { itemsCount, subtotal } = calculateTotals(state.items);
        state.itemsCount = itemsCount;
        state.subtotal = subtotal;
      }
    },

    removeFromCart: (state, action) => {
      const productId = action.payload;

      // Remove item from cart
      state.items = state.items.filter((item) => item.product.id !== productId);

      // Update totals
      const { itemsCount, subtotal } = calculateTotals(state.items);
      state.itemsCount = itemsCount;
      state.subtotal = subtotal;
    },

    clearCart: (state) => {
      // Reset cart
      state.items = [];
      state.itemsCount = 0;
      state.subtotal = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // Handle fetchCart
      .addCase(fetchCart.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCart.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.items;

        // Calculate totals
        const { itemsCount, subtotal } = calculateTotals(action.payload.items);
        state.itemsCount = itemsCount;
        state.subtotal = subtotal;
      })
      .addCase(fetchCart.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });

    // Handle other async actions with similar patterns
    // ...
  },
});

// Export actions and reducer
export const { addToCart, updateCartItem, removeFromCart, clearCart } = cartSlice.actions;
export default cartSlice.reducer;


--- File: client/src/store/slices/notificationSlice.js ---
// src/store/slices/notificationSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import notificationService from '../../services/notificationService';

// Async thunk để lấy danh sách thông báo
export const fetchNotifications = createAsyncThunk(
  'notification/fetchNotifications',
  async (_, { rejectWithValue }) => {
    try {
      const notifications = await notificationService.getNotifications();
      return notifications;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy thông báo');
    }
  }
);

// Async thunk để đánh dấu thông báo đã đọc
export const markAsRead = createAsyncThunk(
  'notification/markAsRead',
  async (notificationId, { rejectWithValue }) => {
    try {
      await notificationService.markAsRead(notificationId);
      return notificationId;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Không thể đánh dấu thông báo đã đọc'
      );
    }
  }
);

// Async thunk để đánh dấu tất cả thông báo đã đọc
export const markAllAsRead = createAsyncThunk(
  'notification/markAllAsRead',
  async (_, { rejectWithValue }) => {
    try {
      await notificationService.markAllAsRead();
      return true;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Không thể đánh dấu tất cả thông báo đã đọc'
      );
    }
  }
);

// Async thunk để xóa thông báo
export const deleteNotification = createAsyncThunk(
  'notification/deleteNotification',
  async (notificationId, { rejectWithValue }) => {
    try {
      await notificationService.deleteNotification(notificationId);
      return notificationId;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể xóa thông báo');
    }
  }
);

// Async thunk để xóa tất cả thông báo
export const deleteAllNotifications = createAsyncThunk(
  'notification/deleteAllNotifications',
  async (_, { rejectWithValue }) => {
    try {
      await notificationService.deleteAllNotifications();
      return true;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể xóa tất cả thông báo');
    }
  }
);

// Initial state
const initialState = {
  notifications: [],
  unreadCount: 0,
  loading: false,
  error: null,
  operationInProgress: false,
};

// Notification slice
const notificationSlice = createSlice({
  name: 'notification',
  initialState,
  reducers: {
    // Thêm thông báo mới (cho realtime notifications)
    addNewNotification: (state, action) => {
      state.notifications.unshift(action.payload);
      state.unreadCount += 1;
    },
    // Reset trạng thái lỗi
    resetNotificationError: (state) => {
      state.error = null;
    },
    // Clear notifications khi logout
    clearNotifications: (state) => {
      state.notifications = [];
      state.unreadCount = 0;
      state.loading = false;
      state.error = null;
      state.operationInProgress = false;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchNotifications
      .addCase(fetchNotifications.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchNotifications.fulfilled, (state, action) => {
        state.loading = false;
        state.notifications = action.payload.notifications;
        state.unreadCount = action.payload.unreadCount;
      })
      .addCase(fetchNotifications.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi lấy thông báo';
      })

      // markAsRead
      .addCase(markAsRead.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(markAsRead.fulfilled, (state, action) => {
        state.operationInProgress = false;
        const notification = state.notifications.find((item) => item._id === action.payload);
        if (notification && !notification.isRead) {
          notification.isRead = true;
          state.unreadCount = Math.max(0, state.unreadCount - 1);
        }
      })
      .addCase(markAsRead.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi đánh dấu thông báo đã đọc';
      })

      // markAllAsRead
      .addCase(markAllAsRead.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(markAllAsRead.fulfilled, (state) => {
        state.operationInProgress = false;
        state.notifications.forEach((notification) => {
          notification.isRead = true;
        });
        state.unreadCount = 0;
      })
      .addCase(markAllAsRead.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi đánh dấu tất cả thông báo đã đọc';
      })

      // deleteNotification
      .addCase(deleteNotification.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(deleteNotification.fulfilled, (state, action) => {
        state.operationInProgress = false;
        const deletedNotification = state.notifications.find((item) => item._id === action.payload);
        if (deletedNotification && !deletedNotification.isRead) {
          state.unreadCount = Math.max(0, state.unreadCount - 1);
        }
        state.notifications = state.notifications.filter((item) => item._id !== action.payload);
      })
      .addCase(deleteNotification.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi xóa thông báo';
      })

      // deleteAllNotifications
      .addCase(deleteAllNotifications.pending, (state) => {
        state.operationInProgress = true;
      })
      .addCase(deleteAllNotifications.fulfilled, (state) => {
        state.operationInProgress = false;
        state.notifications = [];
        state.unreadCount = 0;
      })
      .addCase(deleteAllNotifications.rejected, (state, action) => {
        state.operationInProgress = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi xóa tất cả thông báo';
      });
  },
});

// Export actions
export const { addNewNotification, resetNotificationError, clearNotifications } =
  notificationSlice.actions;

// Export reducer
export default notificationSlice.reducer;


--- File: client/src/store/slices/orderSlice.js ---
// src/store/slices/orderSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { orderService } from '../../services/orderService';

export const fetchUserOrders = createAsyncThunk(
  'order/fetchUserOrders',
  async (_, { rejectWithValue }) => {
    try {
      const orders = await orderService.getUserOrders();
      return orders;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy danh sách đơn hàng');
    }
  }
);

export const fetchOrderDetail = createAsyncThunk(
  'order/fetchOrderDetail',
  async (orderId, { rejectWithValue }) => {
    try {
      const order = await orderService.getOrderById(orderId);
      return order;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy thông tin đơn hàng');
    }
  }
);

const initialState = {
  orders: [],
  currentOrder: null,
  loading: false,
  error: null,
};

const orderSlice = createSlice({
  name: 'order',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // fetchUserOrders
      .addCase(fetchUserOrders.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserOrders.fulfilled, (state, action) => {
        state.loading = false;
        state.orders = action.payload;
      })
      .addCase(fetchUserOrders.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Có lỗi xảy ra khi lấy danh sách đơn hàng';
      })

      // fetchOrderDetail
      .addCase(fetchOrderDetail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchOrderDetail.fulfilled, (state, action) => {
        state.loading = false;
        state.currentOrder = action.payload;
      })
      .addCase(fetchOrderDetail.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Có lỗi xảy ra khi lấy thông tin đơn hàng';
      });
  },
});

export default orderSlice.reducer;


--- File: client/src/store/slices/productSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import productService from '../../services/productService';

// Async thunk để lấy chi tiết sản phẩm
export const fetchProducts = createAsyncThunk(
  'product/fetchProducts',
  async (params, { rejectWithValue }) => {
    try {
      const response = await productService.getProducts(params);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy danh sách sản phẩm');
    }
  }
);

export const fetchProductById = createAsyncThunk(
  'product/fetchProductById',
  async (id, { rejectWithValue }) => {
    try {
      const response = await productService.getProductById(id);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy thông tin sản phẩm');
    }
  }
);

export const fetchCategories = createAsyncThunk(
  'product/fetchCategories',
  async (_, { rejectWithValue }) => {
    try {
      const response = await productService.getCategories();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy danh mục sản phẩm');
    }
  }
);

// Initial state
const initialState = {
  products: [],
  product: null,
  categories: [],
  filters: {
    category: '',
    priceRange: { min: 0, max: 0 },
    sort: 'newest',
  },
  pagination: {
    page: 1,
    limit: 12,
    total: 0,
    pages: 0,
  },
  loading: false,
  error: null,
};

// Slice
const productSlice = createSlice({
  name: 'product',
  initialState,
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      // Reset trang về 1 khi thay đổi bộ lọc
      state.pagination.page = 1;
    },
    setPage: (state, action) => {
      state.pagination.page = action.payload;
    },
    clearProductError: (state) => {
      state.error = null;
    },
    clearSelectedProduct: (state) => {
      state.product = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch products
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.products = action.payload.products;
        state.pagination = {
          page: action.payload.page,
          limit: action.payload.limit,
          total: action.payload.total,
          pages: action.payload.pages,
        };
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch product by id
      .addCase(fetchProductById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductById.fulfilled, (state, action) => {
        state.loading = false;
        state.product = action.payload;
      })
      .addCase(fetchProductById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // Fetch categories
      .addCase(fetchCategories.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCategories.fulfilled, (state, action) => {
        state.loading = false;
        state.categories = action.payload;
      })
      .addCase(fetchCategories.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Actions
export const { setFilters, setPage, clearProductError, clearSelectedProduct } =
  productSlice.actions;

// Selectors
export const selectProducts = (state) => state.product.products;
export const selectSelectedProduct = (state) => state.product.product;
export const selectCategories = (state) => state.product.categories;
export const selectFilters = (state) => state.product.filters;
export const selectPagination = (state) => state.product.pagination;
export const selectProductLoading = (state) => state.product.loading;
export const selectProductError = (state) => state.product.error;

// Reducer

export default productSlice.reducer;


--- File: client/src/store/slices/reviewSlice.js ---
// src/store/slices/reviewSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { reviewService } from '../../services/reviewService';

export const fetchProductReviews = createAsyncThunk(
  'review/fetchProductReviews',
  async (productId, { rejectWithValue }) => {
    try {
      const result = await reviewService.getProductReviews(productId);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy đánh giá sản phẩm');
    }
  }
);

export const submitProductReview = createAsyncThunk(
  'review/submitProductReview',
  async (reviewData, { rejectWithValue, dispatch }) => {
    try {
      const result = await reviewService.createReview(reviewData);
      // Refetch reviews after submitting
      dispatch(fetchProductReviews(reviewData.productId));
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể gửi đánh giá');
    }
  }
);

export const fetchUserReviews = createAsyncThunk(
  'review/fetchUserReviews',
  async (_, { rejectWithValue }) => {
    try {
      const reviews = await reviewService.getUserReviews();
      return reviews;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy đánh giá của bạn');
    }
  }
);

const initialState = {
  reviews: [],
  userReviews: [],
  stats: {
    average: 0,
    count: 0,
    distribution: {},
  },
  loading: false,
  submitting: false,
  error: null,
};

const reviewSlice = createSlice({
  name: 'review',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // fetchProductReviews
      .addCase(fetchProductReviews.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductReviews.fulfilled, (state, action) => {
        state.loading = false;
        state.reviews = action.payload.reviews;
        state.stats = action.payload.stats;
      })
      .addCase(fetchProductReviews.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Có lỗi xảy ra khi lấy đánh giá';
      })

      // submitProductReview
      .addCase(submitProductReview.pending, (state) => {
        state.submitting = true;
        state.error = null;
      })
      .addCase(submitProductReview.fulfilled, (state) => {
        state.submitting = false;
      })
      .addCase(submitProductReview.rejected, (state, action) => {
        state.submitting = false;
        state.error = action.payload || 'Có lỗi xảy ra khi gửi đánh giá';
      })

      // fetchUserReviews
      .addCase(fetchUserReviews.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserReviews.fulfilled, (state, action) => {
        state.loading = false;
        state.userReviews = action.payload;
      })
      .addCase(fetchUserReviews.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Có lỗi xảy ra khi lấy đánh giá của bạn';
      });
  },
});

export default reviewSlice.reducer;


--- File: client/src/store/slices/searchSlice.js ---
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import productService from '../../services/productService';

// Async thunk for searching products
export const searchProducts = createAsyncThunk(
  'search/searchProducts',
  async (keyword, { rejectWithValue }) => {
    try {
      return await productService.searchProducts(keyword);
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Initial state
const initialState = {
  keyword: '',
  results: [],
  loading: false,
  error: null,
  recentSearches: [],
  filters: {
    category: null,
    priceRange: { min: 0, max: 10000000 },
    sortBy: 'relevance',
  },
};

// Slice
const searchSlice = createSlice({
  name: 'search',
  initialState,
  reducers: {
    setKeyword: (state, action) => {
      state.keyword = action.payload;

      // Add to recent searches if not already there
      if (action.payload && !state.recentSearches.includes(action.payload)) {
        state.recentSearches = [
          action.payload,
          ...state.recentSearches.slice(0, 4), // Keep only 5 most recent
        ];
      }
    },
    clearResults: (state) => {
      state.results = [];
    },
    setSearchFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearSearchFilters: (state) => {
      state.filters = initialState.filters;
    },
    clearRecentSearches: (state) => {
      state.recentSearches = [];
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(searchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.results = action.payload;
      })
      .addCase(searchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// Export actions and reducer
export const {
  setKeyword,
  clearResults,
  setSearchFilters,
  clearSearchFilters,
  clearRecentSearches,
} = searchSlice.actions;

export default searchSlice.reducer;


--- File: client/src/store/slices/uiSlice.js ---
import { createSlice } from '@reduxjs/toolkit';

// Hàm tiện ích để thao tác với localStorage an toàn
const safeLocalStorage = {
  getItem: (key, defaultValue = null) => {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (error) {
      console.error(`Lỗi khi đọc ${key} từ localStorage:`, error);
      return defaultValue;
    }
  },
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.error(`Lỗi khi lưu ${key} vào localStorage:`, error);
      return false;
    }
  },
};

// Initial state
const initialState = {
  sidebarOpen: false,
  notifications: [],
  theme: safeLocalStorage.getItem('theme', 'light'),
};

// Slice
const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    setSidebarOpen: (state, action) => {
      state.sidebarOpen = action.payload;
    },
    addNotification: (state, action) => {
      const id = Date.now().toString();
      state.notifications.push({
        id,
        type: action.payload.type || 'info',
        message: action.payload.message,
        duration: action.payload.duration || 5000,
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(
        (notification) => notification.id !== action.payload
      );
    },
    clearNotifications: (state) => {
      state.notifications = [];
    },
    setTheme: (state, action) => {
      state.theme = action.payload;
      safeLocalStorage.setItem('theme', action.payload);
    },
  },
});

// Actions
export const {
  toggleSidebar,
  setSidebarOpen,
  addNotification,
  removeNotification,
  clearNotifications,
  setTheme,
} = uiSlice.actions;

// Selectors
export const selectSidebarOpen = (state) => state.ui.sidebarOpen;
export const selectNotifications = (state) => state.ui.notifications;
export const selectTheme = (state) => state.ui.theme;

// Middleware để xử lý side effects (như thay đổi DOM)
export const uiMiddleware = (store) => (next) => (action) => {
  // Xử lý trước khi action được dispatch
  const result = next(action);

  // Xử lý sau khi action đã được dispatch
  if (setTheme.match(action)) {
    // Áp dụng theme vào document
    document.documentElement.classList.remove('light', 'dark');
    document.documentElement.classList.add(action.payload);
  }

  return result;
};

// Reducer
export default uiSlice.reducer;


--- File: client/src/store/slices/userSlice.js ---
// src/store/slices/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import userService from '../../services/userService';

// Async thunk để lấy thông tin hồ sơ người dùng
export const fetchUserProfile = createAsyncThunk(
  'user/fetchUserProfile',
  async (_, { rejectWithValue }) => {
    try {
      const user = await userService.getUserProfile();
      return user;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy thông tin người dùng');
    }
  }
);

// Async thunk để cập nhật thông tin hồ sơ người dùng
export const updateUserProfile = createAsyncThunk(
  'user/updateUserProfile',
  async (userData, { rejectWithValue }) => {
    try {
      const updatedUser = await userService.updateUserProfile(userData);
      return updatedUser;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Không thể cập nhật thông tin người dùng'
      );
    }
  }
);

// Async thunk để thay đổi mật khẩu
export const changePassword = createAsyncThunk(
  'user/changePassword',
  async (passwordData, { rejectWithValue }) => {
    try {
      const result = await userService.changePassword(passwordData);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể thay đổi mật khẩu');
    }
  }
);

// Async thunk để cập nhật avatar
export const updateAvatar = createAsyncThunk(
  'user/updateAvatar',
  async (formData, { rejectWithValue }) => {
    try {
      const result = await userService.updateAvatar(formData);
      return result;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể cập nhật ảnh đại diện');
    }
  }
);

// Initial state
const initialState = {
  user: null,
  loading: false,
  error: null,
  passwordUpdateStatus: {
    loading: false,
    success: false,
    error: null,
  },
  avatarUpdateStatus: {
    loading: false,
    success: false,
    error: null,
  },
};

// User slice
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // Reset trạng thái cập nhật mật khẩu
    resetPasswordUpdateStatus: (state) => {
      state.passwordUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
    // Reset trạng thái cập nhật avatar
    resetAvatarUpdateStatus: (state) => {
      state.avatarUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
    // Clear user state khi logout
    clearUserState: (state) => {
      state.user = null;
      state.loading = false;
      state.error = null;
      state.passwordUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
      state.avatarUpdateStatus = {
        loading: false,
        success: false,
        error: null,
      };
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchUserProfile
      .addCase(fetchUserProfile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi lấy thông tin người dùng';
      })

      // updateUserProfile
      .addCase(updateUserProfile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi cập nhật thông tin người dùng';
      })

      // changePassword
      .addCase(changePassword.pending, (state) => {
        state.passwordUpdateStatus.loading = true;
        state.passwordUpdateStatus.success = false;
        state.passwordUpdateStatus.error = null;
      })
      .addCase(changePassword.fulfilled, (state) => {
        state.passwordUpdateStatus.loading = false;
        state.passwordUpdateStatus.success = true;
      })
      .addCase(changePassword.rejected, (state, action) => {
        state.passwordUpdateStatus.loading = false;
        state.passwordUpdateStatus.success = false;
        state.passwordUpdateStatus.error = action.payload || 'Đã xảy ra lỗi khi thay đổi mật khẩu';
      })

      // updateAvatar
      .addCase(updateAvatar.pending, (state) => {
        state.avatarUpdateStatus.loading = true;
        state.avatarUpdateStatus.success = false;
        state.avatarUpdateStatus.error = null;
      })
      .addCase(updateAvatar.fulfilled, (state, action) => {
        state.avatarUpdateStatus.loading = false;
        state.avatarUpdateStatus.success = true;
        if (state.user) {
          state.user.avatar = action.payload.avatar;
        }
      })
      .addCase(updateAvatar.rejected, (state, action) => {
        state.avatarUpdateStatus.loading = false;
        state.avatarUpdateStatus.success = false;
        state.avatarUpdateStatus.error =
          action.payload || 'Đã xảy ra lỗi khi cập nhật ảnh đại diện';
      });
  },
});

// Export actions
export const { resetPasswordUpdateStatus, resetAvatarUpdateStatus, clearUserState } =
  userSlice.actions;

// Export reducer
export default userSlice.reducer;


--- File: client/src/store/slices/wishlistSlice.js ---
// src/store/slices/wishlistSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import wishlistService from '../../services/wishlistService';

// Async thunk để lấy danh sách sản phẩm yêu thích
export const fetchWishlist = createAsyncThunk(
  'wishlist/fetchWishlist',
  async (_, { rejectWithValue }) => {
    try {
      const wishlist = await wishlistService.getWishlist();
      return wishlist;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Không thể lấy danh sách yêu thích');
    }
  }
);

// Async thunk để thêm sản phẩm vào danh sách yêu thích
export const addToWishlist = createAsyncThunk(
  'wishlist/addToWishlist',
  async (productId, { rejectWithValue }) => {
    try {
      const result = await wishlistService.addToWishlist(productId);
      return result;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Không thể thêm vào danh sách yêu thích'
      );
    }
  }
);

// Async thunk để xóa sản phẩm khỏi danh sách yêu thích
export const removeFromWishlist = createAsyncThunk(
  'wishlist/removeFromWishlist',
  async (productId, { rejectWithValue }) => {
    try {
      await wishlistService.removeFromWishlist(productId);
      return productId;
    } catch (error) {
      return rejectWithValue(
        error.response?.data?.message || 'Không thể xóa khỏi danh sách yêu thích'
      );
    }
  }
);

// Initial state
const initialState = {
  items: [],
  loading: false,
  error: null,
  addingItem: null,
  removingItem: null,
};

// Wishlist slice
const wishlistSlice = createSlice({
  name: 'wishlist',
  initialState,
  reducers: {
    // Reset trạng thái lỗi
    resetWishlistError: (state) => {
      state.error = null;
    },
    // Clear toàn bộ danh sách yêu thích khi logout
    clearWishlist: (state) => {
      state.items = [];
      state.loading = false;
      state.error = null;
      state.addingItem = null;
      state.removingItem = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchWishlist
      .addCase(fetchWishlist.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchWishlist.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchWishlist.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'Đã xảy ra lỗi khi lấy danh sách yêu thích';
      })

      // addToWishlist
      .addCase(addToWishlist.pending, (state, action) => {
        state.addingItem = action.meta.arg; // productId
      })
      .addCase(addToWishlist.fulfilled, (state, action) => {
        state.addingItem = null;
        // Kiểm tra xem sản phẩm đã có trong danh sách chưa
        const exists = state.items.some((item) => item._id === action.payload._id);
        if (!exists) {
          state.items.push(action.payload);
        }
      })
      .addCase(addToWishlist.rejected, (state, action) => {
        state.addingItem = null;
        state.error = action.payload || 'Đã xảy ra lỗi khi thêm vào danh sách yêu thích';
      })

      // removeFromWishlist
      .addCase(removeFromWishlist.pending, (state, action) => {
        state.removingItem = action.meta.arg; // productId
      })
      .addCase(removeFromWishlist.fulfilled, (state, action) => {
        state.removingItem = null;
        state.items = state.items.filter((item) => item._id !== action.payload);
      })
      .addCase(removeFromWishlist.rejected, (state, action) => {
        state.removingItem = null;
        state.error = action.payload || 'Đã xảy ra lỗi khi xóa khỏi danh sách yêu thích';
      });
  },
});

// Export actions
export const { resetWishlistError, clearWishlist } = wishlistSlice.actions;

// Export reducer
export default wishlistSlice.reducer;


--- File: client/src/utils/authToken.js ---
import axios from 'axios';
// client/src/utils/authToken.js
const TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';

export const setAuthToken = (token) => {
  localStorage.setItem(TOKEN_KEY, token);
};

export const getAuthToken = () => {
  return localStorage.getItem(TOKEN_KEY);
};

export const removeAuthToken = () => {
  localStorage.removeItem(TOKEN_KEY);
};

export const setRefreshToken = (token) => {
  localStorage.setItem(REFRESH_TOKEN_KEY, token);
};

export const getRefreshToken = () => {
  return localStorage.getItem(REFRESH_TOKEN_KEY);
};

export const removeRefreshToken = () => {
  localStorage.removeItem(REFRESH_TOKEN_KEY);
};

export const refreshToken = async () => {
  try {
    const refreshToken = getRefreshToken();

    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await fetch(`${process.env.REACT_APP_API_URL}/auth/refresh-token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error('Failed to refresh token');
    }

    const data = await response.json();
    setAuthToken(data.token);

    if (data.refreshToken) {
      setRefreshToken(data.refreshToken);
    }

    return data.token;
  } catch (error) {
    removeAuthToken();
    removeRefreshToken();
    throw error;
  }
};

export const isAuthenticated = () => {
  return !!getAuthToken();
};
/**
 * Thiết lập token vào header của Axios
 * @param {string} token - JWT token
 */
// export const setAuthToken = (token) => {
//   if (token) {
//     // Áp dụng token cho tất cả các request
//     axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
//   } else {
//     // Xóa header nếu không có token
//     delete axios.defaults.headers.common['Authorization'];
//   }
// };

// /**
//  * Xóa token khỏi header của Axios
//  */
// export const removeAuthToken = () => {
//   delete axios.defaults.headers.common['Authorization'];
// };


--- File: client/src/utils/formatters.js ---
/**
 * Định dạng giá tiền theo loại tiền tệ
 * @param {number} price - Số tiền cần định dạng
 * @param {string} locale - Ngôn ngữ hiển thị (mặc định: 'vi-VN')
 * @param {string} currency - Loại tiền tệ (mặc định: 'VND')
 * @returns {string} Giá tiền đã định dạng
 */
export const formatPrice = (price, locale = 'vi-VN', currency = 'VND') => {
  if (price === null || price === undefined) return '';

  try {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency,
    }).format(price);
  } catch (error) {
    console.error('Lỗi khi định dạng giá tiền:', error);
    return `${price} ${currency}`;
  }
};

/**
 * Định dạng ngày theo định dạng chuẩn
 * @param {string|Date} date - Ngày cần định dạng
 * @param {string} locale - Ngôn ngữ hiển thị (mặc định: 'vi-VN')
 * @param {object} options - Tùy chọn định dạng (mặc định: hiển thị đầy đủ ngày tháng)
 * @returns {string} Ngày đã định dạng
 */
export const formatDate = (date, locale = 'vi-VN', options = null) => {
  if (!date) return '';

  try {
    const dateObj = typeof date === 'string' ? new Date(date) : date;

    // Kiểm tra ngày hợp lệ
    if (isNaN(dateObj.getTime())) {
      return '';
    }

    const defaultOptions = options || {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    };

    return dateObj.toLocaleDateString(locale, defaultOptions);
  } catch (error) {
    console.error('Lỗi khi định dạng ngày:', error);
    return String(date);
  }
};

/**
 * Định dạng thời gian
 * @param {string|Date} date - Thời gian cần định dạng
 * @param {string} locale - Ngôn ngữ hiển thị (mặc định: 'vi-VN')
 * @returns {string} Thời gian đã định dạng
 */
export const formatTime = (date, locale = 'vi-VN') => {
  if (!date) return '';

  try {
    const dateObj = typeof date === 'string' ? new Date(date) : date;

    // Kiểm tra ngày hợp lệ
    if (isNaN(dateObj.getTime())) {
      return '';
    }

    return dateObj.toLocaleTimeString(locale, {
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch (error) {
    console.error('Lỗi khi định dạng thời gian:', error);
    return '';
  }
};

/**
 * Định dạng ngày giờ đầy đủ
 * @param {string|Date} datetime - Ngày giờ cần định dạng
 * @param {string} locale - Ngôn ngữ hiển thị (mặc định: 'vi-VN')
 * @returns {string} Ngày giờ đã định dạng
 */
export const formatDateTime = (datetime, locale = 'vi-VN') => {
  if (!datetime) return '';

  try {
    return `${formatDate(datetime, locale)}, ${formatTime(datetime, locale)}`;
  } catch (error) {
    console.error('Lỗi khi định dạng ngày giờ:', error);
    return String(datetime);
  }
};

/**
 * Rút gọn văn bản nếu quá dài
 * @param {string} text - Văn bản cần rút gọn
 * @param {number} maxLength - Độ dài tối đa (mặc định: 100)
 * @returns {string} Văn bản đã rút gọn
 */
export const truncateText = (text, maxLength = 100) => {
  if (!text) return '';
  if (text.length <= maxLength) return text;

  return text.slice(0, maxLength) + '...';
};

/**
 * Tạo slug từ text
 * @param {string} text - Text cần chuyển đổi
 * @returns {string} Slug
 */
export const createSlug = (text) => {
  if (!text) return '';

  try {
    return text
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  } catch (error) {
    console.error('Lỗi khi tạo slug:', error);
    return '';
  }
};

/**
 * Định dạng số điện thoại Việt Nam
 * @param {string} phone - Số điện thoại cần định dạng
 * @returns {string} Số điện thoại đã định dạng
 */
export const formatPhoneNumber = (phone) => {
  if (!phone) return '';

  // Loại bỏ tất cả ký tự không phải số
  const cleaned = phone.replace(/\D/g, '');

  // Kiểm tra độ dài số điện thoại Việt Nam
  if (cleaned.length !== 10) {
    return phone;
  }

  // Định dạng: 0xx xxxx xxx
  return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 7)} ${cleaned.slice(7)}`;
};

/**
 * Định dạng số lượng lớn (ví dụ: 1.5k thay vì 1500)
 * @param {number} number - Số cần định dạng
 * @returns {string} Số đã định dạng
 */
export const formatCompactNumber = (number) => {
  if (number === null || number === undefined) return '';

  const formatter = new Intl.NumberFormat('vi-VN', {
    notation: 'compact',
    compactDisplay: 'short',
  });

  return formatter.format(number);
};


--- File: client/tailwind.config.js ---
module.exports = {
    content: [
      './src/**/*.{js,jsx,ts,tsx}',
      './public/index.html',
    ],
    theme: {
      extend: {
        colors: {
          primary: {
            50: '#e6f1fe',
            100: '#cce3fd',
            200: '#99c7fb',
            300: '#66aaf9',
            400: '#338ef7',
            500: '#0072f5', // Primary color
            600: '#005bc4',
            700: '#004493',
            800: '#002e62',
            900: '#001731',
          },
        },
        fontFamily: {
          sans: ['Roboto', 'Arial', 'sans-serif'],
          heading: ['Montserrat', 'Arial', 'sans-serif'],
        },
        spacing: {
          '72': '18rem',
          '84': '21rem',
          '96': '24rem',
        },
        borderRadius: {
          'xl': '0.75rem',
          '2xl': '1rem',
        },
        boxShadow: {
          'outline-blue': '0 0 0 3px rgba(0, 114, 245, 0.3)',
        },
        transitionProperty: {
          'height': 'height',
          'spacing': 'margin, padding',
        },
      },
    },
    plugins: [
      require('@tailwindcss/forms'),
    ],
  };

--- File: client/webpack.config.md ---
// File: webpack.config.js - Đặt ở thư mục gốc của dự án (cùng cấp với package.json)
// Cấu hình Webpack đầy đủ cho dự án React/JavaScript

const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const CompressionPlugin = require('compression-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

// Xác định môi trường
const isDevelopment = process.env.NODE_ENV !== 'production';

module.exports = {
  // Chế độ: development hoặc production
  mode: isDevelopment ? 'development' : 'production',

  // Điểm vào của ứng dụng
  entry: './src/index.js', // Điều chỉnh đường dẫn tới file entry point của bạn

  // Cấu hình đầu ra
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: isDevelopment ? '[name].js' : '[name].[contenthash].js',
    publicPath: '/',
    clean: true, // Xóa thư mục dist trước mỗi lần build
  },

  // Source maps cho development
  devtool: isDevelopment ? 'eval-source-map' : false,

  // Cấu hình dev server
  devServer: {
    static: {
      directory: path.join(__dirname, 'public'),
    },
    port: 3000,
    hot: true,
    historyApiFallback: true, // Hỗ trợ cho React Router
    open: true,
  },

  // Cấu hình module rules
  module: {
    rules: [
      // JavaScript/React
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react'],
          },
        },
      },
      // CSS/SCSS
      {
        test: /\.(css|scss)$/,
        use: [
          isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,
          'css-loader',
          'postcss-loader',
          'sass-loader',
        ],
      },
      // Images
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },
      // Fonts
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
      },
    ],
  },

  // Cấu hình resolve
  resolve: {
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'), // Cho phép import từ '@/components/...'
    },
  },

  // Tối ưu hóa bundle size
  optimization: {
    minimize: !isDevelopment,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: !isDevelopment,
          },
        },
      }),
    ],
    splitChunks: {
      chunks: 'all',
      maxInitialRequests: 10,
      minSize: 0,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
            return `vendor.${packageName.replace('@', '')}`;
          },
        },
      },
    },
  },

  // Plugins
  plugins: [
    // Tạo file HTML
    new HtmlWebpackPlugin({
      template: './public/index.html', // Điều chỉnh đường dẫn tới template HTML của bạn
      favicon: './public/favicon.ico', // Nếu có favicon
    }),

    // Extract CSS thành file riêng trong production
    !isDevelopment &&
      new MiniCssExtractPlugin({
        filename: '[name].[contenthash].css',
      }),

    // Nén file JS và CSS
    !isDevelopment &&
      new CompressionPlugin({
        algorithm: 'gzip',
        test: /\.(js|css|html|svg)$/,
        threshold: 10240,
        minRatio: 0.8,
      }),

    // Phân tích bundle size (chỉ chạy khi cần phân tích)
    process.env.ANALYZE === 'true' && new BundleAnalyzerPlugin(),
  ].filter(Boolean),
};


--- File: docker/Dockerfile.client ---
# Sử dụng multi-stage build để tối ưu image size

# Stage 1: Build stage
FROM node:18-alpine AS build

# Tạo thư mục làm việc
WORKDIR /app

# Sao chép package.json và package-lock.json
COPY package*.json ./

# Cài đặt dependencies
RUN npm ci

# Sao chép source code của ứng dụng
COPY . .

# Build ứng dụng React
RUN npm run build

# Stage 2: Production stage
FROM nginx:alpine

# Sao chép build files từ build stage vào thư mục root của Nginx
COPY --from=build /app/build /usr/share/nginx/html

# Sao chép cấu hình Nginx tùy chỉnh (nếu có)
# COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80
EXPOSE 80

# Khởi chạy Nginx
CMD ["nginx", "-g", "daemon off;"]

--- File: docker/Dockerfile.server ---
# Sử dụng Node.js 18 với Alpine Linux cho nhẹ và bảo mật
FROM node:18-alpine

# Tạo thư mục làm việc
WORKDIR /app

# Sao chép package.json và package-lock.json trước để tận dụng Docker caching
COPY package*.json ./

# Cài đặt dependencies
RUN npm ci --only=production

# Sao chép source code của ứng dụng
COPY . .

# Tạo thư mục logs
RUN mkdir -p logs

# Set node user cho bảo mật tốt hơn (không chạy ứng dụng với quyền root)
USER node

# Expose port
EXPOSE 5000

# Biến môi trường
ENV NODE_ENV=production

# Khởi chạy ứng dụng
CMD ["node", "src/server.js"] 

--- File: docker/docker-compose.yml ---
version: '3.8'

services:
  # MongoDB Service
  mongodb:
    image: mongo:6
    container_name: runout_mongodb_prod
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
      MONGO_INITDB_DATABASE: runout_biliard
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init/:/docker-entrypoint-initdb.d/
      - ./mongodb_backup:/backup
    networks:
      - runout_network
    # Không expose port ra ngoài trong môi trường production
    ports:
      - "127.0.0.1:27017:27017"
    command: ["--auth", "--wiredTigerCacheSizeGB", "1"]
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
  
  # MongoDB Backup Service
  mongo-backup:
    image: mongo:6
    container_name: runout_mongodb_backup
    restart: always
    depends_on:
      - mongodb
    volumes:
      - ./mongodb_backup:/backup
      - ./scripts:/scripts
    entrypoint: ["sh", "/scripts/mongodb-backup.sh"]
    networks:
      - runout_network
    environment:
      - MONGO_HOST=mongodb
      - MONGO_PORT=27017
      - MONGO_USERNAME=${MONGO_USERNAME}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_DATABASE=runout_biliard
      - BACKUP_CRON="0 2 * * *" # Chạy lúc 2 giờ sáng hàng ngày

  # Backend Service
  backend:
    image: ${DOCKER_HUB_USERNAME}/runout-biliard-server:latest
    container_name: runout_backend_prod
    restart: always
    depends_on:
      - mongodb
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/runout_biliard?authSource=admin
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN}
      - JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
      - JWT_REFRESH_EXPIRES_IN=${JWT_REFRESH_EXPIRES_IN}
      - CORS_ORIGIN=${CORS_ORIGIN}
      - APP_NAME=RunOut-Biliard
      - SIGNATURE=${SIGNATURE}
      - LOG_LEVEL=${LOG_LEVEL:-info}
    volumes:
      - backend_logs:/app/logs
    networks:
      - runout_network
    # Sử dụng Nginx làm reverse proxy, chỉ expose trong internal network
    expose:
      - "5000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5000/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 512M

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: runout_nginx
    restart: always
    depends_on:
      - backend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
      - ./nginx/www:/var/www/html
    networks:
      - runout_network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M

  # Prometheus for monitoring
  prometheus:
    image: prom/prometheus:latest
    container_name: runout_prometheus
    restart: always
    volumes:
      - ./prometheus:/etc/prometheus
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=15d'
      - '--web.enable-lifecycle'
    networks:
      - runout_network
    expose:
      - "9090"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # Grafana for visualization
  grafana:
    image: grafana/grafana:latest
    container_name: runout_grafana
    restart: always
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    networks:
      - runout_network
    expose:
      - "3000"
    depends_on:
      - prometheus
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # Node Exporter for system metrics
  node-exporter:
    image: prom/node-exporter:latest
    container_name: runout_node_exporter
    restart: always
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.rootfs=/rootfs'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($|/)'
    networks:
      - runout_network
    expose:
      - "9100"

  # Watchtower for automatic container updates
  watchtower:
    image: containrrr/watchtower
    container_name: runout_watchtower
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command: --interval 86400 --cleanup
    environment:
      - WATCHTOWER_NOTIFICATIONS=slack
      - WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL=${SLACK_WEBHOOK_URL}
      - WATCHTOWER_NOTIFICATION_SLACK_IDENTIFIER=watchtower
      - WATCHTOWER_NOTIFICATION_SLACK_CHANNEL=${SLACK_CHANNEL:-deployments}
    networks:
      - runout_network

networks:
  runout_network:
    driver: bridge

volumes:
  mongodb_data:
  backend_logs:
  prometheus_data:
  grafana_data:

--- File: docker-compose.prod.yml ---
version: '3.8'

services:
  # MongoDB Service
  mongodb:
    image: mongo:6
    container_name: runout_mongodb_prod
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
    volumes:
      - mongodb_data:/data/db
    networks:
      - runout_network
    # Không expose port ra ngoài trong môi trường production
    ports:
      - "127.0.0.1:27017:27017"
    healthcheck:
      test: ["CMD", "mongo", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Backend Service
  backend:
    image: ${DOCKER_HUB_USERNAME}/runout-biliard-server:latest
    container_name: runout_backend_prod
    restart: always
    depends_on:
      - mongodb
    environment:
      - NODE_ENV=production
      - PORT=5000
      - MONGODB_URI=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@mongodb:27017/runout_biliard?authSource=admin
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN}
      - CORS_ORIGIN=${CORS_ORIGIN}
      - APP_NAME=RunOut-Biliard
      - SIGNATURE=${SIGNATURE}
    volumes:
      - backend_logs:/app/logs
    networks:
      - runout_network
    # Sử dụng Nginx làm reverse proxy, chỉ expose trong internal network
    expose:
      - "5000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5000/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    container_name: runout_nginx
    restart: always
    depends_on:
      - backend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
    networks:
      - runout_network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  runout_network:
    driver: bridge

volumes:
  mongodb_data:
  backend_logs:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/logs
      o: bind
  nginx_logs:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/nginx/logs
      o: bind
  nginx_ssl:
    driver: local
    driver_opts:
      type: none
      device: /opt/runout-biliard/nginx/ssl
      o: bind
  # Chú ý: Đảm bảo rằng các thư mục /opt/runout-biliard/logs, /opt/runout-biliard/nginx/logs và /opt/runout-biliard/nginx/ssl đã tồn tại trên server trước khi chạy docker-compose.
  # Nếu chưa tồn tại, bạn có thể tạo chúng bằng lệnh sau:
  # mkdir -p /opt/runout-biliard/logs /opt/runout-biliard/nginx/logs /opt/runout-biliard/nginx/ssl
  # Hoặc bạn có thể thay đổi đường dẫn trong driver_opts để phù hợp với cấu trúc thư mục của bạn.
  # Nếu bạn muốn sử dụng volume mặc định của Docker, bạn có thể bỏ qua phần này và chỉ cần định nghĩa mongodb_data.
  # Tuy nhiên, việc sử dụng volume bind mount như trên sẽ giúp bạn dễ dàng truy cập và quản lý các file log và ssl certificate từ bên ngoài container.

--- File: docs/CI-CD-Guide.md ---
# Hướng Dẫn CI/CD cho Dự Án RunOut-Biliard

## Tổng Quan

RunOut-Biliard sử dụng GitHub Actions để tự động hóa quy trình Continuous Integration (CI) và Continuous Deployment (CD). Tài liệu này mô tả cách thức hoạt động của các pipeline CI/CD và cách các developer có thể làm việc với chúng.

## Quy Trình Làm Việc (Workflow)

### 1. Quy Trình Phát Triển

1. **Tạo Branch Mới**: Bắt đầu từ nhánh `develop`, tạo một branch mới cho tính năng hoặc sửa lỗi của bạn:
   ```bash
   git checkout develop
   git pull
   git checkout -b feature/your-feature-name
   ```

2. **Phát Triển**: Viết code, tests và commit thường xuyên:
   ```bash
   git add .
   git commit -m "feat: implement xyz feature"
   ```

3. **Push Branch**: Đẩy branch lên GitHub:
   ```bash
   git push -u origin feature/your-feature-name
   ```

4. **Tạo Pull Request**: Tạo Pull Request (PR) từ branch của bạn vào nhánh `develop`.
   - Điền thông tin theo template PR
   - Chỉ định reviewer thích hợp

5. **CI Tự Động Chạy**: Khi PR được tạo, workflow CI sẽ tự động chạy.

6. **Merge**: Sau khi PR được approve và tất cả checks đã thành công, bạn có thể merge PR vào nhánh `develop`.

### 2. Quy Trình Release

1. **Tạo Release Branch**: Khi chuẩn bị release, tạo branch từ `develop`:
   ```bash
   git checkout develop
   git checkout -b release/v1.0.0
   ```

2. **Cập Nhật Version**: Cập nhật version trong package.json và các tài liệu khác.

3. **Tạo PR vào Main**: Tạo Pull Request từ branch release vào nhánh `main`.

4. **Chạy Tests**: Đảm bảo CI hoàn thành thành công.

5. **Merge vào Main**: Sau khi PR được approve, merge vào `main`.

6. **Tạo Tag**: Tạo tag cho version mới:
   ```bash
   git checkout main
   git pull
   git tag -a v1.0.0 -m "Version 1.0.0"
   git push origin v1.0.0
   ```

7. **Đồng Bộ về Develop**: Tạo PR để merge `main` trở lại `develop`.

## Chi Tiết về CI Pipeline

Pipeline CI sẽ tự động chạy khi:
- Push vào nhánh `main` hoặc `develop`
- Tạo Pull Request vào `main` hoặc `develop`

### Các bước trong CI Pipeline

1. **Backend Tests**:
   - Khởi tạo môi trường với Node.js và MongoDB
   - Cài đặt dependencies
   - Kiểm tra linting
   - Chạy unit tests và integration tests
   - Tạo coverage report

2. **Frontend Tests**:
   - Cài đặt dependencies
   - Kiểm tra linting
   - Chạy unit tests
   - Build ứng dụng

3. **Security Scan**:
   - Chạy npm audit để kiểm tra các dependencies có vấn đề bảo mật không

## Chi Tiết về CD Pipeline

Pipeline CD sẽ tự động chạy khi:
- Push vào nhánh `main`
- Kích hoạt thủ công qua GitHub

### Các bước trong CD Pipeline

1. **Deploy Backend**:
   - Build Docker image
   - Push image lên Docker Hub
   - SSH vào production server và cập nhật container

2. **Deploy Frontend**:
   - Build ứng dụng React với biến môi trường production
   - Deploy lên service hosting (Netlify/Vercel)

3. **Notify**:
   - Gửi thông báo tới Slack về status của deployment

## Biến Môi Trường trong GitHub Secrets

Các GitHub Secrets sau cần được cấu hình:

- `DOCKER_HUB_USERNAME`: Username Docker Hub
- `DOCKER_HUB_TOKEN`: Token để authenticate với Docker Hub
- `PRODUCTION_HOST`: Hostname hoặc IP của production server
- `PRODUCTION_USERNAME`: Username SSH cho server
- `PRODUCTION_SSH_KEY`: Private key SSH
- `PRODUCTION_API_URL`: URL của API production
- `NETLIFY_AUTH_TOKEN`: Token Netlify (nếu sử dụng)
- `NETLIFY_SITE_ID`: ID site Netlify (nếu sử dụng)
- `SLACK_WEBHOOK`: Webhook URL cho thông báo Slack

## Troubleshooting

### Pipeline CI Failed

1. Kiểm tra build logs trong tab Actions của GitHub
2. Sửa các lỗi được báo cáo trong logs
3. Push changes vào PR branch
4. CI pipeline sẽ tự động chạy lại

### Pipeline CD Failed

1. Kiểm tra logs và errors
2. Đảm bảo tất cả secrets được cấu hình đúng
3. Kiểm tra kết nối đến production server
4. Thử deploy lại thủ công bằng cách kích hoạt workflow CD trong tab Actions

## Quy Ước Commit

Dự án này sử dụng quy ước [Conventional Commits](https://www.conventionalcommits.org/):

- `feat`: Thêm tính năng mới
- `fix`: Sửa lỗi
- `docs`: Thay đổi documentation
- `style`: Thay đổi không ảnh hưởng đến code (format, spaces, etc.)
- `refactor`: Thay đổi code không thêm tính năng hoặc sửa lỗi
- `perf`: Cải thiện hiệu suất
- `test`: Thêm hoặc sửa tests
- `chore`: Thay đổi build process, tools, etc.

Ví dụ:
```
feat: add user authentication
fix: correct product pagination
docs: update deployment instructions
```

---

© 2025 RunOut-Biliard. Tất cả các quyền thuộc về Steve.

--- File: nginx/conf.d/default.conf ---
server {
    listen 80;
    server_name example.com www.example.com;
    
    # Redirect tất cả các request HTTP sang HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name example.com www.example.com;
    
    # SSL Configuration
    ssl_certificate /etc/nginx/ssl/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:10m;
    ssl_session_tickets off;
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'; frame-ancestors 'self';" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    # Logs
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
    
    # API Endpoints
    location /api {
        proxy_pass http://backend:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeout settings
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Cache settings
        proxy_cache_bypass $http_upgrade;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
    
    # Root location - Serve SPA frontend
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
        
        # Caching static assets
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 30d;
            add_header Cache-Control "public, no-transform";
        }
        
        # No cache for HTML files
        location ~* \.html$ {
            expires -1;
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        }
    }
    
    # Custom error pages
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    # Favicon
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }
    
    # Robots.txt
    location = /robots.txt {
        log_not_found off;
        access_log off;
    }
    
    # Deny access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Custom header to identify website owner
    add_header X-Owner "RunOut-Biliard - Steve" always;
}

--- File: prometheus/prometheus.yml ---
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  scrape_timeout: 10s

# Alertmanager configuration
alerting:
  alertmanagers:
    - static_configs:
        - targets: []

# Rule files to load
rule_files:
  - "rules/*.yml"

# Scrape configurations
scrape_configs:
  # Prometheus itself
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Node Exporter for system metrics
  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']

  # MongoDB Exporter
  - job_name: 'mongodb'
    static_configs:
      - targets: ['mongodb-exporter:9216']

  # Backend Service
  - job_name: 'backend'
    metrics_path: '/api/metrics'
    static_configs:
      - targets: ['backend:5000']

  # Nginx Exporter
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']

--- File: scripts/init-structure.sh ---
#!/bin/bash

# Tạo thư mục gốc
mkdir -p runout-biliard

# Server (Backend Node.js/Express)
mkdir -p runout-biliard/server/src/{api,services,data,common,config}
touch runout-biliard/server/src/{app.js,server.js}
mkdir -p runout-biliard/server/tests
touch runout-biliard/server/{.eslintrc.js,.prettierrc,jest.config.js,package.json,README.md}

# Client (Frontend React)
mkdir -p runout-biliard/client/public
mkdir -p runout-biliard/client/src/{assets,components,hooks,pages,services,store,utils,routes}
touch runout-biliard/client/src/{App.js,index.js}
touch runout-biliard/client/{.eslintrc.js,.prettierrc,package.json,README.md}

# Docker files
mkdir -p runout-biliard/docker
touch runout-biliard/docker/{docker-compose.yml,Dockerfile.server,Dockerfile.client}

# GitHub Actions
mkdir -p runout-biliard/.github/workflows
touch runout-biliard/.github/workflows/{ci.yml,deploy.yml}

# Root files
touch runout-biliard/.gitignore
touch runout-biliard/README.md

echo "✅ Cấu trúc thư mục dự án runout-biliard đã được tạo thành công."


--- File: scripts/mongodb-backup.sh ---
#!/bin/sh

# Script thực hiện sao lưu MongoDB
# Tác giả: Steve
# Dự án: RunOut-Biliard

# Biến môi trường
MONGO_HOST=${MONGO_HOST:-mongodb}
MONGO_PORT=${MONGO_PORT:-27017}
MONGO_USERNAME=${MONGO_USERNAME:-root}
MONGO_PASSWORD=${MONGO_PASSWORD:-example}
MONGO_DATABASE=${MONGO_DATABASE:-runout_biliard}
BACKUP_DIR=${BACKUP_DIR:-/backup}
BACKUP_CRON=${BACKUP_CRON:-"0 2 * * *"} # Mặc định: 2 giờ sáng hàng ngày
BACKUP_RETENTION=${BACKUP_RETENTION:-7} # Giữ lại backup trong 7 ngày

# Đảm bảo thư mục backup tồn tại
mkdir -p ${BACKUP_DIR}

# Hàm thực hiện backup
perform_backup() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILENAME="${MONGO_DATABASE}_${TIMESTAMP}.gz"
    BACKUP_PATH="${BACKUP_DIR}/${BACKUP_FILENAME}"
    
    echo "$(date): Bắt đầu sao lưu ${MONGO_DATABASE} vào ${BACKUP_PATH}..."
    
    # Thực hiện backup với mongodump
    mongodump \
        --host=${MONGO_HOST} \
        --port=${MONGO_PORT} \
        --username=${MONGO_USERNAME} \
        --password=${MONGO_PASSWORD} \
        --authenticationDatabase=admin \
        --db=${MONGO_DATABASE} \
        --gzip \
        --archive=${BACKUP_PATH}
    
    # Kiểm tra kết quả
    if [ $? -eq 0 ]; then
        echo "$(date): Sao lưu thành công: ${BACKUP_PATH}"
        
        # Cập nhật chủ sở hữu file
        chmod 600 ${BACKUP_PATH}
        
        # Lưu thông tin meta
        echo "Database: ${MONGO_DATABASE}" > "${BACKUP_PATH}.meta"
        echo "Created at: $(date)" >> "${BACKUP_PATH}.meta"
        echo "Server: ${MONGO_HOST}:${MONGO_PORT}" >> "${BACKUP_PATH}.meta"
        echo "Signature: RunOut-Biliard - Steve" >> "${BACKUP_PATH}.meta"
    else
        echo "$(date): Sao lưu thất bại: ${BACKUP_PATH}"
    fi
}

# Hàm xóa backup cũ
cleanup_old_backups() {
    echo "$(date): Xóa các bản sao lưu cũ hơn ${BACKUP_RETENTION} ngày..."
    find ${BACKUP_DIR} -name "${MONGO_DATABASE}_*.gz" -type f -mtime +${BACKUP_RETENTION} -delete
    find ${BACKUP_DIR} -name "${MONGO_DATABASE}_*.gz.meta" -type f -mtime +${BACKUP_RETENTION} -delete
    echo "$(date): Đã xóa các bản sao lưu cũ."
}

# Thực hiện backup ngay lập tức
perform_backup
cleanup_old_backups

# Nếu được chạy như một container độc lập, thiết lập cron job
if [ "$1" = "schedule" ]; then
    echo "Thiết lập cron job: ${BACKUP_CRON}"
    echo "${BACKUP_CRON} /scripts/mongodb-backup.sh backup" > /etc/crontabs/root
    crond -f -d 8
else
    echo "Backup thủ công hoàn tất. Thoát..."
fi

--- File: scripts/setup-directory-structure.sh ---
#!/bin/bash

# Script tạo cấu trúc thư mục cho dự án RunOut-Biliard
# Tác giả: Steve
# Ngày: $(date +"%d/%m/%Y")

# Colors for terminal output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Thư mục gốc
ROOT_DIR="server"

# Tạo thư mục gốc nếu chưa tồn tại
mkdir -p ${ROOT_DIR}

echo -e "${GREEN}Bắt đầu tạo cấu trúc thư mục cho dự án RunOut-Biliard...${NC}"

# Tạo các file cấu hình cơ bản
touch ${ROOT_DIR}/.env.example
touch ${ROOT_DIR}/.eslintrc.js
touch ${ROOT_DIR}/.prettierrc
touch ${ROOT_DIR}/README.md
touch ${ROOT_DIR}/jest.config.js
touch ${ROOT_DIR}/jsconfig.json
touch ${ROOT_DIR}/package.json

# Tạo thư mục logs và tests
mkdir -p ${ROOT_DIR}/logs
mkdir -p ${ROOT_DIR}/tests/unit/services
mkdir -p ${ROOT_DIR}/tests/unit/repositories
mkdir -p ${ROOT_DIR}/tests/unit/controllers
mkdir -p ${ROOT_DIR}/tests/integration/api
mkdir -p ${ROOT_DIR}/tests/integration/repositories
touch ${ROOT_DIR}/tests/setup.js

# Tạo cấu trúc thư mục src
mkdir -p ${ROOT_DIR}/src

# 1. API Layer
mkdir -p ${ROOT_DIR}/src/api/controllers
mkdir -p ${ROOT_DIR}/src/api/routes
mkdir -p ${ROOT_DIR}/src/api/middleware

# Tạo controllers
for controller in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/api/controllers/${controller}Controller.js
done

# Tạo routes
for route in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/api/routes/${route}Routes.js
done

# Tạo middleware API cụ thể
touch ${ROOT_DIR}/src/api/middleware/errorMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/loggingMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/validationMiddleware.js
touch ${ROOT_DIR}/src/api/middleware/authMiddleware.js

# 2. Common Layer
mkdir -p ${ROOT_DIR}/src/common/errors
mkdir -p ${ROOT_DIR}/src/common/middleware
mkdir -p ${ROOT_DIR}/src/common/utils
mkdir -p ${ROOT_DIR}/src/common/validators
mkdir -p ${ROOT_DIR}/src/common/types

# Tạo errors
touch ${ROOT_DIR}/src/common/errors/apiError.js

# Tạo middleware chung
touch ${ROOT_DIR}/src/common/middleware/errorHandler.js
touch ${ROOT_DIR}/src/common/middleware/validate.js
touch ${ROOT_DIR}/src/common/middleware/requestLogger.js

# Tạo utils chung
touch ${ROOT_DIR}/src/common/utils/apiFeatures.js
touch ${ROOT_DIR}/src/common/utils/catchAsync.js
touch ${ROOT_DIR}/src/common/utils/responseHandler.js
touch ${ROOT_DIR}/src/common/utils/validatorUtils.js

# Tạo validators
for validator in auth product user category order cart review; do
    touch ${ROOT_DIR}/src/common/validators/${validator}Validator.js
done

# 3. Config Layer
mkdir -p ${ROOT_DIR}/src/config
touch ${ROOT_DIR}/src/config/database.js
touch ${ROOT_DIR}/src/config/environment.js
touch ${ROOT_DIR}/src/config/indexes.js
touch ${ROOT_DIR}/src/config/logger.js
touch ${ROOT_DIR}/src/config/middleware.js
touch ${ROOT_DIR}/src/config/monitoring.js

# 4. Data Layer
mkdir -p ${ROOT_DIR}/src/data/models
mkdir -p ${ROOT_DIR}/src/data/repositories
mkdir -p ${ROOT_DIR}/src/data/dto

# Tạo models
touch ${ROOT_DIR}/src/data/models/user.model.js
touch ${ROOT_DIR}/src/data/models/product.model.js
touch ${ROOT_DIR}/src/data/models/category.model.js
touch ${ROOT_DIR}/src/data/models/order.model.js
touch ${ROOT_DIR}/src/data/models/cart.model.js
touch ${ROOT_DIR}/src/data/models/review.model.js

# Tạo repositories
touch ${ROOT_DIR}/src/data/repositories/userRepository.js
touch ${ROOT_DIR}/src/data/repositories/productRepository.js
touch ${ROOT_DIR}/src/data/repositories/categoryRepository.js
touch ${ROOT_DIR}/src/data/repositories/orderRepository.js
touch ${ROOT_DIR}/src/data/repositories/cartRepository.js
touch ${ROOT_DIR}/src/data/repositories/reviewRepository.js

# Tạo DTOs
touch ${ROOT_DIR}/src/data/dto/userDTO.js
touch ${ROOT_DIR}/src/data/dto/productDTO.js
touch ${ROOT_DIR}/src/data/dto/categoryDTO.js
touch ${ROOT_DIR}/src/data/dto/orderDTO.js
touch ${ROOT_DIR}/src/data/dto/cartDTO.js
touch ${ROOT_DIR}/src/data/dto/reviewDTO.js

# 5. Migrations
mkdir -p ${ROOT_DIR}/src/migrations/scripts
touch ${ROOT_DIR}/src/migrations/config.js
touch ${ROOT_DIR}/src/migrations/index.js
touch ${ROOT_DIR}/src/migrations/migrationRunner.js
touch ${ROOT_DIR}/src/migrations/scripts/001-initial-categories.js
touch ${ROOT_DIR}/src/migrations/scripts/002-add-indexes.js

# 6. Seeds
mkdir -p ${ROOT_DIR}/src/seeds/data
mkdir -p ${ROOT_DIR}/src/seeds/scripts
touch ${ROOT_DIR}/src/seeds/index.js
touch ${ROOT_DIR}/src/seeds/runner.js

# Tạo seed data
touch ${ROOT_DIR}/src/seeds/data/categories.js
touch ${ROOT_DIR}/src/seeds/data/products.js
touch ${ROOT_DIR}/src/seeds/data/users.js
touch ${ROOT_DIR}/src/seeds/data/orders.js
touch ${ROOT_DIR}/src/seeds/data/carts.js
touch ${ROOT_DIR}/src/seeds/data/reviews.js

# Tạo seed scripts
touch ${ROOT_DIR}/src/seeds/scripts/categorySeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/productSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/userSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/orderSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/cartSeeder.js
touch ${ROOT_DIR}/src/seeds/scripts/reviewSeeder.js

# 7. Services
mkdir -p ${ROOT_DIR}/src/services/auth
mkdir -p ${ROOT_DIR}/src/services/base
mkdir -p ${ROOT_DIR}/src/services/cache
mkdir -p ${ROOT_DIR}/src/services/email/templates
mkdir -p ${ROOT_DIR}/src/services/product
mkdir -p ${ROOT_DIR}/src/services/category
mkdir -p ${ROOT_DIR}/src/services/user
mkdir -p ${ROOT_DIR}/src/services/order
mkdir -p ${ROOT_DIR}/src/services/cart
mkdir -p ${ROOT_DIR}/src/services/review

# Tạo services
touch ${ROOT_DIR}/src/services/auth/authService.js
touch ${ROOT_DIR}/src/services/base/baseService.js
touch ${ROOT_DIR}/src/services/cache/redisCache.js
touch ${ROOT_DIR}/src/services/email/emailService.js
touch ${ROOT_DIR}/src/services/email/templates/resetPassword.hbs
touch ${ROOT_DIR}/src/services/email/templates/verification.hbs
touch ${ROOT_DIR}/src/services/product/productService.js
touch ${ROOT_DIR}/src/services/category/categoryService.js
touch ${ROOT_DIR}/src/services/user/userService.js
touch ${ROOT_DIR}/src/services/order/orderService.js
touch ${ROOT_DIR}/src/services/cart/cartService.js
touch ${ROOT_DIR}/src/services/review/reviewService.js

# 8. Utils và Types
mkdir -p ${ROOT_DIR}/src/utils
mkdir -p ${ROOT_DIR}/src/types
touch ${ROOT_DIR}/src/utils/queryAnalyzer.js
touch ${ROOT_DIR}/src/types/express.d.ts

# 9. App và Server
touch ${ROOT_DIR}/src/app.js
touch ${ROOT_DIR}/src/server.js

echo -e "${GREEN}Đã tạo xong cấu trúc thư mục!${NC}"
echo -e "${BLUE}Tổng số file đã tạo: $(find ${ROOT_DIR} -type f | wc -l)${NC}"
echo -e "${BLUE}Tổng số thư mục đã tạo: $(find ${ROOT_DIR} -type d | wc -l)${NC}"
echo -e "${YELLOW}Cấu trúc thư mục đã được tạo tại thư mục: $(pwd)/${ROOT_DIR}${NC}"

# Hiển thị cấu trúc thư mục (nếu có lệnh tree)
if command -v tree &> /dev/null; then
    tree ${ROOT_DIR} -L 3
else
    echo -e "${YELLOW}Để xem cấu trúc thư mục đầy đủ, hãy cài đặt lệnh 'tree' và chạy: tree ${ROOT_DIR}${NC}"
fi

echo -e "${GREEN}Hoàn tất!${NC}"

--- File: server/.eslintrc.js ---
module.exports = {
  env: {
    node: true,
    commonjs: true,
    es2021: true,
    jest: true,
  },
  extends: ['eslint:recommended', 'plugin:node/recommended', 'plugin:jest/recommended', 'prettier'],
  parserOptions: {
    ecmaVersion: 'latest',
  },
  plugins: ['prettier', 'jest'],
  rules: {
    'prettier/prettier': 'error',
    'no-console': 'warn',
    'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'node/exports-style': ['error', 'module.exports'],
    'node/file-extension-in-import': ['error', 'always'],
    'node/prefer-global/buffer': ['error', 'always'],
    'node/prefer-global/console': ['error', 'always'],
    'node/prefer-global/process': ['error', 'always'],
    'node/prefer-global/url-search-params': ['error', 'always'],
    'node/prefer-global/url': ['error', 'always'],
    'node/prefer-promises/dns': 'error',
    'node/prefer-promises/fs': 'error',
    'jest/no-disabled-tests': 'warn',
    'jest/no-focused-tests': 'error',
    'jest/no-identical-title': 'error',
    'jest/valid-expect': 'error',
  },
};


--- File: server/.prettierrc ---
{
    "semi": true,
    "singleQuote": true,
    "trailingComma": "es5",
    "printWidth": 100,
    "tabWidth": 2,
    "useTabs": false,
    "bracketSpacing": true,
    "arrowParens": "always",
    "endOfLine": "lf"
    
  }

--- File: server/README.md ---
# RunOut-Biliard Backend

## Giới Thiệu

Backend cho hệ thống RunOut-Biliard, xây dựng trên nền tảng Node.js, Express và MongoDB. Hệ thống được thiết kế với kiến trúc phân lớp, tách biệt rõ ràng các thành phần và dễ dàng mở rộng.

## Cấu Trúc Dự Án

server/
├── .env                      # Chứa các biến môi trường (API keys, database connection strings, ports, etc.)
├── .eslintrc.js              # Cấu hình ESLint - công cụ kiểm tra lỗi và format code JavaScript
├── .prettierrc               # Cấu hình Prettier - công cụ tự động format code
├── README.md                 # Tài liệu mô tả tổng quan về dự án, hướng dẫn cài đặt và sử dụng
├── jest.config.js            # Cấu hình Jest - framework testing cho JavaScript
├── jsconfig.json             # Cấu hình cho JavaScript trong VS Code (intellisense, path aliases)
├── package.json              # Quản lý dependencies và scripts của dự án
├── src/
│   ├── api/                       # API Layer - xử lý tất cả các HTTP request/response
│   │   ├── controllers/           # Xử lý logic nhận request từ routes và gọi services tương ứng
│   │   │   ├── authController.js       # Xử lý các request liên quan đến xác thực
│   │   │   ├── productController.js    # Xử lý các request liên quan đến sản phẩm
│   │   │   ├── userController.js       # Xử lý các request liên quan đến người dùng
│   │   │   ├── categoryController.js   # Xử lý các request liên quan đến danh mục
│   │   │   ├── orderController.js      # Xử lý các request liên quan đến đơn hàng
│   │   │   ├── cartController.js       # Xử lý các request liên quan đến giỏ hàng
│   │   │   └── reviewController.js     # Xử lý các request liên quan đến đánh giá
│   │   ├── middleware/            # Middleware cụ thể cho API endpoints
│   │   │   ├── errorMiddleware.js      # Xử lý các lỗi từ API routes
│   │   │   ├── loggingMiddleware.js    # Ghi log các request/response API
│   │   │   ├── validationMiddleware.js # Xác thực dữ liệu trước khi xử lý requests
│   │   │   └── authMiddleware.js       # Xác thực JWT và xác minh quyền người dùng
│   │   └── routes/                # Định nghĩa API endpoints và mapping tới controllers
│   │       ├── authRoutes.js           # Endpoints xác thực (đăng nhập, đăng ký, đặt lại mật khẩu)
│   │       ├── productRoutes.js        # Endpoints quản lý sản phẩm (CRUD)
│   │       ├── userRoutes.js           # Endpoints quản lý người dùng (CRUD)
│   │       ├── categoryRoutes.js       # Endpoints quản lý danh mục (CRUD)
│   │       ├── orderRoutes.js          # Endpoints quản lý đơn hàng (CRUD)
│   │       ├── cartRoutes.js           # Endpoints quản lý giỏ hàng (CRUD)
│   │       └── reviewRoutes.js         # Endpoints quản lý đánh giá (CRUD)
│   │
│   ├── app.js                     # Setup Express application, cấu hình middleware và routes
│   │
│   ├── common/                    # Shared code dùng chung trong toàn bộ ứng dụng
│   │   ├── errors/                # Custom error classes
│   │   │   └── apiError.js             # Class định nghĩa các loại lỗi API
│   │   ├── middleware/            # Middleware dùng chung
│   │   │   ├── errorHandler.js         # Middleware xử lý lỗi chung
│   │   │   ├── validate.js             # Middleware validation chung
│   │   │   └── requestLogger.js        # Middleware ghi log request/response
│   │   ├── types/                 # Type definitions và interfaces
│   │   ├── utils/                 # Các utility functions dùng trong nhiều modules
│   │   │   ├── apiFeatures.js          # Xử lý filtering, sorting, pagination
│   │   │   ├── catchAsync.js           # Wrapper function để xử lý async errors
│   │   │   ├── responseHandler.js      # Format response trả về từ API
│   │   │   └── validatorUtils.js       # Các helper functions cho validation
│   │   └── validators/            # Định nghĩa validation schema và rules
│   │       ├── authValidator.js        # Validation rules cho auth requests
│   │       ├── userValidator.js        # Validation rules cho user requests
│   │       ├── productValidator.js     # Validation rules cho product requests
│   │       ├── categoryValidator.js    # Validation rules cho category requests
│   │       ├── orderValidator.js       # Validation rules cho order requests
│   │       ├── cartValidator.js        # Validation rules cho cart requests
│   │       └── reviewValidator.js      # Validation rules cho review requests
│   │
│   ├── config/                    # Cấu hình ứng dụng
│   │   ├── database.js                 # Cấu hình kết nối MongoDB
│   │   ├── environment.js              # Quản lý biến môi trường
│   │   ├── indexes.js                  # Cấu hình indexes cho database
│   │   ├── logger.js                   # Cấu hình logging
│   │   ├── middleware.js               # Cấu hình middleware ứng dụng
│   │   └── monitoring.js               # Cấu hình health checks và monitoring
│   │
│   ├── data/                      # Data Layer - tương tác với database
│   │   ├── dto/                   # Data Transfer Objects - chuyển đổi dữ liệu giữa service và controller
│   │   │   ├── cartDTO.js              # DTO cho cart data
│   │   │   ├── categoryDTO.js          # DTO cho category data
│   │   │   ├── orderDTO.js             # DTO cho order data
│   │   │   ├── productDTO.js           # DTO cho product data
│   │   │   ├── reviewDTO.js            # DTO cho review data
│   │   │   └── userDTO.js              # DTO cho user data
│   │   │
│   │   ├── models/                # Mongoose Models - định nghĩa schema và validation
│   │   │   ├── cart.model.js           # Model cho collection carts
│   │   │   ├── category.model.js       # Model cho collection categories
│   │   │   ├── order.model.js          # Model cho collection orders
│   │   │   ├── product.model.js        # Model cho collection products
│   │   │   ├── review.model.js         # Model cho collection reviews
│   │   │   └── user.model.js           # Model cho collection users
│   │   │
│   │   └── repositories/          # Repository Pattern - truy vấn database và xử lý dữ liệu
│   │       ├── cartRepository.js       # Repository cho cart data
│   │       ├── categoryRepository.js   # Repository cho category data
│   │       ├── orderRepository.js      # Repository cho order data
│   │       ├── productRepository.js    # Repository cho product data
│   │       ├── reviewRepository.js     # Repository cho review data
│   │       └── userRepository.js       # Repository cho user data
│   │
│   ├── migrations/                # Database migrations - quản lý thay đổi schema
│   │   ├── config.js                   # Cấu hình migration framework
│   │   ├── scripts/                    # Scripts migration cụ thể
│   │   │   ├── 001-initial-categories.js  # Migration đầu tiên tạo categories
│   │   │   └── 002-add-indexes.js        # Migration thêm indexes
│   │   ├── index.js                    # Entry point cho migrations
│   │   └── migrationRunner.js          # Logic chạy migrations
│   │
│   ├── seeds/                     # Database seeds - tạo dữ liệu mẫu ban đầu
│   │   ├── data/                  # Dữ liệu mẫu dùng cho seeding
│   │   │   ├── categories.js           # Dữ liệu mẫu cho categories
│   │   │   ├── products.js             # Dữ liệu mẫu cho products
│   │   │   ├── users.js                # Dữ liệu mẫu cho users
│   │   │   ├── orders.js               # Dữ liệu mẫu cho orders
│   │   │   ├── carts.js                # Dữ liệu mẫu cho carts
│   │   │   └── reviews.js              # Dữ liệu mẫu cho reviews
│   │   ├── scripts/               # Scripts chạy seed data
│   │   │   ├── categorySeeder.js       # Seeder cho categories
│   │   │   ├── productSeeder.js        # Seeder cho products
│   │   │   ├── userSeeder.js           # Seeder cho users
│   │   │   ├── orderSeeder.js          # Seeder cho orders
│   │   │   ├── cartSeeder.js           # Seeder cho carts
│   │   │   └── reviewSeeder.js         # Seeder cho reviews
│   │   ├── index.js                    # Entry point cho seeds
│   │   └── runner.js                   # Logic chạy seeds
│   │
│   ├── server.js                  # Entry point của ứng dụng, khởi động server
│   │
│   ├── services/                  # Service Layer - chứa business logic
│   │   ├── auth/                  # Auth services
│   │   │   └── authService.js          # Logic xác thực và phân quyền
│   │   ├── base/                  # Base services
│   │   │   └── baseService.js          # Service cơ sở để extend
│   │   ├── cache/                 # Caching services
│   │   │   └── redisCache.js           # Service quản lý cache với Redis
│   │   ├── email/                 # Email services
│   │   │   ├── emailService.js         # Service gửi email
│   │   │   └── templates/              # Templates email
│   │   │       ├── resetPassword.hbs   # Template email đặt lại mật khẩu
│   │   │       └── verification.hbs    # Template email xác minh tài khoản
│   │   ├── product/               # Product services
│   │   │   └── productService.js       # Logic xử lý sản phẩm
│   │   ├── category/              # Category services
│   │   │   └── categoryService.js      # Logic xử lý danh mục
│   │   ├── user/                  # User services
│   │   │   └── userService.js          # Logic xử lý người dùng
│   │   ├── order/                 # Order services
│   │   │   └── orderService.js         # Logic xử lý đơn hàng
│   │   ├── cart/                  # Cart services
│   │   │   └── cartService.js          # Logic xử lý giỏ hàng
│   │   └── review/                # Review services
│   │       └── reviewService.js        # Logic xử lý đánh giá
│   │
│   └── utils/                     # Utilities chung ít dùng hơn
│       └── queryAnalyzer.js            # Phân tích hiệu suất truy vấn
│
├── tests/                         # Test files
│   ├── unit/                      # Unit tests - kiểm thử từng thành phần riêng lẻ
│   │   ├── services/                   # Tests cho services
│   │   ├── repositories/               # Tests cho repositories
│   │   └── controllers/                # Tests cho controllers
│   ├── integration/               # Integration tests - kiểm thử nhiều thành phần kết hợp
│   │   ├── api/                        # Tests cho API endpoints
│   │   └── repositories/               # Tests cho tương tác repositories với database
│   └── setup.js                   # Cấu hình môi trường test
│
└── logs/                          # Thư mục chứa các file log

```

## Kiến Trúc Phần Mềm

Backend được xây dựng theo kiến trúc phân lớp:

1. **API Layer**: Xử lý HTTP requests và responses, định tuyến và các middleware.
2. **Service Layer**: Chứa business logic, điều phối dữ liệu và xử lý các quy trình.
3. **Data Access Layer**: Tương tác với database, truy xuất và cập nhật dữ liệu.
4. **Common Layer**: Chứa các code dùng chung trong toàn ứng dụng.

## Cài Đặt và Chạy

### Yêu Cầu

- Node.js >= 18.x
- MongoDB >= 6.0
- npm hoặc yarn

### Cài Đặt Phụ Thuộc

```bash
# Cài đặt dependencies
npm install

# Hoặc sử dụng yarn
yarn install
```

### Cấu Hình Môi Trường

```bash
# Sao chép file .env.example thành .env
cp .env.example .env

# Chỉnh sửa file .env với cấu hình của bạn
nano .env
```

### Chạy Ứng Dụng

```bash
# Chạy trong môi trường development
npm run dev

# Chạy trong môi trường production
npm start
```

### Chạy Tests

```bash
# Chạy tất cả tests
npm test

# Chạy tests và theo dõi thay đổi
npm run test:watch
```

## API Endpoints

API của RunOut-Biliard tuân theo chuẩn RESTful và có các endpoints chính sau:

- **Authentication**: `/api/auth/*`
- **Users**: `/api/users/*`
- **Products**: `/api/products/*`
- **Categories**: `/api/categories/*`
- **Carts**: `/api/carts/*`
- **Orders**: `/api/orders/*`
- **Reviews**: `/api/reviews/*`

Chi tiết về các API endpoints có thể được tìm thấy trong API documentation.

## Docker

Dự án được containerized với Docker:

```bash
# Build image
docker build -t runout-biliard-server .

# Chạy container
docker run -p 5000:5000 runout-biliard-server
```

Hoặc sử dụng Docker Compose:

```bash
# Khởi động tất cả services
docker-compose up

# Chạy trong background
docker-compose up -d
```

## Tính Năng

- **Authentication & Authorization**: JWT-based authentication và role-based authorization.
- **User Management**: Đăng ký, đăng nhập, quản lý profile.
- **Email Service**: Gửi email xác thực và đặt lại mật khẩu.
- **Product Management**: CRUD cho sản phẩm, danh mục, và đánh giá.
- **Cart & Order**: Quản lý giỏ hàng và đơn hàng.
- **Payment Integration**: Tích hợp cổng thanh toán VNPay.
- **Error Handling**: Xử lý lỗi thống nhất.
- **Logging**: Logging đầy đủ cho debugging và monitoring.
- **Validation**: Validation dữ liệu đầu vào.

## Đóng Góp

1. Fork repository
2. Tạo branch mới (`git checkout -b feature/amazing-feature`)
3. Commit thay đổi của bạn (`git commit -m 'feat: add some amazing feature'`)
4. Push lên branch (`git push origin feature/amazing-feature`)
5. Tạo Pull Request

## Giấy Phép

© 2025 RunOut-Biliard. Tất cả các quyền thuộc về Steve.


--- File: server/jest.config.js ---
module.exports = {
  testEnvironment: 'node',
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: ['src/**/*.js', '!src/server.js', '!**/node_modules/**', '!**/vendor/**'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  testPathIgnorePatterns: ['/node_modules/'],
  // Setup file trước khi chạy tests
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  // Tùy chọn đối với môi trường test
  testEnvironmentOptions: {
    NODE_ENV: 'test',
  },
  verbose: true,
  // Tự động xóa các mocks giữa các tests
  clearMocks: true,
  // Timeout cho tests
  testTimeout: 10000,
};


--- File: server/jsconfig.json ---
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "baseUrl": ".",
      "paths": {
        "*": ["src/*"]
      },
      "checkJs": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "moduleResolution": "node"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "**/node_modules/*", "dist", "build"]
  }

--- File: server/package.json ---
{
    "name": "runout-biliard-server",
    "version": "1.0.0",
    "description": "Backend server cho hệ thống RunOut-Biliard",
    "main": "src/server.js",
    "scripts": {
        "start": "node src/server.js",
        "dev": "nodemon src/server.js",
        "test": "jest --coverage",
        "test:watch": "jest --watch",
        "lint": "eslint --ext .js src/",
        "lint:fix": "eslint --ext .js src/ --fix",
        "format": "prettier --write \"src/**/*.js\"",
        "migrate": "node src/migrations migrate",
        "migrate:rollback": "node src/migrations rollback",
        "seed": "node src/seeds/index.js",
        "prepare": "husky install"
    },
    "author": "Steve",
    "license": "UNLICENSED",
    "private": true,
    "dependencies": {
        "bcrypt": "^5.1.1",
        "compression": "^1.7.4",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "csurf": "^1.10.0",
        "dotenv": "^16.3.1",
        "express": "^4.21.2",
        "express-mongo-sanitize": "^2.2.0",
        "express-rate-limit": "^7.5.0",
        "handlebars": "^4.7.8",
        "helmet": "^7.1.0",
        "hpp": "^0.2.3",
        "joi": "^17.11.0",
        "jsonwebtoken": "^9.0.2",
        "mongodb-memory-server": "^10.1.4",
        "mongoose": "^8.0.3",
        "morgan": "^1.10.0",
        "nodemailer": "^7.0.2",
        "redis": "^5.0.1",
        "winston": "^3.11.0",
        "xss-clean": "^0.1.4"
    },
    "devDependencies": {
        "eslint": "^8.55.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-jest": "^27.6.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^5.0.1",
        "husky": "^8.0.3",
        "jest": "^29.7.0",
        "lint-staged": "^15.2.0",
        "nodemon": "^3.0.2",
        "prettier": "^3.1.1",
        "supertest": "^6.3.3"
    },
    "engines": {
        "node": ">=18.0.0"
    },
    "lint-staged": {
        "*.js": [
            "eslint --fix",
            "prettier --write"
        ]
    }
}


--- File: server/src/api/controllers/authController.js ---
// @ts-nocheck
/**
 * Controller cho xác thực người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { ApiError } = require('../../middleware/errorHandler');
const User = require('../../data/models/user.model');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../../services/email/emailService');

/**
 * Tạo JWT token
 * @param {Object} user - User object
 * @returns {String} JWT token
 */
const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, role: user.role },
    environment.auth.jwtSecret,
    { expiresIn: environment.auth.jwtExpiresIn }
  );
};

/**
 * Tạo refresh token
 * @param {Object} user - User object
 * @returns {String} Refresh token
 */
const generateRefreshToken = (user) => {
  return jwt.sign(
    { id: user._id },
    environment.auth.jwtRefreshSecret,
    { expiresIn: environment.auth.jwtRefreshExpiresIn }
  );
};

/**
 * Đăng ký người dùng mới
 */
exports.register = catchAsync(async (req, res, next) => {
  const { name, email, password, phone } = req.body;
  
  // Kiểm tra email đã tồn tại chưa
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email đã được sử dụng'));
  }
  
  // Tạo verification token
  const verificationToken = crypto.randomBytes(32).toString('hex');
  const verificationTokenExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 giờ
  
  // Tạo user mới
  const newUser = await User.create({
    name,
    email,
    password,
    phone,
    emailVerificationToken: crypto
      .createHash('sha256')
      .update(verificationToken)
      .digest('hex'),
    emailVerificationExpires: verificationTokenExpires,
  });
  
  try {
    // Gửi email xác thực
    const verifyURL = `${req.protocol}://${req.get('host')}/api/auth/verify-email/${verificationToken}`;
    
    await sendEmail({
      to: email,
      subject: 'Xác thực tài khoản RunOut-Biliard',
      template: 'verification',
      context: {
        name,
        verifyURL,
      },
    });
    
    res.status(201).json({
      status: 'success',
      message: 'Người dùng đã được tạo. Vui lòng kiểm tra email để xác thực tài khoản.',
    });
  } catch (error) {
    // Xử lý lỗi gửi email
    logger.error(`Không thể gửi email xác thực: ${error.message}`);
    
    // Xóa user trong trường hợp email không gửi được
    await User.findByIdAndDelete(newUser._id);
    
    return next(new ApiError(
      500,
      'Đã xảy ra lỗi khi gửi email xác thực. Vui lòng thử lại sau.'
    ));
  }
});

/**
 * Đăng nhập
 */
exports.login = catchAsync(async (req, res, next) => {
  const { email, password } = req.body;
  
  // Kiểm tra email và password
  if (!email || !password) {
    return next(new ApiError(400, 'Vui lòng cung cấp email và mật khẩu'));
  }
  
  // Tìm user trong database
  const user = await User.findOne({ email }).select('+password');
  
  // Kiểm tra user tồn tại và password đúng
  if (!user || !(await user.correctPassword(password, user.password))) {
    return next(new ApiError(401, 'Email hoặc mật khẩu không đúng'));
  }
  
  // Kiểm tra email đã xác thực chưa
  if (!user.emailVerified) {
    return next(new ApiError(401, 'Vui lòng xác thực email trước khi đăng nhập'));
  }
  
  // Kiểm tra user có active không
  if (!user.isActive) {
    return next(new ApiError(401, 'Tài khoản của bạn đã bị vô hiệu hóa'));
  }
  
  // Tạo token
  const token = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  // Cập nhật thông tin đăng nhập
  user.lastLogin = Date.now();
  user.loginCount += 1;
  await user.save({ validateBeforeSave: false });
  
  // Không gửi password trong response
  user.password = undefined;
  
  res.status(200).json({
    status: 'success',
    data: {
      user,
      token,
      refreshToken,
    },
  });
});

/**
 * Đăng xuất
 */
exports.logout = catchAsync(async (req, res, next) => {
  // Đối với JWT, không cần làm gì ở phía server
  // Client cần xóa token
  
  res.status(200).json({
    status: 'success',
    message: 'Đăng xuất thành công',
  });
});

/**
 * Làm mới access token bằng refresh token
 */
exports.refreshToken = catchAsync(async (req, res, next) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return next(new ApiError(400, 'Refresh token không được cung cấp'));
  }
  
  try {
    // Xác thực refresh token
    const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);
    
    // Tìm user
    const user = await User.findById(decoded.id);
    
    if (!user || !user.isActive) {
      return next(new ApiError(401, 'Người dùng không tồn tại hoặc đã bị vô hiệu hóa'));
    }
    
    // Tạo token mới
    const newToken = generateToken(user);
    
    res.status(200).json({
      status: 'success',
      data: {
        token: newToken,
      },
    });
  } catch (error) {
    return next(new ApiError(401, 'Refresh token không hợp lệ hoặc đã hết hạn'));
  }
});

/**
 * Quên mật khẩu
 */
exports.forgotPassword = catchAsync(async (req, res, next) => {
  const { email } = req.body;
  
  // Tìm user theo email
  const user = await User.findOne({ email });
  
  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng với email này'));
  }
  
  // Tạo reset token
  const resetToken = user.createPasswordResetToken();
  await user.save({ validateBeforeSave: false });
  
  try {
    // Tạo URL reset password
    const resetURL = `${req.protocol}://${req.get('host')}/reset-password/${resetToken}`;
    
    // Gửi email
    await sendEmail({
      to: user.email,
      subject: 'Đặt lại mật khẩu (có hiệu lực trong 10 phút)',
      template: 'resetPassword',
      context: {
        name: user.name,
        resetURL,
      },
    });
    
    res.status(200).json({
      status: 'success',
      message: 'Token đã được gửi đến email',
    });
  } catch (error) {
    // Xử lý lỗi gửi email
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save({ validateBeforeSave: false });
    
    logger.error(`Không thể gửi email đặt lại mật khẩu: ${error.message}`);
    
    return next(new ApiError(
      500,
      'Có lỗi xảy ra khi gửi email. Vui lòng thử lại sau!'
    ));
  }
});

/**
 * Đặt lại mật khẩu
 */
exports.resetPassword = catchAsync(async (req, res, next) => {
  const { token, password } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Tìm user với token và kiểm tra thời hạn
  const user = await User.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpires: { $gt: Date.now() },
  });
  
  // Kiểm tra nếu token hợp lệ
  if (!user) {
    return next(new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn'));
  }
  
  // Cập nhật mật khẩu
  user.password = password;
  user.resetPasswordToken = undefined;
  user.resetPasswordExpires = undefined;
  await user.save();
  
  // Đăng nhập người dùng
  const jwtToken = generateToken(user);
  const refreshToken = generateRefreshToken(user);
  
  res.status(200).json({
    status: 'success',
    message: 'Mật khẩu đã được cập nhật',
    data: {
      token: jwtToken,
      refreshToken,
    },
  });
});

/**
 * Xác thực email
 */
exports.verifyEmail = catchAsync(async (req, res, next) => {
  const { token } = req.body;
  
  // Hash token
  const hashedToken = crypto
    .createHash('sha256')
    .update(token)
    .digest('hex');
  
  // Tìm user và kiểm tra thời hạn
  const user = await User.findOne({
    emailVerificationToken: hashedToken,
    emailVerificationExpires: { $gt: Date.now() },
  });
  
  // Kiểm tra nếu token hợp lệ
  if (!user) {
    return next(new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn'));
  }
  
  // Cập nhật trạng thái xác thực
  user.emailVerified = true;
  user.emailVerificationToken = undefined;
  user.emailVerificationExpires = undefined;
  await user.save({ validateBeforeSave: false });
  
  res.status(200).json({
    status: 'success',
    message: 'Email đã được xác thực thành công',
  });
});

--- File: server/src/api/controllers/cartController.js ---
/**
 * Cart Controller
 * Xử lý các request liên quan đến giỏ hàng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const cartService = require('../../services/cart/cartService');

/**
 * Lấy giỏ hàng hiện tại của người dùng đăng nhập hoặc khách
 * @route GET /api/carts/mycart
 * @access Public
 */
const getMyCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  // Nếu đã đăng nhập, lấy giỏ hàng theo userId
  if (req.user) {
    userId = req.user.id;
  } else {
    // Nếu chưa đăng nhập, lấy giỏ hàng theo sessionId
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    // Nếu chưa có sessionId, tạo mới
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 ngày
        httpOnly: true
      });
    }
  }
  
  const cart = await cartService.getActiveCart(userId, sessionId);
  return responseHandler.success(res, cart);
});

/**
 * Thêm sản phẩm vào giỏ hàng
 * @route POST /api/carts/items
 * @access Public
 */
const addItemToCart = catchAsync(async (req, res) => {
  const { productId, quantity, attributes } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId || req.body.sessionId;
    
    if (!sessionId) {
      sessionId = cartService.generateSessionId();
      res.cookie('cartSessionId', sessionId, {
        maxAge: 7 * 24 * 60 * 60 * 1000,
        httpOnly: true
      });
    }
  }
  
  const updatedCart = await cartService.addItemToCart(
    userId,
    sessionId,
    productId,
    quantity,
    attributes
  );
  
  return responseHandler.success(res, updatedCart);
});

/**
 * Cập nhật số lượng sản phẩm trong giỏ hàng
 * @route PATCH /api/carts/items/:itemId
 * @access Public
 */
const updateCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  const { quantity } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.updateCartItem(userId, sessionId, itemId, quantity);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa sản phẩm khỏi giỏ hàng
 * @route DELETE /api/carts/items/:itemId
 * @access Public
 */
const removeCartItem = catchAsync(async (req, res) => {
  const { itemId } = req.params;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeItemFromCart(userId, sessionId, itemId);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa toàn bộ giỏ hàng
 * @route DELETE /api/carts/mycart
 * @access Public
 */
const clearCart = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  await cartService.clearCart(userId, sessionId);
  return responseHandler.success(res, { message: 'Cart cleared successfully' });
});

/**
 * Áp dụng mã giảm giá vào giỏ hàng
 * @route POST /api/carts/apply-coupon
 * @access Public
 */
const applyCoupon = catchAsync(async (req, res) => {
  const { code } = req.body;
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.applyCoupon(userId, sessionId, code);
  return responseHandler.success(res, updatedCart);
});

/**
 * Xóa mã giảm giá khỏi giỏ hàng
 * @route DELETE /api/carts/remove-coupon
 * @access Public
 */
const removeCoupon = catchAsync(async (req, res) => {
  let userId = null;
  let sessionId = null;
  
  if (req.user) {
    userId = req.user.id;
  } else {
    sessionId = req.cookies.cartSessionId;
    if (!sessionId) {
      return responseHandler.badRequest(res, 'Cart session not found');
    }
  }
  
  const updatedCart = await cartService.removeCoupon(userId, sessionId);
  return responseHandler.success(res, updatedCart);
});

/**
 * Hợp nhất giỏ hàng từ session với giỏ hàng người dùng khi đăng nhập
 * @route POST /api/carts/merge
 * @access Private
 */
const mergeCart = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const { sessionId } = req.body;
  
  if (!sessionId) {
    return responseHandler.badRequest(res, 'Session ID is required');
  }
  
  const mergedCart = await cartService.mergeCartsOnLogin(userId, sessionId);
  
  // Xóa cookie giỏ hàng của session
  res.clearCookie('cartSessionId');
  
  return responseHandler.success(res, mergedCart);
});

module.exports = {
  getMyCart,
  addItemToCart,
  updateCartItem,
  removeCartItem,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCart
};

--- File: server/src/api/controllers/categoryController.js ---
/**
 * Category Controller
 * Xử lý các request liên quan đến danh mục sản phẩm
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const categoryService = require('../../services/category/categoryService');

/**
 * Lấy tất cả danh mục
 * @route GET /api/categories
 * @access Public
 */
const getAllCategories = catchAsync(async (req, res) => {
  const features = req.query;
  const categories = await categoryService.getAllCategories(features);
  return responseHandler.success(res, categories);
});

/**
 * Lấy danh mục theo ID
 * @route GET /api/categories/:id
 * @access Public
 */
const getCategoryById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const category = await categoryService.getCategoryById(id);
  return responseHandler.success(res, category);
});

/**
 * Lấy tất cả sản phẩm trong danh mục
 * @route GET /api/categories/:id/products
 * @access Public
 */
const getCategoryProducts = catchAsync(async (req, res) => {
  const { id } = req.params;
  const features = req.query;
  const products = await categoryService.getCategoryProducts(id, features);
  return responseHandler.success(res, products);
});

/**
 * Tạo danh mục mới
 * @route POST /api/categories
 * @access Private (Admin only)
 */
const createCategory = catchAsync(async (req, res) => {
  const categoryData = req.body;
  const newCategory = await categoryService.createCategory(categoryData);
  return responseHandler.created(res, newCategory);
});

/**
 * Cập nhật danh mục
 * @route PUT /api/categories/:id
 * @access Private (Admin only)
 */
const updateCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  const categoryData = req.body;
  const updatedCategory = await categoryService.updateCategory(id, categoryData);
  return responseHandler.success(res, updatedCategory);
});

/**
 * Xóa danh mục
 * @route DELETE /api/categories/:id
 * @access Private (Admin only)
 */
const deleteCategory = catchAsync(async (req, res) => {
  const { id } = req.params;
  await categoryService.deleteCategory(id);
  return responseHandler.success(res, { message: 'Danh mục đã được xóa thành công' });
});

/**
 * Lấy tất cả danh mục con
 * @route GET /api/categories/:id/subcategories
 * @access Public
 */
const getSubcategories = catchAsync(async (req, res) => {
  const { id } = req.params;
  const subcategories = await categoryService.getSubcategories(id);
  return responseHandler.success(res, subcategories);
});

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getSubcategories
};

--- File: server/src/api/controllers/orderController.js ---
/**
 * Order Controller
 * Xử lý các request liên quan đến đơn hàng
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const orderService = require('../../services/order/orderService');

/**
 * Lấy tất cả đơn hàng (Admin)
 * @route GET /api/orders
 * @access Private (Admin only)
 */
const getAllOrders = catchAsync(async (req, res) => {
  const features = req.query;
  const orders = await orderService.getAllOrders(features);
  return responseHandler.success(res, orders);
});

/**
 * Lấy đơn hàng theo ID
 * @route GET /api/orders/:id
 * @access Private (Admin hoặc người dùng sở hữu đơn hàng)
 */
const getOrderById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  const order = await orderService.getOrderById(id, userId, isAdmin);
  return responseHandler.success(res, order);
});

/**
 * Lấy đơn hàng của người dùng đăng nhập
 * @route GET /api/orders/myorders
 * @access Private
 */
const getMyOrders = catchAsync(async (req, res) => {
  const userId = req.user.id;
  const features = req.query;
  
  const orders = await orderService.getOrdersByUserId(userId, features);
  return responseHandler.success(res, orders);
});

/**
 * Tạo đơn hàng mới
 * @route POST /api/orders
 * @access Private
 */
const createOrder = catchAsync(async (req, res) => {
  const orderData = req.body;
  const userId = req.user.id;
  
  const newOrder = await orderService.createOrder(orderData, userId);
  return responseHandler.created(res, newOrder);
});

/**
 * Cập nhật trạng thái đơn hàng
 * @route PATCH /api/orders/:id/status
 * @access Private (Admin only)
 */
const updateOrderStatus = catchAsync(async (req, res) => {
  const { id } = req.params;
  const { status, note } = req.body;
  const adminId = req.user.id;
  
  const updatedOrder = await orderService.updateOrderStatus(id, status, note, adminId);
  return responseHandler.success(res, updatedOrder);
});

/**
 * Hủy đơn hàng
 * @route PATCH /api/orders/:id/cancel
 * @access Private (Admin hoặc người dùng sở hữu đơn hàng)
 */
const cancelOrder = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { reason } = req.body;
  
  const cancelledOrder = await orderService.cancelOrder(id, userId, isAdmin, reason);
  return responseHandler.success(res, cancelledOrder);
});

/**
 * Xử lý webhook thanh toán từ VNPay
 * @route POST /api/orders/payment/vnpay-webhook
 * @access Public
 */
const processVnPayWebhook = catchAsync(async (req, res) => {
  const paymentData = req.body;
  await orderService.processPaymentWebhook(paymentData);
  return responseHandler.success(res, { message: 'Payment processed successfully' });
});

/**
 * Xử lý callback từ VNPay
 * @route GET /api/orders/payment/vnpay-return
 * @access Private
 */
const processVnPayReturn = catchAsync(async (req, res) => {
  const paymentData = req.query;
  const result = await orderService.processPaymentReturn(paymentData);
  return responseHandler.success(res, result);
});

module.exports = {
  getAllOrders,
  getOrderById,
  getMyOrders,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processVnPayWebhook,
  processVnPayReturn
};

--- File: server/src/api/controllers/productController.js ---
/**
 * ProductController
 * Xử lý các request API liên quan đến sản phẩm
 */

const productService = require('../../services/product/productService');
const catchAsync = require('../../common/utils/catchAsync');
const responseHandler = require('../../common/utils/responseHandler');
const AppError = require('../../common/errors/apiError');

// Tạo đối tượng controller
const productController = {
  /**
   * Lấy danh sách sản phẩm
   * @route GET /api/products
   * @access Public
   */
  getProducts: catchAsync(async (req, res) => {
    const result = await productService.getProducts(req.query);
    responseHandler.success(res, {
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * Lấy chi tiết sản phẩm
   * @route GET /api/products/:id
   * @access Public
   */
  getProductById: catchAsync(async (req, res) => {
    const product = await productService.getProductById(req.params.id);
    responseHandler.success(res, { product });
  }),

  /**
   * Lấy sản phẩm theo slug
   * @route GET /api/products/by-slug/:slug
   * @access Public
   */
  getProductBySlug: catchAsync(async (req, res) => {
    // Sử dụng getProducts với filter theo slug
    const result = await productService.getProducts({
      slug: req.params.slug,
      limit: 1,
    });

    if (!result.products || result.products.length === 0) {
      throw new AppError(404, 'Không tìm thấy sản phẩm');
    }

    // Lấy sản phẩm đầu tiên từ kết quả
    const product = result.products[0];

    // Lấy thêm thông tin chi tiết nếu cần
    const detailedProduct = await productService.getProductById(product.id);

    responseHandler.success(res, { product: detailedProduct });
  }),

  /**
   * Lấy sản phẩm theo danh mục
   * @route GET /api/categories/:categoryId/products
   * @access Public
   */
  getProductsByCategory: catchAsync(async (req, res) => {
    const { categoryId } = req.params;
    const result = await productService.getProductsByCategory(categoryId, req.query);
    responseHandler.success(res, {
      category: result.category,
      products: result.products,
      totalCount: result.totalCount,
      pagination: result.pagination,
    });
  }),

  /**
   * Lấy sản phẩm nổi bật
   * @route GET /api/products/trending
   * @access Public
   */
  getTrendingProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;
    const products = await productService.getTrendingProducts(limit);
    responseHandler.success(res, { products });
  }),

  /**
   * Lấy sản phẩm mới
   * @route GET /api/products/new
   * @access Public
   */
  getNewProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // Sử dụng getProducts với sắp xếp theo ngày tạo mới nhất
    const result = await productService.getProducts({
      limit,
      sort: { createdAt: -1 },
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * Lấy sản phẩm giảm giá
   * @route GET /api/products/sale
   * @access Public
   */
  getSaleProducts: catchAsync(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;

    // Sử dụng getProducts với bộ lọc cho sản phẩm có giá khuyến mãi
    const result = await productService.getProducts({
      limit,
      filters: { salePrice: { $gt: 0 } },
      sort: { salePrice: 1 }, // Sắp xếp theo giá khuyến mãi tăng dần
      status: 'active',
    });

    responseHandler.success(res, { products: result.products });
  }),

  /**
   * Tìm kiếm sản phẩm
   * @route GET /api/products/search
   * @access Public
   */
  searchProducts: catchAsync(async (req, res) => {
    const { q } = req.query;
    if (!q) {
      throw new AppError(400, 'Vui lòng cung cấp từ khóa tìm kiếm');
    }

    const options = {
      limit: parseInt(req.query.limit) || 10,
      page: parseInt(req.query.page) || 1,
      sort: req.query.sort ? JSON.parse(req.query.sort) : { newest: -1 },
      filters: req.query.filters ? JSON.parse(req.query.filters) : {},
    };

    const result = await productService.searchProducts(q, options);
    responseHandler.success(res, result);
  }),

  /**
   * Tạo sản phẩm mới (Admin)
   * @route POST /api/admin/products
   * @access Private/Admin
   */
  createProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const product = await productService.createProduct(req.body, userId);
    responseHandler.created(res, { product });
  }),

  /**
   * Cập nhật sản phẩm (Admin)
   * @route PUT /api/admin/products/:id
   * @access Private/Admin
   */
  updateProduct: catchAsync(async (req, res) => {
    const userId = req.user.id;
    const { id } = req.params;
    const product = await productService.updateProduct(id, req.body, userId);
    responseHandler.success(res, { product });
  }),

  /**
   * Xóa sản phẩm (Admin)
   * @route DELETE /api/admin/products/:id
   * @access Private/Admin
   */
  deleteProduct: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.deleteProduct(id);
    responseHandler.success(res, { message: 'Sản phẩm đã được xóa thành công' });
  }),

  /**
   * Cập nhật tồn kho (Admin)
   * @route PATCH /api/admin/products/:id/stock
   * @access Private/Admin
   */
  updateStock: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { quantity } = req.body;

    if (quantity === undefined) {
      throw new AppError(400, 'Vui lòng cung cấp số lượng tồn kho');
    }

    const result = await productService.updateStock(id, parseInt(quantity));
    responseHandler.success(res, result);
  }),

  /**
   * Cập nhật trạng thái sản phẩm (Admin)
   * @route PATCH /api/admin/products/:id/status
   * @access Private/Admin
   */
  updateStatus: catchAsync(async (req, res) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
      throw new AppError(400, 'Vui lòng cung cấp trạng thái');
    }

    const allowedStatuses = ['active', 'draft', 'discontinued'];
    if (!allowedStatuses.includes(status)) {
      throw new AppError(
        400,
        `Trạng thái không hợp lệ. Các trạng thái hợp lệ: ${allowedStatuses.join(', ')}`
      );
    }

    const product = await productService.updateProduct(id, { status }, req.user.id);
    responseHandler.success(res, { product });
  }),

  /**
   * Lấy thống kê sản phẩm (Admin)
   * @route GET /api/admin/products/stats
   * @access Private/Admin
   */
  getProductStats: catchAsync(async (req, res) => {
    const stats = await productService.getProductStats();
    responseHandler.success(res, { stats });
  }),

  /**
   * Lấy sản phẩm liên quan
   * @route GET /api/products/:id/related
   * @access Public
   */
  getRelatedProducts: catchAsync(async (req, res) => {
    const { id } = req.params;
    const limit = parseInt(req.query.limit) || 5;

    const products = await productService.getRelatedProducts(id, limit);
    responseHandler.success(res, { products });
  }),

  /**
   * Tăng số lượt xem sản phẩm
   * @route POST /api/products/:id/view
   * @access Public
   */
  incrementProductView: catchAsync(async (req, res) => {
    const { id } = req.params;
    await productService.incrementViewCount(id);
    responseHandler.success(res, { message: 'Đã cập nhật lượt xem' });
  }),
};

// Xuất controller
module.exports = productController;


--- File: server/src/api/controllers/reviewController.js ---
/**
 * Review Controller
 * Xử lý các request liên quan đến đánh giá sản phẩm
 */

const { catchAsync } = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const reviewService = require('../../services/review/reviewService');

/**
 * Lấy tất cả đánh giá (có phân trang, lọc)
 * @route GET /api/reviews
 * @access Public
 */
const getAllReviews = catchAsync(async (req, res) => {
  const features = req.query;
  const reviews = await reviewService.getAllReviews(features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy đánh giá theo ID
 * @route GET /api/reviews/:id
 * @access Public
 */
const getReviewById = catchAsync(async (req, res) => {
  const { id } = req.params;
  const review = await reviewService.getReviewById(id);
  return responseHandler.success(res, review);
});

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @route GET /api/products/:productId/reviews
 * @access Public
 */
const getProductReviews = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const features = req.query;
  const reviews = await reviewService.getProductReviews(productId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Lấy tất cả đánh giá của một người dùng
 * @route GET /api/users/:userId/reviews
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const getUserReviews = catchAsync(async (req, res) => {
  const { userId } = req.params;
  
  // Kiểm tra quyền truy cập
  const requestUserId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  if (userId !== requestUserId && !isAdmin) {
    return responseHandler.forbidden(res, 'Bạn không có quyền xem đánh giá của người dùng khác');
  }
  
  const features = req.query;
  const reviews = await reviewService.getUserReviews(userId, features);
  return responseHandler.success(res, reviews);
});

/**
 * Tạo đánh giá mới
 * @route POST /api/products/:productId/reviews
 * @access Private
 */
const createReview = catchAsync(async (req, res) => {
  const { productId } = req.params;
  const userId = req.user.id;
  const reviewData = req.body;
  
  const newReview = await reviewService.createReview(productId, userId, reviewData);
  return responseHandler.created(res, newReview);
});

/**
 * Cập nhật đánh giá
 * @route PUT /api/reviews/:id
 * @access Private (Người dùng sở hữu đánh giá)
 */
const updateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const reviewData = req.body;
  
  const updatedReview = await reviewService.updateReview(id, userId, reviewData, isAdmin);
  return responseHandler.success(res, updatedReview);
});

/**
 * Xóa đánh giá
 * @route DELETE /api/reviews/:id
 * @access Private (Admin hoặc người dùng sở hữu đánh giá)
 */
const deleteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  
  await reviewService.deleteReview(id, userId, isAdmin);
  return responseHandler.success(res, { message: 'Đánh giá đã được xóa thành công' });
});

/**
 * Upvote hoặc downvote đánh giá
 * @route POST /api/reviews/:id/vote
 * @access Private
 */
const voteReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { vote } = req.body; // 1 for upvote, -1 for downvote
  
  const updatedReview = await reviewService.voteReview(id, userId, vote);
  return responseHandler.success(res, updatedReview);
});

/**
 * Kiểm duyệt đánh giá (duyệt hoặc từ chối)
 * @route PATCH /api/reviews/:id/moderate
 * @access Private (Admin only)
 */
const moderateReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const adminId = req.user.id;
  const { action, reason } = req.body; // 'approve' or 'reject'
  
  const moderatedReview = await reviewService.moderateReview(id, action, reason, adminId);
  return responseHandler.success(res, moderatedReview);
});

/**
 * Báo cáo đánh giá
 * @route POST /api/reviews/:id/report
 * @access Private
 */
const reportReview = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const { reason, description } = req.body;
  
  const reportedReview = await reviewService.reportReview(id, userId, reason, description);
  return responseHandler.success(res, reportedReview);
});

/**
 * Thêm phản hồi cho đánh giá
 * @route POST /api/reviews/:id/responses
 * @access Private (Admin hoặc người dùng sở hữu sản phẩm)
 */
const addReviewResponse = catchAsync(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;
  const isAdmin = req.user.role === 'admin';
  const { content } = req.body;
  
  const updatedReview = await reviewService.addReviewResponse(id, userId, content, isAdmin);
  return responseHandler.success(res, updatedReview);
});

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse
};

--- File: server/src/api/controllers/userController.js ---
/**
 * Controller cho quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const { ApiError, isOwnerOrAdmin } = require('../middleware/authMiddleware');
const catchAsync = require('../../utils/catchAsync');
const logger = require('../../config/logger');
const responseHandler = require('../../utils/responseHandler');

/**
 * Lấy danh sách người dùng (với phân trang và filter)
 */
exports.getUsers = catchAsync(async (req, res, next) => {
  // Xử lý query params
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;
  const sort = req.query.sort || '-createdAt';

  // Xây dựng filter
  const filter = {};

  // Lọc theo role nếu có
  if (req.query.role) {
    filter.role = req.query.role;
  }

  // Lọc theo trạng thái active
  if (req.query.isActive) {
    filter.isActive = req.query.isActive === 'true';
  }

  // Tìm kiếm theo tên hoặc email
  if (req.query.search) {
    const searchRegex = new RegExp(req.query.search, 'i');
    filter.$or = [{ name: searchRegex }, { email: searchRegex }];
  }

  // Thực hiện query
  const users = await User.find(filter).sort(sort).skip(skip).limit(limit).select('-password');

  // Đếm tổng số users phù hợp với filter
  const total = await User.countDocuments(filter);

  // Tính toán thông tin phân trang
  const totalPages = Math.ceil(total / limit);
  const hasNext = page < totalPages;
  const hasPrev = page > 1;

  responseHandler.success(res, {
    results: users.length,
    pagination: {
      total,
      page,
      limit,
      totalPages,
      hasNext,
      hasPrev,
    },
    data: users,
  });
});

/**
 * Lấy thông tin người dùng theo ID
 * Middleware isOwnerOrAdmin đã được áp dụng ở route
 */
exports.getUserById = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Tìm user
  const user = await User.findById(userId).select('-password');

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  responseHandler.success(res, { data: user });
});

/**
 * Tạo người dùng mới (chỉ admin)
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.createUser = catchAsync(async (req, res, next) => {
  const { name, email, password, role, phone } = req.body;

  // Kiểm tra email đã tồn tại chưa
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new ApiError(409, 'Email đã được sử dụng'));
  }

  // Tạo user mới
  const newUser = await User.create({
    name,
    email,
    password,
    role,
    phone,
    // Admin tạo user thì mặc định đã xác thực email
    emailVerified: true,
  });

  // Không gửi password trong response
  newUser.password = undefined;

  // Ghi log
  logger.info(`User ${newUser.email} đã được tạo bởi ${req.user.email}`);

  responseHandler.created(res, { data: newUser });
});

/**
 * Cập nhật thông tin người dùng
 * Middleware isOwnerOrAdmin đã được áp dụng ở route
 */
exports.updateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Loại bỏ các trường không được phép cập nhật
  const { password, emailVerified, loginCount, lastLogin, ...updateData } = req.body;

  // Admin có thể cập nhật role
  if (req.user.role !== 'admin') {
    delete updateData.role;
  }

  // Tìm và cập nhật user
  const updatedUser = await User.findByIdAndUpdate(userId, updateData, {
    new: true,
    runValidators: true,
  }).select('-password');

  if (!updatedUser) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  // Ghi log
  logger.info(`User ${updatedUser.email} đã được cập nhật bởi ${req.user.email}`);

  responseHandler.success(res, { data: updatedUser });
});

/**
 * Xóa người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.deleteUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  // Xóa user
  const user = await User.findByIdAndDelete(userId);

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã bị xóa bởi ${req.user.email}`);

  responseHandler.success(res, { message: 'Người dùng đã được xóa thành công' });
});

/**
 * Lấy thông tin profile người dùng hiện tại
 * Middleware authenticate đã được áp dụng ở route
 */
exports.getProfile = catchAsync(async (req, res, next) => {
  // Thông tin người dùng đã được lưu trong req.user từ middleware authenticate
  const user = req.user;

  responseHandler.success(res, { data: user });
});

/**
 * Thay đổi mật khẩu
 * Middleware authenticate đã được áp dụng ở route
 * @param {import('express').Request} req - Express request object
 * @param {import('express').Response} res - Express response object
 * @param {import('express').NextFunction} next - Express next function
 */
exports.changePassword = catchAsync(async (req, res, next) => {
  const { currentPassword, newPassword } = req.body;

  // Kiểm tra dữ liệu đầu vào
  if (!currentPassword || !newPassword) {
    return next(new ApiError(400, 'Vui lòng cung cấp mật khẩu hiện tại và mật khẩu mới'));
  }

  // Lấy user hiện tại với password
  /**
   * @type {import('mongoose').Document & {
   *   password: string,
   *   correctPassword: (candidatePassword: string, userPassword: string) => Promise<boolean>
   * }}
   */
  const user = await User.findById(req.user.id).select('+password');

  // Kiểm tra mật khẩu hiện tại
  if (!(await user.correctPassword(currentPassword, user.password))) {
    return next(new ApiError(401, 'Mật khẩu hiện tại không đúng'));
  }

  // Cập nhật mật khẩu
  user.password = newPassword;
  await user.save();

  // Không gửi password trong response
  user.password = undefined;

  // Ghi log
  logger.info(`User ${user.email} đã thay đổi mật khẩu`);

  responseHandler.success(res, { message: 'Mật khẩu đã được cập nhật thành công' });
});

/**
 * Vô hiệu hóa tài khoản người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.deactivateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: false }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã bị vô hiệu hóa bởi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'Tài khoản người dùng đã bị vô hiệu hóa',
    data: user,
  });
});

/**
 * Kích hoạt lại tài khoản người dùng
 * Middleware restrictTo('admin') đã được áp dụng ở route
 */
exports.activateUser = catchAsync(async (req, res, next) => {
  const userId = req.params.id;

  const user = await User.findByIdAndUpdate(userId, { isActive: true }, { new: true }).select(
    '-password'
  );

  if (!user) {
    return next(new ApiError(404, 'Không tìm thấy người dùng'));
  }

  logger.info(`User ${user.email} đã được kích hoạt lại bởi ${req.user.email}`);

  responseHandler.success(res, {
    message: 'Tài khoản người dùng đã được kích hoạt lại',
    data: user,
  });
});


--- File: server/src/api/middleware/authMiddleware.js ---
/**
 * Authentication Middleware
 * Xử lý xác thực và phân quyền cho API endpoints
 */

const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const catchAsync = require('../../common/utils/catchAsync');
const { responseHandler } = require('../../common/utils/responseHandler');
const userService = require('../../services/user/userService');
const config = require('../../config/environment');

const authMiddleware = {
  /**
   * Xác thực người dùng qua JWT token
   * Token được cung cấp qua header Authorization
   */
  authenticate: catchAsync(async (req, res, next) => {
    // 1) Lấy token và kiểm tra nếu tồn tại
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies && req.cookies.jwt) {
      token = req.cookies.jwt;
    }

    if (!token) {
      return responseHandler.unauthorized(res, 'Vui lòng đăng nhập để truy cập');
    }

    // 2) Xác thực token
    const decoded = await promisify(jwt.verify)(token, config.jwt.secret);

    // 3) Kiểm tra nếu người dùng vẫn tồn tại
    const user = await userService.getUserById(decoded.id);
    if (!user) {
      return responseHandler.unauthorized(res, 'Người dùng không còn tồn tại');
    }

    // 4) Kiểm tra nếu người dùng đã thay đổi mật khẩu sau khi token được cấp
    if (user.changedPasswordAfter(decoded.iat)) {
      return responseHandler.unauthorized(res, 'Mật khẩu đã thay đổi, vui lòng đăng nhập lại');
    }

    // Lưu thông tin người dùng vào request
    req.user = user;
    next();
  }),

  /**
   * Giới hạn quyền truy cập dựa trên vai trò người dùng
   * @param {...string} roles - Các vai trò được phép truy cập
   */
  restrictTo: (...roles) => {
    return (req, res, next) => {
      // Kiểm tra nếu vai trò của người dùng nằm trong danh sách được phép
      if (!roles.includes(req.user.role)) {
        return responseHandler.forbidden(res, 'Bạn không có quyền thực hiện hành động này');
      }
      next();
    };
  },

  /**
   * Kiểm tra xem người dùng đã xác thực email chưa
   */
  isEmailVerified: (req, res, next) => {
    if (!req.user.emailVerified) {
      return responseHandler.forbidden(res, 'Vui lòng xác thực email của bạn trước');
    }
    next();
  },

  /**
   * Kiểm tra nếu người dùng đang truy cập dữ liệu của chính họ
   * hoặc là admin
   */
  isOwnerOrAdmin: (userIdPath) => {
    return (req, res, next) => {
      const userId = userIdPath.split('.').reduce((obj, prop) => obj[prop], req);

      // Cho phép nếu là admin hoặc chủ sở hữu
      if (req.user.role === 'admin' || req.user.id === userId) {
        return next();
      }

      return responseHandler.forbidden(res, 'Bạn không có quyền truy cập dữ liệu này');
    };
  },
};

module.exports = {
  authenticate: authMiddleware.authenticate,
  restrictTo: authMiddleware.restrictTo,
  isEmailVerified: authMiddleware.isEmailVerified,
  isOwnerOrAdmin: authMiddleware.isOwnerOrAdmin,
};


--- File: server/src/api/middleware/errorHandler.js ---
/**
 * Error Handler Middleware
 * Xử lý các lỗi trong API và trả về response phù hợp
 * @author Steve
 * @project RunOut-Biliard
 */

const logger = require('../../config/logger');

/**
 * Class ApiError - Định nghĩa cấu trúc lỗi API
 */
class ApiError extends Error {
  /**
   * Khởi tạo lỗi API
   * @param {number} statusCode - Mã HTTP status
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết (optional)
   * @param {boolean} isOperational - Xác định lỗi là operational hay programming
   * @param {string} stack - Stack trace
   */
  constructor(statusCode, message, errors = [], isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.errors = errors;

    // Thêm timestamp
    this.timestamp = new Date();

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  /**
   * Tạo lỗi 404 Not Found
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static notFound(message = 'Không tìm thấy tài nguyên') {
    return new ApiError(404, message);
  }

  /**
   * Tạo lỗi 400 Bad Request
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết
   * @returns {ApiError} - Đối tượng ApiError
   */
  static badRequest(message = 'Yêu cầu không hợp lệ', errors = []) {
    return new ApiError(400, message, errors);
  }

  /**
   * Tạo lỗi 401 Unauthorized
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static unauthorized(message = 'Không được phép truy cập') {
    return new ApiError(401, message);
  }

  /**
   * Tạo lỗi 403 Forbidden
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Đối tượng ApiError
   */
  static forbidden(message = 'Bạn không có quyền truy cập tài nguyên này') {
    return new ApiError(403, message);
  }

  /**
   * Tạo lỗi 500 Internal Server Error
   * @param {string} message - Thông báo lỗi
   * @param {boolean} isOperational - Xác định lỗi là operational hay programming
   * @returns {ApiError} - Đối tượng ApiError
   */
  static internal(message = 'Lỗi máy chủ nội bộ', isOperational = true) {
    return new ApiError(500, message, [], isOperational);
  }

  /**
   * Tạo lỗi 422 Unprocessable Entity
   * @param {string} message - Thông báo lỗi
   * @param {Array} errors - Danh sách lỗi chi tiết
   * @returns {ApiError} - Đối tượng ApiError
   */
  static validationError(message = 'Lỗi xác thực dữ liệu', errors = []) {
    return new ApiError(422, message, errors);
  }
}

/**
 * Middleware xử lý lỗi
 * @param {Error} err - Đối tượng lỗi
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // Nếu lỗi không phải là ApiError, chuyển đổi thành ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Lỗi máy chủ nội bộ';
    error = new ApiError(statusCode, message, [], false, err.stack);
  }

  // Log lỗi
  if (error.statusCode >= 500) {
    logger.error(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
    logger.error(error.stack);
  } else {
    logger.warn(
      `[${req.method}] ${req.path} >> StatusCode:: ${error.statusCode}, Message:: ${error.message}`
    );
  }

  // Chuẩn bị response
  const response = {
    success: false,
    status: error.statusCode,
    message: error.message,
    errors: error.errors.length > 0 ? error.errors : undefined,
    timestamp: error.timestamp,
    path: req.path,
  };

  // Trong môi trường development, thêm stack trace
  if (process.env.NODE_ENV === 'development') {
    response.stack = error.stack;
  }

  // Gửi response
  res.status(error.statusCode).json(response);
};

/**
 * Middleware bắt lỗi 404 cho các routes không tồn tại
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const notFoundHandler = (req, res, next) => {
  const error = ApiError.notFound(`Không tìm thấy đường dẫn: ${req.originalUrl}`);
  next(error);
};

/**
 * Middleware bắt lỗi validation từ express-validator
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @param {NextFunction} next - Express next function
 */
const validationErrorHandler = (req, res, next) => {
  const { validationErrors } = req;

  if (validationErrors && validationErrors.length > 0) {
    const errors = validationErrors.map((error) => ({
      field: error.param,
      message: error.msg,
      value: error.value,
    }));

    const error = ApiError.validationError('Dữ liệu không hợp lệ', errors);
    return next(error);
  }

  next();
};

/**
 * Xử lý lỗi không được bắt trong promise
 */
const setupUnhandledRejectionHandler = () => {
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // Trong môi trường production, có thể cân nhắc tắt server hoặc xử lý graceful shutdown
    // process.exit(1);
  });
};

/**
 * Xử lý lỗi không được bắt
 */
const setupUncaughtExceptionHandler = () => {
  process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception:', error);
    // Trong môi trường production, nên tắt server vì trạng thái có thể không ổn định
    // process.exit(1);
  });
};

module.exports = {
  ApiError,
  errorHandler,
  notFoundHandler,
  validationErrorHandler,
  setupUnhandledRejectionHandler,
  setupUncaughtExceptionHandler,
};


--- File: server/src/api/middleware/errorMiddleware.js ---
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'Internal Server Error',
  });
};

module.exports = { errorHandler };


--- File: server/src/api/middleware/loggingMiddleware.js ---
const loggingMiddleware = (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  next();
};

module.exports = { loggingMiddleware };


--- File: server/src/api/middleware/validationMiddleware.js ---
/**
 * Middleware xác thực dữ liệu sử dụng Joi và các tiện ích khác
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('express').Request} Request
 * @typedef {import('express').Response} Response
 * @typedef {import('express').NextFunction} NextFunction
 */

const Joi = require('joi');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;

/**
 * Middleware kiểm tra tính hợp lệ của MongoDB ObjectId
 * @returns {function} Express middleware
 */
const validateMongoId = () => (req, res, next) => {
  const idParam = req.params.id;

  if (!idParam) {
    return res.status(400).json({
      success: false,
      message: 'ID không được cung cấp',
    });
  }

  if (!ObjectId.isValid(idParam)) {
    return res.status(400).json({
      success: false,
      message: 'ID không hợp lệ',
    });
  }

  next();
};

/**
 * Middleware tạo bộ xác thực dữ liệu từ schema Joi
 * @param {Joi.Schema} schema - Joi schema sử dụng để xác thực
 * @returns {function} Express middleware
 */
const validate = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body, {
    abortEarly: false, // Trả về tất cả lỗi thay vì chỉ lỗi đầu tiên
    stripUnknown: true, // Loại bỏ các trường không được định nghĩa trong schema
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'Dữ liệu không hợp lệ',
      errors: errorMessages,
    });
  }

  next();
};

/**
 * Middleware tạo bộ xác thực dữ liệu từ schema Joi cho query params
 * @param {Joi.Schema} schema - Joi schema sử dụng để xác thực
 * @returns {function} Express middleware
 */
const validateQuery = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.query, {
    abortEarly: false,
    stripUnknown: true,
  });

  if (error) {
    const errorMessages = error.details.map((detail) => detail.message);
    return res.status(400).json({
      success: false,
      message: 'Tham số truy vấn không hợp lệ',
      errors: errorMessages,
    });
  }

  next();
};

// Schema mẫu cho sản phẩm (giữ lại từ file gốc)
const productSchema = Joi.object({
  name: Joi.string().min(3).max(100).required(),
  price: Joi.number().min(0).required(),
  description: Joi.string().max(500).required(),
});

/**
 * Middleware xác thực dữ liệu sản phẩm (giữ lại từ file gốc để tương thích ngược)
 * @deprecated Sử dụng hàm validate với schema tương ứng thay thế
 */
const validateProduct = (req, res, next) => {
  const { error } = productSchema.validate(req.body);
  if (error) {
    return res.status(400).json({
      success: false,
      error: error.details[0].message,
    });
  }
  next();
};

/**
 * Các helpers hữu ích cho xác thực dữ liệu
 */
const validationHelpers = {
  /**
   * Tạo một custom validator để xác thực mật khẩu mạnh
   */
  strongPassword: () =>
    Joi.string()
      .min(8)
      .max(30)
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
      .message(
        'Mật khẩu phải có ít nhất 8 ký tự, bao gồm chữ hoa, chữ thường, số và ký tự đặc biệt'
      ),

  /**
   * Tạo custom validator cho số điện thoại Việt Nam
   */
  vietnamesePhone: () =>
    Joi.string()
      .pattern(/^(0|\+84)([0-9]{9,10})$/)
      .message('Số điện thoại không hợp lệ, phải là số điện thoại Việt Nam'),
};

module.exports = {
  validateMongoId,
  validate,
  validateQuery,
  validateProduct, // Giữ lại để tương thích ngược
  validationHelpers,
};


--- File: server/src/app.js ---
/**
 * Tệp cấu hình Express chính cho ứng dụng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const dotenv = require('dotenv');
const path = require('path');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');

const { connectToDatabase } = require('./config/database');
const config = require('./config/environment');
const logger = require('./config/logger');

// Routes
const productRoutes = require('./api/routes/productRoutes');
const authRoutes = require('./api/routes/authRoutes');
const userRoutes = require('./api/routes/userRoutes');
// const bookingRoutes = require('./api/routes/bookingRoutes');
// const paymentRoutes = require('./api/routes/paymentRoutes');

// Middleware
const { loggingMiddleware } = require('./api/middleware/loggingMiddleware');
const { errorHandler } = require('./api/middleware/errorMiddleware');
// Sửa cách import authMiddleware - không cần import ở đây vì đã import trong routes

// Khởi tạo app Express
const app = express();

// Cấu hình biến môi trường
dotenv.config();

// Kết nối đến cơ sở dữ liệu
connectToDatabase();

// Cấu hình bảo mật
app.use(helmet()); // Thiết lập các HTTP header bảo mật
app.use(mongoSanitize()); // Bảo vệ khỏi SQL injection
app.use(xss()); // Bảo vệ khỏi XSS attacks
app.use(hpp({ whitelist: ['price', 'date', 'rating'] })); // Bảo vệ khỏi HTTP Parameter Pollution

// Rate limiting để chống DDOS và brute force
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 phút
  max: 100, // 100 yêu cầu mỗi IP
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Quá nhiều yêu cầu từ IP này, vui lòng thử lại sau 15 phút',
});

// Áp dụng rate limiting cho tất cả các request API
app.use('/api', limiter);

// CORS config từ biến môi trường
app.use(
  cors({
    origin: config.cors.origin.split(','),
    methods: config.cors.methods,
    credentials: true,
    optionsSuccessStatus: 204,
  })
);

// Middleware nén response
app.use(compression());

// Body parsers
app.use(express.json({ limit: '10kb' })); // Giới hạn kích thước body
app.use(express.urlencoded({ extended: true, limit: '10kb' }));
app.use(cookieParser()); // Xử lý cookies

// Ghi log cho requests trong môi trường phát triển
if (config.app.environment === 'development') {
  app.use(morgan('dev'));
}

// Middleware ghi log tùy chỉnh
app.use(loggingMiddleware);

// Thư mục tĩnh cho uploads và tài nguyên công khai
app.use('/uploads', express.static(path.join(__dirname, '..', config.paths.uploads)));
app.use(express.static(path.join(__dirname, '..', 'public')));

// Routes API
app.use('/api/products', productRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes); // Không cần thêm middleware ở đây vì đã có trong routes
// app.use('/api/bookings', bookingRoutes);
// app.use('/api/payments', paymentRoutes);

// Route sức khỏe hệ thống
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'Hệ thống đang hoạt động',
    environment: config.app.environment,
    timestamp: new Date().toISOString(),
  });
});

// Route trang chủ API
app.get('/', (req, res) => {
  res.json({
    message: 'Chào mừng đến với API RunOut-Biliard!',
    version: '1.0.0',
    docs: '/api/docs',
  });
});

// API Documentation route
app.get('/api/docs', (req, res) => {
  res.redirect('/api-docs'); // Chuyển hướng đến Swagger hoặc trang tài liệu
});

// Xử lý route không tìm thấy
app.all('*', (req, res, next) => {
  const err = new Error(`Không thể tìm thấy ${req.originalUrl} trên server này!`);
  err.status = 'fail';
  err.statusCode = 404;
  next(err);
});

// Middleware xử lý lỗi toàn cục
app.use(errorHandler);

// Xử lý sự kiện process
process.on('SIGTERM', () => {
  logger.info('SIGTERM nhận được. Đang chuẩn bị đóng ứng dụng Express...');
});

// Export app cho server.js sử dụng
module.exports = app;


--- File: server/src/common/errors/apiError.js ---
/**
 * Lớp ApiError mở rộng từ Error để xử lý các lỗi API với mã trạng thái
 * @extends Error
 */
class ApiError extends Error {
  /**
   * Tạo một ApiError
   * @param {number} statusCode - Mã trạng thái HTTP
   * @param {string} message - Thông báo lỗi
   * @param {object} [errors] - Các lỗi chi tiết (tùy chọn)
   */
  constructor(statusCode, message, errors = {}) {
    super(message);
    this.statusCode = statusCode;
    this.errors = errors;
    this.name = this.constructor.name;

    // Ghi lại stack trace
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Chuyển đổi lỗi thành định dạng JSON
   * @returns {object} - Đối tượng lỗi dạng JSON
   */
  toJSON() {
    return {
      status: 'error',
      statusCode: this.statusCode,
      message: this.message,
      errors: Object.keys(this.errors).length > 0 ? this.errors : undefined,
    };
  }

  /**
   * Tạo một lỗi BadRequest (400)
   * @param {string} message - Thông báo lỗi
   * @param {object} [errors] - Các lỗi chi tiết (tùy chọn)
   * @returns {ApiError} - Lỗi BadRequest
   */
  static badRequest(message = 'Bad Request', errors = {}) {
    return new ApiError(400, message, errors);
  }

  /**
   * Tạo một lỗi Unauthorized (401)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Unauthorized
   */
  static unauthorized(message = 'Unauthorized') {
    return new ApiError(401, message);
  }

  /**
   * Tạo một lỗi Forbidden (403)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Forbidden
   */
  static forbidden(message = 'Forbidden') {
    return new ApiError(403, message);
  }

  /**
   * Tạo một lỗi NotFound (404)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi NotFound
   */
  static notFound(message = 'Resource not found') {
    return new ApiError(404, message);
  }

  /**
   * Tạo một lỗi Conflict (409)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi Conflict
   */
  static conflict(message = 'Resource already exists') {
    return new ApiError(409, message);
  }

  /**
   * Tạo một lỗi InternalServer (500)
   * @param {string} message - Thông báo lỗi
   * @returns {ApiError} - Lỗi InternalServer
   */
  static internal(message = 'Internal Server Error') {
    return new ApiError(500, message);
  }
}

module.exports = ApiError;


--- File: server/src/common/middleware/errorHandler.js ---
const ApiError = require('../errors/apiError');
const logger = require('../../config/logger');

/**
 * Middleware xử lý lỗi toàn cục
 */
const errorHandler = (err, req, res, next) => {
  let error = err;

  // Nếu lỗi không phải là instance của ApiError, chuyển đổi thành ApiError
  if (!(error instanceof ApiError)) {
    const statusCode = error.statusCode || 500;
    const message = error.message || 'Something went wrong';
    error = new ApiError(statusCode, message, false, err.stack);
  }

  // Ghi log lỗi
  if (error.statusCode >= 500) {
    logger.error(error);
  } else {
    logger.warn(`${error.statusCode} - ${error.message}`);
  }

  // Phản hồi cho client
  const response = {
    status: error.status,
    message: error.message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack }),
  };

  // Thêm errors vào response nếu là ValidationError
  if (error.errors) {
    response.errors = error.errors;
  }

  res.status(error.statusCode).json(response);
  next();
};

module.exports = errorHandler;


--- File: server/src/common/middleware/rateLimiter.js ---
const rateLimit = require('express-rate-limit');
const BusinessError = require('../errors/apiError');

/**
 * Middleware giới hạn số request trong một khoảng thời gian
 * @param {Object} options - Tùy chọn cấu hình
 */
const rateLimiter = (options = {}) => {
  const defaultOptions = {
    windowMs: 15 * 60 * 1000, // 15 phút
    max: 100, // Giới hạn 100 request mỗi IP trong 15 phút
    message: 'Too many requests from this IP, please try again later',
  };

  const limiterOptions = { ...defaultOptions, ...options };

  return rateLimit({
    windowMs: limiterOptions.windowMs,
    max: limiterOptions.max,
    handler: (req, res, next) => {
      next(new BusinessError(limiterOptions.message, 429));
    },
  });
};

module.exports = rateLimiter;


--- File: server/src/common/middleware/requestLogger.js ---
const logger = require('../../config/logger');

/**
 * Middleware ghi log request và response
 */
const requestLogger = (req, res, next) => {
  // Lưu thời gian bắt đầu request
  req.startTime = Date.now();

  // Ghi log request
  logger.info({
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userId: req.user ? req.user.id : 'anonymous',
  });

  // Bắt sự kiện 'finish' để ghi log sau khi request hoàn thành
  res.on('finish', () => {
    const duration = Date.now() - req.startTime;
    logger.info({
      method: req.method,
      url: req.originalUrl,
      status: res.statusCode,
      duration: `${duration}ms`,
    });
  });

  next();
};

module.exports = requestLogger;


--- File: server/src/common/middleware/validate.js ---
const { ValidationError } = require('../errors/apiError');

/**
 * Middleware validation dựa trên schema
 * @param {Object} schema - Joi schema hoặc validation schema
 * @param {String} source - Nguồn dữ liệu cần validate ('body', 'query', 'params')
 */
const validate = (schema, source = 'body') => {
  return (req, res, next) => {
    const data = req[source];
    const { error, value } = schema.validate(data, { abortEarly: false });

    if (error) {
      const validationErrors = {};

      error.details.forEach((detail) => {
        const path = detail.path.join('.');
        validationErrors[path] = detail.message;
      });

      return next(new ValidationError('Validation failed', validationErrors));
    }

    // Gán lại dữ liệu đã được validate vào request
    req[source] = value;
    return next();
  };
};

module.exports = validate;


--- File: server/src/common/readme.md ---
```
server/
└── src/
    └── common/                    # Shared code dùng chung trong toàn bộ ứng dụng
        ├── errors/                # Custom error classes
        │   ├── apiError.js             # Class định nghĩa các loại lỗi API chung
        │   ├── authError.js            # Lỗi liên quan đến xác thực
        │   ├── validationError.js      # Lỗi liên quan đến validation
        │   ├── notFoundError.js        # Lỗi khi không tìm thấy tài nguyên
        │   ├── forbiddenError.js       # Lỗi về quyền truy cập
        │   └── businessError.js        # Lỗi liên quan đến business logic
        │
        ├── middleware/            # Middleware dùng chung
        │   ├── errorHandler.js         # Middleware xử lý lỗi chung
        │   ├── validate.js             # Middleware validation chung
        │   ├── requestLogger.js        # Middleware ghi log request/response
        │   └── rateLimiter.js          # Giới hạn số request trong một khoảng thời gian
        │
        ├── types/                 # Type definitions và interfaces
        │   ├── express.d.ts            # Type definitions mở rộng cho Express
        │   ├── auth.types.js           # Types liên quan đến authentication
        │   ├── product.types.js        # Types liên quan đến product
        │   ├── order.types.js          # Types liên quan đến order
        │   └── common.types.js         # Types dùng chung
        │
        ├── utils/                 # Các utility functions dùng trong nhiều modules
        │   ├── apiFeatures.js          # Xử lý filtering, sorting, pagination
        │   ├── catchAsync.js           # Wrapper function để xử lý async errors
        │   ├── responseHandler.js      # Format response trả về từ API
        │   ├── validatorUtils.js       # Các helper functions cho validation
        │   ├── dateUtils.js            # Các utility function xử lý datetime
        │   ├── fileUtils.js            # Xử lý file upload, manipulation
        │   ├── securityUtils.js        # Các utility cho hash, token, encrypt
        │   └── formatters.js           # Các hàm format data (currency, phone, etc.)
        │
        └── validators/            # Định nghĩa validation schema và rules
            ├── authValidator.js        # Validation rules cho auth requests
            ├── userValidator.js        # Validation rules cho user requests
            ├── productValidator.js     # Validation rules cho product requests
            ├── categoryValidator.js    # Validation rules cho category requests
            ├── orderValidator.js       # Validation rules cho order requests
            ├── cartValidator.js        # Validation rules cho cart requests
            ├── reviewValidator.js      # Validation rules cho review requests
            └── commonValidator.js      # Validation rules dùng chung

        └── readme.md                 # README file for common package

```
1. errors/
Thư mục này chứa các class định nghĩa lỗi tùy chỉnh để xử lý lỗi một cách nhất quán trong toàn bộ ứng dụng.

apiError.js: Class cơ sở cho tất cả các loại lỗi API. Định nghĩa cấu trúc lỗi với statusCode, message, và các thông tin bổ sung.
authError.js: Lỗi xác thực như token không hợp lệ, hết hạn, không có quyền, v.v.
validationError.js: Lỗi xảy ra khi dữ liệu đầu vào không đạt yêu cầu validation.
notFoundError.js: Lỗi khi tài nguyên không tồn tại (404).
forbiddenError.js: Lỗi khi người dùng không có quyền truy cập tài nguyên (403).
businessError.js: Lỗi liên quan đến logic nghiệp vụ, ví dụ: sản phẩm hết hàng, đơn hàng đã bị hủy, v.v.

2. middleware/
Chứa các middleware dùng chung có thể áp dụng ở nhiều nơi trong ứng dụng.

errorHandler.js: Middleware xử lý tất cả các lỗi, chuyển đổi chúng thành response chuẩn.
validate.js: Middleware xác thực dữ liệu đầu vào dựa trên schema được định nghĩa.
requestLogger.js: Ghi log tất cả các requests và responses để debugging và monitoring.
rateLimiter.js: Giới hạn số lượng request trong một khoảng thời gian để ngăn chặn DoS.

3. types/
Định nghĩa các kiểu dữ liệu và interfaces để đảm bảo tính nhất quán trong toàn bộ ứng dụng.

express.d.ts: Mở rộng kiểu dữ liệu cho Express, ví dụ: thêm thuộc tính user vào Request.
auth.types.js: Định nghĩa các kiểu liên quan đến xác thực như UserRole, TokenPayload.
product.types.js: Định nghĩa các kiểu dữ liệu cho sản phẩm như ProductStatus, ProductVariant.
order.types.js: Định nghĩa các kiểu dữ liệu cho đơn hàng như OrderStatus, PaymentStatus.
common.types.js: Các kiểu dữ liệu dùng chung như PaginationParams, SortDirection.

4. utils/
Các hàm tiện ích dùng chung trong ứng dụng.

apiFeatures.js: Xử lý các tính năng API như filtering, sorting, pagination một cách nhất quán.
catchAsync.js: Wrapper function để bắt lỗi trong các hàm async mà không cần try/catch lặp lại.
responseHandler.js: Chuẩn hóa cấu trúc response từ API (success, error, data, message).
validatorUtils.js: Các hàm hỗ trợ cho validation như isValidEmail, isStrongPassword.
dateUtils.js: Xử lý các operations liên quan đến datetime như format, compare, diff.
fileUtils.js: Xử lý file upload, manipulation, validation.
securityUtils.js: Các hàm liên quan đến bảo mật như hash password, generate token.
formatters.js: Định dạng data như formatCurrency, formatPhoneNumber, formatAddress.

5. validators/
Chứa các schema và rules validation cho dữ liệu đầu vào.

authValidator.js: Validation cho request đăng nhập, đăng ký, đặt lại mật khẩu.
userValidator.js: Validation cho thông tin người dùng, cập nhật profile.
productValidator.js: Validation cho thông tin sản phẩm, thêm/sửa sản phẩm.
categoryValidator.js: Validation cho thông tin danh mục.
orderValidator.js: Validation cho thông tin đơn hàng, cập nhật trạng thái.
cartValidator.js: Validation cho thông tin giỏ hàng, thêm/sửa sản phẩm trong giỏ.
reviewValidator.js: Validation cho đánh giá sản phẩm.
commonValidator.js: Các rules validation dùng chung như validateObjectId, validatePagination.
```


--- File: server/src/common/types/auth.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến authentication
 */

// Enum vai trò người dùng
const UserRole = {
  ADMIN: 'admin',
  STAFF: 'staff',
  USER: 'user',
};

// Cấu trúc payload trong JWT token
const TokenPayload = {
  id: String, // ID người dùng
  email: String, // Email người dùng
  role: String, // Vai trò người dùng
  iat: Number, // Issued at - thời điểm token được tạo
  exp: Number, // Expiration - thời điểm token hết hạn
};

// Cấu trúc response khi đăng nhập
const AuthResponse = {
  user: Object, // Thông tin người dùng
  token: String, // Access token
  refreshToken: String, // Refresh token
};

module.exports = {
  UserRole,
  TokenPayload,
  AuthResponse,
};


--- File: server/src/common/types/common.types.js ---
/**
 * Các kiểu dữ liệu dùng chung trong ứng dụng
 */

// Tham số phân trang
const PaginationParams = {
  page: Number, // Trang hiện tại
  limit: Number, // Số lượng item mỗi trang
  total: Number, // Tổng số item
  totalPages: Number, // Tổng số trang
};

// Hướng sắp xếp
const SortDirection = {
  ASC: 'asc',
  DESC: 'desc',
};

// Điều kiện lọc
const FilterOperator = {
  EQ: 'eq', // Bằng
  NE: 'ne', // Không bằng
  GT: 'gt', // Lớn hơn
  GTE: 'gte', // Lớn hơn hoặc bằng
  LT: 'lt', // Nhỏ hơn
  LTE: 'lte', // Nhỏ hơn hoặc bằng
  IN: 'in', // Trong tập giá trị
  NIN: 'nin', // Không trong tập giá trị
  REGEX: 'regex', // Khớp với biểu thức chính quy
};

module.exports = {
  PaginationParams,
  SortDirection,
  FilterOperator,
};


--- File: server/src/common/types/express.d.ts ---
// Mở rộng kiểu Request từ Express
declare namespace Express {
    export interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
        permissions?: string[];
      };
      startTime?: number;
      correlationId?: string;
    }
  }

--- File: server/src/common/types/order.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến đơn hàng
 */

// Enum trạng thái đơn hàng
const OrderStatus = {
  PENDING: 'pending', // Chờ xác nhận
  PROCESSING: 'processing', // Đang xử lý
  PACKED: 'packed', // Đã đóng gói
  SHIPPED: 'shipped', // Đang giao hàng
  DELIVERED: 'delivered', // Đã giao hàng
  CANCELLED: 'cancelled', // Đã hủy
  RETURNED: 'returned', // Đã trả hàng
};

// Enum trạng thái thanh toán
const PaymentStatus = {
  PENDING: 'pending', // Chờ thanh toán
  AUTHORIZED: 'authorized', // Đã ủy quyền
  PAID: 'paid', // Đã thanh toán
  FAILED: 'failed', // Thanh toán thất bại
  REFUNDED: 'refunded', // Đã hoàn tiền
  PARTIALLY_REFUNDED: 'partially_refunded', // Hoàn tiền một phần
};

// Enum phương thức thanh toán
const PaymentMethod = {
  COD: 'cod', // Thanh toán khi nhận hàng
  CREDIT_CARD: 'credit_card', // Thẻ tín dụng
  VNPAY: 'vnpay', // VNPay
  BANK_TRANSFER: 'bank_transfer', // Chuyển khoản ngân hàng
  MOMO: 'momo', // Ví MoMo
};

module.exports = {
  OrderStatus,
  PaymentStatus,
  PaymentMethod,
};


--- File: server/src/common/types/product.types.js ---
/**
 * Các kiểu dữ liệu liên quan đến sản phẩm
 */

// Enum trạng thái sản phẩm
const ProductStatus = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  OUT_OF_STOCK: 'out_of_stock',
  COMING_SOON: 'coming_soon',
  DISCONTINUED: 'discontinued',
};

// Enum loại sản phẩm
const ProductType = {
  CUE: 'cue', // Gậy billiard
  BALL: 'ball', // Bi
  ACCESSORIES: 'accessories', // Phụ kiện
  TABLE: 'table', // Bàn billiard
  CHALK: 'chalk', // Phấn
};

module.exports = {
  ProductStatus,
  ProductType,
};


--- File: server/src/common/utils/apiFeatures.js ---
/**
 * Class xử lý các tính năng API như filtering, sorting, pagination
 */
class APIFeatures {
  /**
   * @param {Object} query - Mongoose query object
   * @param {Object} queryString - Query string từ Express request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * Filter query dựa trên các tham số
   * Hỗ trợ các operators: gt, gte, lt, lte, in
   */
  filter() {
    const queryObj = { ...this.queryString };
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'q', 'populate'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // Advanced filtering với gte, gt, lte, lt
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in)\b/g, (match) => `$${match}`);

    this.query = this.query.find(JSON.parse(queryStr));
    return this;
  }

  /**
   * Sắp xếp kết quả
   * Format: sort=field,direction (ví dụ: sort=price,-createdAt)
   */
  sort() {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // Default sort theo createdAt giảm dần (mới nhất trước)
      this.query = this.query.sort('-createdAt');
    }
    return this;
  }

  /**
   * Giới hạn các trường được trả về
   * Format: fields=field1,field2,-field3
   */
  limitFields() {
    if (this.queryString.fields) {
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // Mặc định bỏ trường __v
      this.query = this.query.select('-__v');
    }
    return this;
  }

  /**
   * Phân trang kết quả
   * page: Số trang (default: 1)
   * limit: Số items mỗi trang (default: 10)
   */
  paginate() {
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    this.query = this.query.skip(skip).limit(limit);
    return this;
  }

  /**
   * Populate các trường reference
   * Format: populate=field1,field2
   */
  populate() {
    if (this.queryString.populate) {
      const fields = this.queryString.populate.split(',');
      fields.forEach((field) => {
        this.query = this.query.populate(field);
      });
    }
    return this;
  }

  /**
   * Search dựa trên text index
   * Format: q=search term
   */
  search() {
    if (this.queryString.q) {
      this.query = this.query.find({ $text: { $search: this.queryString.q } });
    }
    return this;
  }
}

module.exports = APIFeatures;


--- File: server/src/common/utils/catchAsync.js ---
/**
 * Wrapper function để bắt lỗi trong các hàm async
 * Tránh việc phải sử dụng try/catch nhiều lần
 *
 * @param {Function} fn - Async function cần bọc
 * @returns {Function} Middleware function với lỗi đã được xử lý
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

module.exports = catchAsync;


--- File: server/src/common/utils/dateUtils.js ---
/**
 * Các hàm tiện ích xử lý datetime
 */
/**
 * no-type
 * @module dateUtils
 * @description Các hàm tiện ích xử lý datetime
 * @example
 * const dateUtils = require('./dateUtils');
 * const formattedDate = dateUtils.formatDate(new Date());
 */
const dateUtils = {
  /**
   * Format date theo định dạng DD/MM/YYYY
   *
   * @param {Date} date - Date object cần format
   * @returns {String} Chuỗi đã format
   */
  formatDate: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();

    return `${day}/${month}/${year}`;
  },

  /**
   * Format datetime theo định dạng DD/MM/YYYY HH:MM
   *
   * @param {Date} date - Date object cần format
   * @returns {String} Chuỗi đã format
   */
  formatDateTime: (date) => {
    if (!date) return '';

    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');

    return `${day}/${month}/${year} ${hours}:${minutes}`;
  },

  /**
   * Tính số ngày giữa hai ngày
   *
   * @param {Date} startDate - Ngày bắt đầu
   * @param {Date} endDate - Ngày kết thúc
   * @returns {Number} Số ngày
   */
  daysBetween: (startDate, endDate) => {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end.getTime() - start.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    return diffDays;
  },

  /**
   * Thêm số ngày vào một ngày
   *
   * @param {Date} date - Ngày gốc
   * @param {Number} days - Số ngày cần thêm
   * @returns {Date} Ngày mới
   */
  addDays: (date, days) => {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  },

  /**
   * Lấy ngày đầu tiên của tháng
   *
   * @param {Date} date - Ngày bất kỳ trong tháng
   * @returns {Date} Ngày đầu tiên của tháng
   */
  firstDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth(), 1);
  },

  /**
   * Lấy ngày cuối cùng của tháng
   *
   * @param {Date} date - Ngày bất kỳ trong tháng
   * @returns {Date} Ngày cuối cùng của tháng
   */
  lastDayOfMonth: (date) => {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0);
  },

  /**
   * Kiểm tra ngày có phải là ngày hiện tại
   *
   * @param {Date} date - Ngày cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isToday: (date) => {
    const today = new Date();
    const d = new Date(date);

    return (
      d.getDate() === today.getDate() &&
      d.getMonth() === today.getMonth() &&
      d.getFullYear() === today.getFullYear()
    );
  },
};

module.exports = dateUtils;


--- File: server/src/common/utils/fileUtils.js ---
const fs = require('fs');
const path = require('path');
const util = require('util');
const crypto = require('crypto');

// Promisify fs functions
const unlinkAsync = util.promisify(fs.unlink);
const mkdirAsync = util.promisify(fs.mkdir);
const statAsync = util.promisify(fs.stat);

/**
 * Các hàm tiện ích xử lý file
 */
const fileUtils = {
  /**
   * Kiểm tra một file có tồn tại
   *
   * @param {String} filePath - Đường dẫn file
   * @returns {Promise<Boolean>} Kết quả kiểm tra
   */
  fileExists: async (filePath) => {
    try {
      await statAsync(filePath);
      return true;
    } catch (error) {
      return false;
    }
  },

  /**
   * Tạo thư mục nếu chưa tồn tại
   *
   * @param {String} dirPath - Đường dẫn thư mục
   * @returns {Promise<void>}
   */
  ensureDirectoryExists: async (dirPath) => {
    if (!fs.existsSync(dirPath)) {
      await mkdirAsync(dirPath, { recursive: true });
    }
  },

  /**
   * Xóa một file
   *
   * @param {String} filePath - Đường dẫn file
   * @returns {Promise<void>}
   */
  removeFile: async (filePath) => {
    if (await fileUtils.fileExists(filePath)) {
      await unlinkAsync(filePath);
    }
  },

  /**
   * Lấy extension của file
   *
   * @param {String} filename - Tên file
   * @returns {String} Extension của file
   */
  getFileExtension: (filename) => {
    return path.extname(filename).toLowerCase();
  },

  /**
   * Kiểm tra file có phải là hình ảnh
   *
   * @param {String} filename - Tên file
   * @returns {Boolean} Kết quả kiểm tra
   */
  isImageFile: (filename) => {
    const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
    const extension = fileUtils.getFileExtension(filename);
    return validExtensions.includes(extension);
  },

  /**
   * Tạo tên file ngẫu nhiên
   *
   * @param {String} originalname - Tên file gốc
   * @returns {String} Tên file mới
   */
  generateUniqueFilename: (originalname) => {
    const extension = fileUtils.getFileExtension(originalname);
    const randomName = crypto.randomBytes(16).toString('hex');
    return `${randomName}${extension}`;
  },

  /**
   * Tính kích thước file theo định dạng readable
   *
   * @param {Number} bytes - Kích thước file tính bằng bytes
   * @returns {String} Kích thước file dạng readable
   */
  formatFileSize: (bytes) => {
    if (bytes === 0) return '0 Bytes';

    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));

    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
  },
};

module.exports = fileUtils;


--- File: server/src/common/utils/formatters.js ---
/**
 * Các hàm tiện ích định dạng dữ liệu
 */
const formatters = {
  /**
   * Định dạng số tiền
   *
   * @param {Number} amount - Số tiền cần định dạng
   * @param {String} currency - Đơn vị tiền tệ (mặc định: VND)
   * @returns {String} Chuỗi đã định dạng
   */
  formatCurrency: (amount, currency = 'VND') => {
    const formatter = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
    });

    return formatter.format(amount);
  },

  /**
   * Định dạng số điện thoại Việt Nam
   *
   * @param {String} phone - Số điện thoại cần định dạng
   * @returns {String} Số điện thoại đã định dạng
   */
  formatPhoneNumber: (phone) => {
    if (!phone) return '';

    // Loại bỏ tất cả ký tự không phải số
    const cleaned = phone.replace(/\D/g, '');

    // Kiểm tra độ dài
    if (cleaned.length !== 10) return phone;

    // Định dạng: XXX XXX XXXX
    return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)} ${cleaned.slice(6)}`;
  },

  /**
   * Định dạng địa chỉ
   *
   * @param {Object} address - Object chứa thông tin địa chỉ
   * @returns {String} Địa chỉ đã định dạng
   */
  formatAddress: (address) => {
    if (!address) return '';

    const parts = [];

    if (address.street) parts.push(address.street);
    if (address.city) parts.push(address.city);
    if (address.state) parts.push(address.state);
    if (address.zipCode) parts.push(address.zipCode);
    if (address.country) parts.push(address.country);

    return parts.join(', ');
  },

  /**
   * Rút gọn chuỗi nếu quá dài
   *
   * @param {String} text - Chuỗi cần rút gọn
   * @param {Number} maxLength - Độ dài tối đa
   * @returns {String} Chuỗi đã rút gọn
   */
  truncateText: (text, maxLength = 100) => {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.slice(0, maxLength) + '...';
  },

  /**
   * Chuyển đổi chuỗi thành slug URL
   *
   * @param {String} text - Chuỗi cần chuyển đổi
   * @returns {String} Slug URL
   */
  slugify: (text) => {
    if (!text) return '';

    // Chuyển về chữ thường và thay thế dấu tiếng Việt
    const slug = text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[đĐ]/g, 'd')
      .replace(/[^a-z0-9\s-]/g, '') // Loại bỏ ký tự đặc biệt
      .replace(/\s+/g, '-') // Thay space bằng dấu gạch ngang
      .replace(/-+/g, '-') // Loại bỏ dấu gạch ngang liên tiếp
      .trim();

    return slug;
  },

  /**
   * Định dạng tên người
   *
   * @param {String} firstName - Tên
   * @param {String} lastName - Họ
   * @returns {String} Tên đầy đủ
   */
  formatName: (firstName, lastName) => {
    if (!firstName && !lastName) return '';
    if (!firstName) return lastName;
    if (!lastName) return firstName;

    return `${lastName} ${firstName}`;
  },

  /**
   * Định dạng dữ liệu sản phẩm trước khi trả về client
   *
   * @param {Object} product - Dữ liệu sản phẩm cần định dạng
   * @returns {Object} - Dữ liệu sản phẩm đã được định dạng
   */
  formatProductResponse: (product) => {
    if (!product) return null;

    // Tạo bản sao để không ảnh hưởng đến dữ liệu gốc
    const formattedProduct = { ...product };

    // Định dạng giá tiền
    if (formattedProduct.pricing) {
      if (formattedProduct.pricing.regular) {
        formattedProduct.pricing.formattedRegularPrice = formatters.formatCurrency(
          formattedProduct.pricing.regular,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.sale) {
        formattedProduct.pricing.formattedSalePrice = formatters.formatCurrency(
          formattedProduct.pricing.sale,
          formattedProduct.pricing.currency || 'VND'
        );
      }

      if (formattedProduct.pricing.finalPrice) {
        formattedProduct.pricing.formattedFinalPrice = formatters.formatCurrency(
          formattedProduct.pricing.finalPrice,
          formattedProduct.pricing.currency || 'VND'
        );
      }
    }

    // Định dạng mô tả ngắn gọn
    if (formattedProduct.description) {
      formattedProduct.shortDescription = formatters.truncateText(
        formattedProduct.description,
        150
      );
    }

    // Định dạng ngày tháng
    if (formattedProduct.dates) {
      if (formattedProduct.dates.created) {
        formattedProduct.dates.formattedCreatedDate = new Date(
          formattedProduct.dates.created
        ).toLocaleDateString('vi-VN');
      }
      if (formattedProduct.dates.updated) {
        formattedProduct.dates.formattedUpdatedDate = new Date(
          formattedProduct.dates.updated
        ).toLocaleDateString('vi-VN');
      }
    }

    // Định dạng trạng thái tồn kho
    if (formattedProduct.inventory) {
      formattedProduct.inventory.statusText = formattedProduct.inventory.inStock
        ? 'Còn hàng'
        : 'Hết hàng';
    }

    // Định dạng đánh giá trung bình
    if (formattedProduct.averageRating !== undefined) {
      formattedProduct.formattedRating = formattedProduct.averageRating.toFixed(1);
    }

    return formattedProduct;
  },
};

module.exports = formatters;


--- File: server/src/common/utils/responseHandler.js ---
/**
 * Tiện ích xử lý response chuẩn hóa
 */
const responseHandler = {
  /**
   * Trả về response thành công
   *
   * @param {Object} res - Express response object
   * @param {Object} data - Dữ liệu trả về
   * @param {String} message - Thông báo thành công
   * @param {Number} statusCode - HTTP status code
   */
  success: (res, data = null, message = 'Success', statusCode = 200) => {
    return res.status(statusCode).json({
      status: 'success',
      message,
      data,
    });
  },

  /**
   * Trả về response lỗi
   *
   * @param {Object} res - Express response object
   * @param {String} message - Thông báo lỗi
   * @param {Number} statusCode - HTTP status code
   * @param {Object} errors - Chi tiết lỗi
   */
  error: (res, message = 'Error occurred', statusCode = 400, errors = null) => {
    const response = {
      status: 'error',
      message,
    };

    if (errors) {
      response.errors = errors;
    }

    return res.status(statusCode).json(response);
  },

  /**
   * Trả về response khi tạo thành công
   *
   * @param {Object} res - Express response object
   * @param {Object} data - Dữ liệu trả về
   * @param {String} message - Thông báo thành công
   */
  created: (res, data = null, message = 'Resource created successfully') => {
    return responseHandler.success(res, data, message, 201);
  },

  /**
   * Trả về response không có nội dung
   *
   * @param {Object} res - Express response object
   */
  noContent: (res) => {
    return res.status(204).end();
  },

  /**
   * Trả về response với dữ liệu được phân trang
   *
   * @param {Object} res - Express response object
   * @param {Array} data - Dữ liệu trả về
   * @param {Number} page - Trang hiện tại
   * @param {Number} limit - Số lượng items mỗi trang
   * @param {Number} total - Tổng số items
   */
  paginated: (res, data, page, limit, total) => {
    const totalPages = Math.ceil(total / limit);

    return res.status(200).json({
      status: 'success',
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages,
      },
    });
  },
};

module.exports = responseHandler;


--- File: server/src/common/utils/securityUtils.js ---
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

/**
 * Các hàm tiện ích liên quan đến bảo mật
 */
const securityUtils = {
  /**
   * Hash mật khẩu sử dụng bcrypt
   *
   * @param {String} password - Mật khẩu cần hash
   * @returns {Promise<String>} Mật khẩu đã hash
   */
  hashPassword: async (password) => {
    const saltRounds = 10;
    return await bcrypt.hash(password, saltRounds);
  },

  /**
   * So sánh mật khẩu với hash
   *
   * @param {String} password - Mật khẩu cần kiểm tra
   * @param {String} hash - Hash đã lưu
   * @returns {Promise<Boolean>} Kết quả so sánh
   */
  comparePassword: async (password, hash) => {
    return await bcrypt.compare(password, hash);
  },

  /**
   * Tạo JWT token
   *
   * @param {Object} payload - Dữ liệu cần lưu trong token
   * @param {String} secret - Secret key
   * @param {Object} options - Tùy chọn cho token
   * @returns {String} JWT token
   */
  generateToken: (payload, secret, options = {}) => {
    return jwt.sign(payload, secret, options);
  },

  /**
   * Xác thực và decode JWT token
   *
   * @param {String} token - JWT token
   * @param {String} secret - Secret key
   * @returns {Object} Payload đã decode
   */
  verifyToken: (token, secret) => {
    return jwt.verify(token, secret);
  },

  /**
   * Tạo chuỗi random để làm reset token, verification token...
   *
   * @param {Number} length - Độ dài chuỗi (mặc định: 32)
   * @returns {String} Chuỗi random
   */
  generateRandomToken: (length = 32) => {
    return crypto.randomBytes(length).toString('hex');
  },

  /**
   * Hash một chuỗi sử dụng SHA-256
   *
   * @param {String} data - Chuỗi cần hash
   * @returns {String} Chuỗi đã hash
   */
  hashData: (data) => {
    return crypto.createHash('sha256').update(data).digest('hex');
  },

  /**
   * Mã hóa dữ liệu
   *
   * @param {String} data - Dữ liệu cần mã hóa
   * @param {String} secret - Secret key
   * @returns {String} Dữ liệu đã mã hóa
   */
  encrypt: (data, secret) => {
    const algorithm = 'aes-256-ctr';
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, secret, iv);

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return `${iv.toString('hex')}:${encrypted}`;
  },

  /**
   * Giải mã dữ liệu
   *
   * @param {String} encryptedData - Dữ liệu đã mã hóa
   * @param {String} secret - Secret key
   * @returns {String} Dữ liệu đã giải mã
   */
  decrypt: (encryptedData, secret) => {
    const algorithm = 'aes-256-ctr';
    const [ivHex, encrypted] = encryptedData.split(':');

    const iv = Buffer.from(ivHex, 'hex');
    const decipher = crypto.createDecipheriv(algorithm, secret, iv);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  },
};

module.exports = securityUtils;


--- File: server/src/common/utils/validatorUtils.js ---
const mongoose = require('mongoose');

/**
 * Các hàm tiện ích cho validation
 */
const validatorUtils = {
  /**
   * Kiểm tra chuỗi có phải là email hợp lệ
   *
   * @param {String} email - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidEmail: (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  /**
   * Kiểm tra chuỗi có phải là số điện thoại Việt Nam hợp lệ
   *
   * @param {String} phone - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidVietnamesePhone: (phone) => {
    const phoneRegex = /(84|0[3|5|7|8|9])+([0-9]{8})\b/;
    return phoneRegex.test(phone);
  },

  /**
   * Kiểm tra chuỗi có phải là mật khẩu mạnh
   * Yêu cầu: ít nhất 8 ký tự, chứa chữ hoa, chữ thường, số và ký tự đặc biệt
   *
   * @param {String} password - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isStrongPassword: (password) => {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  },

  /**
   * Kiểm tra chuỗi có phải là MongoDB ObjectId hợp lệ
   *
   * @param {String} id - Chuỗi cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isValidObjectId: (id) => {
    return mongoose.Types.ObjectId.isValid(id);
  },

  /**
   * Kiểm tra giá trị có phải là số nguyên dương
   *
   * @param {Number} value - Giá trị cần kiểm tra
   * @returns {Boolean} Kết quả kiểm tra
   */
  isPositiveInteger: (value) => {
    return Number.isInteger(value) && value > 0;
  },

  /**
   * Kiểm tra giá trị có nằm trong khoảng
   *
   * @param {Number} value - Giá trị cần kiểm tra
   * @param {Number} min - Giá trị tối thiểu
   * @param {Number} max - Giá trị tối đa
   * @returns {Boolean} Kết quả kiểm tra
   */
  isInRange: (value, min, max) => {
    return value >= min && value <= max;
  },
};

module.exports = validatorUtils;


--- File: server/src/common/validators/authValidator.js ---
/**
 * Auth Validator - Định nghĩa các schema validation cho authentication
 * @author Steve
 * @project RunOut-Biliard
 */

const Joi = require('joi');

// Schema đăng ký
const registerSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().messages({
    'string.min': 'Tên phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên không được vượt quá {#limit} ký tự',
    'string.empty': 'Tên không được để trống',
    'any.required': 'Tên là trường bắt buộc',
  }),

  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.pattern.base': 'Mật khẩu phải chứa ít nhất một chữ hoa, một chữ thường và một chữ số',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là trường bắt buộc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
    'string.empty': 'Xác nhận mật khẩu không được để trống',
    'any.required': 'Xác nhận mật khẩu là trường bắt buộc',
  }),

  phone: Joi.string()
    .pattern(/^(0|\+84)[3|5|7|8|9][0-9]{8}$/)
    .allow('', null)
    .messages({
      'string.pattern.base': 'Số điện thoại không hợp lệ',
    }),
});

// Schema đăng nhập
const loginSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),

  password: Joi.string().required().messages({
    'string.empty': 'Mật khẩu không được để trống',
    'any.required': 'Mật khẩu là trường bắt buộc',
  }),

  rememberMe: Joi.boolean().default(false),
});

// Schema refresh token
const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().required().messages({
    'string.empty': 'Refresh token không được để trống',
    'any.required': 'Refresh token là trường bắt buộc',
  }),
});

// Schema quên mật khẩu
const forgotPasswordSchema = Joi.object({
  email: Joi.string()
    .email({ tlds: { allow: false } })
    .required()
    .messages({
      'string.email': 'Email không hợp lệ',
      'string.empty': 'Email không được để trống',
      'any.required': 'Email là trường bắt buộc',
    }),
});

// Schema đặt lại mật khẩu
const resetPasswordSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token không được để trống',
    'any.required': 'Token là trường bắt buộc',
  }),

  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]+$/)
    .required()
    .messages({
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.pattern.base': 'Mật khẩu phải chứa ít nhất một chữ hoa, một chữ thường và một chữ số',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là trường bắt buộc',
    }),

  confirmPassword: Joi.string().valid(Joi.ref('password')).required().messages({
    'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
    'string.empty': 'Xác nhận mật khẩu không được để trống',
    'any.required': 'Xác nhận mật khẩu là trường bắt buộc',
  }),
});

// Schema xác thực email
const verifyEmailSchema = Joi.object({
  token: Joi.string().required().messages({
    'string.empty': 'Token không được để trống',
    'any.required': 'Token là trường bắt buộc',
  }),
});

module.exports = {
  register: registerSchema,
  login: loginSchema,
  refreshToken: refreshTokenSchema,
  forgotPassword: forgotPasswordSchema,
  resetPassword: resetPasswordSchema,
  verifyEmail: verifyEmailSchema,
};


--- File: server/src/common/validators/cartValidator.js ---
// server/src/common/validators/cartValidator.js

const Joi = require('joi');

const createCartValidator = Joi.object({
  user: Joi.string().allow(null).messages({
    'string.base': 'User ID phải là một chuỗi',
  }),

  sessionId: Joi.string().allow(null).messages({
    'string.base': 'Session ID phải là một chuỗi',
  }),

  items: Joi.array()
    .items(
      Joi.object({
        product: Joi.string().required().messages({
          'string.base': 'Product ID phải là một chuỗi',
          'string.empty': 'Product ID không được để trống',
          'any.required': 'Product ID là bắt buộc',
        }),
        quantity: Joi.number().integer().min(1).required().messages({
          'number.base': 'Số lượng phải là một số',
          'number.integer': 'Số lượng phải là số nguyên',
          'number.min': 'Số lượng phải lớn hơn 0',
          'any.required': 'Số lượng là bắt buộc',
        }),
        attributes: Joi.object().allow(null).default({}),
      })
    )
    .default([]),
})
  .or('user', 'sessionId')
  .messages({
    'object.missing': 'Phải có ít nhất một trong hai trường user hoặc sessionId',
  });

const addItemValidator = Joi.object({
  product: Joi.string().required().messages({
    'string.base': 'Product ID phải là một chuỗi',
    'string.empty': 'Product ID không được để trống',
    'any.required': 'Product ID là bắt buộc',
  }),
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'Số lượng phải là một số',
    'number.integer': 'Số lượng phải là số nguyên',
    'number.min': 'Số lượng phải lớn hơn 0',
    'any.required': 'Số lượng là bắt buộc',
  }),
  attributes: Joi.object().allow(null).default({}),
});

const updateItemValidator = Joi.object({
  quantity: Joi.number().integer().min(1).required().messages({
    'number.base': 'Số lượng phải là một số',
    'number.integer': 'Số lượng phải là số nguyên',
    'number.min': 'Số lượng phải lớn hơn 0',
    'any.required': 'Số lượng là bắt buộc',
  }),
});

const applyCouponValidator = Joi.object({
  code: Joi.string().required().messages({
    'string.base': 'Mã giảm giá phải là một chuỗi',
    'string.empty': 'Mã giảm giá không được để trống',
    'any.required': 'Mã giảm giá là bắt buộc',
  }),
});

const shippingAddressValidator = Joi.object({
  name: Joi.string().required().messages({
    'string.base': 'Tên người nhận phải là một chuỗi',
    'string.empty': 'Tên người nhận không được để trống',
    'any.required': 'Tên người nhận là bắt buộc',
  }),
  phone: Joi.string()
    .required()
    .pattern(/^(0|\+84)([0-9]{9,10})$/)
    .messages({
      'string.base': 'Số điện thoại phải là một chuỗi',
      'string.empty': 'Số điện thoại không được để trống',
      'string.pattern.base': 'Số điện thoại không hợp lệ (phải là số điện thoại Việt Nam)',
      'any.required': 'Số điện thoại là bắt buộc',
    }),
  street: Joi.string().required().messages({
    'string.base': 'Địa chỉ đường phố phải là một chuỗi',
    'string.empty': 'Địa chỉ đường phố không được để trống',
    'any.required': 'Địa chỉ đường phố là bắt buộc',
  }),
  city: Joi.string().required().messages({
    'string.base': 'Thành phố phải là một chuỗi',
    'string.empty': 'Thành phố không được để trống',
    'any.required': 'Thành phố là bắt buộc',
  }),
  state: Joi.string().allow('', null).messages({
    'string.base': 'Tỉnh/Bang phải là một chuỗi',
  }),
  zipCode: Joi.string().required().messages({
    'string.base': 'Mã bưu điện phải là một chuỗi',
    'string.empty': 'Mã bưu điện không được để trống',
    'any.required': 'Mã bưu điện là bắt buộc',
  }),
  country: Joi.string().required().messages({
    'string.base': 'Quốc gia phải là một chuỗi',
    'string.empty': 'Quốc gia không được để trống',
    'any.required': 'Quốc gia là bắt buộc',
  }),
  notes: Joi.string().allow('', null).messages({
    'string.base': 'Ghi chú phải là một chuỗi',
  }),
});

const shippingMethodValidator = Joi.object({
  type: Joi.string().valid('standard', 'express').required().messages({
    'string.base': 'Phương thức vận chuyển phải là một chuỗi',
    'string.empty': 'Phương thức vận chuyển không được để trống',
    'any.only': 'Phương thức vận chuyển phải là một trong các giá trị: standard, express',
    'any.required': 'Phương thức vận chuyển là bắt buộc',
  }),
});

const checkoutValidator = Joi.object({
  cartId: Joi.string().required().messages({
    'string.base': 'Cart ID phải là một chuỗi',
    'string.empty': 'Cart ID không được để trống',
    'any.required': 'Cart ID là bắt buộc',
  }),
  shippingAddress: shippingAddressValidator.required().messages({
    'any.required': 'Địa chỉ giao hàng là bắt buộc',
  }),
  shippingMethod: shippingMethodValidator.required().messages({
    'any.required': 'Phương thức vận chuyển là bắt buộc',
  }),
  paymentMethod: Joi.string()
    .valid('cod', 'bank_transfer', 'vnpay', 'credit_card')
    .required()
    .messages({
      'string.base': 'Phương thức thanh toán phải là một chuỗi',
      'string.empty': 'Phương thức thanh toán không được để trống',
      'any.only':
        'Phương thức thanh toán phải là một trong các giá trị: cod, bank_transfer, vnpay, credit_card',
      'any.required': 'Phương thức thanh toán là bắt buộc',
    }),
  customerNotes: Joi.string().allow('', null).max(500).messages({
    'string.base': 'Ghi chú phải là một chuỗi',
    'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
  }),
});

const mergeCartsValidator = Joi.object({
  sourceCartId: Joi.string().required().messages({
    'string.base': 'Source Cart ID phải là một chuỗi',
    'string.empty': 'Source Cart ID không được để trống',
    'any.required': 'Source Cart ID là bắt buộc',
  }),
  destinationCartId: Joi.string().required().messages({
    'string.base': 'Destination Cart ID phải là một chuỗi',
    'string.empty': 'Destination Cart ID không được để trống',
    'any.required': 'Destination Cart ID là bắt buộc',
  }),
});

module.exports = {
  createCartValidator,
  addItemValidator,
  updateItemValidator,
  applyCouponValidator,
  shippingAddressValidator,
  shippingMethodValidator,
  checkoutValidator,
  mergeCartsValidator,
};


--- File: server/src/common/validators/categoryValidator.js ---
/**
 * Category Validator
 * Định nghĩa các validation rules cho category API
 */

const Joi = require('joi');

const categoryValidator = {
  /**
   * Validate khi tạo danh mục mới
   */
  createCategory: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên danh mục phải là chuỗi',
      'string.empty': 'Tên danh mục không được để trống',
      'string.min': 'Tên danh mục phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên danh mục không được vượt quá {#limit} ký tự',
      'any.required': 'Tên danh mục là bắt buộc',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug phải là chuỗi',
      'string.empty': 'Slug không được để trống',
      'string.min': 'Slug phải có ít nhất {#limit} ký tự',
      'string.max': 'Slug không được vượt quá {#limit} ký tự',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'Mô tả phải là chuỗi',
      'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh mục cha phải là chuỗi',
        'string.pattern.base': 'ID danh mục cha không hợp lệ',
      }),

    image: Joi.object({
      url: Joi.string().uri().required().messages({
        'string.base': 'URL hình ảnh phải là chuỗi',
        'string.empty': 'URL hình ảnh không được để trống',
        'string.uri': 'URL hình ảnh không hợp lệ',
        'any.required': 'URL hình ảnh là bắt buộc',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text phải là chuỗi',
        'string.max': 'Alt text không được vượt quá {#limit} ký tự',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon phải là chuỗi',
      'string.max': 'Icon không được vượt quá {#limit} ký tự',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'Mã màu phải là chuỗi',
      'string.max': 'Mã màu không được vượt quá {#limit} ký tự',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Thứ tự phải là số',
      'number.integer': 'Thứ tự phải là số nguyên',
      'number.min': 'Thứ tự không được nhỏ hơn {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive phải là boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible phải là boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured phải là boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),

  /**
   * Validate khi cập nhật danh mục
   */
  updateCategory: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên danh mục phải là chuỗi',
      'string.empty': 'Tên danh mục không được để trống',
      'string.min': 'Tên danh mục phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên danh mục không được vượt quá {#limit} ký tự',
    }),

    slug: Joi.string().min(2).max(100).messages({
      'string.base': 'Slug phải là chuỗi',
      'string.empty': 'Slug không được để trống',
      'string.min': 'Slug phải có ít nhất {#limit} ký tự',
      'string.max': 'Slug không được vượt quá {#limit} ký tự',
    }),

    description: Joi.string().max(500).messages({
      'string.base': 'Mô tả phải là chuỗi',
      'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
    }),

    parent: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .allow(null)
      .messages({
        'string.base': 'ID danh mục cha phải là chuỗi',
        'string.pattern.base': 'ID danh mục cha không hợp lệ',
      }),

    image: Joi.object({
      url: Joi.string().uri().messages({
        'string.base': 'URL hình ảnh phải là chuỗi',
        'string.empty': 'URL hình ảnh không được để trống',
        'string.uri': 'URL hình ảnh không hợp lệ',
      }),
      alt: Joi.string().max(100).messages({
        'string.base': 'Alt text phải là chuỗi',
        'string.max': 'Alt text không được vượt quá {#limit} ký tự',
      }),
    }),

    icon: Joi.string().max(100).messages({
      'string.base': 'Icon phải là chuỗi',
      'string.max': 'Icon không được vượt quá {#limit} ký tự',
    }),

    color: Joi.string().max(20).messages({
      'string.base': 'Mã màu phải là chuỗi',
      'string.max': 'Mã màu không được vượt quá {#limit} ký tự',
    }),

    order: Joi.number().integer().min(0).messages({
      'number.base': 'Thứ tự phải là số',
      'number.integer': 'Thứ tự phải là số nguyên',
      'number.min': 'Thứ tự không được nhỏ hơn {#limit}',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'isActive phải là boolean',
    }),

    isVisible: Joi.boolean().messages({
      'boolean.base': 'isVisible phải là boolean',
    }),

    isFeatured: Joi.boolean().messages({
      'boolean.base': 'isFeatured phải là boolean',
    }),

    seo: Joi.object({
      metaTitle: Joi.string().max(100),
      metaDescription: Joi.string().max(200),
      keywords: Joi.array().items(Joi.string().max(50)),
    }),

    filters: Joi.array().items(
      Joi.object({
        name: Joi.string().required(),
        type: Joi.string().valid('select', 'range', 'checkbox').required(),
        options: Joi.when('type', {
          is: Joi.valid('select', 'checkbox'),
          then: Joi.array().items(Joi.string()).required(),
          otherwise: Joi.forbidden(),
        }),
        min: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        max: Joi.when('type', {
          is: 'range',
          then: Joi.number().required(),
          otherwise: Joi.forbidden(),
        }),
        unit: Joi.when('type', {
          is: 'range',
          then: Joi.string(),
          otherwise: Joi.forbidden(),
        }),
      })
    ),
  }),
};

module.exports = { categoryValidator };


--- File: server/src/common/validators/orderValidator.js ---
/**
 * Order Validator
 * Định nghĩa các validation rules cho order API
 */

const Joi = require('joi');

const orderValidator = {
  /**
   * Validate khi tạo đơn hàng mới
   */
  createOrder: Joi.object({
    // Thông tin liên hệ
    customerInfo: Joi.object({
      name: Joi.string().min(2).max(100).required().messages({
        'string.base': 'Tên khách hàng phải là chuỗi',
        'string.empty': 'Tên khách hàng không được để trống',
        'string.min': 'Tên khách hàng phải có ít nhất {#limit} ký tự',
        'string.max': 'Tên khách hàng không được vượt quá {#limit} ký tự',
        'any.required': 'Tên khách hàng là bắt buộc',
      }),
      email: Joi.string().email().required().messages({
        'string.base': 'Email phải là chuỗi',
        'string.empty': 'Email không được để trống',
        'string.email': 'Email không hợp lệ',
        'any.required': 'Email là bắt buộc',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .required()
        .messages({
          'string.base': 'Số điện thoại phải là chuỗi',
          'string.empty': 'Số điện thoại không được để trống',
          'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
          'any.required': 'Số điện thoại là bắt buộc',
        }),
    })
      .required()
      .messages({
        'object.base': 'Thông tin khách hàng phải là đối tượng',
        'any.required': 'Thông tin khách hàng là bắt buộc',
      }),

    // Thông tin vận chuyển
    shippingAddress: Joi.object({
      name: Joi.string().min(2).max(100).messages({
        'string.base': 'Tên người nhận phải là chuỗi',
        'string.min': 'Tên người nhận phải có ít nhất {#limit} ký tự',
        'string.max': 'Tên người nhận không được vượt quá {#limit} ký tự',
      }),
      phone: Joi.string()
        .pattern(/^[0-9]{10,11}$/)
        .messages({
          'string.base': 'Số điện thoại phải là chuỗi',
          'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
        }),
      street: Joi.string().required().messages({
        'string.base': 'Địa chỉ đường phố phải là chuỗi',
        'string.empty': 'Địa chỉ đường phố không được để trống',
        'any.required': 'Địa chỉ đường phố là bắt buộc',
      }),
      city: Joi.string().required().messages({
        'string.base': 'Thành phố phải là chuỗi',
        'string.empty': 'Thành phố không được để trống',
        'any.required': 'Thành phố là bắt buộc',
      }),
      state: Joi.string().allow('').messages({
        'string.base': 'Tỉnh/Bang phải là chuỗi',
      }),
      zipCode: Joi.string().required().messages({
        'string.base': 'Mã bưu điện phải là chuỗi',
        'string.empty': 'Mã bưu điện không được để trống',
        'any.required': 'Mã bưu điện là bắt buộc',
      }),
      country: Joi.string().required().messages({
        'string.base': 'Quốc gia phải là chuỗi',
        'string.empty': 'Quốc gia không được để trống',
        'any.required': 'Quốc gia là bắt buộc',
      }),
      notes: Joi.string().max(500).messages({
        'string.base': 'Ghi chú phải là chuỗi',
        'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
      }),
    })
      .required()
      .messages({
        'object.base': 'Địa chỉ giao hàng phải là đối tượng',
        'any.required': 'Địa chỉ giao hàng là bắt buộc',
      }),

    // Phương thức vận chuyển và thanh toán
    shippingMethod: Joi.string().valid('standard', 'express').required().messages({
      'string.base': 'Phương thức vận chuyển phải là chuỗi',
      'string.empty': 'Phương thức vận chuyển không được để trống',
      'any.only': 'Phương thức vận chuyển không hợp lệ',
      'any.required': 'Phương thức vận chuyển là bắt buộc',
    }),

    paymentMethod: Joi.string().valid('cod', 'credit_card', 'paypal', 'vnpay').required().messages({
      'string.base': 'Phương thức thanh toán phải là chuỗi',
      'string.empty': 'Phương thức thanh toán không được để trống',
      'any.only': 'Phương thức thanh toán không hợp lệ',
      'any.required': 'Phương thức thanh toán là bắt buộc',
    }),

    // Ghi chú đơn hàng
    customerNotes: Joi.string().max(500).messages({
      'string.base': 'Ghi chú phải là chuỗi',
      'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
    }),

    // Mã giảm giá
    couponCode: Joi.string().max(50).messages({
      'string.base': 'Mã giảm giá phải là chuỗi',
      'string.max': 'Mã giảm giá không được vượt quá {#limit} ký tự',
    }),

    // ID giỏ hàng (nếu tạo đơn hàng từ giỏ hàng)
    cartId: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID giỏ hàng phải là chuỗi',
        'string.pattern.base': 'ID giỏ hàng không hợp lệ',
      }),

    // Các mặt hàng trong đơn hàng (bắt buộc nếu không có cartId)
    items: Joi.when('cartId', {
      is: Joi.exist(),
      then: Joi.array(),
      otherwise: Joi.array()
        .items(
          Joi.object({
            product: Joi.string()
              .regex(/^[0-9a-fA-F]{24}$/)
              .required()
              .messages({
                'string.base': 'ID sản phẩm phải là chuỗi',
                'string.pattern.base': 'ID sản phẩm không hợp lệ',
                'any.required': 'ID sản phẩm là bắt buộc',
              }),
            quantity: Joi.number().integer().min(1).required().messages({
              'number.base': 'Số lượng phải là số',
              'number.integer': 'Số lượng phải là số nguyên',
              'number.min': 'Số lượng phải ít nhất là {#limit}',
              'any.required': 'Số lượng là bắt buộc',
            }),
            attributes: Joi.object().default({}),
          })
        )
        .min(1)
        .required()
        .messages({
          'array.base': 'Các mặt hàng phải là mảng',
          'array.min': 'Phải có ít nhất một mặt hàng',
          'any.required': 'Các mặt hàng là bắt buộc',
        }),
    }),
  }),

  /**
   * Validate khi cập nhật trạng thái đơn hàng
   */
  updateOrderStatus: Joi.object({
    status: Joi.string()
      .valid('pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned')
      .required()
      .messages({
        'string.base': 'Trạng thái phải là chuỗi',
        'string.empty': 'Trạng thái không được để trống',
        'any.only': 'Trạng thái không hợp lệ',
        'any.required': 'Trạng thái là bắt buộc',
      }),

    note: Joi.string().max(500).messages({
      'string.base': 'Ghi chú phải là chuỗi',
      'string.max': 'Ghi chú không được vượt quá {#limit} ký tự',
    }),
  }),

  /**
   * Validate khi hủy đơn hàng
   */
  cancelOrder: Joi.object({
    reason: Joi.string().max(500).required().messages({
      'string.base': 'Lý do hủy phải là chuỗi',
      'string.empty': 'Lý do hủy không được để trống',
      'string.max': 'Lý do hủy không được vượt quá {#limit} ký tự',
      'any.required': 'Lý do hủy là bắt buộc',
    }),
  }),
};
module.exports = orderValidator;
//     'any.required': 'Vai trò là bắt buộc'


--- File: server/src/common/validators/productValidator.js ---
// server/src/common/validators/productValidator.js

const Joi = require('joi');

// const priceRegex = /^\d+(\.\d{1,2})?$/; // Định dạng giá (số nguyên hoặc tối đa 2 chữ số thập phân)
const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/; // Định dạng slug

const createProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).required().messages({
    'string.base': 'Tên sản phẩm phải là một chuỗi',
    'string.empty': 'Tên sản phẩm không được để trống',
    'string.min': 'Tên sản phẩm phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên sản phẩm không được vượt quá {#limit} ký tự',
    'any.required': 'Tên sản phẩm là bắt buộc',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).required().messages({
    'string.base': 'Slug phải là một chuỗi',
    'string.empty': 'Slug không được để trống',
    'string.min': 'Slug phải có ít nhất {#limit} ký tự',
    'string.max': 'Slug không được vượt quá {#limit} ký tự',
    'string.pattern.base': 'Slug chỉ được chứa chữ cái thường, số và dấu gạch ngang',
    'any.required': 'Slug là bắt buộc',
  }),

  description: Joi.object({
    short: Joi.string().max(200).required().messages({
      'string.base': 'Mô tả ngắn phải là một chuỗi',
      'string.empty': 'Mô tả ngắn không được để trống',
      'string.max': 'Mô tả ngắn không được vượt quá {#limit} ký tự',
      'any.required': 'Mô tả ngắn là bắt buộc',
    }),
    long: Joi.string().max(2000).required().messages({
      'string.base': 'Mô tả chi tiết phải là một chuỗi',
      'string.empty': 'Mô tả chi tiết không được để trống',
      'string.max': 'Mô tả chi tiết không được vượt quá {#limit} ký tự',
      'any.required': 'Mô tả chi tiết là bắt buộc',
    }),
  }).required(),

  category: Joi.string().required().messages({
    'string.base': 'Danh mục phải là một chuỗi',
    'string.empty': 'Danh mục không được để trống',
    'any.required': 'Danh mục là bắt buộc',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh mục phụ phải là một chuỗi',
  }),

  brand: Joi.string().required().messages({
    'string.base': 'Thương hiệu phải là một chuỗi',
    'string.empty': 'Thương hiệu không được để trống',
    'any.required': 'Thương hiệu là bắt buộc',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nhà sản xuất phải là một chuỗi',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Quốc gia xuất xứ phải là một chuỗi',
  }),

  price: Joi.number().min(0).required().messages({
    'number.base': 'Giá phải là một số',
    'number.min': 'Giá không được âm',
    'any.required': 'Giá là bắt buộc',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Giá khuyến mãi phải là một số',
    'number.min': 'Giá khuyến mãi không được âm',
  }),

  stock: Joi.number().integer().min(0).required().messages({
    'number.base': 'Số lượng tồn kho phải là một số',
    'number.integer': 'Số lượng tồn kho phải là số nguyên',
    'number.min': 'Số lượng tồn kho không được âm',
    'any.required': 'Số lượng tồn kho là bắt buộc',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU phải là một chuỗi',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean().default(false),
      })
    )
    .min(1)
    .required()
    .messages({
      'array.base': 'Hình ảnh phải là một mảng',
      'array.min': 'Phải có ít nhất {#limit} hình ảnh',
      'any.required': 'Hình ảnh là bắt buộc',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'Tính năng phải là một mảng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean().default(true),
  isPromoted: Joi.boolean().default(false),
  isFeatured: Joi.boolean().default(false),
});

const updateProductValidator = Joi.object({
  name: Joi.string().min(3).max(100).messages({
    'string.base': 'Tên sản phẩm phải là một chuỗi',
    'string.empty': 'Tên sản phẩm không được để trống',
    'string.min': 'Tên sản phẩm phải có ít nhất {#limit} ký tự',
    'string.max': 'Tên sản phẩm không được vượt quá {#limit} ký tự',
  }),

  slug: Joi.string().pattern(slugRegex).min(3).max(100).messages({
    'string.base': 'Slug phải là một chuỗi',
    'string.empty': 'Slug không được để trống',
    'string.min': 'Slug phải có ít nhất {#limit} ký tự',
    'string.max': 'Slug không được vượt quá {#limit} ký tự',
    'string.pattern.base': 'Slug chỉ được chứa chữ cái thường, số và dấu gạch ngang',
  }),

  description: Joi.object({
    short: Joi.string().max(200).messages({
      'string.base': 'Mô tả ngắn phải là một chuỗi',
      'string.empty': 'Mô tả ngắn không được để trống',
      'string.max': 'Mô tả ngắn không được vượt quá {#limit} ký tự',
    }),
    long: Joi.string().max(2000).messages({
      'string.base': 'Mô tả chi tiết phải là một chuỗi',
      'string.empty': 'Mô tả chi tiết không được để trống',
      'string.max': 'Mô tả chi tiết không được vượt quá {#limit} ký tự',
    }),
  }),

  category: Joi.string().messages({
    'string.base': 'Danh mục phải là một chuỗi',
    'string.empty': 'Danh mục không được để trống',
  }),

  subCategory: Joi.string().allow(null, '').messages({
    'string.base': 'Danh mục phụ phải là một chuỗi',
  }),

  brand: Joi.string().messages({
    'string.base': 'Thương hiệu phải là một chuỗi',
    'string.empty': 'Thương hiệu không được để trống',
  }),

  manufacturer: Joi.string().allow('', null).messages({
    'string.base': 'Nhà sản xuất phải là một chuỗi',
  }),

  countryOfOrigin: Joi.string().allow('', null).messages({
    'string.base': 'Quốc gia xuất xứ phải là một chuỗi',
  }),

  price: Joi.number().min(0).messages({
    'number.base': 'Giá phải là một số',
    'number.min': 'Giá không được âm',
  }),

  salePrice: Joi.number().min(0).allow(null).messages({
    'number.base': 'Giá khuyến mãi phải là một số',
    'number.min': 'Giá khuyến mãi không được âm',
  }),

  stock: Joi.number().integer().min(0).messages({
    'number.base': 'Số lượng tồn kho phải là một số',
    'number.integer': 'Số lượng tồn kho phải là số nguyên',
    'number.min': 'Số lượng tồn kho không được âm',
  }),

  sku: Joi.string().allow('', null).messages({
    'string.base': 'SKU phải là một chuỗi',
  }),

  images: Joi.array()
    .items(
      Joi.object({
        url: Joi.string().required(),
        alt: Joi.string().allow('', null),
        isPrimary: Joi.boolean(),
      })
    )
    .min(1)
    .messages({
      'array.base': 'Hình ảnh phải là một mảng',
      'array.min': 'Phải có ít nhất {#limit} hình ảnh',
    }),

  features: Joi.array().items(Joi.string()).messages({
    'array.base': 'Tính năng phải là một mảng',
  }),

  specifications: Joi.object().unknown(true),

  discount: Joi.object({
    percentage: Joi.number().min(0).max(100),
    startDate: Joi.date(),
    endDate: Joi.date().greater(Joi.ref('startDate')),
    type: Joi.string(),
  }).allow(null),

  seo: Joi.object({
    metaTitle: Joi.string().max(60),
    metaDescription: Joi.string().max(160),
    keywords: Joi.array().items(Joi.string()),
  }).allow(null),

  isActive: Joi.boolean(),
  isPromoted: Joi.boolean(),
  isFeatured: Joi.boolean(),
});
/**
/**
 * Xác thực dữ liệu sản phẩm với nhiều tùy chọn nâng cao
 * @param {Object} data - Dữ liệu sản phẩm cần xác thực
 * @param {Object|Boolean} options - Các tùy chọn xác thực hoặc boolean cho isUpdate
 * @property {Boolean} options.isUpdate - Có phải đang cập nhật không (true) hay đang tạo mới (false)
 * @property {Array<string>} options.fields - Danh sách các trường cần xác thực (nếu chỉ muốn xác thực một số trường)
 * @property {Boolean} options.formatErrors - Có định dạng lỗi thành dạng dễ đọc không
 * @property {Boolean} options.checkBusinessRules - Có kiểm tra các quy tắc nghiệp vụ không
 * @returns {Object} - Kết quả xác thực { error, value, isValid, errorDetails }
 */
const validateProductData = (data, options = {}) => {
  // Xử lý trường hợp options là boolean (tương thích ngược)
  let isUpdate = false;
  let fields = null;
  let formatErrors = false;
  let checkBusinessRules = false;

  // Kiểm tra kiểu dữ liệu của options
  if (typeof options === 'boolean') {
    isUpdate = options;
  } else if (options && typeof options === 'object') {
    // Chỉ lấy các thuộc tính nếu options là object
    isUpdate = options.isUpdate === true;
    fields = Array.isArray(options.fields) ? options.fields : null;
    formatErrors = options.formatErrors === true;
    checkBusinessRules = options.checkBusinessRules === true;
  }

  // Chọn schema phù hợp
  let schema = isUpdate ? updateProductValidator : createProductValidator;

  // Nếu chỉ xác thực một số trường cụ thể
  if (fields && Array.isArray(fields) && fields.length > 0) {
    const schemaToUse = isUpdate ? updateProductValidator : createProductValidator;
    const filteredSchema = Joi.object(
      fields.reduce((acc, field) => {
        if (
          schemaToUse.$_terms &&
          schemaToUse.$_terms.keys &&
          schemaToUse.$_terms.keys.some((k) => k.key === field)
        ) {
          acc[field] = schemaToUse.$_terms.keys.find((k) => k.key === field).schema;
        }
        return acc;
      }, {})
    );
    schema = filteredSchema;
  }

  // Thực hiện xác thực cơ bản
  const validationResult = schema.validate(data, { abortEarly: false });

  // Nếu không cần xử lý thêm, trả về kết quả ngay
  if (!formatErrors && !checkBusinessRules) {
    return {
      ...validationResult,
      isValid: !validationResult.error,
    };
  }

  // Xử lý kết quả
  let result = {
    value: validationResult.value,
    isValid: !validationResult.error,
    errorDetails: null,
  };

  // Định dạng lỗi thành dạng dễ đọc nếu cần
  if (validationResult.error && formatErrors) {
    const errorDetails = {};

    validationResult.error.details.forEach((err) => {
      const field = err.path.join('.');
      if (!errorDetails[field]) {
        errorDetails[field] = [];
      }
      errorDetails[field].push(err.message);
    });

    result.error = validationResult.error;
    result.errorDetails = errorDetails;
  } else {
    result.error = validationResult.error;
  }

  // Kiểm tra các quy tắc nghiệp vụ nếu cần
  if (checkBusinessRules && !result.error) {
    const businessErrors = validateBusinessRules(data, isUpdate);

    if (businessErrors.length > 0) {
      result.isValid = false;
      result.businessErrors = businessErrors;

      if (formatErrors) {
        const errorDetails = result.errorDetails || {};

        businessErrors.forEach((err) => {
          const field = err.field;
          if (!errorDetails[field]) {
            errorDetails[field] = [];
          }
          errorDetails[field].push(err.message);
        });

        result.errorDetails = errorDetails;
      }
    }
  }

  return result;
};
/**
 * Kiểm tra các quy tắc nghiệp vụ phức tạp không thể xác thực bằng Joi
 * @param {Object} data - Dữ liệu sản phẩm
 * @param {Boolean} isUpdate - Có phải đang cập nhật không
 * @returns {Array} - Danh sách lỗi nghiệp vụ
 */
function validateBusinessRules(data, isUpdate) {
  const errors = [];

  // Kiểm tra giá khuyến mãi phải nhỏ hơn giá gốc
  if (data.price && data.salePrice && data.salePrice >= data.price) {
    errors.push({
      field: 'salePrice',
      message: 'Giá khuyến mãi phải nhỏ hơn giá gốc',
    });
  }

  // Kiểm tra nếu có discount thì phải có các trường bắt buộc
  if (data.discount && data.discount.percentage) {
    if (!data.discount.startDate) {
      errors.push({
        field: 'discount.startDate',
        message: 'Ngày bắt đầu khuyến mãi là bắt buộc khi có phần trăm giảm giá',
      });
    }

    if (!data.discount.endDate) {
      errors.push({
        field: 'discount.endDate',
        message: 'Ngày kết thúc khuyến mãi là bắt buộc khi có phần trăm giảm giá',
      });
    }
  }

  // Kiểm tra ít nhất một hình ảnh phải là hình chính
  if (data.images && data.images.length > 0) {
    const hasPrimaryImage = data.images.some((img) => img.isPrimary);
    if (!hasPrimaryImage) {
      errors.push({
        field: 'images',
        message: 'Phải có ít nhất một hình ảnh được đánh dấu là hình chính (isPrimary)',
      });
    }
  }

  return errors;
}
module.exports = {
  createProductValidator,
  updateProductValidator,
  validateProductData,
};


--- File: server/src/common/validators/reviewValidator.js ---
/**
 * Review Validator
 * Định nghĩa các validation rules cho review API
 */

const Joi = require('joi');

const reviewValidator = {
  /**
   * Validate khi tạo đánh giá mới
   */
  createReview: Joi.object({
    rating: Joi.number().min(1).max(5).required().messages({
      'number.base': 'Đánh giá sao phải là số',
      'number.min': 'Đánh giá sao không được nhỏ hơn {#limit}',
      'number.max': 'Đánh giá sao không được lớn hơn {#limit}',
      'any.required': 'Đánh giá sao là bắt buộc',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Tiêu đề phải là chuỗi',
      'string.max': 'Tiêu đề không được vượt quá {#limit} ký tự',
    }),

    review: Joi.string().max(2000).required().messages({
      'string.base': 'Nội dung đánh giá phải là chuỗi',
      'string.empty': 'Nội dung đánh giá không được để trống',
      'string.max': 'Nội dung đánh giá không được vượt quá {#limit} ký tự',
      'any.required': 'Nội dung đánh giá là bắt buộc',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL hình ảnh phải là chuỗi',
            'string.empty': 'URL hình ảnh không được để trống',
            'string.uri': 'URL hình ảnh không hợp lệ',
            'any.required': 'URL hình ảnh là bắt buộc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail phải là chuỗi',
            'string.uri': 'URL thumbnail không hợp lệ',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Chú thích hình ảnh phải là chuỗi',
            'string.max': 'Chú thích hình ảnh không được vượt quá {#limit} ký tự',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'Hình ảnh phải là mảng',
        'array.max': 'Không được đăng tải quá {#limit} hình ảnh',
      }),

    order: Joi.string()
      .regex(/^[0-9a-fA-F]{24}$/)
      .messages({
        'string.base': 'ID đơn hàng phải là chuỗi',
        'string.pattern.base': 'ID đơn hàng không hợp lệ',
      }),
  }),

  /**
   * Validate khi cập nhật đánh giá
   */
  updateReview: Joi.object({
    rating: Joi.number().min(1).max(5).messages({
      'number.base': 'Đánh giá sao phải là số',
      'number.min': 'Đánh giá sao không được nhỏ hơn {#limit}',
      'number.max': 'Đánh giá sao không được lớn hơn {#limit}',
    }),

    title: Joi.string().max(100).messages({
      'string.base': 'Tiêu đề phải là chuỗi',
      'string.max': 'Tiêu đề không được vượt quá {#limit} ký tự',
    }),

    review: Joi.string().max(2000).messages({
      'string.base': 'Nội dung đánh giá phải là chuỗi',
      'string.max': 'Nội dung đánh giá không được vượt quá {#limit} ký tự',
    }),

    images: Joi.array()
      .items(
        Joi.object({
          url: Joi.string().uri().required().messages({
            'string.base': 'URL hình ảnh phải là chuỗi',
            'string.empty': 'URL hình ảnh không được để trống',
            'string.uri': 'URL hình ảnh không hợp lệ',
            'any.required': 'URL hình ảnh là bắt buộc',
          }),
          thumbnail: Joi.string().uri().messages({
            'string.base': 'URL thumbnail phải là chuỗi',
            'string.uri': 'URL thumbnail không hợp lệ',
          }),
          caption: Joi.string().max(200).messages({
            'string.base': 'Chú thích hình ảnh phải là chuỗi',
            'string.max': 'Chú thích hình ảnh không được vượt quá {#limit} ký tự',
          }),
        })
      )
      .max(5)
      .messages({
        'array.base': 'Hình ảnh phải là mảng',
        'array.max': 'Không được đăng tải quá {#limit} hình ảnh',
      }),
  }),

  /**
   * Validate khi upvote/downvote đánh giá
   */
  voteReview: Joi.object({
    vote: Joi.number().valid(1, -1).required().messages({
      'number.base': 'Vote phải là số',
      'any.only': 'Vote chỉ có thể là 1 (upvote) hoặc -1 (downvote)',
      'any.required': 'Vote là bắt buộc',
    }),
  }),

  /**
   * Validate khi báo cáo đánh giá
   */
  reportReview: Joi.object({
    reason: Joi.string()
      .valid('spam', 'offensive', 'inappropriate', 'misleading', 'other')
      .required()
      .messages({
        'string.base': 'Lý do phải là chuỗi',
        'string.empty': 'Lý do không được để trống',
        'any.only': 'Lý do không hợp lệ',
        'any.required': 'Lý do là bắt buộc',
      }),

    description: Joi.string()
      .max(500)
      .when('reason', {
        is: 'other',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'Mô tả phải là chuỗi',
        'string.empty': 'Mô tả không được để trống',
        'string.max': 'Mô tả không được vượt quá {#limit} ký tự',
        'any.required': 'Mô tả là bắt buộc khi lý do là "other"',
      }),
  }),

  /**
   * Validate khi kiểm duyệt đánh giá
   */
  moderateReview: Joi.object({
    action: Joi.string().valid('approve', 'reject').required().messages({
      'string.base': 'Hành động phải là chuỗi',
      'string.empty': 'Hành động không được để trống',
      'any.only': 'Hành động phải là "approve" hoặc "reject"',
      'any.required': 'Hành động là bắt buộc',
    }),

    reason: Joi.string()
      .max(500)
      .when('action', {
        is: 'reject',
        then: Joi.required(),
      })
      .messages({
        'string.base': 'Lý do phải là chuỗi',
        'string.empty': 'Lý do không được để trống',
        'string.max': 'Lý do không được vượt quá {#limit} ký tự',
        'any.required': 'Lý do là bắt buộc khi từ chối đánh giá',
      }),
  }),

  /**
   * Validate khi thêm phản hồi cho đánh giá
   */
  addReviewResponse: Joi.object({
    content: Joi.string().min(2).max(1000).required().messages({
      'string.base': 'Nội dung phản hồi phải là chuỗi',
      'string.empty': 'Nội dung phản hồi không được để trống',
      'string.min': 'Nội dung phản hồi phải có ít nhất {#limit} ký tự',
      'string.max': 'Nội dung phản hồi không được vượt quá {#limit} ký tự',
      'any.required': 'Nội dung phản hồi là bắt buộc',
    }),
  }),
};

module.exports = { reviewValidator };


--- File: server/src/common/validators/userValidator.js ---
/**
 * User Validator
 * Định nghĩa các validation rules cho user API
 */

const Joi = require('joi');

const userValidator = {
  /**
   * Validate khi đăng ký người dùng mới
   */
  register: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên phải là chuỗi',
      'string.empty': 'Tên không được để trống',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
      'any.required': 'Tên là bắt buộc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu phải là chuỗi',
        'string.empty': 'Mật khẩu không được để trống',
        'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar phải là chuỗi',
      'string.uri': 'Avatar phải là một URL hợp lệ',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en').default('vi'),
      notifications: Joi.object({
        email: Joi.boolean().default(true),
        marketing: Joi.boolean().default(true),
      }).default({
        email: true,
        marketing: true,
      }),
    })
      .optional()
      .default({
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      }),
  }),

  /**
   * Validate khi đăng nhập
   */
  login: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string().required().messages({
      'string.base': 'Mật khẩu phải là chuỗi',
      'string.empty': 'Mật khẩu không được để trống',
      'any.required': 'Mật khẩu là bắt buộc',
    }),

    rememberMe: Joi.boolean().default(false),
  }),

  /**
   * Validate khi yêu cầu đặt lại mật khẩu
   */
  forgotPassword: Joi.object({
    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),
  }),

  /**
   * Validate khi đặt lại mật khẩu
   */
  resetPassword: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token phải là chuỗi',
      'string.empty': 'Token không được để trống',
      'any.required': 'Token là bắt buộc',
    }),

    password: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu phải là chuỗi',
        'string.empty': 'Mật khẩu không được để trống',
        'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('password')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),
  }),

  /**
   * Validate khi cập nhật thông tin người dùng
   */
  updateProfile: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên phải là chuỗi',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),

    avatar: Joi.string().uri().allow('').messages({
      'string.base': 'Avatar phải là chuỗi',
      'string.uri': 'Avatar phải là một URL hợp lệ',
    }),

    address: Joi.object({
      street: Joi.string().allow(''),
      city: Joi.string().allow(''),
      state: Joi.string().allow(''),
      zipCode: Joi.string().allow(''),
      country: Joi.string().allow(''),
    }).optional(),

    preferences: Joi.object({
      language: Joi.string().valid('vi', 'en'),
      notifications: Joi.object({
        email: Joi.boolean(),
        marketing: Joi.boolean(),
      }),
    }).optional(),
  }),

  /**
   * Validate khi thay đổi mật khẩu
   */
  changePassword: Joi.object({
    currentPassword: Joi.string().required().messages({
      'string.base': 'Mật khẩu hiện tại phải là chuỗi',
      'string.empty': 'Mật khẩu hiện tại không được để trống',
      'any.required': 'Mật khẩu hiện tại là bắt buộc',
    }),

    newPassword: Joi.string()
      .min(8)
      .max(64)
      .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
      .required()
      .messages({
        'string.base': 'Mật khẩu mới phải là chuỗi',
        'string.empty': 'Mật khẩu mới không được để trống',
        'string.min': 'Mật khẩu mới phải có ít nhất {#limit} ký tự',
        'string.max': 'Mật khẩu mới không được vượt quá {#limit} ký tự',
        'string.pattern.base':
          'Mật khẩu mới phải có ít nhất một chữ thường, một chữ hoa, một số và một ký tự đặc biệt',
        'any.required': 'Mật khẩu mới là bắt buộc',
      }),

    confirmPassword: Joi.any().equal(Joi.ref('newPassword')).required().messages({
      'any.only': 'Xác nhận mật khẩu phải khớp với mật khẩu mới',
      'any.required': 'Xác nhận mật khẩu là bắt buộc',
    }),
  }),

  /**
   * Validate khi xác thực email
   */
  verifyEmail: Joi.object({
    token: Joi.string().required().messages({
      'string.base': 'Token phải là chuỗi',
      'string.empty': 'Token không được để trống',
      'any.required': 'Token là bắt buộc',
    }),
  }),

  /**
   * Validate khi admin cập nhật người dùng
   */
  adminUpdateUser: Joi.object({
    name: Joi.string().min(2).max(100).messages({
      'string.base': 'Tên phải là chuỗi',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
    }),

    email: Joi.string().email().messages({
      'string.base': 'Email phải là chuỗi',
      'string.email': 'Email không hợp lệ',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').messages({
      'string.base': 'Vai trò phải là chuỗi',
      'any.only': 'Vai trò không hợp lệ',
    }),

    isActive: Joi.boolean().messages({
      'boolean.base': 'Trạng thái hoạt động phải là boolean',
    }),

    emailVerified: Joi.boolean().messages({
      'boolean.base': 'Trạng thái xác thực email phải là boolean',
    }),
  }),

  /**
   * Validate khi tạo người dùng mới (bởi admin)
   */
  adminCreateUser: Joi.object({
    name: Joi.string().min(2).max(100).required().messages({
      'string.base': 'Tên phải là chuỗi',
      'string.empty': 'Tên không được để trống',
      'string.min': 'Tên phải có ít nhất {#limit} ký tự',
      'string.max': 'Tên không được vượt quá {#limit} ký tự',
      'any.required': 'Tên là bắt buộc',
    }),

    email: Joi.string().email().required().messages({
      'string.base': 'Email phải là chuỗi',
      'string.empty': 'Email không được để trống',
      'string.email': 'Email không hợp lệ',
      'any.required': 'Email là bắt buộc',
    }),

    password: Joi.string().min(8).max(64).required().messages({
      'string.base': 'Mật khẩu phải là chuỗi',
      'string.empty': 'Mật khẩu không được để trống',
      'string.min': 'Mật khẩu phải có ít nhất {#limit} ký tự',
      'string.max': 'Mật khẩu không được vượt quá {#limit} ký tự',
      'any.required': 'Mật khẩu là bắt buộc',
    }),

    role: Joi.string().valid('user', 'admin', 'staff').default('user').messages({
      'string.base': 'Vai trò phải là chuỗi',
      'any.only': 'Vai trò không hợp lệ',
    }),

    isActive: Joi.boolean().default(true).messages({
      'boolean.base': 'Trạng thái hoạt động phải là boolean',
    }),

    emailVerified: Joi.boolean().default(false).messages({
      'boolean.base': 'Trạng thái xác thực email phải là boolean',
    }),

    phone: Joi.string()
      .pattern(/^[0-9]{10,11}$/)
      .allow('')
      .messages({
        'string.base': 'Số điện thoại phải là chuỗi',
        'string.pattern.base': 'Số điện thoại phải có 10-11 chữ số',
      }),
  }),
};

module.exports =  userValidator ;


--- File: server/src/config/database.js ---
const mongoose = require('mongoose');
const logger = require('./logger');
const { setupIndexes } = require('./indexes');
// Tùy chọn kết nối Mongoose
const options = {
  autoIndex: process.env.NODE_ENV !== 'production', // Tự động tạo index trong môi trường dev
  serverSelectionTimeoutMS: 5000, // Timeout cho việc lựa chọn server
  socketTimeoutMS: 45000, // Đóng socket sau 45 giây không hoạt động
  family: 4, // Sử dụng IPv4, bỏ qua IPv6
};

// Kết nối đến MongoDB
const connectToDatabase = async () => {
  try {
    // Xác định URI dựa vào môi trường
    const uri =
      process.env.NODE_ENV === 'test' ? process.env.MONGODB_URI_TEST : process.env.MONGODB_URI;

    await mongoose.connect(uri, options);

    logger.info('Kết nối thành công đến MongoDB');
    setupIndexes();
    // Xử lý sự kiện khi kết nối bị ngắt
    mongoose.connection.on('disconnected', () => {
      logger.warn('Mất kết nối MongoDB, đang thử kết nối lại...');
      setTimeout(connectToDatabase, 5000);
    });

    // Xử lý sự kiện khi có lỗi
    mongoose.connection.on('error', (err) => {
      logger.error(`Lỗi kết nối MongoDB: ${err.message}`);
    });

    return mongoose.connection;
  } catch (error) {
    logger.error(`Không thể kết nối đến MongoDB: ${error.message}`);
    process.exit(1);
  }
};

// Ngắt kết nối từ MongoDB
const disconnectFromDatabase = async () => {
  try {
    await mongoose.disconnect();
    logger.info('Đã ngắt kết nối từ MongoDB');
  } catch (error) {
    logger.error(`Lỗi khi ngắt kết nối từ MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = {
  connectToDatabase,
  disconnectFromDatabase,
};


--- File: server/src/config/environment.js ---
/**
 * Cấu hình biến môi trường
 * @author Steve
 * @project RunOut-Biliard
 */

// Load biến môi trường từ file .env
require('dotenv').config();

// Lấy biến môi trường hoặc giá trị mặc định
const getEnv = (key, defaultValue = undefined) => {
  return process.env[key] || defaultValue;
};

// Biến môi trường
const environment = {
  // Thông tin ứng dụng
  app: {
    name: getEnv('APP_NAME', 'RunOut-Biliard'),
    signature: getEnv('SIGNATURE', 'Steve'),
    environment: getEnv('NODE_ENV', 'development'),
    port: parseInt(getEnv('PORT', '5000'), 10),
    host: getEnv('HOST', 'localhost'),
  },

  // Cơ sở dữ liệu
  db: {
    uri: getEnv('MONGODB_URI', 'mongodb://localhost:27017/runout_biliard'),
    uriTest: getEnv('MONGODB_URI_TEST', 'mongodb://localhost:27017/runout_biliard_test'),
  },

  // Xác thực
  auth: {
    jwtSecret: getEnv('JWT_SECRET', 'your_jwt_secret_key_here'),
    jwtExpiresIn: getEnv('JWT_EXPIRES_IN', '7d'),
    jwtRefreshSecret: getEnv('JWT_REFRESH_SECRET', 'your_refresh_secret_key_here'),
    jwtRefreshExpiresIn: getEnv('JWT_REFRESH_EXPIRES_IN', '30d'),
  },

  // CORS
  cors: {
    origin: getEnv('CORS_ORIGIN', 'http://localhost:3000'),
    methods: getEnv('CORS_METHODS', 'GET,HEAD,PUT,PATCH,POST,DELETE'),
  },

  // Logging
  logging: {
    level: getEnv('LOG_LEVEL', 'info'),
    colorize: getEnv('NODE_ENV', 'development') === 'development',
  },

  // Đường dẫn tĩnh
  paths: {
    uploads: getEnv('UPLOAD_PATH', 'uploads'),
  },

  // Thanh toán
  payment: {
    vnpay: {
      tmnCode: getEnv('VNPAY_TMN_CODE', ''),
      secretKey: getEnv('VNPAY_SECRET_KEY', ''),
      returnUrl: getEnv('VNPAY_RETURN_URL', 'http://localhost:5000/api/payments/vnpay-return'),
      ipnUrl: getEnv('VNPAY_IPN_URL', 'http://localhost:5000/api/payments/vnpay-ipn'),
    },
  },

  // Redis
  redis: {
    url: getEnv('REDIS_URL', 'redis://localhost:6379'),
  },
  // Email
  email: {
    host: getEnv('EMAIL_HOST', 'smtp.example.com'),
    port: parseInt(getEnv('EMAIL_PORT', '587'), 10),
    secure: getEnv('EMAIL_SECURE', 'false') === 'true',
    user: getEnv('EMAIL_USER', 'example@example.com'),
    pass: getEnv('EMAIL_PASS', 'password'),
  },
};

// Validate các biến môi trường quan trọng
const validateEnvironment = () => {
  // Kiểm tra biến môi trường quan trọng
  if (environment.app.environment === 'production') {
    if (!process.env.JWT_SECRET) {
      throw new Error('JWT_SECRET không được cấu hình cho môi trường production');
    }

    if (!process.env.MONGODB_URI) {
      throw new Error('MONGODB_URI không được cấu hình cho môi trường production');
    }
  }
};

// Nếu ở môi trường production, validate các biến môi trường
if (environment.app.environment === 'production') {
  validateEnvironment();
}

module.exports = environment;


--- File: server/src/config/fix-indexes.js ---
/**
 * Script để sửa lỗi chỉ mục trùng lặp trong MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');
require('dotenv').config();

async function dropIndexes() {
  try {
    logger.info('Kết nối đến MongoDB để sửa lỗi chỉ mục...');
    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('Kết nối thành công!');

    // Lấy danh sách tất cả các collection trong database
    const collections = await mongoose.connection.db.listCollections().toArray();
    const collectionNames = collections.map((c) => c.name);

    logger.info(`Tìm thấy ${collectionNames.length} collection: ${collectionNames.join(', ')}`);

    // Xử lý từng collection
    for (const collectionName of collectionNames) {
      // Bỏ qua các collection hệ thống
      if (collectionName.startsWith('system.')) {
        logger.info(`Bỏ qua collection hệ thống: ${collectionName}`);
        continue;
      }

      try {
        const collection = mongoose.connection.collection(collectionName);

        // Lấy danh sách tất cả chỉ mục
        const indexes = await collection.indexes();
        logger.info(`Collection ${collectionName}: Tìm thấy ${indexes.length} chỉ mục`);

        // Log tất cả các chỉ mục để tham khảo
        indexes.forEach((index) => {
          logger.info(
            `- Chỉ mục: ${index.name}, Key: ${JSON.stringify(index.key)}, Options: ${JSON.stringify(index)}`
          );
        });

        // Xóa tất cả các chỉ mục trừ _id
        const dropPromises = indexes
          .filter((index) => index.name !== '_id_') // Giữ lại chỉ mục _id
          .map((index) => {
            logger.info(`Đang xóa chỉ mục: ${index.name} trong collection ${collectionName}`);
            return collection
              .dropIndex(index.name)
              .then(() => logger.info(`Đã xóa thành công chỉ mục ${index.name}`))
              .catch((err) => logger.error(`Không thể xóa chỉ mục ${index.name}: ${err.message}`));
          });

        await Promise.all(dropPromises);
        logger.info(`Đã xóa tất cả chỉ mục trừ _id trong collection ${collectionName}`);
      } catch (collectionError) {
        logger.error(`Lỗi khi xử lý collection ${collectionName}: ${collectionError.message}`);
      }
    }

    logger.info('Hoàn tất xóa chỉ mục. Hãy khởi động lại ứng dụng để tạo lại chỉ mục hợp lệ.');
    await mongoose.disconnect();
    logger.info('Đã ngắt kết nối MongoDB');
  } catch (error) {
    logger.error(`Lỗi khi xóa chỉ mục: ${error.message}`);
    throw error;
  }
}

// Chạy script
dropIndexes();


--- File: server/src/config/indexes.js ---
/**
 * Cấu hình thiết lập chỉ mục cho MongoDB
 */
const mongoose = require('mongoose');
const { logger } = require('../utils/logger');

/**
 * Kiểm tra xem chỉ mục có tồn tại chưa
 * @param {Object} collection - Collection MongoDB
 * @param {Object} indexSpec - Chỉ mục cần kiểm tra
 * @returns {Promise<boolean>} - true nếu chỉ mục đã tồn tại
 */
async function indexExists(collection, indexSpec) {
  try {
    const indexes = await collection.indexes();

    // So sánh cấu trúc chỉ mục (chỉ dựa trên các trường)
    const keyString = JSON.stringify(Object.keys(indexSpec).sort());

    for (const index of indexes) {
      const existingKeyString = JSON.stringify(Object.keys(index.key).sort());
      if (existingKeyString === keyString) {
        return true;
      }
    }

    return false;
  } catch (error) {
    logger.error(`Lỗi khi kiểm tra chỉ mục: ${error.message}`);
    return false;
  }
}

/**
 * Thiết lập chỉ mục cho các collection
 */
async function setupIndexes() {
  try {
    logger.info('Thiết lập chỉ mục cơ sở dữ liệu...');

    // Chỉ mục đặc biệt cho Product (text search)
    try {
      const Product = mongoose.model('Product');
      const productCollection = Product.collection;

      const textIndexSpec = {
        name: 'text',
        'description.short': 'text',
        'description.long': 'text',
        brand: 'text',
      };

      // Kiểm tra xem chỉ mục text đã tồn tại chưa
      const productIndexes = await productCollection.indexes();
      const hasTextIndex = productIndexes.some((idx) => idx.textIndexVersion);

      if (!hasTextIndex) {
        logger.info('Tạo chỉ mục text cho collection Product');
        await Product.collection.createIndex(textIndexSpec, {
          weights: {
            name: 10,
            'description.short': 5,
            'description.long': 3,
            brand: 3,
          },
          name: 'product_text_search',
        });
      } else {
        logger.info('Chỉ mục text cho collection Product đã tồn tại, bỏ qua tạo mới');
      }
    } catch (productError) {
      logger.error(`Không thể thiết lập chỉ mục text cho Product: ${productError.message}`);
    }

    // KHÔNG TẠO THÊM CHỈ MỤC TẠI ĐÂY
    // Để các model tự tạo chỉ mục của mình khi khởi động

    logger.info('Hoàn tất thiết lập chỉ mục');
    return true;
  } catch (error) {
    logger.error(`Lỗi khi thiết lập chỉ mục: ${error.message}`);
    throw error;
  }
}

module.exports = { setupIndexes };


--- File: server/src/config/logger.js ---
const winston = require('winston');
const path = require('path');

// Định nghĩa các levels của logger
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Chọn level dựa trên môi trường
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  const isDevelopment = env === 'development';
  return isDevelopment ? 'debug' : 'warn';
};

// Tùy chỉnh format cho logs
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf((info) => `${info.timestamp} ${info.level}: ${info.message}`)
);

// Định nghĩa các transports cho logger
const transports = [
  // Ghi log đến console
  new winston.transports.Console(),

  // Ghi log errors vào file
  new winston.transports.File({
    filename: path.join('logs', 'error.log'),
    level: 'error',
  }),

  // Ghi tất cả logs vào file
  new winston.transports.File({
    filename: path.join('logs', 'all.log'),
  }),
];

// Tạo logger với các tùy chọn đã định nghĩa
const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
  // Thêm metadata custom để nhận diện ứng dụng
  defaultMeta: {
    service: process.env.APP_NAME || 'runout-biliard',
    signature: process.env.SIGNATURE || 'Steve',
  },
});

module.exports = logger;


--- File: server/src/config/middleware.js ---
/**
 * Cấu hình middleware
 * @author Steve
 * @project RunOut-Biliard
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const { rateLimit } = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const csrf = require('csurf');
const environment = require('./environment');
const logger = require('./logger');

/**
 * Cấu hình và áp dụng các middleware cơ bản cho ứng dụng Express
 * @param {express.Application} app - Ứng dụng Express
 */
const setupCommonMiddleware = (app) => {
  // Security middleware
  app.use(
    helmet({
      contentSecurityPolicy: environment.app.environment === 'production',
      crossOriginEmbedderPolicy: environment.app.environment === 'production',
      crossOriginOpenerPolicy: environment.app.environment === 'production',
      crossOriginResourcePolicy: environment.app.environment === 'production',
    })
  ); // Bảo mật HTTP headers

  // CORS middleware
  app.use(
    cors({
      origin: environment.cors.origin,
      methods: environment.cors.methods.split(','),
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'CSRF-Token'],
      exposedHeaders: ['Content-Disposition', 'CSRF-Token'],
      credentials: true,
      maxAge: 86400, // 24 giờ
    })
  );

  // Body parsing middleware
  app.use(express.json({ limit: '10kb' })); // Limit JSON body size
  app.use(express.urlencoded({ extended: true, limit: '10kb' }));

  // Cookie parsing middleware
  app.use(cookieParser(environment.app.cookieSecret));

  // Compression middleware
  app.use(compression());

  // Logger middleware
  if (environment.app.environment === 'development') {
    app.use(morgan('dev'));
  } else {
    // Sử dụng winston cho production
    app.use(
      morgan('combined', {
        stream: {
          write: (message) => logger.http(message.trim()),
        },
      })
    );
  }
};

/**
 * Cấu hình middleware bảo mật bổ sung
 * @param {express.Application} app - Ứng dụng Express
 */
const setupSecurityMiddleware = (app) => {
  // Rate limiting middleware
  const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 phút
    max: 100, // Limit mỗi IP 100 requests mỗi windowMs
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Quá nhiều yêu cầu từ IP này, vui lòng thử lại sau 15 phút',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // Áp dụng rate limit cho tất cả các routes /api
  app.use('/api', apiLimiter);

  // Middleware chống brute force cho authentication
  const authLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 giờ
    max: 5, // Giới hạn 5 lần thử trong 1 giờ
    standardHeaders: true,
    legacyHeaders: false,
    message: {
      status: 'error',
      message: 'Quá nhiều lần thử đăng nhập, vui lòng thử lại sau 1 giờ',
    },
    handler: (req, res, next, options) => {
      logger.warn(`Auth rate limit exceeded for IP: ${req.ip}`);
      res.status(429).json(options.message);
    },
  });

  // Áp dụng auth limiter cho routes đăng nhập/đăng ký
  app.use('/api/auth/login', authLimiter);
  app.use('/api/auth/register', authLimiter);

  // CSRF protection middleware
  if (environment.app.environment === 'production') {
    const csrfProtection = csrf({ cookie: true });

    // Áp dụng CSRF protection cho các routes không phải API public
    app.use('/api/admin', csrfProtection);
    app.use('/api/user', csrfProtection);

    // Middleware để cung cấp CSRF token
    app.get('/api/csrf-token', csrfProtection, (req, res) => {
      res.json({ csrfToken: req.csrfToken() });
    });
  }
};

/**
 * Setup middleware xử lý lỗi
 * @param {express.Application} app - Ứng dụng Express
 */
const setupErrorHandlingMiddleware = (app) => {
  // Middleware xử lý 404 - Phải đặt sau tất cả các routes
  app.use((req, res, next) => {
    res.status(404).json({
      status: 'error',
      message: 'Không tìm thấy tài nguyên yêu cầu',
    });
    next(); // Gọi next() để chuyển sang middleware tiếp theo
  });

  // Middleware xử lý lỗi toàn cục
  app.use((err, req, res, next) => {
    // Xử lý lỗi CSRF
    if (err.code === 'EBADCSRFTOKEN') {
      logger.error(`CSRF attack detected from IP: ${req.ip}`);
      return res.status(403).json({
        status: 'error',
        message: 'Phiên làm việc không hợp lệ, vui lòng thử lại',
      });
    }

    // Log lỗi
    logger.error(`Error: ${err.message}`, {
      stack: err.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
    });

    // Trả về lỗi cho client
    const statusCode = err.statusCode || 500;
    const message =
      environment.app.environment === 'production' && statusCode === 500
        ? 'Đã xảy ra lỗi, vui lòng thử lại sau'
        : err.message;

    res.status(statusCode).json({
      status: 'error',
      message,
      ...(environment.app.environment !== 'production' && { stack: err.stack }),
    });

    next(); // Thêm câu lệnh gọi next() sau khi xử lý lỗi toàn cục
  });
};

/**
 * Setup tất cả middleware
 * @param {express.Application} app - Ứng dụng Express
 */
const setupAllMiddleware = (app) => {
  setupCommonMiddleware(app);
  setupSecurityMiddleware(app);

  // Middleware cho static files
  app.use('/uploads', express.static(environment.paths.uploads));

  // Middleware thêm signature cho tất cả các responses
  app.use((req, res, next) => {
    res.setHeader('X-Powered-By', `RunOut-Biliard - ${environment.app.signature}`);
    next();
  });

  // Middleware xử lý lỗi phải được đặt cuối cùng
  // Lưu ý: Phải gọi sau khi đã thiết lập tất cả các routes
};

module.exports = {
  setupCommonMiddleware,
  setupSecurityMiddleware,
  setupErrorHandlingMiddleware,
  setupAllMiddleware,
};


--- File: server/src/config/monitoring.js ---
// server/src/config/monitoring.js (mẫu)
const mongoose = require('mongoose');
const logger = require('./logger');

function setupMongoMonitoring() {
  // Monitor connection events
  mongoose.connection.on('connected', () => {
    logger.info('MongoDB connected');
  });

  mongoose.connection.on('error', (err) => {
    logger.error('MongoDB connection error:', err);
  });

  mongoose.connection.on('disconnected', () => {
    logger.warn('MongoDB disconnected');
  });

  // Monitor DB operations in development
  if (process.env.NODE_ENV === 'development') {
    mongoose.set('debug', (collection, method, query, doc) => {
      logger.debug(`MongoDB ${collection}.${method}`, { query, doc });
    });
  }
}

module.exports = { setupMongoMonitoring };


--- File: server/src/data/dto/cartDTO.js ---
// server/src/data/dto/cartDTO.js
class CartDTO {
  constructor(cart) {
    this.id = cart._id;
    this.items = cart.items.map((item) => ({
      id: item._id,
      product: item.product,
      quantity: item.quantity,
      price: item.price,
      attributes: item.attributes,
      addedAt: item.addedAt,
      updatedAt: item.updatedAt,
      totalPrice: item.price * item.quantity,
    }));

    this.subtotal = cart.subtotal;
    this.coupon = cart.coupon;
    this.totalItems = cart.items.reduce((sum, item) => sum + item.quantity, 0);
    this.lastActivity = cart.lastActivity;
    this.updatedAt = cart.updatedAt;
  }

  static fromEntity(cart) {
    return new CartDTO(cart);
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    delete entity.totalItems;

    if (entity.items) {
      entity.items = entity.items.map((item) => {
        const itemEntity = { ...item };
        delete itemEntity.id;
        delete itemEntity.totalPrice;
        return itemEntity;
      });
    }

    return entity;
  }
}

module.exports = CartDTO;


--- File: server/src/data/dto/categoryDTO.js ---
// server/src/data/dto/categoryDTO.js
class CategoryDTO {
  constructor(category) {
    this.id = category._id;
    this.name = category.name;
    this.slug = category.slug;
    this.description = category.description;
    this.parent = category.parent;
    this.ancestors = category.ancestors;
    this.level = category.level;
    this.image = category.image;
    this.icon = category.icon;
    this.order = category.order;
    this.isActive = category.isActive;
    this.isVisible = category.isVisible;
    this.createdAt = category.createdAt;
    this.updatedAt = category.updatedAt;
    this.children = category.children || [];
    this.meta = category.meta || {};
    this.meta.title = category.meta?.title || '';
    this.meta.description = category.meta?.description || '';
    this.meta.keywords = category.meta?.keywords || '';
    this.meta.robots = category.meta?.robots || '';
    this.meta.canonical = category.meta?.canonical || '';
  }

  static fromEntity(category) {
    return new CategoryDTO(category);
  }

  static fromEntities(categories) {
    return categories.map((category) => CategoryDTO.fromEntity(category));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  static fromTree(categoryTree) {
    return categoryTree.map((category) => {
      const dto = CategoryDTO.fromEntity(category);
      if (category.children && category.children.length > 0) {
        dto.children = CategoryDTO.fromTree(category.children);
      }
      return dto;
    });
  }
}

module.exports = CategoryDTO;


--- File: server/src/data/dto/orderDTO.js ---
// server/src/data/dto/orderDTO.js
class OrderDTO {
  constructor(order) {
    this.id = order._id;
    this.orderNumber = order.orderNumber;
    this.customerInfo = order.customerInfo;
    this.items = order.items;
    this.subtotal = order.subtotal;
    this.shippingCost = order.shippingCost;
    this.tax = order.tax;
    this.discount = order.discount;
    this.totalAmount = order.totalAmount;
    this.shippingAddress = order.shippingAddress;
    this.shippingMethod = order.shippingMethod;
    this.trackingNumber = order.trackingNumber;
    this.paymentMethod = order.paymentMethod;
    this.paymentStatus = order.paymentStatus;
    this.paymentDetails = order.paymentDetails;
    this.status = order.status;
    this.statusHistory = order.statusHistory;
    this.customerNotes = order.customerNotes;
    this.createdAt = order.createdAt;
    this.updatedAt = order.updatedAt;
    this.completedAt = order.completedAt;
    this.cancelledAt = order.cancelledAt;
  }

  static fromEntity(order) {
    return new OrderDTO(order);
  }

  static fromEntities(orders) {
    return orders.map((order) => OrderDTO.fromEntity(order));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }
}

module.exports = OrderDTO;


--- File: server/src/data/dto/productDTO.js ---
// server/src/data/dto/productDTO.js

/**
 * ProductDTO
 * Đối tượng chuyển đổi dữ liệu cho sản phẩm
 */
class ProductDTO {
  /**
   * Khởi tạo đối tượng ProductDTO
   * @param {Object} product - Đối tượng sản phẩm từ database
   */
  constructor(product) {
    this.product = product;

    if (product) {
      this.id = product._id;
      this.name = product.name;
      this.slug = product.slug;
      this.description = product.description;
      this.detailedDescription = product.detailedDescription;
      this.price = product.price;
      this.salePrice = product.salePrice;
      this.currency = product.currency || 'VND';
      this.stock = product.stock;
      this.categories = product.categories;
      this.images = product.images;
      this.attributes = product.attributes;
      this.status = product.status;
      this.featured = product.featured;
      this.sku = product.sku;
      this.brand = product.brand;
      this.createdAt = product.createdAt;
      this.updatedAt = product.updatedAt;
    }
  }

  /**
   * Tạo DTO từ entity
   * @param {Object} product - Entity sản phẩm
   * @returns {ProductDTO} - Đối tượng DTO
   */
  static fromEntity(product) {
    return new ProductDTO(product);
  }

  /**
   * Tạo danh sách DTO từ danh sách entity
   * @param {Array} products - Danh sách entity sản phẩm
   * @returns {Array} - Danh sách DTO
   */
  static fromEntities(products) {
    return products.map((product) => ProductDTO.fromEntity(product));
  }

  /**
   * Chuyển đổi DTO thành entity
   * @param {ProductDTO} dto - Đối tượng DTO
   * @returns {Object} - Entity sản phẩm
   */
  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;
    return entity;
  }

  /**
   * Chuyển đổi đối tượng sản phẩm thành JSON
   * @returns {Object} - Đối tượng JSON chứa thông tin sản phẩm
   */
  toJSON() {
    if (!this.product) return null;

    // Lấy dữ liệu từ đối tượng sản phẩm
    const {
      _id,
      name,
      slug,
      description,
      detailedDescription,
      price,
      salePrice,
      currency,
      stock,
      categories,
      images,
      attributes,
      status,
      featured,
      sku,
      brand,
      weight,
      dimensions,
      tags,
      warranty,
      soldCount,
      viewCount,
      createdAt,
      updatedAt,
    } = this.product;

    // Biến đổi dữ liệu
    return {
      id: _id.toString(),
      name,
      slug,
      description,
      detailedDescription,
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        currency: currency || 'VND',
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inventory: {
        stock,
        inStock: stock > 0,
        status: stock > 0 ? 'Còn hàng' : 'Hết hàng',
      },
      categories: Array.isArray(categories)
        ? categories.map((cat) =>
            typeof cat === 'object' && cat._id ? cat._id.toString() : cat.toString()
          )
        : [],
      images: this._formatImages(images),
      mainImage: this._getMainImage(images),
      attributes: attributes || [],
      status,
      featured,
      sku,
      brand,
      specifications: {
        weight: weight || null,
        dimensions: dimensions || null,
      },
      tags: tags || [],
      warranty: warranty || null,
      stats: {
        soldCount: soldCount || 0,
        viewCount: viewCount || 0,
      },
      dates: {
        created: createdAt,
        updated: updatedAt,
      },
    };
  }

  /**
   * Tạo DTO cho danh sách sản phẩm
   * @param {Array} products - Danh sách sản phẩm
   * @returns {Array} - Danh sách DTO
   */
  static toJSONList(products) {
    if (!Array.isArray(products)) return [];
    return products.map((product) => new ProductDTO(product).toJSON());
  }

  /**
   * Tạo phiên bản rút gọn của DTO cho hiển thị trong danh sách
   * @returns {Object} - Đối tượng JSON rút gọn
   */
  toSummaryJSON() {
    if (!this.product) return null;

    const {
      _id,
      name,
      slug,
      description,
      price,
      salePrice,
      stock,
      images,
      status,
      featured,
      soldCount,
      createdAt,
    } = this.product;

    return {
      id: _id.toString(),
      name,
      slug,
      shortDescription: this._truncateText(description, 100),
      pricing: {
        regular: price,
        sale: salePrice > 0 && salePrice < price ? salePrice : null,
        discount: this._calculateDiscount(price, salePrice),
        finalPrice: this._getFinalPrice(price, salePrice),
      },
      inStock: stock > 0,
      mainImage: this._getMainImage(images),
      status,
      featured,
      soldCount: soldCount || 0,
      createdAt,
    };
  }

  /**
   * Tạo phiên bản chi tiết đầy đủ, bao gồm cả đánh giá và danh mục
   * @param {Array} reviews - Danh sách đánh giá
   * @param {Array} categoryDetails - Thông tin chi tiết danh mục
   * @returns {Object} - Đối tượng JSON chi tiết
   */
  toDetailedJSON(reviews = [], categoryDetails = []) {
    const baseDTO = this.toJSON();

    // Thêm thông tin đánh giá
    baseDTO.reviews = reviews;
    baseDTO.averageRating =
      reviews.length > 0
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
        : 0;

    // Thêm thông tin chi tiết danh mục
    baseDTO.categoryDetails = categoryDetails;

    // Thêm sản phẩm liên quan nếu có
    if (this.relatedProducts) {
      baseDTO.relatedProducts = this.relatedProducts;
    }

    return baseDTO;
  }

  /**
   * Thiết lập sản phẩm liên quan
   * @param {Array} relatedProducts - Danh sách sản phẩm liên quan
   */
  setRelatedProducts(relatedProducts) {
    this.relatedProducts = ProductDTO.toJSONList(relatedProducts);
    return this;
  }

  /**
   * Tính phần trăm giảm giá
   * @param {Number} price - Giá gốc
   * @param {Number} salePrice - Giá khuyến mãi
   * @returns {Number} - Phần trăm giảm giá
   * @private
   */
  _calculateDiscount(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return Math.round(((price - salePrice) / price) * 100);
    }
    return 0;
  }

  /**
   * Lấy giá cuối cùng (sau giảm giá nếu có)
   * @param {Number} price - Giá gốc
   * @param {Number} salePrice - Giá khuyến mãi
   * @returns {Number} - Giá cuối cùng
   * @private
   */
  _getFinalPrice(price, salePrice) {
    if (salePrice && salePrice > 0 && salePrice < price) {
      return salePrice;
    }
    return price;
  }

  /**
   * Định dạng danh sách hình ảnh
   * @param {Array} images - Danh sách hình ảnh
   * @returns {Array} - Danh sách hình ảnh đã định dạng
   * @private
   */
  _formatImages(images) {
    if (!images || !Array.isArray(images)) return [];

    return images.map((image) => {
      // Nếu image là string (url)
      if (typeof image === 'string') {
        return {
          url: image,
          alt: this.product.name,
          isMain: false,
        };
      }

      // Nếu image là object
      return {
        url: image.url,
        alt: image.alt || this.product.name,
        isMain: !!image.isMain,
      };
    });
  }

  /**
   * Lấy hình ảnh chính của sản phẩm
   * @param {Array} images - Danh sách hình ảnh
   * @returns {String} - URL hình ảnh chính
   * @private
   */
  _getMainImage(images) {
    if (!images || !Array.isArray(images) || images.length === 0) {
      return null;
    }

    // Tìm hình ảnh được đánh dấu là chính
    const mainImage = images.find((img) => {
      if (typeof img === 'object' && img.isMain) {
        return true;
      }
      return false;
    });

    // Nếu có hình ảnh chính, trả về URL
    if (mainImage) {
      return typeof mainImage === 'string' ? mainImage : mainImage.url;
    }

    // Nếu không có hình ảnh chính, lấy hình ảnh đầu tiên
    const firstImage = images[0];
    return typeof firstImage === 'string' ? firstImage : firstImage.url;
  }

  /**
   * Cắt ngắn văn bản
   * @param {String} text - Văn bản
   * @param {Number} maxLength - Độ dài tối đa
   * @returns {String} - Văn bản đã cắt ngắn
   * @private
   */
  _truncateText(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;

    return text.substring(0, maxLength) + '...';
  }
}

module.exports = ProductDTO;


--- File: server/src/data/dto/reviewDTO.js ---
// server/src/data/dto/reviewDTO.js
class ReviewDTO {
  constructor(review) {
    this.id = review._id;
    this.product = review.product;
    this.user = review.user;
    this.rating = review.rating;
    this.title = review.title;
    this.review = review.review;
    this.images = review.images;
    this.isVerifiedPurchase = review.isVerifiedPurchase;
    this.helpfulness = {
      upvotes: review.helpfulness.upvotes,
      downvotes: review.helpfulness.downvotes,
    };
    this.responses = review.responses.map((response) => ({
      id: response._id,
      user: response.user,
      isAdmin: response.isAdmin,
      content: response.content,
      createdAt: response.createdAt,
      updatedAt: response.updatedAt,
    }));
    this.createdAt = review.createdAt;
  }

  static fromEntity(review) {
    return new ReviewDTO(review);
  }

  static fromEntities(reviews) {
    return reviews.map((review) => ReviewDTO.fromEntity(review));
  }

  static toEntity(dto) {
    const entity = { ...dto };
    delete entity.id;

    if (entity.responses) {
      entity.responses = entity.responses.map((response) => {
        const responseEntity = { ...response };
        delete responseEntity.id;
        return responseEntity;
      });
    }

    return entity;
  }
}

module.exports = ReviewDTO;


--- File: server/src/data/dto/userDTO.js ---
/**
 * DTO cho User - chuyển đổi dữ liệu giữa service layer và client
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Class UserDTO - chuyển đổi dữ liệu User cho response
 */
class UserDTO {
  /**
   * Chuyển đổi từ model User sang DTO
   * @param {Object} user - User model
   * @returns {Object} - User DTO
   */
  static toDTO(user) {
    if (!user) return null;

    // Chuyển đổi user model thành plain object nếu chưa phải
    const userObj = user.toObject ? user.toObject() : user;

    return {
      id: userObj._id.toString(),
      name: userObj.name,
      email: userObj.email,
      role: userObj.role,
      avatar: userObj.avatar,
      phone: userObj.phone || '',
      address: userObj.address || {},
      isActive: userObj.isActive,
      emailVerified: userObj.emailVerified,
      lastLogin: userObj.lastLogin,
      loginCount: userObj.loginCount,
      preferences: userObj.preferences || {
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      },
      createdAt: userObj.createdAt,
      updatedAt: userObj.updatedAt,
    };
  }

  /**
   * Chuyển đổi một mảng User models sang DTO
   * @param {Array} users - Mảng User models
   * @returns {Array} - Mảng User DTOs
   */
  static toList(users) {
    if (!users || !Array.isArray(users)) return [];
    return users.map((user) => UserDTO.toDTO(user));
  }

  /**
   * Chuyển đổi dữ liệu phân trang từ service
   * @param {Object} paginatedResult - Kết quả phân trang từ service
   * @returns {Object} - Kết quả phân trang đã chuyển đổi
   */
  static toPagination(paginatedResult) {
    return {
      data: UserDTO.toList(paginatedResult.data || paginatedResult.users),
      pagination: {
        total: paginatedResult.totalCount || paginatedResult.pagination.total,
        page: paginatedResult.page || paginatedResult.pagination.page,
        limit: paginatedResult.limit || paginatedResult.pagination.limit,
        totalPages: paginatedResult.totalPages || paginatedResult.pagination.totalPages,
        hasNext: paginatedResult.hasNext || paginatedResult.pagination.hasNext,
        hasPrev: paginatedResult.hasPrev || paginatedResult.pagination.hasPrev,
      },
    };
  }

  /**
   * Chuyển đổi dữ liệu cho profile
   * @param {Object} user - User model
   * @returns {Object} - User profile DTO
   */
  static toProfile(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Thêm các thông tin bổ sung cho profile nếu cần
    return {
      ...dto,
      // Có thể thêm các trường khác ở đây
    };
  }

  /**
   * Chuyển đổi dữ liệu cho admin (bao gồm thông tin nhạy cảm hơn)
   * @param {Object} user - User model
   * @returns {Object} - Admin User DTO
   */
  static toAdminDTO(user) {
    if (!user) return null;

    const dto = UserDTO.toDTO(user);

    // Thêm các thông tin admin cần
    return {
      ...dto,
      emailVerified: user.emailVerified,
      isActive: user.isActive,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      lastLogin: user.lastLogin,
      loginCount: user.loginCount,
    };
  }
}

module.exports = UserDTO;


--- File: server/src/data/models/cart.model.js ---
// server/src/data/models/cart.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CartSchema = new Schema(
  {
    // Thông tin chủ sở hữu
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },
    sessionId: {
      type: String,
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },

    // Danh sách sản phẩm
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        addedAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // Tính toán giá
    subtotal: {
      type: Number,
      default: 0,
    },

    // Mã giảm giá
    coupon: {
      code: String,
      discount: Number,
      appliedAt: Date,
    },

    // Trạng thái
    status: {
      type: String,
      enum: ['active', 'converted', 'abandoned', 'merged'],
      default: 'active',
    },

    // Thời gian hoạt động và hết hạn
    lastActivity: {
      type: Date,
      default: Date.now,
    },
    expiresAt: {
      type: Date,
      // Bỏ sparse: true ở đây, chỉ để lại trong khai báo index
    },
  },
  {
    timestamps: true,
  }
);

// Indexes - Giữ lại các khai báo chỉ mục rõ ràng và thêm tên
CartSchema.index({ user: 1 }, { sparse: true, name: 'cart_user_idx' });
CartSchema.index({ sessionId: 1 }, { sparse: true, name: 'cart_sessionId_idx' });
CartSchema.index({ status: 1 }, { name: 'cart_status_idx' });
CartSchema.index({ user: 1, status: 1 }, { name: 'cart_user_status_idx' });
CartSchema.index({ sessionId: 1, status: 1 }, { sparse: true, name: 'cart_sessionId_status_idx' });
CartSchema.index(
  { expiresAt: 1 },
  { expireAfterSeconds: 0, sparse: true, name: 'cart_expiresAt_ttl_idx' }
);
CartSchema.index({ 'items.product': 1 }, { name: 'cart_items_product_idx' });

module.exports = mongoose.model('Cart', CartSchema);


--- File: server/src/data/models/category.model.js ---
// server/src/data/models/category.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const CategorySchema = new Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
    },
    description: String,

    // Cấu trúc phân cấp
    parent: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      default: null,
    },
    ancestors: [
      {
        _id: {
          type: Schema.Types.ObjectId,
          ref: 'Category',
        },
        name: String,
        slug: String,
      },
    ],
    level: {
      type: Number,
      default: 0,
    },

    // Hiển thị
    image: {
      url: String,
      alt: String,
    },
    icon: String,

    // Thứ tự và trạng thái
    order: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    isVisible: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes với tên rõ ràng
CategorySchema.index({ name: 1 }, { name: 'category_name_idx' });
CategorySchema.index({ slug: 1 }, { unique: true, name: 'category_slug_unique_idx' });
CategorySchema.index({ parent: 1 }, { name: 'category_parent_idx' });
CategorySchema.index({ 'ancestors._id': 1 }, { name: 'category_ancestors_idx' });
CategorySchema.index({ level: 1 }, { name: 'category_level_idx' });
CategorySchema.index({ order: 1 }, { name: 'category_order_idx' });
CategorySchema.index({ isActive: 1, isVisible: 1 }, { name: 'category_active_visible_idx' });
CategorySchema.index({ name: 'text', description: 'text' }, { name: 'category_text_search_idx' });

module.exports = mongoose.model('Category', CategorySchema);


--- File: server/src/data/models/order.model.js ---
// server/src/data/models/order.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const OrderSchema = new Schema(
  {
    // Thông tin cơ bản
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      // Không cần khai báo index: true ở đây vì đã có trong schema.index()
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      // Không cần khai báo index: true ở đây vì đã có trong schema.index()
    },

    // Thông tin liên hệ
    customerInfo: {
      name: {
        type: String,
        required: true,
      },
      email: {
        type: String,
        required: true,
      },
      phone: {
        type: String,
        required: true,
      },
    },

    // Chi tiết sản phẩm
    items: [
      {
        product: {
          type: Schema.Types.ObjectId,
          ref: 'Product',
          required: true,
        },
        name: {
          type: String,
          required: true,
        },
        price: {
          type: Number,
          required: true,
          min: 0,
        },
        quantity: {
          type: Number,
          required: true,
          min: 1,
        },
        totalPrice: {
          type: Number,
          required: true,
          min: 0,
        },
        attributes: {
          type: Object,
          default: {},
        },
        sku: String,
        image: String,
      },
    ],

    // Tổng tiền
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    shippingCost: {
      type: Number,
      required: true,
      default: 0,
    },
    tax: {
      type: Number,
      required: true,
      default: 0,
    },
    discount: {
      amount: {
        type: Number,
        default: 0,
      },
      code: String,
    },
    totalAmount: {
      type: Number,
      required: true,
      min: 0,
    },

    // Thông tin vận chuyển
    shippingAddress: {
      name: String,
      phone: String,
      street: {
        type: String,
        required: true,
      },
      city: {
        type: String,
        required: true,
      },
      state: String,
      zipCode: {
        type: String,
        required: true,
      },
      country: {
        type: String,
        required: true,
      },
      notes: String,
    },
    shippingMethod: {
      type: String,
      required: true,
    },
    trackingNumber: String,

    // Thông tin thanh toán
    paymentMethod: {
      type: String,
      required: true,
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'authorized', 'paid', 'failed', 'refunded', 'partially_refunded'],
      default: 'pending',
    },
    paymentDetails: {
      provider: String,
      transactionId: String,
      paymentDate: Date,
    },

    // Trạng thái đơn hàng
    status: {
      type: String,
      enum: ['pending', 'processing', 'packed', 'shipped', 'delivered', 'cancelled', 'returned'],
      default: 'pending',
    },

    // Lịch sử trạng thái
    statusHistory: [
      {
        status: {
          type: String,
          enum: [
            'pending',
            'processing',
            'packed',
            'shipped',
            'delivered',
            'cancelled',
            'returned',
          ],
        },
        date: {
          type: Date,
          default: Date.now,
        },
        note: String,
        updatedBy: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
      },
    ],

    // Ghi chú
    customerNotes: String,
    adminNotes: String,

    // Thời gian hoàn thành hoặc hủy
    completedAt: Date,
    cancelledAt: Date,
  },
  {
    timestamps: true,
  }
);

// Indexes
// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Indexes với tên rõ ràng
OrderSchema.index({ orderNumber: 1 }, { unique: true, name: 'order_number_unique_idx' });
OrderSchema.index({ user: 1 }, { name: 'order_user_idx' });
OrderSchema.index({ 'customerInfo.email': 1 }, { name: 'order_customer_email_idx' });
OrderSchema.index({ 'customerInfo.phone': 1 }, { name: 'order_customer_phone_idx' });
OrderSchema.index({ status: 1 }, { name: 'order_status_idx' });
OrderSchema.index({ paymentStatus: 1 }, { name: 'order_payment_status_idx' });
OrderSchema.index({ createdAt: -1 }, { name: 'order_created_desc_idx' });
OrderSchema.index({ completedAt: -1 }, { name: 'order_completed_desc_idx' });
OrderSchema.index({ user: 1, createdAt: -1 }, { name: 'order_user_created_idx' });
OrderSchema.index({ status: 1, createdAt: -1 }, { name: 'order_status_created_idx' });
OrderSchema.index({ 'items.product': 1 }, { name: 'order_items_product_idx' });
module.exports = mongoose.model('Order', OrderSchema);


--- File: server/src/data/models/product.model.js ---
// server/src/data/models/product.model.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

/**
 * Product Model
 * Schema MongoDB cho đối tượng sản phẩm
 */
const ProductSchema = new Schema(
  {
    // Thông tin cơ bản
    name: {
      type: String,
      required: [true, 'Tên sản phẩm là bắt buộc'],
      trim: true,
      maxlength: [200, 'Tên sản phẩm không được vượt quá 200 ký tự'],
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      // Loại bỏ index: true tại đây
    },
    description: {
      short: {
        type: String,
        required: [true, 'Mô tả ngắn sản phẩm là bắt buộc'],
        trim: true,
        maxlength: [500, 'Mô tả ngắn không được vượt quá 500 ký tự'],
      },
      long: {
        type: String,
        trim: true,
      },
    },

    // Danh mục và phân loại
    categories: [
      {
        type: Schema.Types.ObjectId,
        ref: 'Category',
        required: [true, 'Sản phẩm phải thuộc ít nhất một danh mục'],
      },
    ],
    tags: [String],

    // Thương hiệu và nguồn gốc
    brand: {
      type: String,
      required: true,
      trim: true,
    },

    // Giá và tồn kho
    price: {
      type: Number,
      required: [true, 'Giá sản phẩm là bắt buộc'],
      min: [0, 'Giá sản phẩm không được âm'],
    },
    salePrice: {
      type: Number,
      default: 0,
      min: [0, 'Giá khuyến mãi không được âm'],
    },
    currency: {
      type: String,
      default: 'VND',
    },
    stock: {
      type: Number,
      required: [true, 'Số lượng tồn kho là bắt buộc'],
      min: [0, 'Số lượng tồn kho không được âm'],
      default: 0,
    },
    sku: {
      type: String,
      trim: true,
      unique: true,
      sparse: true,
      // Loại bỏ index: true tại đây nếu có
    },

    // Hình ảnh sản phẩm
    images: [
      {
        url: {
          type: String,
          required: true,
        },
        alt: String,
        isMain: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Thuộc tính sản phẩm
    attributes: [
      {
        name: {
          type: String,
          required: true,
        },
        value: {
          type: String,
          required: true,
        },
      },
    ],

    // Đặc điểm sản phẩm
    features: [String],

    // Thông số kỹ thuật
    specifications: {
      weight: Number,
      length: Number,
      diameter: Number,
      material: String,
      tipSize: String,
      wrap: String,
    },

    // Kích thước và trọng lượng
    weight: {
      value: Number,
      unit: {
        type: String,
        default: 'g',
      },
    },
    dimensions: {
      length: Number,
      width: Number,
      height: Number,
      unit: {
        type: String,
        default: 'cm',
      },
    },

    // Bảo hành
    warranty: {
      type: String,
      trim: true,
    },

    // Đánh giá
    ratings: {
      average: {
        type: Number,
        default: 0,
        min: 0,
        max: 5,
      },
      count: {
        type: Number,
        default: 0,
      },
    },

    // Thống kê
    soldCount: {
      type: Number,
      default: 0,
    },
    viewCount: {
      type: Number,
      default: 0,
    },

    // Trạng thái
    status: {
      type: String,
      enum: {
        values: ['active', 'draft', 'discontinued'],
        message: 'Trạng thái phải là: active, draft hoặc discontinued',
      },
      default: 'draft',
    },
    featured: {
      type: Boolean,
      default: false,
    },
    isPromoted: {
      type: Boolean,
      default: false,
    },

    // Thông tin quản lý
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    updatedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Index cho tìm kiếm - giữ lại một chỉ mục text duy nhất
ProductSchema.index(
  {
    name: 'text',
    'description.short': 'text',
    'description.long': 'text',
    brand: 'text',
    'attributes.value': 'text',
  },
  {
    weights: {
      name: 10,
      'description.short': 5,
      'description.long': 3,
      brand: 3,
      'attributes.value': 2,
    },
    name: 'product_text_search_index', // Đặt tên rõ ràng để tránh xung đột
  }
);

// Tạo các index khác để tối ưu truy vấn
// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Tạo các index khác để tối ưu truy vấn
ProductSchema.index({ slug: 1 }, { unique: true, name: 'product_slug_unique_idx' });
ProductSchema.index({ sku: 1 }, { unique: true, sparse: true, name: 'product_sku_unique_idx' });
ProductSchema.index({ status: 1, categories: 1 }, { name: 'product_status_categories_idx' });
ProductSchema.index({ status: 1, price: 1 }, { name: 'product_status_price_idx' });
ProductSchema.index({ status: 1, createdAt: -1 }, { name: 'product_status_created_idx' });
ProductSchema.index({ categories: 1 }, { name: 'product_categories_idx' });
ProductSchema.index({ brand: 1 }, { name: 'product_brand_idx' });
ProductSchema.index({ featured: 1 }, { name: 'product_featured_idx' });
ProductSchema.index({ isPromoted: 1 }, { name: 'product_promoted_idx' });
ProductSchema.index({ 'ratings.average': -1, status: 1 }, { name: 'product_ratings_status_idx' });
ProductSchema.index(
  { status: 1, categories: 1, price: 1 },
  { name: 'product_status_categories_price_idx' }
);

// Virtual để lấy đánh giá
ProductSchema.virtual('reviews', {
  ref: 'Review',
  foreignField: 'productId',
  localField: '_id',
});

// Phương thức để kiểm tra còn hàng
ProductSchema.methods.isInStock = function () {
  return this.stock > 0;
};

// Phương thức để tính giá sau giảm giá
ProductSchema.methods.getFinalPrice = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return this.salePrice;
  }
  return this.price;
};

// Phương thức để tính phần trăm giảm giá
ProductSchema.methods.getDiscountPercentage = function () {
  if (this.salePrice > 0 && this.salePrice < this.price) {
    return Math.round(((this.price - this.salePrice) / this.price) * 100);
  }
  return 0;
};

// Middleware trước khi lưu
ProductSchema.pre('save', function (next) {
  // Cập nhật ngày sửa đổi
  this.updatedAt = Date.now();
  next();
});

// Middleware sau khi tìm kiếm
ProductSchema.post('find', function (docs) {
  if (docs) {
    console.log(`Tìm thấy ${docs.length} sản phẩm`);
  }
});

const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;


--- File: server/src/data/models/review.model.js ---
// server/src/data/models/review.model.js
// File này không có vấn đề chỉ mục trùng lặp, giữ nguyên nội dung
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const ReviewSchema = new Schema(
  {
    // Thông tin cơ bản
    product: {
      type: Schema.Types.ObjectId,
      ref: 'Product',
      required: true,
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    order: {
      type: Schema.Types.ObjectId,
      ref: 'Order',
    },

    // Nội dung đánh giá
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    title: {
      type: String,
      trim: true,
      maxlength: 100,
    },
    review: {
      type: String,
      trim: true,
      maxlength: 2000,
    },

    // Hình ảnh đính kèm
    images: [
      {
        url: String,
        thumbnail: String,
        caption: String,
      },
    ],

    // Metadata
    isVerifiedPurchase: {
      type: Boolean,
      default: false,
    },
    purchaseDate: Date,

    // Tương tác với đánh giá
    helpfulness: {
      upvotes: {
        type: Number,
        default: 0,
      },
      downvotes: {
        type: Number,
        default: 0,
      },
      voters: [
        {
          user: {
            type: Schema.Types.ObjectId,
            ref: 'User',
          },
          vote: {
            type: Number,
            enum: [1, -1],
          },
          votedAt: {
            type: Date,
            default: Date.now,
          },
        },
      ],
    },

    // Phản hồi
    responses: [
      {
        user: {
          type: Schema.Types.ObjectId,
          ref: 'User',
        },
        isAdmin: {
          type: Boolean,
          default: false,
        },
        content: {
          type: String,
          required: true,
          trim: true,
          maxlength: 1000,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
        updatedAt: Date,
      },
    ],

    // Trạng thái
    isVisible: {
      type: Boolean,
      default: true,
    },

    // Thông tin kiểm duyệt
    moderation: {
      status: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
      },
      moderatedBy: {
        type: Schema.Types.ObjectId,
        ref: 'User',
      },
      moderatedAt: Date,
      reason: String,
    },
  },
  {
    timestamps: true,
  }
);

// Chỉ hiển thị phần khai báo chỉ mục để tiết kiệm không gian
// Indexes với tên rõ ràng
ReviewSchema.index({ product: 1 }, { name: 'review_product_idx' });
ReviewSchema.index({ user: 1 }, { name: 'review_user_idx' });
ReviewSchema.index({ product: 1, createdAt: -1 }, { name: 'review_product_created_idx' });
ReviewSchema.index({ product: 1, rating: -1 }, { name: 'review_product_rating_idx' });
ReviewSchema.index(
  { product: 1, 'helpfulness.upvotes': -1 },
  { name: 'review_product_upvotes_idx' }
);
ReviewSchema.index({ 'moderation.status': 1 }, { name: 'review_moderation_status_idx' });
ReviewSchema.index(
  { product: 1, 'moderation.status': 1, isVisible: 1 },
  { name: 'review_product_moderation_visible_idx' }
);
ReviewSchema.index({ title: 'text', review: 'text' }, { name: 'review_text_search_idx' });

module.exports = mongoose.model('Review', ReviewSchema);


--- File: server/src/data/models/user.model.js ---
// server/src/data/models/user.model.js - Cập nhật cho phần xác thực
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true, // Chỉ giữ unique: true, không cần thêm index: true
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, // Không bao gồm password trong query results
    },
    role: {
      type: String,
      enum: ['user', 'admin', 'staff'],
      default: 'user',
    },
    avatar: String,

    phone: String,
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String,
    },

    isActive: {
      type: Boolean,
      default: true,
    },
    emailVerified: {
      type: Boolean,
      default: false,
    },

    resetPasswordToken: String,
    resetPasswordExpires: Date,
    emailVerificationToken: String,
    emailVerificationExpires: Date,

    refreshToken: String,

    lastLogin: Date,
    loginCount: {
      type: Number,
      default: 0,
    },

    preferences: {
      language: {
        type: String,
        default: 'vi',
      },
      notifications: {
        email: {
          type: Boolean,
          default: true,
        },
        marketing: {
          type: Boolean,
          default: true,
        },
      },
    },
  },
  {
    timestamps: true,
  }
);

// Thêm các chỉ mục phù hợp
// Không cần thêm chỉ mục cho email vì unique: true đã tự tạo chỉ mục
userSchema.index({ role: 1 });
userSchema.index({ isActive: 1 });
userSchema.index({ emailVerified: 1 });
userSchema.index({ resetPasswordToken: 1 }, { sparse: true });
userSchema.index({ emailVerificationToken: 1 }, { sparse: true });
userSchema.index({ phone: 1 }, { sparse: true });
userSchema.index({ name: 'text' });

// Hooks
userSchema.pre('save', async function (next) {
  // Chỉ hash mật khẩu nếu nó thay đổi
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Methods
userSchema.methods.comparePassword = async function (candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.generateAuthToken = function () {
  return jwt.sign({ id: this._id, role: this.role }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

userSchema.methods.generateRefreshToken = function () {
  const refreshToken = jwt.sign({ id: this._id }, process.env.JWT_REFRESH_SECRET, {
    expiresIn: process.env.JWT_REFRESH_EXPIRES_IN,
  });

  this.refreshToken = refreshToken;
  return refreshToken;
};

const User = mongoose.model('User', userSchema);

module.exports = User;


--- File: server/src/data/repositories/cartRepository.js ---
// server/src/data/repositories/cartRepository.js
const Cart = require('../models/cart.model');
const ApiError = require('../../common/errors/apiError');
const Product = require('../models/product.model');
const mongoose = require('mongoose');

class CartRepository {
  async findByUser(userId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ user: userId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findBySessionId(sessionId, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findOne({ sessionId, status: 'active' });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    return await query.exec();
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Cart.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const cart = await query.exec();

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    return cart;
  }

  async create(data) {
    const cart = new Cart({
      ...data,
      status: 'active',
      lastActivity: new Date(),
    });

    // Nếu là giỏ hàng khách vãng lai, đặt thời gian hết hạn
    if (data.sessionId && !data.user) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 days from now
      cart.expiresAt = expiryDate;
    }

    return await cart.save();
  }

  async addItem(cartId, item) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Kiểm tra tồn kho
      const product = await Product.findById(item.product);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < item.quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // Lấy giỏ hàng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // Tìm sản phẩm trong giỏ hàng
      const existingItemIndex = cart.items.findIndex(
        (cartItem) =>
          cartItem.product.toString() === item.product.toString() &&
          JSON.stringify(cartItem.attributes || {}) === JSON.stringify(item.attributes || {})
      );

      const now = new Date();

      if (existingItemIndex > -1) {
        // Cập nhật sản phẩm đã có
        const newQuantity = cart.items[existingItemIndex].quantity + item.quantity;

        if (product.stock < newQuantity) {
          throw new ApiError(400, 'Insufficient stock');
        }

        cart.items[existingItemIndex].quantity = newQuantity;
        cart.items[existingItemIndex].updatedAt = now;
      } else {
        // Thêm sản phẩm mới vào giỏ hàng
        cart.items.push({
          product: item.product,
          quantity: item.quantity,
          price: product.salePrice || product.price,
          attributes: item.attributes || {},
          addedAt: now,
          updatedAt: now,
        });
      }

      // Cập nhật tổng tiền
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // Cập nhật timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // Lưu giỏ hàng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateItemQuantity(cartId, productId, quantity, attributes = {}) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Kiểm tra tồn kho
      const product = await Product.findById(productId);

      if (!product) {
        throw new ApiError(404, 'Product not found');
      }

      if (product.stock < quantity) {
        throw new ApiError(400, 'Insufficient stock');
      }

      // Lấy giỏ hàng
      const cart = await Cart.findById(cartId);

      if (!cart) {
        throw new ApiError(404, 'Cart not found');
      }

      // Tìm sản phẩm trong giỏ hàng
      const itemIndex = cart.items.findIndex(
        (item) =>
          item.product.toString() === productId.toString() &&
          JSON.stringify(item.attributes || {}) === JSON.stringify(attributes)
      );

      if (itemIndex === -1) {
        throw new ApiError(404, 'Product not found in cart');
      }

      const now = new Date();

      if (quantity <= 0) {
        // Xóa sản phẩm khỏi giỏ hàng
        cart.items.splice(itemIndex, 1);
      } else {
        // Cập nhật số lượng
        cart.items[itemIndex].quantity = quantity;
        cart.items[itemIndex].updatedAt = now;
      }

      // Cập nhật tổng tiền
      cart.subtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

      // Cập nhật timestamps
      cart.updatedAt = now;
      cart.lastActivity = now;

      // Lưu giỏ hàng
      await cart.save({ session });

      await session.commitTransaction();
      return cart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async removeItem(cartId, productId, attributes = {}) {
    return await this.updateItemQuantity(cartId, productId, 0, attributes);
  }

  async clear(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.items = [];
    cart.subtotal = 0;
    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async applyCoupon(cartId, couponCode, discount) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = {
      code: couponCode,
      discount,
      appliedAt: new Date(),
    };

    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async removeCoupon(cartId) {
    const cart = await Cart.findById(cartId);

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    cart.coupon = undefined;
    cart.updatedAt = new Date();
    cart.lastActivity = new Date();

    return await cart.save();
  }

  async mergeGuestCart(userId, sessionId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tìm giỏ hàng guest
      const guestCart = await Cart.findOne({ sessionId, status: 'active' });

      // Nếu không có giỏ hàng guest, không cần hợp nhất
      if (!guestCart) {
        await session.commitTransaction();
        return null;
      }

      // Tìm giỏ hàng người dùng
      let userCart = await Cart.findOne({ user: userId, status: 'active' });

      if (!userCart) {
        // Nếu người dùng không có giỏ hàng, chuyển đổi giỏ hàng guest thành của người dùng
        guestCart.user = userId;
        guestCart.sessionId = null;
        guestCart.expiresAt = null;
        guestCart.updatedAt = new Date();
        guestCart.lastActivity = new Date();
        await guestCart.save({ session });

        await session.commitTransaction();
        return guestCart;
      }

      // Hợp nhất các sản phẩm từ giỏ hàng guest vào giỏ hàng người dùng
      const now = new Date();

      for (const guestItem of guestCart.items) {
        // Kiểm tra tồn kho
        const product = await Product.findById(guestItem.product);

        if (product) {
          const existingItemIndex = userCart.items.findIndex(
            (item) =>
              item.product.toString() === guestItem.product.toString() &&
              JSON.stringify(item.attributes || {}) === JSON.stringify(guestItem.attributes || {})
          );

          if (existingItemIndex > -1) {
            // Cộng số lượng nếu sản phẩm đã tồn tại
            const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

            if (product.stock >= newQuantity) {
              userCart.items[existingItemIndex].quantity = newQuantity;
              userCart.items[existingItemIndex].updatedAt = now;
            } else {
              // Nếu không đủ tồn kho, đặt số lượng tối đa có thể
              userCart.items[existingItemIndex].quantity = product.stock;
              userCart.items[existingItemIndex].updatedAt = now;
            }
          } else {
            // Thêm sản phẩm mới
            if (product.stock >= guestItem.quantity) {
              userCart.items.push({
                ...guestItem.toObject(),
                updatedAt: now,
              });
            } else if (product.stock > 0) {
              // Thêm với số lượng tối đa có thể
              userCart.items.push({
                ...guestItem.toObject(),
                quantity: product.stock,
                updatedAt: now,
              });
            }
          }
        }
      }

      // Cập nhật tổng tiền
      userCart.subtotal = userCart.items.reduce(
        (total, item) => total + item.price * item.quantity,
        0
      );

      // Giữ lại coupon nếu có
      if (guestCart.coupon && !userCart.coupon) {
        userCart.coupon = guestCart.coupon;
      }

      // Cập nhật timestamps
      userCart.updatedAt = now;
      userCart.lastActivity = now;

      // Lưu giỏ hàng người dùng
      await userCart.save({ session });

      // Đánh dấu giỏ hàng guest đã được hợp nhất
      guestCart.status = 'merged';
      guestCart.updatedAt = now;
      await guestCart.save({ session });

      await session.commitTransaction();
      return userCart;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async getCartDetails(cartId) {
    const cart = await Cart.findById(cartId).populate({
      path: 'items.product',
      select: 'name slug images stock price salePrice',
    });

    if (!cart) {
      throw new ApiError(404, 'Cart not found');
    }

    // Kiểm tra tồn kho và cập nhật giá (nếu có thay đổi)
    let needsUpdate = false;

    for (const item of cart.items) {
      const product = item.product;

      // Cập nhật giá nếu có thay đổi
      const currentPrice = product.salePrice || product.price;
      if (item.price !== currentPrice) {
        item.price = currentPrice;
        needsUpdate = true;
      }

      // Kiểm tra tồn kho
      if (product.stock < item.quantity) {
        item.quantity = Math.max(0, product.stock);
        needsUpdate = true;
      }
    }

    // Lọc bỏ sản phẩm có số lượng 0
    cart.items = cart.items.filter((item) => item.quantity > 0);

    // Cập nhật tổng tiền
    const newSubtotal = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);

    if (cart.subtotal !== newSubtotal) {
      cart.subtotal = newSubtotal;
      needsUpdate = true;
    }

    // Lưu lại giỏ hàng nếu có thay đổi
    if (needsUpdate) {
      cart.updatedAt = new Date();
      cart.lastActivity = new Date();
      await cart.save();
    }

    return cart;
  }
}

module.exports = new CartRepository();


--- File: server/src/data/repositories/categoryRepository.js ---
// server/src/data/repositories/categoryRepository.js
const Category = require('../models/category.model');
const ApiError = require('../../common/errors/apiError');
// const mongoose = require('mongoose');

class CategoryRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { order: 1 }, limit = 0, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Category.find(filter).sort(sort);

    // Áp dụng pagination nếu limit > 0
    if (limit > 0) {
      query.skip(skip).limit(limit);
    }

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [categories, totalCount] = await Promise.all([
      query.exec(),
      Category.countDocuments(filter),
    ]);

    if (limit > 0) {
      return {
        data: categories,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };
    }

    return categories;
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Category.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async findBySlug(slug, options = {}) {
    const { populate = [] } = options;

    const query = Category.findOne({ slug });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const category = await query.exec();

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return category;
  }

  async create(data) {
    // Kiểm tra slug đã tồn tại chưa
    const existingCategory = await Category.findOne({ slug: data.slug }).exec();

    if (existingCategory) {
      throw new ApiError(409, 'Category with this slug already exists');
    }

    // Nếu có parent, cập nhật ancestors và level
    if (data.parent) {
      const parentCategory = await this.findById(data.parent);

      data.level = parentCategory.level + 1;
      data.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        },
      ];
    } else {
      data.level = 0;
      data.ancestors = [];
    }

    const category = new Category(data);
    return await category.save();
  }

  async update(id, data) {
    // Nếu có cập nhật slug, kiểm tra slug đã tồn tại chưa
    if (data.slug) {
      const existingCategory = await Category.findOne({ slug: data.slug, _id: { $ne: id } }).exec();

      if (existingCategory) {
        throw new ApiError(409, 'Category with this slug already exists');
      }
    }

    // Nếu có thay đổi parent, cập nhật ancestors và level
    if (data.parent !== undefined) {
      if (data.parent) {
        const parentCategory = await this.findById(data.parent);

        // Kiểm tra parent không phải là con của category hiện tại
        if (parentCategory.ancestors.some((a) => a._id.toString() === id)) {
          throw new ApiError(400, 'Cannot set a child category as parent');
        }

        data.level = parentCategory.level + 1;
        data.ancestors = [
          ...parentCategory.ancestors,
          {
            _id: parentCategory._id,
            name: parentCategory.name,
            slug: parentCategory.slug,
          },
        ];
      } else {
        data.level = 0;
        data.ancestors = [];
      }
    }

    const category = await Category.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    // Nếu category đã được cập nhật thành công và name hoặc slug đã thay đổi,
    // cần cập nhật ancestors cho tất cả các category con
    if (data.name || data.slug) {
      await this.updateChildrenAncestors(category);
    }

    return category;
  }

  async updateChildrenAncestors(parentCategory) {
    const childCategories = await Category.find({ parent: parentCategory._id });

    const updatePromises = childCategories.map(async (childCategory) => {
      // Cập nhật ancestors
      const ancestorIndex = childCategory.ancestors.findIndex(
        (a) => a._id.toString() === parentCategory._id.toString()
      );

      if (ancestorIndex !== -1) {
        childCategory.ancestors[ancestorIndex] = {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug,
        };

        await childCategory.save();

        // Cập nhật đệ quy cho con của childCategory
        await this.updateChildrenAncestors(childCategory);
      }
    });

    await Promise.all(updatePromises);
  }

  async delete(id) {
    // Kiểm tra xem category có con không
    const hasChildren = await Category.exists({ parent: id });

    if (hasChildren) {
      throw new ApiError(400, 'Cannot delete category with children');
    }

    const category = await Category.findByIdAndDelete(id);

    if (!category) {
      throw new ApiError(404, 'Category not found');
    }

    return { success: true };
  }

  async getCategoryTree(filter = {}) {
    // Lấy tất cả categories
    const categories = await Category.find(filter).sort({ order: 1 }).lean();

    // Tạo map cho việc tìm kiếm nhanh
    const categoryMap = {};
    categories.forEach((category) => {
      categoryMap[category._id.toString()] = {
        ...category,
        children: [],
      };
    });

    // Xây dựng cây
    const rootCategories = [];

    categories.forEach((category) => {
      const categoryWithChildren = categoryMap[category._id.toString()];

      if (category.parent) {
        const parentId = category.parent.toString();
        if (categoryMap[parentId]) {
          categoryMap[parentId].children.push(categoryWithChildren);
        }
      } else {
        rootCategories.push(categoryWithChildren);
      }
    });

    return rootCategories;
  }

  async getVisibleCategories() {
    return await this.getCategoryTree({ isActive: true, isVisible: true });
  }
}

module.exports = new CategoryRepository();


--- File: server/src/data/repositories/orderRepository.js ---
// server/src/data/repositories/orderRepository.js
const Order = require('../models/order.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class OrderRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Order.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [orders, totalCount] = await Promise.all([query.exec(), Order.countDocuments(filter)]);

    return {
      data: orders,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Order.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async findByOrderNumber(orderNumber, options = {}) {
    const { populate = [] } = options;

    const query = Order.findOne({ orderNumber });

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const order = await query.exec();

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    return order;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tạo order
      const order = new Order(data);
      await order.save({ session });

      await session.commitTransaction();
      return order;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateStatus(id, status, note, updatedBy) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    // Kiểm tra trạng thái hợp lệ
    const validStatusTransitions = {
      pending: ['processing', 'cancelled'],
      processing: ['packed', 'cancelled'],
      packed: ['shipped', 'cancelled'],
      shipped: ['delivered', 'returned'],
      delivered: ['returned'],
      cancelled: [],
      returned: [],
    };

    if (!validStatusTransitions[order.status].includes(status)) {
      throw new ApiError(400, `Invalid status transition from ${order.status} to ${status}`);
    }

    // Cập nhật trạng thái
    order.status = status;

    // Thêm vào lịch sử trạng thái
    order.statusHistory.push({
      status,
      date: new Date(),
      note,
      updatedBy,
    });

    // Cập nhật các trường liên quan đến completion/cancellation
    if (status === 'delivered') {
      order.completedAt = new Date();
    } else if (status === 'cancelled') {
      order.cancelledAt = new Date();
    }

    // Cập nhật trạng thái thanh toán nếu COD
    if (status === 'delivered' && order.paymentMethod === 'cod') {
      order.paymentStatus = 'paid';
      order.paymentDetails.paymentDate = new Date();
    }

    return await order.save();
  }

  async updatePaymentStatus(id, paymentStatus, paymentDetails = {}) {
    const order = await Order.findById(id);

    if (!order) {
      throw new ApiError(404, 'Order not found');
    }

    order.paymentStatus = paymentStatus;

    if (Object.keys(paymentDetails).length > 0) {
      order.paymentDetails = {
        ...order.paymentDetails,
        ...paymentDetails,
      };
    }

    return await order.save();
  }

  async getUserOrders(userId, options = {}) {
    const filter = { user: userId };
    return await this.findAll(filter, options);
  }

  async getOrdersByStatus(status, options = {}) {
    const filter = { status };
    return await this.findAll(filter, options);
  }

  async getOrdersByPaymentStatus(paymentStatus, options = {}) {
    const filter = { paymentStatus };
    return await this.findAll(filter, options);
  }

  async getSalesReport(startDate, endDate) {
    const query = {
      createdAt: {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      },
      status: { $in: ['delivered', 'completed'] },
      paymentStatus: 'paid',
    };

    return await Order.aggregate([
      { $match: query },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' },
            day: { $dayOfMonth: '$createdAt' },
          },
          totalSales: { $sum: '$totalAmount' },
          orders: { $sum: 1 },
          averageOrderValue: { $avg: '$totalAmount' },
        },
      },
      {
        $sort: {
          '_id.year': 1,
          '_id.month': 1,
          '_id.day': 1,
        },
      },
    ]);
  }

  async generateOrderNumber() {
    const year = new Date().getFullYear();

    // Tìm đơn hàng cuối cùng trong năm hiện tại
    const lastOrder = await Order.findOne(
      { orderNumber: new RegExp(`^RO-${year}-`) },
      { orderNumber: 1 },
      { sort: { orderNumber: -1 } }
    );

    let nextNumber = 1;

    if (lastOrder) {
      // Extract số từ orderNumber cuối (RO-2025-0001 -> 1)
      const lastNumber = parseInt(lastOrder.orderNumber.split('-')[2]);
      nextNumber = lastNumber + 1;
    }

    // Format với số 0 đứng trước (1 -> 0001)
    return `RO-${year}-${nextNumber.toString().padStart(4, '0')}`;
  }
}

module.exports = new OrderRepository();


--- File: server/src/data/repositories/productRepository.js ---
// server/src/data/repositories/productRepository.js
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');
const redisCache = require('../../services/cache/redisCache'); // Thay thế bằng RedisCache
const logger = require('../../utils/logger'); // Giả định có module logger

class ProductRepository {
  constructor() {
    // Prefix cho cache keys
    this.cachePrefix = 'products';
    // Thời gian cache mặc định (5 phút)
    this.defaultCacheTTL = 300;
  }

  /**
   * Tìm tất cả sản phẩm với phân trang và lọc
   * @param {Object} filter - Bộ lọc
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Kết quả với phân trang
   */
  async findAll(filter = {}, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:all`, { filter, options });

    // Kiểm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy dữ liệu từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Product.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const [products, totalCount] = await Promise.all([
        query.lean().exec(), // Sử dụng lean() để tăng hiệu suất
        Product.countDocuments(filter),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // Lưu vào cache
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('Lỗi khi tìm tất cả sản phẩm:', error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm theo ID
   * @param {string} id - ID sản phẩm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Sản phẩm
   */
  async findById(id, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:id`, { id, options });

    // Kiểm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`Lấy sản phẩm từ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findById(id);

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Lưu vào cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi tìm sản phẩm theo ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm theo slug
   * @param {string} slug - Slug sản phẩm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Sản phẩm
   */
  async findBySlug(slug, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:slug`, { slug, options });

    // Kiểm tra cache
    const cachedProduct = await redisCache.get(cacheKey);
    if (cachedProduct) {
      logger.info(`Lấy sản phẩm từ cache: ${cacheKey}`);
      return cachedProduct;
    }

    const { populate = [] } = options;

    const query = Product.findOne({ slug });

    if (populate.length > 0) {
      query.populate(populate);
    }

    try {
      const product = await query.lean().exec();

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Lưu vào cache
      await redisCache.set(cacheKey, product, this.defaultCacheTTL);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi tìm sản phẩm theo slug ${slug}:`, error);
      throw error;
    }
  }

  /**
   * Tạo sản phẩm mới
   * @param {Object} data - Dữ liệu sản phẩm
   * @returns {Object} - Sản phẩm đã tạo
   */
  async create(data) {
    try {
      const product = new Product(data);
      const savedProduct = await product.save();

      // Xóa cache liên quan đến danh sách sản phẩm
      await this.invalidateProductListCache();

      return savedProduct;
    } catch (error) {
      logger.error('Lỗi khi tạo sản phẩm:', error);
      throw error;
    }
  }

  /**
   * Cập nhật sản phẩm
   * @param {string} id - ID sản phẩm
   * @param {Object} data - Dữ liệu cập nhật
   * @returns {Object} - Sản phẩm đã cập nhật
   */
  async update(id, data) {
    try {
      const product = await Product.findByIdAndUpdate(
        id,
        { ...data, updatedAt: Date.now() },
        { new: true, runValidators: true }
      );

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Xóa cache của sản phẩm này
      await this.invalidateProductCache(id, product.slug);

      return product;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi cập nhật sản phẩm ${id}:`, error);
      throw error;
    }
  }

  /**
   * Xóa sản phẩm
   * @param {string} id - ID sản phẩm
   * @returns {Object} - Kết quả xóa
   */
  async delete(id) {
    try {
      const product = await Product.findByIdAndDelete(id);

      if (!product) {
        throw ApiError.notFound('Không tìm thấy sản phẩm');
      }

      // Xóa cache của sản phẩm này và danh sách sản phẩm
      await this.invalidateProductCache(id, product.slug);
      await this.invalidateProductListCache();

      return { success: true };
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      logger.error(`Lỗi khi xóa sản phẩm ${id}:`, error);
      throw error;
    }
  }

  /**
   * Tìm kiếm sản phẩm theo text
   * @param {string} query - Từ khóa tìm kiếm
   * @param {Object} options - Tùy chọn
   * @returns {Object} - Kết quả tìm kiếm với phân trang
   */
  async searchProducts(query, options = {}) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:search`, { query, options });

    // Kiểm tra cache
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy kết quả tìm kiếm từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const { sort = { score: { $meta: 'textScore' } }, limit = 50, page = 1 } = options;
    const skip = (page - 1) * limit;

    const textSearchQuery = {
      $text: { $search: query },
      isActive: true,
    };

    try {
      const [products, totalCount] = await Promise.all([
        Product.find(textSearchQuery, { score: { $meta: 'textScore' } })
          .sort(sort)
          .skip(skip)
          .limit(limit)
          .lean()
          .exec(),
        Product.countDocuments(textSearchQuery),
      ]);

      const result = {
        data: products,
        pagination: {
          total: totalCount,
          page,
          limit,
          pages: Math.ceil(totalCount / limit),
        },
      };

      // Lưu vào cache với thời gian ngắn hơn (2 phút) vì dữ liệu tìm kiếm thường thay đổi
      await redisCache.set(cacheKey, result, 120);

      return result;
    } catch (error) {
      logger.error(`Lỗi khi tìm kiếm sản phẩm với từ khóa "${query}":`, error);
      throw error;
    }
  }

  /**
   * Cập nhật đánh giá sản phẩm
   * @param {string} productId - ID sản phẩm
   * @param {Object} rating - Thông tin đánh giá
   * @returns {Object} - Sản phẩm đã cập nhật
   */
  async updateRating(productId, rating) {
    try {
      const product = await Product.findByIdAndUpdate(
        productId,
        { ratings: rating },
        { new: true }
      );

      if (product) {
        // Xóa cache của sản phẩm này
        await this.invalidateProductCache(productId, product.slug);
      }

      return product;
    } catch (error) {
      logger.error(`Lỗi khi cập nhật đánh giá sản phẩm ${productId}:`, error);
      throw error;
    }
  }

  /**
   * Tìm sản phẩm với các bộ lọc và hỗ trợ cache
   * @param {Object} filters - Các bộ lọc để tìm sản phẩm
   * @param {Object} options - Các tùy chọn bổ sung
   * @returns {Object} - Kết quả tìm kiếm với phân trang
   */
  async findWithFilters(filters, options = {}) {
    // Tạo cache key dựa trên filters và options
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:filters`, { filters, options });

    // Kiểm tra cache trước
    const cachedResult = await redisCache.get(cacheKey);
    if (cachedResult) {
      logger.info(`Lấy kết quả lọc từ cache: ${cacheKey}`);
      return cachedResult;
    }

    const {
      category,
      minPrice,
      maxPrice,
      brand,
      sort = { createdAt: -1 },
      page = 1,
      limit = 20,
    } = filters;

    // Xây dựng query criteria
    const criteria = { isActive: true };

    if (category) {
      criteria.category = mongoose.Types.ObjectId(category);
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      criteria.price = {};
      if (minPrice !== undefined) criteria.price.$gte = minPrice;
      if (maxPrice !== undefined) criteria.price.$lte = maxPrice;
    }

    if (brand) {
      criteria.brand = brand;
    }

    // Sử dụng projection để giảm kích thước response
    const projection = options.projection || {
      name: 1,
      slug: 1,
      price: 1,
      category: 1,
      brand: 1,
      images: { $slice: 1 }, // Chỉ lấy ảnh đầu tiên
      ratings: 1,
    };

    // Tính toán skip value cho pagination
    const skip = (page - 1) * limit;

    try {
      // Thực hiện query với tối ưu
      const products = await Product.find(criteria, projection)
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(); // Sử dụng lean() để tăng hiệu suất

      // Đếm tổng số sản phẩm (sử dụng countDocuments thay vì count)
      const total = await Product.countDocuments(criteria);

      const result = {
        data: products,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit),
        },
      };

      // Lưu kết quả vào cache (TTL 5 phút)
      await redisCache.set(cacheKey, result, this.defaultCacheTTL);

      return result;
    } catch (error) {
      logger.error('Lỗi khi tìm sản phẩm với bộ lọc:', error);
      throw error;
    }
  }

  /**
   * Xóa cache của một sản phẩm cụ thể
   * @param {string} id - ID sản phẩm
   * @param {string} slug - Slug sản phẩm
   * @returns {Promise<void>}
   */
  async invalidateProductCache(id, slug) {
    try {
      // Xóa cache theo ID
      await redisCache.deleteByPattern(`${this.cachePrefix}:id:*${id}*`);

      // Xóa cache theo slug nếu có
      if (slug) {
        await redisCache.deleteByPattern(`${this.cachePrefix}:slug:*${slug}*`);
      }

      logger.info(`Đã xóa cache cho sản phẩm: ${id}`);
    } catch (error) {
      logger.error(`Lỗi khi xóa cache sản phẩm ${id}:`, error);
    }
  }

  /**
   * Xóa cache của danh sách sản phẩm
   * @returns {Promise<void>}
   */
  async invalidateProductListCache() {
    try {
      // Xóa tất cả cache liên quan đến danh sách sản phẩm
      await redisCache.deleteByPattern(`${this.cachePrefix}:all:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:filters:*`);
      await redisCache.deleteByPattern(`${this.cachePrefix}:search:*`);

      logger.info('Đã xóa cache danh sách sản phẩm');
    } catch (error) {
      logger.error('Lỗi khi xóa cache danh sách sản phẩm:', error);
    }
  }

  /**
   * Lấy sản phẩm nổi bật
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm nổi bật
   */
  async getFeaturedProducts(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:featured`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm nổi bật từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({
        isActive: true,
        isFeatured: true,
      })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 1 giờ)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm nổi bật:', error);
      throw error;
    }
  }

  /**
   * Lấy sản phẩm mới nhất
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm mới nhất
   */
  async getNewArrivals(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:new`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm mới từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 30 phút)
      await redisCache.set(cacheKey, products, 1800);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm mới nhất:', error);
      throw error;
    }
  }

  /**
   * Lấy sản phẩm bán chạy nhất
   * @param {number} limit - Số lượng sản phẩm cần lấy
   * @returns {Array} - Danh sách sản phẩm bán chạy
   */
  async getBestSellers(limit = 10) {
    const cacheKey = redisCache.generateKey(`${this.cachePrefix}:bestsellers`, { limit });

    // Kiểm tra cache
    const cachedProducts = await redisCache.get(cacheKey);
    if (cachedProducts) {
      logger.info(`Lấy sản phẩm bán chạy từ cache: ${cacheKey}`);
      return cachedProducts;
    }

    try {
      const products = await Product.find({ isActive: true })
        .sort({ soldCount: -1 })
        .limit(limit)
        .lean()
        .exec();

      // Lưu vào cache (TTL 1 giờ)
      await redisCache.set(cacheKey, products, 3600);

      return products;
    } catch (error) {
      logger.error('Lỗi khi lấy sản phẩm bán chạy:', error);
      throw error;
    }
  }
}

module.exports = new ProductRepository();


--- File: server/src/data/repositories/reviewRepository.js ---
// server/src/data/repositories/reviewRepository.js
const Review = require('../models/review.model');
const Product = require('../models/product.model');
const ApiError = require('../../common/errors/apiError');
const mongoose = require('mongoose');

class ReviewRepository {
  // server/src/data/repositories/reviewRepository.js (tiếp)
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, populate = [] } = options;
    const skip = (page - 1) * limit;

    const query = Review.find(filter).sort(sort).skip(skip).limit(limit);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const [reviews, totalCount] = await Promise.all([query.exec(), Review.countDocuments(filter)]);

    return {
      data: reviews,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, options = {}) {
    const { populate = [] } = options;

    const query = Review.findById(id);

    if (populate.length > 0) {
      populate.forEach((field) => {
        query.populate(field);
      });
    }

    const review = await query.exec();

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    return review;
  }

  async create(data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Tạo review
      const review = new Review(data);
      await review.save({ session });

      // Cập nhật rating cho product
      await this.updateProductRating(data.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async update(id, data) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findByIdAndUpdate(id, data, {
        new: true,
        runValidators: true,
        session,
      });

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // Cập nhật rating cho product
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async delete(id) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const review = await Review.findById(id).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      const productId = review.product;

      await Review.findByIdAndDelete(id).session(session);

      // Cập nhật rating cho product
      await this.updateProductRating(productId, session);

      await session.commitTransaction();
      return { success: true };
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async updateProductRating(productId, session = null) {
    // Lấy tất cả đánh giá được phê duyệt cho sản phẩm
    const aggregateOptions = session ? { session } : {};

    const reviews = await Review.aggregate(
      [
        {
          $match: {
            product: new mongoose.Types.ObjectId(productId),
            'moderation.status': 'approved',
            isVisible: true,
          },
        },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            count: { $sum: 1 },
          },
        },
      ],
      aggregateOptions
    );

    let averageRating = 0;
    let count = 0;

    if (reviews.length > 0) {
      averageRating = reviews[0].averageRating;
      count = reviews[0].count;
    }

    // Cập nhật product
    const updateOptions = session ? { session } : {};

    await Product.findByIdAndUpdate(
      productId,
      {
        'ratings.average': parseFloat(averageRating.toFixed(1)),
        'ratings.count': count,
      },
      updateOptions
    );
  }

  async getProductReviews(productId, options = {}) {
    const { sort = 'newest', page = 1, limit = 10, filter = {} } = options;

    const sortOptions = {
      newest: { createdAt: -1 },
      oldest: { createdAt: 1 },
      highestRating: { rating: -1 },
      lowestRating: { rating: 1 },
      mostHelpful: { 'helpfulness.upvotes': -1 },
    };

    const query = {
      product: productId,
      'moderation.status': 'approved',
      isVisible: true,
      ...filter,
    };

    return await this.findAll(query, {
      sort: sortOptions[sort] || sortOptions.newest,
      page,
      limit,
      populate: [{ path: 'user', select: 'name avatar' }],
    });
  }

  async getUserReviews(userId, options = {}) {
    const query = { user: userId };
    return await this.findAll(query, options);
  }

  async moderateReview(reviewId, action, reason, adminId) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // Validate action
      if (!['approve', 'reject'].includes(action)) {
        throw new ApiError(400, 'Invalid moderation action');
      }

      // Tìm review
      const review = await Review.findById(reviewId).session(session);

      if (!review) {
        throw new ApiError(404, 'Review not found');
      }

      // Cập nhật trạng thái kiểm duyệt
      review.moderation = {
        status: action === 'approve' ? 'approved' : 'rejected',
        moderatedBy: adminId,
        moderatedAt: new Date(),
        reason: action === 'reject' ? reason : undefined,
      };

      // Nếu từ chối, ẩn review
      if (action === 'reject') {
        review.isVisible = false;
      }

      // Lưu review
      await review.save({ session });

      // Cập nhật tổng rating cho sản phẩm
      await this.updateProductRating(review.product, session);

      await session.commitTransaction();
      return review;
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  async voteReview(reviewId, userId, vote) {
    // Validate vote
    if (![1, -1].includes(vote)) {
      throw new ApiError(400, 'Invalid vote value');
    }

    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    // Kiểm tra xem người dùng đã vote chưa
    const voterIndex = review.helpfulness.voters.findIndex(
      (voter) => voter.user.toString() === userId.toString()
    );

    if (voterIndex > -1) {
      const previousVote = review.helpfulness.voters[voterIndex].vote;

      // Nếu vote trùng với vote cũ, xóa vote
      if (previousVote === vote) {
        // Cập nhật upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes--;
        } else {
          review.helpfulness.downvotes--;
        }

        // Xóa voter
        review.helpfulness.voters.splice(voterIndex, 1);
      } else {
        // Nếu vote khác với vote cũ, cập nhật vote
        review.helpfulness.voters[voterIndex].vote = vote;
        review.helpfulness.voters[voterIndex].votedAt = new Date();

        // Cập nhật upvotes/downvotes
        if (vote === 1) {
          review.helpfulness.upvotes++;
          review.helpfulness.downvotes--;
        } else {
          review.helpfulness.upvotes--;
          review.helpfulness.downvotes++;
        }
      }
    } else {
      // Nếu chưa vote, thêm vote mới
      review.helpfulness.voters.push({
        user: userId,
        vote,
        votedAt: new Date(),
      });

      // Cập nhật upvotes/downvotes
      if (vote === 1) {
        review.helpfulness.upvotes++;
      } else {
        review.helpfulness.downvotes++;
      }
    }

    return await review.save();
  }

  async addResponse(reviewId, userId, content, isAdmin = false) {
    const review = await Review.findById(reviewId);

    if (!review) {
      throw new ApiError(404, 'Review not found');
    }

    review.responses.push({
      user: userId,
      isAdmin,
      content,
      createdAt: new Date(),
    });

    return await review.save();
  }

  async getRatingDistribution(productId) {
    return await Review.aggregate([
      {
        $match: {
          product: new mongoose.Types.ObjectId(productId),
          'moderation.status': 'approved',
          isVisible: true,
        },
      },
      {
        $group: {
          _id: '$rating',
          count: { $sum: 1 },
        },
      },
      {
        $project: {
          rating: '$_id',
          count: 1,
          _id: 0,
        },
      },
      {
        $sort: { rating: -1 },
      },
    ]);
  }
}

module.exports = new ReviewRepository();
// module.exports = ReviewRepository;


--- File: server/src/data/repositories/userRepository.js ---
// server/src/data/repositories/userRepository.js
const User = require('../models/user.model');
const ApiError = require('../../common/errors/apiError');

class UserRepository {
  async findAll(filter = {}, options = {}) {
    const { sort = { createdAt: -1 }, limit = 50, page = 1, select = '' } = options;
    const skip = (page - 1) * limit;

    const [users, totalCount] = await Promise.all([
      User.find(filter).sort(sort).skip(skip).limit(limit).select(select).exec(),
      User.countDocuments(filter),
    ]);

    return {
      data: users,
      pagination: {
        total: totalCount,
        page,
        limit,
        pages: Math.ceil(totalCount / limit),
      },
    };
  }

  async findById(id, select = '') {
    const user = await User.findById(id).select(select).exec();

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async findByEmail(email) {
    const user = await User.findOne({ email }).exec();
    return user;
  }

  async create(data) {
    // Kiểm tra email đã tồn tại chưa
    const existingUser = await this.findByEmail(data.email);

    if (existingUser) {
      throw new ApiError(409, 'Email already exists');
    }

    const user = new User(data);
    return await user.save();
  }

  async update(id, data) {
    // Nếu có cập nhật email, kiểm tra email đã tồn tại chưa
    if (data.email) {
      const existingUser = await User.findOne({ email: data.email, _id: { $ne: id } }).exec();

      if (existingUser) {
        throw new ApiError(409, 'Email already exists');
      }
    }

    const user = await User.findByIdAndUpdate(id, data, { new: true, runValidators: true });

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return user;
  }

  async delete(id) {
    const user = await User.findByIdAndDelete(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    return { success: true };
  }

  async updatePassword(id, newPassword) {
    const user = await User.findById(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    user.password = newPassword;
    return await user.save();
  }

  async findByResetToken(token) {
    return await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() },
    });
  }

  async findByVerificationToken(token) {
    return await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: Date.now() },
    });
  }

  async updateLoginStats(id) {
    return await User.findByIdAndUpdate(id, {
      $inc: { loginCount: 1 },
      lastLogin: Date.now(),
    });
  }
}

module.exports = new UserRepository();


--- File: server/src/migrations/config.js ---
/**
 * Cấu hình cho hệ thống migration
 */
const config = {
  // Collection để lưu trạng thái các migrations đã chạy
  migrationCollection: 'migrations',

  // Thư mục chứa các migration scripts
  scriptsDir: './scripts',

  // Môi trường chạy migrations
  environment: process.env.NODE_ENV || 'development',

  // Có bắt buộc migrations phải chạy theo thứ tự không
  requireSequential: true,

  // Logger cho migrations
  logger: console,
};

module.exports = config;


--- File: server/src/migrations/index.js ---
const migrationRunner = require('./migrationRunner');
const mongoose = require('mongoose');
const config = require('../config/environment');

/**
 * Lớp lỗi tùy chỉnh cho migrations
 */
class MigrationError extends Error {
  constructor(message, originalError = null) {
    super(message);
    this.name = 'MigrationError';
    this.originalError = originalError;
  }
}

/**
 * Đóng kết nối database
 */
const closeConnection = async () => {
  if (mongoose.connection.readyState !== 0) {
    console.log('Closing database connection...');
    await mongoose.connection.close();
  }
};

/**
 * Chạy migrations
 */
const runMigrations = async () => {
  try {
    // Kết nối database nếu chưa kết nối
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Running migrations...');
    await migrationRunner.migrate();

    console.log('Migrations completed successfully');
  } catch (error) {
    console.error('Error running migrations:', error);
    throw new MigrationError('Failed to run migrations', error);
  }
};

/**
 * Rollback migration gần nhất
 */
const rollbackMigration = async () => {
  try {
    // Kết nối database nếu chưa kết nối
    if (mongoose.connection.readyState === 0) {
      console.log('Connecting to database...');
      await mongoose.connect(config.database.uri, config.database.options);
    }

    console.log('Rolling back last migration...');
    await migrationRunner.rollback();

    console.log('Rollback completed successfully');
  } catch (error) {
    console.error('Error rolling back migration:', error);
    throw new MigrationError('Failed to rollback migration', error);
  }
};

// Xử lý arguments từ command line
const processArguments = async () => {
  const args = process.argv.slice(2);
  const command = args[0];

  try {
    switch (command) {
      case 'migrate':
        await runMigrations();
        break;
      case 'rollback':
        await rollbackMigration();
        break;
      default:
        console.log('Usage: node migrations [migrate|rollback]');
        return; // Thoát hàm mà không ném lỗi vì đây không phải lỗi thực sự
    }
  } catch (error) {
    // Xử lý lỗi ở cấp cao nhất
    console.error(`Migration command '${command}' failed:`, error);
    // Đặt mã thoát là 1 để chỉ ra lỗi
    process.exitCode = 1;
  } finally {
    // Đảm bảo đóng kết nối database trong mọi trường hợp
    await closeConnection();
  }
};

// Chỉ chạy nếu được gọi trực tiếp (không phải require)
if (require.main === module) {
  processArguments().catch((error) => {
    console.error('Unhandled error in migrations:', error);
    process.exitCode = 1;
  });
} else {
  // Export functions để có thể gọi từ module khác
  module.exports = {
    runMigrations,
    rollbackMigration,
    closeConnection, // Export thêm hàm đóng kết nối để module khác có thể sử dụng
  };
}


--- File: server/src/migrations/migrationFramework.js ---
// server/src/data/migrations/migrationFramework.js
const mongoose = require('mongoose');
const logger = require('../config/logger');

// Migration Model
const migrationSchema = new mongoose.Schema({
  version: {
    type: String,
    required: true,
    unique: true,
  },
  description: {
    type: String,
    required: true,
  },
  appliedAt: {
    type: Date,
    default: Date.now,
  },
});

const Migration = mongoose.model('Migration', migrationSchema);

// Migration Framework
class MigrationFramework {
  constructor() {
    this.migrations = [];
  }

  register(version, description, up, down) {
    this.migrations.push({
      version,
      description,
      up,
      down,
    });

    return this;
  }

  async migrate(targetVersion = null) {
    logger.info('Starting migrations...');

    try {
      // Sắp xếp migrations theo version
      this.migrations.sort((a, b) => {
        return a.version.localeCompare(b.version, undefined, { numeric: true });
      });

      // Lấy tất cả migrations đã được áp dụng
      const appliedMigrations = await Migration.find().sort({ version: 1 });
      const lastAppliedVersion = appliedMigrations.length
        ? appliedMigrations[appliedMigrations.length - 1].version
        : null;

      // Nếu không có targetVersion, dùng migration cuối cùng
      targetVersion = targetVersion || this.migrations[this.migrations.length - 1].version;

      if (lastAppliedVersion === targetVersion) {
        logger.info(`Database already at version ${targetVersion}`);
        return;
      }

      // Lấy danh sách các versions đã áp dụng
      const appliedVersions = appliedMigrations.map((m) => m.version);

      // Nếu downgrade
      if (
        lastAppliedVersion &&
        lastAppliedVersion.localeCompare(targetVersion, undefined, { numeric: true }) > 0
      ) {
        logger.info(`Downgrading from ${lastAppliedVersion} to ${targetVersion}`);

        // Lấy các migrations cần rollback
        const migrationsToRollback = this.migrations
          .filter(
            (m) =>
              m.version.localeCompare(targetVersion, undefined, { numeric: true }) > 0 &&
              appliedVersions.includes(m.version)
          )
          .reverse();

        // Áp dụng rollback
        for (const migration of migrationsToRollback) {
          logger.info(`Rolling back migration ${migration.version}: ${migration.description}`);
          await migration.down();
          await Migration.deleteOne({ version: migration.version });
        }

        logger.info(`Successfully downgraded to version ${targetVersion}`);
      }
      // Nếu upgrade
      else {
        logger.info(`Upgrading to version ${targetVersion}`);

        // Lấy các migrations cần áp dụng
        const migrationsToApply = this.migrations.filter(
          (m) =>
            !appliedVersions.includes(m.version) &&
            m.version.localeCompare(targetVersion, undefined, { numeric: true }) <= 0
        );

        // Áp dụng migrations
        for (const migration of migrationsToApply) {
          logger.info(`Applying migration ${migration.version}: ${migration.description}`);
          await migration.up();
          await Migration.create({
            version: migration.version,
            description: migration.description,
          });
        }

        logger.info(`Successfully upgraded to version ${targetVersion}`);
      }
    } catch (error) {
      logger.error('Migration failed', error);
      throw error;
    }
  }

  // Lấy version hiện tại
  async getCurrentVersion() {
    const lastMigration = await Migration.findOne().sort({ version: -1 });
    return lastMigration ? lastMigration.version : null;
  }
}

module.exports = { MigrationFramework, Migration };


--- File: server/src/migrations/migrationRunner.js ---
const mongoose = require('mongoose');
const fs = require('fs');
const path = require('path');
const config = require('./config');

/**
 * Lớp quản lý và chạy migrations
 */
class MigrationRunner {
  constructor() {
    this.db = mongoose.connection;
    this.migrationCollection = this.db.collection(config.migrationCollection);
    this.logger = config.logger;
  }

  /**
   * Lấy danh sách các migrations đã chạy
   * @returns {Promise<Array>} Danh sách migrations đã chạy
   */
  async getCompletedMigrations() {
    try {
      // Nếu collection không tồn tại, tạo mới
      const collections = await this.db.db
        .listCollections({ name: config.migrationCollection })
        .toArray();

      if (collections.length === 0) {
        await this.db.createCollection(config.migrationCollection);
        return [];
      }

      // Lấy danh sách migrations đã chạy
      const completedMigrations = await this.migrationCollection
        .find({})
        .sort({ timestamp: 1 })
        .toArray();
      return completedMigrations.map((migration) => migration.name);
    } catch (error) {
      this.logger.error('Error getting completed migrations:', error);
      throw error;
    }
  }

  /**
   * Đánh dấu một migration đã chạy thành công
   * @param {String} name - Tên migration
   * @returns {Promise<void>}
   */
  async markMigrationAsCompleted(name) {
    try {
      await this.migrationCollection.insertOne({
        name,
        timestamp: new Date(),
        environment: config.environment,
      });

      this.logger.info(`Migration ${name} marked as completed`);
    } catch (error) {
      this.logger.error(`Error marking migration ${name} as completed:`, error);
      throw error;
    }
  }

  /**
   * Lấy danh sách tất cả các migration scripts
   * @returns {Promise<Array>} Danh sách tên các migration scripts
   */
  async getAllMigrationScripts() {
    try {
      const scriptsDir = path.resolve(__dirname, config.scriptsDir);
      const files = fs.readdirSync(scriptsDir);

      // Lọc chỉ lấy các file JavaScript
      return files.filter((file) => file.endsWith('.js')).sort(); // Sắp xếp theo thứ tự tên file
    } catch (error) {
      this.logger.error('Error getting migration scripts:', error);
      throw error;
    }
  }

  /**
   * Lấy danh sách các migrations cần chạy
   * @returns {Promise<Array>} Danh sách tên các migrations cần chạy
   */
  async getPendingMigrations() {
    const completedMigrations = await this.getCompletedMigrations();
    const allMigrations = await this.getAllMigrationScripts();

    // Lọc các migrations chưa chạy
    return allMigrations.filter((migration) => !completedMigrations.includes(migration));
  }

  /**
   * Chạy một migration script
   * @param {String} scriptName - Tên file script
   * @returns {Promise<void>}
   */
  async runMigration(scriptName) {
    try {
      this.logger.info(`Running migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Chạy migration
      if (typeof migration.up !== 'function') {
        throw new Error(`Migration ${scriptName} does not have an 'up' function`);
      }

      await migration.up(this.db);

      // Đánh dấu migration đã hoàn thành
      await this.markMigrationAsCompleted(scriptName);

      this.logger.info(`Migration ${scriptName} completed successfully`);
    } catch (error) {
      this.logger.error(`Error running migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Rollback một migration
   * @param {String} scriptName - Tên file script
   * @returns {Promise<void>}
   */
  async rollbackMigration(scriptName) {
    try {
      this.logger.info(`Rolling back migration: ${scriptName}`);

      // Import migration script
      const scriptPath = path.resolve(__dirname, config.scriptsDir, scriptName);
      const migration = require(scriptPath);

      // Chạy rollback
      if (typeof migration.down !== 'function') {
        throw new Error(`Migration ${scriptName} does not have a 'down' function`);
      }

      await migration.down(this.db);

      // Xóa migration khỏi danh sách đã hoàn thành
      await this.migrationCollection.deleteOne({ name: scriptName });

      this.logger.info(`Migration ${scriptName} rolled back successfully`);
    } catch (error) {
      this.logger.error(`Error rolling back migration ${scriptName}:`, error);
      throw error;
    }
  }

  /**
   * Chạy tất cả các migrations chưa hoàn thành
   * @returns {Promise<void>}
   */
  async migrate() {
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info('No pending migrations to run');
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Chạy từng migration theo thứ tự
    for (const migration of pendingMigrations) {
      await this.runMigration(migration);
    }

    this.logger.info('All migrations completed successfully');
  }

  /**
   * Rollback migration cuối cùng đã chạy
   * @returns {Promise<void>}
   */
  async rollback() {
    const completedMigrations = await this.getCompletedMigrations();

    if (completedMigrations.length === 0) {
      this.logger.info('No migrations to roll back');
      return;
    }

    // Lấy migration cuối cùng
    const lastMigration = completedMigrations[completedMigrations.length - 1];

    await this.rollbackMigration(lastMigration);
  }
}

module.exports = new MigrationRunner();


--- File: server/src/migrations/scripts/001-initial-categories.js ---
/**
 * Migration: Tạo các danh mục sản phẩm ban đầu
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // Tạo collection categories nếu chưa tồn tại
    const collections = await db.db.listCollections({ name: 'categories' }).toArray();
    if (collections.length === 0) {
      await db.db.createCollection('categories');
    }

    const categories = db.collection('categories');

    // Danh sách các danh mục cơ bản
    const initialCategories = [
      {
        name: 'Gậy Billiard',
        slug: 'gay-billiard',
        description: 'Tất cả các loại gậy billiard chất lượng cao',
        parent: null,
        level: 0,
        order: 1,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Bi Billiard',
        slug: 'bi-billiard',
        description: 'Các bộ bi billiard tiêu chuẩn quốc tế',
        parent: null,
        level: 0,
        order: 2,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'Phụ Kiện',
        slug: 'phu-kien',
        description: 'Phụ kiện billiard chất lượng cao',
        parent: null,
        level: 0,
        order: 3,
        isActive: true,
        isVisible: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Chèn các danh mục vào database
    await categories.insertMany(initialCategories);
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const categories = db.collection('categories');

    // Xóa các danh mục đã tạo
    await categories.deleteMany({
      slug: { $in: ['gay-billiard', 'bi-billiard', 'phu-kien'] },
    });
  },
};


--- File: server/src/migrations/scripts/002-add-indexes.js ---
/**
 * Migration: Tạo các indexes cho database
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    // Index cho User collection
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
    await db.collection('users').createIndex({ role: 1 });

    // Index cho Product collection
    await db.collection('products').createIndex({ slug: 1 }, { unique: true });
    await db.collection('products').createIndex({ category: 1 });
    await db.collection('products').createIndex({ createdAt: -1 });
    await db.collection('products').createIndex({ price: 1 });

    // Text index cho tìm kiếm sản phẩm
    await db.collection('products').createIndex(
      { name: 'text', description: 'text' },
      {
        weights: {
          name: 10,
          description: 5,
        },
        default_language: 'none',
      }
    );

    // Index cho Category collection
    await db.collection('categories').createIndex({ slug: 1 }, { unique: true });
    await db.collection('categories').createIndex({ parent: 1 });

    // Index cho Order collection
    await db.collection('orders').createIndex({ orderNumber: 1 }, { unique: true });
    await db.collection('orders').createIndex({ user: 1 });
    await db.collection('orders').createIndex({ status: 1 });
    await db.collection('orders').createIndex({ createdAt: -1 });

    // Index cho Cart collection
    await db.collection('carts').createIndex({ user: 1 }, { sparse: true });
    await db.collection('carts').createIndex({ sessionId: 1 }, { sparse: true });

    // TTL index cho cart expiration
    await db.collection('carts').createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });

    // Index cho Review collection
    await db.collection('reviews').createIndex({ product: 1 });
    await db.collection('reviews').createIndex({ user: 1 });
    await db.collection('reviews').createIndex({ product: 1, createdAt: -1 });
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    // Drop indexes từ User collection
    await db.collection('users').dropIndex({ email: 1 });
    await db.collection('users').dropIndex({ role: 1 });

    // Drop indexes từ Product collection
    await db.collection('products').dropIndex({ slug: 1 });
    await db.collection('products').dropIndex({ category: 1 });
    await db.collection('products').dropIndex({ createdAt: -1 });
    await db.collection('products').dropIndex({ price: 1 });
    await db.collection('products').dropIndex('name_text_description_text');

    // Drop indexes từ Category collection
    await db.collection('categories').dropIndex({ slug: 1 });
    await db.collection('categories').dropIndex({ parent: 1 });

    // Drop indexes từ Order collection
    await db.collection('orders').dropIndex({ orderNumber: 1 });
    await db.collection('orders').dropIndex({ user: 1 });
    await db.collection('orders').dropIndex({ status: 1 });
    await db.collection('orders').dropIndex({ createdAt: -1 });

    // Drop indexes từ Cart collection
    await db.collection('carts').dropIndex({ user: 1 });
    await db.collection('carts').dropIndex({ sessionId: 1 });
    await db.collection('carts').dropIndex({ expiresAt: 1 });

    // Drop indexes từ Review collection
    await db.collection('reviews').dropIndex({ product: 1 });
    await db.collection('reviews').dropIndex({ user: 1 });
    await db.collection('reviews').dropIndex({ product: 1, createdAt: -1 });
  },
};


--- File: server/src/migrations/scripts/003-add-admin-user.js ---
const bcrypt = require('bcrypt');

/**
 * Migration: Tạo user admin mặc định
 */
module.exports = {
  /**
   * Chạy migration
   * @param {Object} db - MongoDB connection
   */
  up: async (db) => {
    const users = db.collection('users');

    // Kiểm tra xem đã có admin chưa
    const adminExists = await users.findOne({ role: 'admin' });

    if (!adminExists) {
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash('Admin@123', salt);

      // Tạo admin user
      await users.insertOne({
        name: 'Admin',
        email: 'admin@runout-biliard.com',
        password: hashedPassword,
        role: 'admin',
        isActive: true,
        emailVerified: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }
  },

  /**
   * Rollback migration
   * @param {Object} db - MongoDB connection
   */
  down: async (db) => {
    const users = db.collection('users');

    // Xóa admin user
    await users.deleteOne({ email: 'admin@runout-biliard.com' });
  },
};


--- File: server/src/seeds/data/carts.js ---
// server/src/seeds/data/carts.js

module.exports = [
  {
    user: 'nguyenvana@example.com', // email của user
    items: [
      {
        product: 'gay-billiard-pro-series-x1', // slug của sản phẩm
        quantity: 1,
        price: 1500000,
        addedAt: new Date('2023-05-10T08:30:15.123Z'),
      },
    ],
    subtotal: 1500000,
    status: 'active',
    createdAt: new Date('2023-05-10T08:30:15.123Z'),
    updatedAt: new Date('2023-05-10T08:30:15.123Z'),
    lastActivity: new Date('2023-05-10T08:30:15.123Z'),
  },
  {
    user: 'tranthib@example.com', // email của user
    items: [
      {
        product: 'bo-bi-a-pro-tournament', // slug của sản phẩm
        quantity: 1,
        price: 850000,
        addedAt: new Date('2023-05-12T10:15:30.456Z'),
      },
      {
        product: 'gay-billiard-pro-series-x1', // slug của sản phẩm
        quantity: 1,
        price: 1500000,
        addedAt: new Date('2023-05-12T10:20:45.789Z'),
      },
    ],
    subtotal: 2350000,
    coupon: {
      code: 'SUMMER10',
      discount: 235000,
      appliedAt: new Date('2023-05-12T10:25:10.123Z'),
    },
    status: 'active',
    createdAt: new Date('2023-05-12T10:15:30.456Z'),
    updatedAt: new Date('2023-05-12T10:25:10.123Z'),
    lastActivity: new Date('2023-05-12T10:25:10.123Z'),
  },
  {
    sessionId: 'sess_12345abcde67890fghijk',
    items: [
      {
        product: 'ban-billiard-champion-9ft', // slug của sản phẩm
        quantity: 1,
        price: 45000000,
        addedAt: new Date('2023-05-15T14:45:20.321Z'),
      },
    ],
    subtotal: 45000000,
    status: 'active',
    createdAt: new Date('2023-05-15T14:45:20.321Z'),
    updatedAt: new Date('2023-05-15T14:45:20.321Z'),
    lastActivity: new Date('2023-05-15T14:45:20.321Z'),
    expiresAt: new Date('2023-05-22T14:45:20.321Z'), // 7 ngày sau
  },
];


--- File: server/src/seeds/data/categories.js ---
// server/src/seeds/data/categories.js

module.exports = [
  {
    name: 'Gậy Billiard',
    slug: 'gay-billiard',
    description: 'Tất cả các loại gậy billiard chất lượng cao',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/gays-billiard.jpg',
      alt: 'Bộ sưu tập gậy billiard',
    },
    icon: 'cue-stick-icon',
    color: '#3498db',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'Gậy Billiard Chuyên Nghiệp',
    slug: 'gay-billiard-chuyen-nghiep',
    description: 'Gậy billiard dành cho người chơi chuyên nghiệp',
    level: 1,
    image: {
      url: '/assets/categories/gay-chuyen-nghiep.jpg',
      alt: 'Gậy billiard chuyên nghiệp',
    },
    icon: 'pro-cue-icon',
    color: '#2980b9',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: false,
  },
  {
    name: 'Bi-a',
    slug: 'bi-a',
    description: 'Các loại bi-a chính hãng',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/bi-a.jpg',
      alt: 'Bi-a các loại',
    },
    icon: 'ball-icon',
    color: '#e74c3c',
    order: 2,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'Phụ Kiện',
    slug: 'phu-kien',
    description: 'Phụ kiện cho các loại gậy và bàn billiard',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/phu-kien.jpg',
      alt: 'Phụ kiện billiard',
    },
    icon: 'accessories-icon',
    color: '#f39c12',
    order: 3,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
  {
    name: 'Bàn Billiard',
    slug: 'ban-billiard',
    description: 'Các loại bàn billiard nhập khẩu',
    parent: null,
    level: 0,
    image: {
      url: '/assets/categories/ban-billiard.jpg',
      alt: 'Bàn billiard',
    },
    icon: 'table-icon',
    color: '#27ae60',
    order: 4,
    isActive: true,
    isVisible: true,
    isFeatured: true,
  },
];


--- File: server/src/seeds/data/orders.js ---
// server/src/seeds/data/orders.js

module.exports = [
  {
    orderNumber: 'RO-2023-0001',
    customerInfo: {
      name: 'Nguyễn Văn A',
      email: 'nguyenvana@example.com',
      phone: '0901234567',
    },
    items: [
      {
        product: 'gay-billiard-pro-series-x1', // slug của sản phẩm
        name: 'Gậy Billiard Pro Series X1',
        price: 1500000,
        quantity: 1,
        totalPrice: 1500000,
        discount: 0,
      },
    ],
    subtotal: 1500000,
    shippingCost: 30000,
    tax: 0,
    discount: {
      amount: 100000,
      code: 'WELCOME10',
    },
    totalAmount: 1430000,
    shippingAddress: {
      name: 'Nguyễn Văn A',
      phone: '0901234567',
      street: '123 Nguyễn Huệ',
      city: 'Hồ Chí Minh',
      state: '',
      zipCode: '70000',
      country: 'Việt Nam',
      notes: 'Giao hàng vào buổi sáng',
    },
    shippingMethod: 'standard',
    paymentMethod: 'cod',
    paymentStatus: 'pending',
    status: 'processing',
    statusHistory: [
      {
        status: 'pending',
        date: new Date('2023-03-15T08:30:15.123Z'),
        note: 'Đơn hàng đã được tạo',
      },
      {
        status: 'processing',
        date: new Date('2023-03-15T09:45:30.456Z'),
        note: 'Đơn hàng đang được xử lý',
      },
    ],
    customerNotes: 'Vui lòng gọi trước khi giao hàng',
    createdAt: new Date('2023-03-15T08:30:15.123Z'),
    updatedAt: new Date('2023-03-15T09:45:30.456Z'),
  },
  {
    orderNumber: 'RO-2023-0002',
    customerInfo: {
      name: 'Trần Thị B',
      email: 'tranthib@example.com',
      phone: '0912345678',
    },
    items: [
      {
        product: 'bo-bi-a-pro-tournament', // slug của sản phẩm
        name: 'Bộ Bi-a Pro Tournament',
        price: 850000,
        quantity: 1,
        totalPrice: 850000,
        discount: 0,
      },
      {
        product: 'gay-billiard-pro-series-x1', // slug của sản phẩm
        name: 'Gậy Billiard Pro Series X1',
        price: 1500000,
        quantity: 1,
        totalPrice: 1500000,
        discount: 0,
      },
    ],
    subtotal: 2350000,
    shippingCost: 50000,
    tax: 0,
    totalAmount: 2400000,
    shippingAddress: {
      name: 'Trần Thị B',
      phone: '0912345678',
      street: '101 Lê Duẩn',
      city: 'Đà Nẵng',
      state: '',
      zipCode: '50000',
      country: 'Việt Nam',
    },
    shippingMethod: 'express',
    paymentMethod: 'bank_transfer',
    paymentStatus: 'paid',
    status: 'delivered',
    statusHistory: [
      {
        status: 'pending',
        date: new Date('2023-03-20T10:15:20.123Z'),
        note: 'Đơn hàng đã được tạo',
      },
      {
        status: 'processing',
        date: new Date('2023-03-20T11:30:45.456Z'),
        note: 'Đơn hàng đang được xử lý',
      },
      {
        status: 'shipped',
        date: new Date('2023-03-21T09:15:30.789Z'),
        note: 'Đơn hàng đã được giao cho đơn vị vận chuyển',
      },
      {
        status: 'delivered',
        date: new Date('2023-03-22T14:20:10.321Z'),
        note: 'Đơn hàng đã được giao thành công',
      },
    ],
    createdAt: new Date('2023-03-20T10:15:20.123Z'),
    updatedAt: new Date('2023-03-22T14:20:10.321Z'),
    completedAt: new Date('2023-03-22T14:20:10.321Z'),
  },
];


--- File: server/src/seeds/data/products.js ---
// server/src/seeds/data/products.js

module.exports = [
  {
    name: 'Gậy Billiard Pro Series X1',
    slug: 'gay-billiard-pro-series-x1',
    description: {
      short: 'Gậy billiard chuyên nghiệp với trọng lượng cân bằng hoàn hảo',
      long: 'Gậy billiard Pro Series X1 được thiết kế dành cho người chơi chuyên nghiệp, với thân gậy làm từ gỗ sồi cao cấp và đầu tip cứng. Sản phẩm mang lại độ chính xác và cảm giác tuyệt vời khi chơi.',
    },
    category: 'gay-billiard-chuyen-nghiep', // slug của danh mục
    brand: 'ProCue',
    manufacturer: 'Billiard Master',
    countryOfOrigin: 'USA',
    price: 1500000,
    stock: 15,
    sku: 'PC-X1-001',
    images: [
      {
        url: '/assets/products/pc-x1-001-main.jpg',
        alt: 'Gậy Billiard Pro Series X1 - Hình chính',
        isPrimary: true,
      },
      {
        url: '/assets/products/pc-x1-001-angle.jpg',
        alt: 'Gậy Billiard Pro Series X1 - Góc nhìn khác',
        isPrimary: false,
      },
    ],
    features: [
      'Thân gậy làm từ gỗ sồi cao cấp',
      'Đầu tip cứng độ bền cao',
      'Trọng lượng cân bằng hoàn hảo',
      'Tay cầm chống trượt',
    ],
    specifications: {
      weight: 567,
      length: 147,
      diameter: 13,
      material: 'Gỗ sồi',
      tipSize: '13mm',
      wrap: 'Irish linen',
    },
    isActive: true,
    isPromoted: true,
    isFeatured: true,
  },
  {
    name: 'Bộ Bi-a Pro Tournament',
    slug: 'bo-bi-a-pro-tournament',
    description: {
      short: 'Bộ bi-a tiêu chuẩn giải đấu chuyên nghiệp',
      long: 'Bộ bi-a Pro Tournament được sản xuất với độ chính xác cao, đạt tiêu chuẩn giải đấu quốc tế. Các viên bi được làm từ nhựa phenolic chất lượng cao, đảm bảo độ bền và độ chính xác trong mọi pha chơi.',
    },
    category: 'bi-a', // slug của danh mục
    brand: 'ProGame',
    manufacturer: 'Aramith',
    countryOfOrigin: 'Belgium',
    price: 850000,
    stock: 10,
    sku: 'PB-T1-001',
    images: [
      {
        url: '/assets/products/pb-t1-001-main.jpg',
        alt: 'Bộ Bi-a Pro Tournament - Hình chính',
        isPrimary: true,
      },
    ],
    features: [
      'Tiêu chuẩn giải đấu quốc tế',
      'Làm từ nhựa phenolic cao cấp',
      'Độ chính xác cao',
      'Bao gồm 16 viên bi',
    ],
    specifications: {
      material: 'Phenolic resin',
      weight: 170,
      diameter: 57.2,
      set: '16 balls',
    },
    isActive: true,
    isPromoted: true,
    isFeatured: false,
  },
  {
    name: 'Bàn Billiard Champion 9ft',
    slug: 'ban-billiard-champion-9ft',
    description: {
      short: 'Bàn billiard cao cấp 9ft dành cho các câu lạc bộ chuyên nghiệp',
      long: 'Bàn Billiard Champion 9ft được thiết kế dành cho các câu lạc bộ và giải đấu chuyên nghiệp. Bàn được làm từ gỗ sồi Mỹ cao cấp, khung bàn vững chắc và mặt bàn được phủ vải wool-nylon blend cao cấp đảm bảo độ bền và cảm giác chơi tuyệt vời.',
    },
    category: 'ban-billiard', // slug của danh mục
    brand: 'Champion',
    manufacturer: 'Billiard Master',
    countryOfOrigin: 'USA',
    price: 45000000,
    stock: 3,
    sku: 'BT-C9-001',
    images: [
      {
        url: '/assets/products/bt-c9-001-main.jpg',
        alt: 'Bàn Billiard Champion 9ft - Hình chính',
        isPrimary: true,
      },
      {
        url: '/assets/products/bt-c9-001-angle.jpg',
        alt: 'Bàn Billiard Champion 9ft - Góc nhìn khác',
        isPrimary: false,
      },
    ],
    features: [
      'Kích thước chuẩn 9ft',
      'Làm từ gỗ sồi Mỹ cao cấp',
      'Mặt bàn phủ vải wool-nylon blend',
      'Khung bàn vững chắc',
    ],
    specifications: {
      length: 274,
      width: 137,
      height: 79,
      frameType: '1-piece slate',
      clothType: 'Championship wool-nylon blend',
      railCushions: 'K-66 profile',
    },
    isActive: true,
    isPromoted: false,
    isFeatured: true,
  },
];


--- File: server/src/seeds/data/reviews.js ---
// server/src/seeds/data/reviews.js

module.exports = [
  {
    product: 'gay-billiard-pro-series-x1', // slug của sản phẩm
    user: 'nguyenvana@example.com', // email của user
    rating: 5,
    title: 'Sản phẩm tuyệt vời, đáng đồng tiền',
    review:
      'Gậy billiard Pro Series X1 có chất lượng rất tốt, cân bằng hoàn hảo và cho cảm giác rất thoải mái khi chơi. Tôi đặc biệt thích chất liệu gỗ sồi cao cấp và đầu tip cứng. Sau khi sử dụng, tôi cảm thấy kỹ năng chơi của mình cũng được cải thiện đáng kể. Rất hài lòng với sản phẩm này!',
    images: [
      {
        url: '/assets/reviews/review-1-1.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-1-1.jpg',
        caption: 'Gậy billiard sau 2 tuần sử dụng',
      },
    ],
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 12,
      downvotes: 1,
    },
    isVisible: true,
    createdAt: new Date('2023-03-25T10:15:20.123Z'),
    updatedAt: new Date('2023-03-25T10:15:20.123Z'),
  },
  {
    product: 'bo-bi-a-pro-tournament', // slug của sản phẩm
    user: 'tranthib@example.com', // email của user
    rating: 4,
    title: 'Bộ bi-a chất lượng tốt',
    review:
      'Bộ bi-a Pro Tournament có chất lượng rất tốt, đúng như mô tả. Các viên bi có trọng lượng cân đối, màu sắc tươi sáng. Tuy nhiên, hộp đựng không được chắc chắn lắm nên chỉ đánh giá 4 sao.',
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 8,
      downvotes: 0,
    },
    isVisible: true,
    createdAt: new Date('2023-03-28T15:45:30.456Z'),
    updatedAt: new Date('2023-03-28T15:45:30.456Z'),
  },
  {
    product: 'ban-billiard-champion-9ft', // slug của sản phẩm
    user: 'levanc@example.com', // email của user
    rating: 5,
    title: 'Bàn billiard đẳng cấp chuyên nghiệp',
    review:
      'Bàn billiard Champion 9ft thực sự xứng đáng với giá tiền. Mặt bàn cực kỳ phẳng, viên bi lăn rất mượt mà và chính xác. Khung bàn vững chắc, thiết kế sang trọng và đẳng cấp. Tôi đã mua cho câu lạc bộ của mình và tất cả các thành viên đều rất hài lòng với sản phẩm này.',
    images: [
      {
        url: '/assets/reviews/review-3-1.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-3-1.jpg',
        caption: 'Bàn billiard trong câu lạc bộ của tôi',
      },
      {
        url: '/assets/reviews/review-3-2.jpg',
        thumbnail: '/assets/reviews/thumbnails/review-3-2.jpg',
        caption: 'Chi tiết góc bàn',
      },
    ],
    isVerifiedPurchase: true,
    helpfulness: {
      upvotes: 20,
      downvotes: 0,
    },
    isVisible: true,
    createdAt: new Date('2023-04-05T09:30:15.789Z'),
    updatedAt: new Date('2023-04-05T09:30:15.789Z'),
  },
];


--- File: server/src/seeds/data/users.js ---
// server/src/seeds/data/users.js

module.exports = [
  {
    name: 'Admin User',
    email: 'admin@runout-biliard.com',
    password: 'Admin@123', // Sẽ được hash trước khi lưu vào database
    role: 'admin',
    phone: '0901234567',
    address: {
      street: '123 Nguyễn Huệ',
      city: 'Hồ Chí Minh',
      state: '',
      zipCode: '70000',
      country: 'Việt Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Staff User',
    email: 'staff@runout-biliard.com',
    password: 'Staff@123',
    role: 'staff',
    phone: '0909876543',
    address: {
      street: '456 Lê Lợi',
      city: 'Hồ Chí Minh',
      state: '',
      zipCode: '70000',
      country: 'Việt Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Nguyễn Văn A',
    email: 'nguyenvana@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0901234567',
    address: {
      street: '789 Trần Hưng Đạo',
      city: 'Hà Nội',
      state: '',
      zipCode: '10000',
      country: 'Việt Nam',
    },
    isActive: true,
    emailVerified: true,
  },
  {
    name: 'Trần Thị B',
    email: 'tranthib@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0912345678',
    address: {
      street: '101 Lê Duẩn',
      city: 'Đà Nẵng',
      state: '',
      zipCode: '50000',
      country: 'Việt Nam',
    },
    isActive: true,
    emailVerified: false,
  },
  {
    name: 'Lê Văn C',
    email: 'levanc@example.com',
    password: 'User@123',
    role: 'user',
    phone: '0923456789',
    address: {
      street: '202 Nguyễn Văn Linh',
      city: 'Cần Thơ',
      state: '',
      zipCode: '90000',
      country: 'Việt Nam',
    },
    isActive: true,
    emailVerified: true,
  },
];


--- File: server/src/seeds/index.js ---
// server/src/data/seeds/index.js
const { seedUsers } = require('./scripts/userSeeder');
const { seedCategories } = require('./scripts/categorySeeder');
const { seedProducts } = require('./scripts/productSeeder');
const { seedOrders } = require('./scripts/orderSeeder');
const { seedReviews } = require('./scripts/reviewSeeder');
const { seedCarts } = require('./scripts/cartSeeder');
const logger = require('../config/logger');

const runSeeds = async () => {
  try {
    logger.info('Starting database seeding...');

    // Thứ tự chạy seed quan trọng do các dependencies
    await seedUsers();
    await seedCategories();
    await seedProducts();
    await seedOrders();
    await seedReviews();
    await seedCarts();

    logger.info('All database seeding completed successfully');
  } catch (error) {
    logger.error('Error running seeds', error);
    throw error;
  }
};

module.exports = { runSeeds };


--- File: server/src/seeds/runner.js ---
// server/src/seeds/runner.js
const User = require('../data/models/user.model');
const Category = require('../data/models/category.model');
const Product = require('../data/models/product.model');
const Order = require('../data/models/order.model');
const Review = require('../data/models/review.model');

const users = require('./data/users');
const categories = require('./data/categories');
const products = require('./data/products');
const orders = require('./data/orders');
const reviews = require('./data/reviews');

class SeedRunner {
  async run(environment = 'development') {
    try {
      console.log(`Seeding database for ${environment} environment...`);

      // Xóa dữ liệu cũ (chỉ trong môi trường development và testing)
      if (['development', 'testing'].includes(environment)) {
        await this.clearDatabase();
      }

      // Seed các collections
      const createdUsers = await this.seedUsers();
      const createdCategories = await this.seedCategories();

      // Seed products với references đến categories
      const productData = this.prepareProducts(createdCategories);
      const createdProducts = await this.seedProducts(productData);

      // Seed orders và reviews với references đến users và products
      await this.seedOrders(createdUsers, createdProducts);
      await this.seedReviews(createdUsers, createdProducts);

      console.log('Seeding completed successfully.');
    } catch (error) {
      console.error('Seeding failed:', error);
      throw error;
    }
  }

  async clearDatabase() {
    console.log('Clearing database...');
    await User.deleteMany({});
    await Category.deleteMany({});
    await Product.deleteMany({});
    await Order.deleteMany({});
    await Review.deleteMany({});
  }

  async seedUsers() {
    console.log('Seeding users...');
    return await User.insertMany(users);
  }

  async seedCategories() {
    console.log('Seeding categories...');
    return await Category.insertMany(categories);
  }

  prepareProducts(createdCategories) {
    console.log('Preparing product data with category references...');
    // Gán category ID thực tế cho mỗi sản phẩm
    return products.map((product) => {
      // Tìm category tương ứng dựa trên tên hoặc slug
      const category = createdCategories.find(
        (cat) => cat.name === product.categoryName || cat.slug === product.categorySlug
      );

      // Nếu tìm thấy category, gán ID của category đó cho sản phẩm
      if (category) {
        return {
          ...product,
          category: category._id,
          // Xóa các trường tạm không cần thiết
          categoryName: undefined,
          categorySlug: undefined,
        };
      }

      return product;
    });
  }

  async seedProducts(productData) {
    console.log('Seeding products...');
    return await Product.insertMany(productData);
  }

  async seedOrders(createdUsers, createdProducts) {
    console.log('Seeding orders...');

    // Chuẩn bị dữ liệu đơn hàng với references đến users và products
    const preparedOrders = orders
      .map((order) => {
        // Tìm user tương ứng
        const user = createdUsers.find((u) => u.email === order.userEmail);

        // Chuẩn bị các item trong đơn hàng
        const items = order.items
          .map((item) => {
            // Tìm product tương ứng
            const product = createdProducts.find((p) => p.sku === item.productSku);

            return {
              product: product ? product._id : null,
              quantity: item.quantity,
              price: item.price,
            };
          })
          .filter((item) => item.product !== null);

        return {
          user: user ? user._id : null,
          items: items,
          totalAmount: order.totalAmount,
          status: order.status,
          shippingAddress: order.shippingAddress,
          paymentMethod: order.paymentMethod,
          createdAt: order.createdAt || new Date(),
        };
      })
      .filter((order) => order.user !== null && order.items.length > 0);

    return await Order.insertMany(preparedOrders);
  }

  async seedReviews(createdUsers, createdProducts) {
    console.log('Seeding reviews...');

    // Chuẩn bị dữ liệu đánh giá với references đến users và products
    const preparedReviews = reviews
      .map((review) => {
        // Tìm user và product tương ứng
        const user = createdUsers.find((u) => u.email === review.userEmail);
        const product = createdProducts.find((p) => p.sku === review.productSku);

        if (user && product) {
          return {
            user: user._id,
            product: product._id,
            rating: review.rating,
            comment: review.comment,
            createdAt: review.createdAt || new Date(),
          };
        }
        return null;
      })
      .filter((review) => review !== null);

    return await Review.insertMany(preparedReviews);
  }
}

module.exports = new SeedRunner();


--- File: server/src/seeds/scripts/cartSeeder.js ---
// server/src/data/seeds/cartSeeds.js
const Cart = require('../data/carts');
const User = require('../data/users');
const Product = require('../data/products');
const logger = require('../../config/logger');

const seedCarts = async () => {
  try {
    // Kiểm tra xem đã có carts trong DB chưa
    const count = await Cart.countDocuments();
    if (count > 0) {
      logger.info('Carts collection already seeded');
      return;
    }

    // Lấy một số users và products để tạo carts
    const users = await User.find().limit(5);
    const products = await Product.find().limit(10);

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed carts: No users or products found');
      return;
    }

    const carts = [];

    // Tạo một giỏ hàng cho mỗi user
    for (const user of users) {
      // Tạo 1-4 items cho mỗi giỏ hàng
      const itemCount = Math.floor(Math.random() * 4) + 1;
      const items = [];
      let subtotal = 0;

      for (let i = 0; i < itemCount; i++) {
        const product = products[Math.floor(Math.random() * products.length)];
        const quantity = Math.floor(Math.random() * 3) + 1;
        const price = product.price;

        items.push({
          product: product._id,
          quantity,
          price,
          attributes: {},
          addedAt: new Date(),
          updatedAt: new Date(),
        });

        subtotal += price * quantity;
      }

      const now = new Date();

      carts.push({
        user: user._id,
        items,
        subtotal,
        status: 'active',
        createdAt: now,
        updatedAt: now,
        lastActivity: now,
      });
    }

    // Tạo một số giỏ hàng cho khách vãng lai
    for (let i = 0; i < 3; i++) {
      const itemCount = Math.floor(Math.random() * 3) + 1;
      const items = [];
      let subtotal = 0;

      for (let j = 0; j < itemCount; j++) {
        const product = products[Math.floor(Math.random() * products.length)];
        const quantity = Math.floor(Math.random() * 2) + 1;
        const price = product.price;

        items.push({
          product: product._id,
          quantity,
          price,
          attributes: {},
          addedAt: new Date(),
          updatedAt: new Date(),
        });

        subtotal += price * quantity;
      }

      const now = new Date();
      const expiryDate = new Date();
      expiryDate.setDate(now.getDate() + 7); // 7 ngày hết hạn

      carts.push({
        sessionId: `sess_guest_${i}_${Date.now()}`,
        items,
        subtotal,
        status: 'active',
        createdAt: now,
        updatedAt: now,
        lastActivity: now,
        expiresAt: expiryDate,
      });
    }

    // Lưu vào database
    await Cart.insertMany(carts);
    logger.info(`Seeded ${carts.length} carts`);
  } catch (error) {
    logger.error('Error seeding carts', error);
    throw error;
  }
};

module.exports = { seedCarts };


--- File: server/src/seeds/scripts/categorySeeder.js ---
/**
 * Category Seeder
 * 
 * File này tạo dữ liệu mẫu cho các danh mục sản phẩm trong cửa hàng billiard
 * Bao gồm cả danh mục chính và danh mục con
 * File categorySeeder.js này thực hiện các chức năng sau:

Định nghĩa dữ liệu mẫu cho các danh mục chính và danh mục con
Tạo slugs tự động cho các danh mục dựa trên tên
Thiết lập mối quan hệ phân cấp giữa danh mục chính và danh mục con
Kiểm tra xem danh mục đã tồn tại trước khi seed để tránh trùng lặp
Ghi log quá trình seed để dễ dàng debug
 */
// const mongoose = require('mongoose');
const Category = require('../../data/models/category.model');
const { slugify } = require('../../common/utils/formatters');
const logger = require('../../config/logger');

/**
 * Dữ liệu mẫu cho danh mục chính
 */
const mainCategories = [
  {
    name: 'Gậy Billiard',
    description:
      'Tất cả các loại gậy billiard chất lượng cao từ các thương hiệu uy tín trong và ngoài nước',
    image: {
      url: '/images/categories/gay-billiard.jpg',
      alt: 'Gậy Billiard',
    },
    icon: 'cue-stick-icon',
    color: '#3498db',
    order: 1,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'Gậy Billiard Chất Lượng Cao | RunOut-Biliard',
      metaDescription:
        'Khám phá bộ sưu tập gậy billiard chất lượng cao cho người chơi ở mọi trình độ tại RunOut-Biliard',
      keywords: ['gậy billiard', 'gậy bida', 'cơ bida', 'gậy chơi bida'],
    },
    filters: [
      {
        name: 'Chất liệu',
        type: 'select',
        options: ['Gỗ sồi', 'Gỗ thích', 'Gỗ maple', 'Composit'],
      },
      {
        name: 'Trọng lượng',
        type: 'range',
        min: 400,
        max: 700,
        unit: 'g',
      },
    ],
  },
  {
    name: 'Bi Billiard',
    description: 'Các bộ bi billiard tiêu chuẩn quốc tế, phù hợp cho mọi loại hình chơi',
    image: {
      url: '/images/categories/bi-billiard.jpg',
      alt: 'Bi Billiard',
    },
    icon: 'billiard-ball-icon',
    color: '#e74c3c',
    order: 2,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'Bi Billiard Chính Hãng | RunOut-Biliard',
      metaDescription:
        'Bộ sưu tập bi billiard chất lượng cao, đạt tiêu chuẩn quốc tế cho các giải đấu chuyên nghiệp',
      keywords: ['bi billiard', 'bi bida', 'bộ bi bida', 'bi lỗ', 'bi carom'],
    },
  },
  {
    name: 'Phụ Kiện',
    description: 'Các phụ kiện billiard chất lượng cao, từ phấn, găng tay đến túi đựng gậy',
    image: {
      url: '/images/categories/phu-kien.jpg',
      alt: 'Phụ Kiện Billiard',
    },
    icon: 'billiard-accessories-icon',
    color: '#2ecc71',
    order: 3,
    isActive: true,
    isVisible: true,
    isFeatured: false,
    seo: {
      metaTitle: 'Phụ Kiện Billiard | RunOut-Biliard',
      metaDescription:
        'Đa dạng phụ kiện billiard chất lượng cao giúp nâng cao trải nghiệm chơi bida của bạn',
      keywords: ['phụ kiện billiard', 'phấn bida', 'găng tay bida', 'túi đựng gậy'],
    },
  },
  {
    name: 'Bàn Billiard',
    description: 'Các loại bàn billiard cao cấp cho gia đình và kinh doanh',
    image: {
      url: '/images/categories/ban-billiard.jpg',
      alt: 'Bàn Billiard',
    },
    icon: 'billiard-table-icon',
    color: '#9b59b6',
    order: 4,
    isActive: true,
    isVisible: true,
    isFeatured: true,
    seo: {
      metaTitle: 'Bàn Billiard Chất Lượng Cao | RunOut-Biliard',
      metaDescription:
        'Bàn billiard chất lượng cao, đa dạng kích thước và thiết kế cho gia đình và kinh doanh',
      keywords: ['bàn billiard', 'bàn bida', 'bàn bi-a', 'bàn pool', 'bàn carom'],
    },
  },
];

/**
 * Dữ liệu mẫu cho danh mục con
 * Mỗi item trong mảng đại diện cho một danh mục con của một danh mục chính
 * parentName: tên của danh mục cha
 */
const subCategories = [
  // Danh mục con của "Gậy Billiard"
  {
    name: 'Gậy Billiard Cao Cấp',
    description: 'Các loại gậy billiard cao cấp dành cho người chơi chuyên nghiệp',
    parentName: 'Gậy Billiard',
    image: {
      url: '/images/categories/gay-billiard-cao-cap.jpg',
      alt: 'Gậy Billiard Cao Cấp',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Gậy Billiard Phổ Thông',
    description: 'Các loại gậy billiard giá cả phải chăng cho người mới chơi',
    parentName: 'Gậy Billiard',
    image: {
      url: '/images/categories/gay-billiard-pho-thong.jpg',
      alt: 'Gậy Billiard Phổ Thông',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Gậy Billiard Thi Đấu',
    description: 'Các loại gậy billiard chuyên dụng cho thi đấu',
    parentName: 'Gậy Billiard',
    image: {
      url: '/images/categories/gay-billiard-thi-dau.jpg',
      alt: 'Gậy Billiard Thi Đấu',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh mục con của "Bi Billiard"
  {
    name: 'Bi Pool',
    description: 'Bộ bi dành cho billiard lỗ (Pool)',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-pool.jpg',
      alt: 'Bi Pool',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bi Carom',
    description: 'Bộ bi dành cho billiard không lỗ (Carom)',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-carom.jpg',
      alt: 'Bi Carom',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bi Snooker',
    description: 'Bộ bi dành cho billiard snooker',
    parentName: 'Bi Billiard',
    image: {
      url: '/images/categories/bi-snooker.jpg',
      alt: 'Bi Snooker',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh mục con của "Phụ Kiện"
  {
    name: 'Phấn Billiard',
    description: 'Các loại phấn billiard chất lượng cao',
    parentName: 'Phụ Kiện',
    image: {
      url: '/images/categories/phan-billiard.jpg',
      alt: 'Phấn Billiard',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Găng Tay',
    description: 'Găng tay billiard giúp tăng độ chính xác',
    parentName: 'Phụ Kiện',
    image: {
      url: '/images/categories/gang-tay.jpg',
      alt: 'Găng Tay Billiard',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Túi Đựng Gậy',
    description: 'Các loại túi đựng gậy billiard đa dạng kích thước',
    parentName: 'Phụ Kiện',
    image: {
      url: '/images/categories/tui-dung-gay.jpg',
      alt: 'Túi Đựng Gậy Billiard',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },

  // Danh mục con của "Bàn Billiard"
  {
    name: 'Bàn Pool',
    description: 'Bàn billiard lỗ tiêu chuẩn quốc tế',
    parentName: 'Bàn Billiard',
    image: {
      url: '/images/categories/ban-pool.jpg',
      alt: 'Bàn Pool',
    },
    order: 1,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bàn Carom',
    description: 'Bàn billiard không lỗ chuyên nghiệp',
    parentName: 'Bàn Billiard',
    image: {
      url: '/images/categories/ban-carom.jpg',
      alt: 'Bàn Carom',
    },
    order: 2,
    isActive: true,
    isVisible: true,
  },
  {
    name: 'Bàn Snooker',
    description: 'Bàn billiard snooker đạt tiêu chuẩn thi đấu',
    parentName: 'Bàn Billiard',
    image: {
      url: '/images/categories/ban-snooker.jpg',
      alt: 'Bàn Snooker',
    },
    order: 3,
    isActive: true,
    isVisible: true,
  },
];

/**
 * Hàm seed danh mục chính
 */
const seedMainCategories = async () => {
  logger.info('Seeding main categories...');

  try {
    // Xóa tất cả danh mục hiện có nếu cần thiết
    // await Category.deleteMany({});

    // Thêm trường slug và timestamps cho mỗi danh mục
    const mainCategoriesWithSlug = mainCategories.map((category) => ({
      ...category,
      slug: slugify(category.name),
      ancestors: [],
      level: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
    }));

    // Chèn danh mục vào database
    await Category.insertMany(mainCategoriesWithSlug);

    logger.info(`Seeded ${mainCategoriesWithSlug.length} main categories successfully!`);
    return mainCategoriesWithSlug;
  } catch (error) {
    logger.error('Error seeding main categories:', error);
    throw error;
  }
};

/**
 * Hàm seed danh mục con
 */
const seedSubCategories = async (mainCategoriesData) => {
  logger.info('Seeding sub categories...');

  try {
    // Chuẩn bị danh mục con với slug, parent, ancestors và level
    const subcategoriesWithDetails = [];

    for (const subCategory of subCategories) {
      // Tìm danh mục cha tương ứng
      const parent = mainCategoriesData.find((cat) => cat.name === subCategory.parentName);

      if (!parent) {
        logger.warn(
          `Parent category "${subCategory.parentName}" not found for "${subCategory.name}"`
        );
        continue;
      }

      // Chuẩn bị thông tin danh mục con
      const subCategoryWithDetails = {
        ...subCategory,
        slug: slugify(subCategory.name),
        parent: parent._id,
        ancestors: [
          {
            _id: parent._id,
            name: parent.name,
            slug: parent.slug,
          },
        ],
        level: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // Loại bỏ trường parentName vì không cần thiết nữa
      delete subCategoryWithDetails.parentName;

      subcategoriesWithDetails.push(subCategoryWithDetails);
    }

    // Chèn danh mục con vào database
    await Category.insertMany(subcategoriesWithDetails);

    logger.info(`Seeded ${subcategoriesWithDetails.length} sub categories successfully!`);
  } catch (error) {
    logger.error('Error seeding sub categories:', error);
    throw error;
  }
};

/**
 * Hàm chính để seed tất cả danh mục
 */
const seedCategories = async () => {
  try {
    logger.info('Starting category seeding process...');

    // Kiểm tra xem đã có danh mục nào chưa
    const existingCategories = await Category.countDocuments();

    if (existingCategories > 0) {
      logger.info(`Found ${existingCategories} existing categories. Skipping seeding process.`);
      return;
    }

    // Seed danh mục chính trước
    const mainCategoriesData = await seedMainCategories();

    // Seed danh mục con sau khi đã có danh mục chính
    await seedSubCategories(mainCategoriesData);

    logger.info('Category seeding completed successfully!');
  } catch (error) {
    logger.error('Category seeding failed:', error);
    throw error;
  }
};

module.exports = seedCategories;
/**
 * Chạy script này để seed danh mục vào database
 * Sử dụng lệnh: node src/seeds/scripts/categorySeeder.js
 * Đảm bảo đã kết nối với MongoDB trước khi chạy script này
 */


--- File: server/src/seeds/scripts/orderSeeder.js ---
// server/src/data/seeds/orderSeeds.js
// const mongoose = require('mongoose');
const Order = require('../data/orders');
const User = require('../data/users');
const Product = require('../data/products');
const logger = require('../../config/logger');

const seedOrders = async () => {
  try {
    // Kiểm tra xem đã có orders trong DB chưa
    const count = await Order.countDocuments();
    if (count > 0) {
      logger.info('Orders collection already seeded');
      return;
    }

    // Lấy một số users và products để tạo orders
    const users = await User.find().limit(5);
    const products = await Product.find().limit(10);

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed orders: No users or products found');
      return;
    }

    const orders = [];

    // Tạo một số orders mẫu
    for (let i = 0; i < users.length; i++) {
      const user = users[i];
      // Tạo 1-3 orders cho mỗi user
      const orderCount = Math.floor(Math.random() * 3) + 1;

      for (let j = 0; j < orderCount; j++) {
        // Tạo items cho order
        const itemCount = Math.floor(Math.random() * 3) + 1;
        const items = [];
        let subtotal = 0;

        for (let k = 0; k < itemCount; k++) {
          const product = products[Math.floor(Math.random() * products.length)];
          const quantity = Math.floor(Math.random() * 3) + 1;
          const price = product.price;
          const totalPrice = price * quantity;

          items.push({
            product: product._id,
            name: product.name,
            price,
            quantity,
            totalPrice,
            attributes: {},
            sku: `SKU-${product._id.toString().substr(-6)}`,
            image: product.images && product.images.length > 0 ? product.images[0].url : '',
          });

          subtotal += totalPrice;
        }

        const shippingCost = 30000;
        const totalAmount = subtotal + shippingCost;

        const statuses = ['pending', 'processing', 'shipped', 'delivered'];
        const status = statuses[Math.floor(Math.random() * statuses.length)];

        const createdAt = new Date();
        createdAt.setDate(createdAt.getDate() - Math.floor(Math.random() * 30));

        orders.push({
          orderNumber: `RO-${2025}-${String(i * 3 + j + 1).padStart(4, '0')}`,
          user: user._id,
          customerInfo: {
            name: user.name,
            email: user.email,
            phone: user.phone || '0901234567',
          },
          items,
          subtotal,
          shippingCost,
          tax: 0,
          totalAmount,
          shippingAddress: {
            name: user.name,
            phone: user.phone || '0901234567',
            street: user.address?.street || '123 Nguyễn Huệ',
            city: user.address?.city || 'Hồ Chí Minh',
            state: user.address?.state || '',
            zipCode: user.address?.zipCode || '70000',
            country: user.address?.country || 'Việt Nam',
          },
          shippingMethod: 'standard',
          paymentMethod: 'cod',
          paymentStatus: status === 'delivered' ? 'paid' : 'pending',
          status,
          statusHistory: [
            {
              status: 'pending',
              date: createdAt,
              note: 'Đơn hàng đã được tạo',
            },
            ...(status !== 'pending'
              ? [
                  {
                    status: 'processing',
                    date: new Date(createdAt.getTime() + 86400000),
                    note: 'Đơn hàng đang được xử lý',
                  },
                ]
              : []),
            ...(status === 'shipped' || status === 'delivered'
              ? [
                  {
                    status: 'shipped',
                    date: new Date(createdAt.getTime() + 86400000 * 2),
                    note: 'Đơn hàng đã được giao cho đơn vị vận chuyển',
                  },
                ]
              : []),
            ...(status === 'delivered'
              ? [
                  {
                    status: 'delivered',
                    date: new Date(createdAt.getTime() + 86400000 * 4),
                    note: 'Đơn hàng đã được giao thành công',
                  },
                ]
              : []),
          ],
          createdAt,
          updatedAt: createdAt,
          ...(status === 'delivered'
            ? { completedAt: new Date(createdAt.getTime() + 86400000 * 4) }
            : {}),
        });
      }
    }

    // Lưu vào database
    await Order.insertMany(orders);
    logger.info(`Seeded ${orders.length} orders`);
  } catch (error) {
    logger.error('Error seeding orders', error);
    throw error;
  }
};

module.exports = { seedOrders };


--- File: server/src/seeds/scripts/productSeeder.js ---
// server/src/seeds/productSeeder.js

const Product = require('../data/products');
const Category = require('../data/categories');
// const mongoose = require('mongoose');

async function seedProducts() {
  console.log('Seeding products...');

  // Xóa tất cả sản phẩm hiện có (chỉ dùng trong development)
  if (process.env.NODE_ENV !== 'production') {
    await Product.deleteMany({});
  }

  // Lấy ID các danh mục
  const gayChuyenNghiepCategory = await Category.findOne({ slug: 'gay-billiard-chuyen-nghiep' });
  const gayPhoThongCategory = await Category.findOne({ slug: 'gay-billiard-pho-thong' });
  const biCategory = await Category.findOne({ slug: 'bi-billiard' });

  if (!gayChuyenNghiepCategory || !gayPhoThongCategory || !biCategory) {
    console.error('Categories not found. Please run category seeder first.');
    return;
  }

  // Tạo sản phẩm mẫu
  const sampleProducts = [
    {
      name: 'Gậy Billiard Pro Series X1',
      slug: 'gay-billiard-pro-series-x1',
      description: {
        short: 'Gậy billiard chuyên nghiệp với trọng lượng cân bằng hoàn hảo',
        long: 'Gậy billiard Pro Series X1 được thiết kế dành cho người chơi chuyên nghiệp, với thân gậy làm từ gỗ sồi cao cấp và đầu tip cứng. Sản phẩm mang lại độ chính xác và cảm giác tuyệt vời khi chơi.',
      },
      category: gayChuyenNghiepCategory._id,
      brand: 'ProCue',
      manufacturer: 'Billiard Master',
      countryOfOrigin: 'USA',
      price: 1500000,
      stock: 15,
      sku: 'PC-X1-001',
      images: [
        {
          url: 'https://example.com/products/pc-x1-001-main.jpg',
          alt: 'Gậy Billiard Pro Series X1 - Hình chính',
          isPrimary: true,
        },
      ],
      features: [
        'Thân gậy làm từ gỗ sồi cao cấp',
        'Đầu tip cứng độ bền cao',
        'Trọng lượng cân bằng hoàn hảo',
        'Tay cầm chống trượt',
      ],
      specifications: {
        weight: 567,
        length: 147,
        diameter: 13,
        material: 'Gỗ sồi',
        tipSize: '13mm',
        wrap: 'Irish linen',
      },
      isActive: true,
      isPromoted: true,
      isFeatured: true,
    },
    {
      name: 'Gậy Billiard Starter S1',
      slug: 'gay-billiard-starter-s1',
      description: {
        short: 'Gậy billiard phổ thông dành cho người mới chơi',
        long: 'Gậy billiard Starter S1 là lựa chọn hoàn hảo cho người mới bắt đầu chơi billiard. Với thiết kế cân bằng và dễ sử dụng, S1 giúp người chơi nhanh chóng làm quen với kỹ thuật cơ bản.',
      },
      category: gayPhoThongCategory._id,
      brand: 'StarterCue',
      manufacturer: 'Billiard Master',
      countryOfOrigin: 'Vietnam',
      price: 750000,
      stock: 30,
      sku: 'SC-S1-001',
      images: [
        {
          url: 'https://example.com/products/sc-s1-001-main.jpg',
          alt: 'Gậy Billiard Starter S1 - Hình chính',
          isPrimary: true,
        },
      ],
      features: [
        'Thiết kế cân bằng dễ sử dụng',
        'Thân gậy làm từ gỗ maple',
        'Đầu tip mềm thân thiện cho người mới',
        'Giá cả phải chăng',
      ],
      specifications: {
        weight: 540,
        length: 145,
        diameter: 13,
        material: 'Gỗ maple',
        tipSize: '13mm',
        wrap: 'Nylon',
      },
      isActive: true,
      isPromoted: false,
      isFeatured: true,
    },
    {
      name: 'Bộ Bi Billiard Pro Tournament',
      slug: 'bo-bi-billiard-pro-tournament',
      description: {
        short: 'Bộ bi billiard chuyên nghiệp cho giải đấu',
        long: 'Bộ Bi Billiard Pro Tournament được làm từ chất liệu cao cấp, đạt chuẩn thi đấu quốc tế. Độ bóng và cân bằng hoàn hảo giúp đảm bảo các ván đấu công bằng và chính xác.',
      },
      category: biCategory._id,
      brand: 'MasterBall',
      manufacturer: 'Professional Billiards',
      countryOfOrigin: 'Belgium',
      price: 2200000,
      stock: 10,
      sku: 'MB-PT-001',
      images: [
        {
          url: 'https://example.com/products/mb-pt-001-main.jpg',
          alt: 'Bộ Bi Billiard Pro Tournament - Hình chính',
          isPrimary: true,
        },
      ],
      features: [
        'Chuẩn thi đấu quốc tế',
        'Chất liệu resin cao cấp',
        'Độ bóng và cân bằng hoàn hảo',
        'Tuổi thọ cao',
      ],
      specifications: {
        diameter: 57.2,
        weight: 170,
        material: 'Resin',
        quantity: 16,
      },
      isActive: true,
      isPromoted: true,
      isFeatured: false,
    },
  ];

  await Product.insertMany(sampleProducts);
  console.log(`Seeded ${sampleProducts.length} products successfully.`);
}

module.exports = seedProducts;


--- File: server/src/seeds/scripts/reviewSeeder.js ---
// server/src/data/seeds/reviewSeeds.js
const Review = require('../data/reviews');
const User = require('../data/users');
const Product = require('../data/products');
const Order = require('../data/orders');
const logger = require('../../config/logger');

const seedReviews = async () => {
  try {
    // Kiểm tra xem đã có reviews trong DB chưa
    const count = await Review.countDocuments();
    if (count > 0) {
      logger.info('Reviews collection already seeded');
      return;
    }

    // Lấy users, products và orders để tạo reviews
    const users = await User.find().limit(10);
    const products = await Product.find().limit(20);
    const orders = await Order.find({ status: 'delivered' });

    if (users.length === 0 || products.length === 0) {
      logger.warn('Cannot seed reviews: No users or products found');
      return;
    }

    const reviews = [];
    const reviewTitles = [
      'Sản phẩm tuyệt vời',
      'Rất hài lòng với sản phẩm',
      'Chất lượng tốt',
      'Đáng đồng tiền',
      'Sẽ mua lại',
      'Khá ổn',
      'Bình thường',
    ];

    const reviewContents = [
      'Sản phẩm đúng như mô tả, giao hàng nhanh, đóng gói cẩn thận.',
      'Chất lượng sản phẩm rất tốt, đúng như mong đợi. Sẽ tiếp tục ủng hộ shop.',
      'Sản phẩm đẹp, chất lượng tốt, giao hàng nhanh, đóng gói cẩn thận, shop tư vấn nhiệt tình.',
      'Sản phẩm đúng như hình, chất lượng tốt, sẽ ủng hộ shop dài dài.',
      'Mình rất thích sản phẩm này, chất lượng tuyệt vời, giá cả hợp lý.',
      'Khá ổn với mức giá này, có thể cải thiện thêm về phần đóng gói.',
      'Sản phẩm tạm được, không xuất sắc nhưng cũng không tệ.',
    ];

    // Tạo reviews từ các đơn hàng đã giao
    for (const order of orders) {
      for (const item of order.items) {
        const rating = Math.floor(Math.random() * 3) + 3; // 3-5 sao
        const reviewTitle = reviewTitles[Math.floor(Math.random() * reviewTitles.length)];
        const reviewContent = reviewContents[Math.floor(Math.random() * reviewContents.length)];

        const createdAt = new Date(order.completedAt);
        createdAt.setDate(createdAt.getDate() + Math.floor(Math.random() * 7)); // 0-7 ngày sau khi đơn hàng hoàn thành

        reviews.push({
          product: item.product,
          user: order.user,
          order: order._id,
          rating,
          title: reviewTitle,
          review: reviewContent,
          isVerifiedPurchase: true,
          purchaseDate: order.createdAt,
          helpfulness: {
            upvotes: Math.floor(Math.random() * 10),
            downvotes: Math.floor(Math.random() * 3),
            voters: [],
          },
          moderation: {
            status: 'approved',
            moderatedAt: new Date(),
          },
          isVisible: true,
          createdAt,
          updatedAt: createdAt,
        });
      }
    }

    // Tạo thêm một số reviews ngẫu nhiên
    for (let i = 0; i < 30; i++) {
      const user = users[Math.floor(Math.random() * users.length)];
      const product = products[Math.floor(Math.random() * products.length)];
      const rating = Math.floor(Math.random() * 5) + 1; // 1-5 sao
      const reviewTitle =
        rating >= 3
          ? reviewTitles[Math.floor(Math.random() * reviewTitles.length)]
          : 'Không như mong đợi';
      const reviewContent =
        rating >= 3
          ? reviewContents[Math.floor(Math.random() * reviewContents.length)]
          : 'Sản phẩm không đúng như mô tả, chất lượng kém.';

      const createdAt = new Date();
      createdAt.setDate(createdAt.getDate() - Math.floor(Math.random() * 30));

      reviews.push({
        product: product._id,
        user: user._id,
        rating,
        title: reviewTitle,
        review: reviewContent,
        isVerifiedPurchase: false,
        helpfulness: {
          upvotes: Math.floor(Math.random() * 5),
          downvotes: Math.floor(Math.random() * 2),
          voters: [],
        },
        moderation: {
          status: 'approved',
          moderatedAt: new Date(),
        },
        isVisible: true,
        createdAt,
        updatedAt: createdAt,
      });
    }

    // Lưu vào database
    await Review.insertMany(reviews);
    logger.info(`Seeded ${reviews.length} reviews`);

    // Cập nhật ratings cho products
    for (const product of products) {
      const productReviews = reviews.filter(
        (review) => review.product.toString() === product._id.toString()
      );

      if (productReviews.length > 0) {
        const totalRating = productReviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = totalRating / productReviews.length;

        await Product.findByIdAndUpdate(product._id, {
          'ratings.average': parseFloat(averageRating.toFixed(1)),
          'ratings.count': productReviews.length,
        });
      }
    }

    logger.info('Updated product ratings');
  } catch (error) {
    logger.error('Error seeding reviews', error);
    throw error;
  }
};

module.exports = { seedReviews };


--- File: server/src/seeds/scripts/userSeeder.js ---
// server/src/seeds/userSeeder.js

const { User } = require('../data/users');
const bcrypt = require('bcrypt');

async function seedUsers() {
  console.log('Seeding users...');

  // Xóa tất cả người dùng hiện có (chỉ dùng trong development)
  if (process.env.NODE_ENV !== 'production') {
    await User.deleteMany({});
  }

  // Hash mật khẩu
  const saltRounds = 10;
  const adminPasswordHash = await bcrypt.hash('admin123', saltRounds);
  const userPasswordHash = await bcrypt.hash('user123', saltRounds);

  // Tạo người dùng mẫu
  const users = [
    {
      name: 'Admin User',
      email: 'admin@runout-biliard.com',
      password: adminPasswordHash,
      role: 'admin',
      phone: '0901234567',
      address: {
        street: '123 Nguyễn Huệ',
        city: 'Hồ Chí Minh',
        state: '',
        zipCode: '70000',
        country: 'Việt Nam',
      },
      isActive: true,
      emailVerified: true,
      preferences: {
        language: 'vi',
        notifications: {
          email: true,
          marketing: true,
        },
      },
    },
    {
      name: 'Regular User',
      email: 'user@example.com',
      password: userPasswordHash,
      role: 'user',
      phone: '0909876543',
      address: {
        street: '456 Lê Lợi',
        city: 'Hà Nội',
        state: '',
        zipCode: '10000',
        country: 'Việt Nam',
      },
      isActive: true,
      emailVerified: true,
      preferences: {
        language: 'vi',
        notifications: {
          email: true,
          marketing: false,
        },
      },
    },
  ];

  await User.insertMany(users);
  console.log(`Seeded ${users.length} users successfully.`);
}

module.exports = seedUsers;


--- File: server/src/server.js ---
/**
 * Server chính cho ứng dụng RunOut-Biliard
 * @author Steve
 * @project RunOut-Biliard
 */

const http = require('http');
const app = require('./app');
const config = require('./config/environment');
const logger = require('./config/logger');

// Lấy PORT từ cấu hình hoặc biến môi trường
const PORT = process.env.PORT || config.app.port || 5000;

// Tạo HTTP server
const server = http.createServer(app);

// Xử lý các lỗi server
server.on('error', (error) => {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof PORT === 'string' ? 'Pipe ' + PORT : 'Port ' + PORT;

  // Xử lý các lỗi server cụ thể với thông báo thân thiện
  switch (error.code) {
    case 'EACCES':
      logger.error(`${bind} yêu cầu quyền nâng cao`);
      throw new Error(`${bind} yêu cầu quyền nâng cao`);
    case 'EADDRINUSE':
      logger.error(`${bind} đã được sử dụng`);
      throw new Error(`${bind} đã được sử dụng`);
    default:
      throw error;
  }
});

// Khởi động server
server.listen(PORT, () => {
  logger.info(`🚀 Server đang chạy trong môi trường ${config.app.environment}`);
  logger.info(`🌐 Địa chỉ: http://${config.app.host}:${PORT}`);
});

// Xử lý tắt server an toàn
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

/**
 * Đóng server một cách an toàn
 */
function gracefulShutdown() {
  logger.info('Nhận tín hiệu tắt server, đang đóng kết nối...');

  server.close(() => {
    logger.info('Server đã đóng, đang ngắt kết nối cơ sở dữ liệu...');

    // Đóng kết nối cơ sở dữ liệu nếu cần
    try {
      if (require('mongoose').connection.readyState) {
        require('mongoose').connection.close(false, () => {
          logger.info('Đã ngắt kết nối MongoDB.');
          throw new Error('Server đã đóng và ngắt kết nối thành công');
        });
      } else {
        throw new Error('Server đã đóng và không cần ngắt kết nối');
      }
    } catch (err) {
      logger.error(`Lỗi khi đóng kết nối: ${err.message}`);
      throw new Error(`Lỗi khi đóng kết nối: ${err.message}`);
    }
  });

  // Nếu server không đóng sau 10s, tắt cưỡng chế
  setTimeout(() => {
    logger.error('Không thể đóng kết nối một cách êm dịu, đang tắt cưỡng chế...');
    throw new Error('Không thể đóng kết nối một cách êm dịu, đang tắt cưỡng chế...');
  }, 10000);
}

// Xử lý các lỗi không bắt được khác
process.on('uncaughtException', (error) => {
  logger.error(`Lỗi không bắt được: ${error.message}`);
  logger.error(error.stack);

  // Trong môi trường sản xuất, đảm bảo server đóng an toàn sau lỗi không bắt được
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Lời hứa bị từ chối không được xử lý:');
  logger.error(`Promise: ${promise}, Reason: ${reason}`);

  // Trong môi trường sản xuất, có thể xem xét tắt ứng dụng
  if (config.app.environment === 'production') {
    gracefulShutdown();
  }
});

module.exports = server; // Export để sử dụng trong kiểm thử


--- File: server/src/services/auth/authService.js ---
/**
 * Auth Service - xử lý logic xác thực và phân quyền
 * @author Steve
 * @project RunOut-Biliard
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const User = require('../../data/models/user.model');
const { ApiError } = require('../../common/errors/apiError');
const logger = require('../../config/logger');
const environment = require('../../config/environment');
const { sendEmail } = require('../email/emailService');

/**
 * Class AuthService xử lý logic xác thực và phân quyền
 */
class AuthService {
  /**
   * Đăng ký tài khoản mới
   * @param {Object} userData - Thông tin đăng ký
   * @param {string} host - Host để tạo URL xác thực
   * @returns {Promise<Object>} - Thông tin người dùng đã tạo
   */
  async register(userData, host) {
    try {
      const { name, email, password, phone } = userData;

      // Kiểm tra email đã tồn tại chưa
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        throw new ApiError(409, 'Email đã được sử dụng');
      }

      // Tạo verification token
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(verificationToken).digest('hex');

      // Tạo user mới
      const newUser = await User.create({
        name,
        email,
        password,
        phone,
        emailVerificationToken: hashedToken,
        emailVerificationExpires: Date.now() + 24 * 60 * 60 * 1000, // 24 giờ
      });

      // Tạo URL xác thực
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const verifyURL = `${protocol}://${host}/api/auth/verify-email/${verificationToken}`;

      // Gửi email xác thực
      await sendEmail({
        to: email,
        subject: 'Xác thực tài khoản RunOut-Biliard',
        template: 'verification',
        context: {
          name,
          verifyURL,
        },
      });

      // Không gửi mật khẩu và token trong response
      const userObj = newUser.toObject();
      delete userObj.password;
      delete userObj.emailVerificationToken;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi đăng ký: ${error.message}`);
      throw error;
    }
  }

  /**
   * Đăng nhập
   * @param {string} email - Email người dùng
   * @param {string} password - Mật khẩu
   * @returns {Promise<Object>} - Thông tin người dùng và token
   */
  async login(email, password) {
    try {
      // Tìm user và lấy cả password (mặc định password bị loại trừ)
      const user = await User.findOne({ email }).select('+password');

      // Kiểm tra user tồn tại và password đúng
      if (!user || !(await user.correctPassword(password, user.password))) {
        throw new ApiError(401, 'Email hoặc mật khẩu không đúng');
      }

      // Kiểm tra email đã xác thực chưa
      if (!user.emailVerified) {
        throw new ApiError(401, 'Vui lòng xác thực email trước khi đăng nhập');
      }

      // Kiểm tra user có active không
      if (!user.isActive) {
        throw new ApiError(401, 'Tài khoản của bạn đã bị vô hiệu hóa');
      }

      // Tạo JWT token và refresh token
      const token = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // Cập nhật thông tin đăng nhập
      user.lastLogin = Date.now();
      user.loginCount += 1;
      await user.save({ validateBeforeSave: false });

      // Chuyển đổi user thành object và loại bỏ password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token,
        refreshToken,
      };
    } catch (error) {
      logger.error(`Lỗi đăng nhập: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tạo JWT token
   * @param {Object} user - User object
   * @returns {string} - JWT token
   */
  generateToken(user) {
    return jwt.sign({ id: user._id, role: user.role }, environment.auth.jwtSecret, {
      expiresIn: environment.auth.jwtExpiresIn,
    });
  }

  /**
   * Tạo refresh token
   * @param {Object} user - User object
   * @returns {string} - Refresh token
   */
  generateRefreshToken(user) {
    return jwt.sign({ id: user._id }, environment.auth.jwtRefreshSecret, {
      expiresIn: environment.auth.jwtRefreshExpiresIn,
    });
  }

  /**
   * Làm mới token
   * @param {string} refreshToken - Refresh token
   * @returns {Promise<Object>} - Token mới
   */
  async refreshToken(refreshToken) {
    try {
      // Xác thực refresh token
      const decoded = jwt.verify(refreshToken, environment.auth.jwtRefreshSecret);

      // Tìm user
      const user = await User.findById(decoded.id);

      if (!user || !user.isActive) {
        throw new ApiError(401, 'Người dùng không tồn tại hoặc đã bị vô hiệu hóa');
      }

      // Tạo token mới
      const newToken = this.generateToken(user);

      return { token: newToken };
    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new ApiError(401, 'Refresh token không hợp lệ hoặc đã hết hạn');
      }

      logger.error(`Lỗi refresh token: ${error.message}`);
      throw error;
    }
  }

  /**
   * Quên mật khẩu
   * @param {string} email - Email người dùng
   * @param {string} host - Host để tạo URL reset
   * @returns {Promise<boolean>} - Thành công hay không
   */
  async forgotPassword(email, host) {
    try {
      // Tìm user theo email
      const user = await User.findOne({ email });

      if (!user) {
        throw new ApiError(404, 'Không tìm thấy người dùng với email này');
      }

      // Tạo reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');

      // Lưu token và thời hạn vào database
      user.resetPasswordToken = hashedToken;
      user.resetPasswordExpires = Date.now() + 10 * 60 * 1000; // 10 phút
      await user.save({ validateBeforeSave: false });

      // Tạo URL reset
      const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
      const resetURL = `${protocol}://${host}/reset-password/${resetToken}`;

      // Gửi email
      await sendEmail({
        to: user.email,
        subject: 'Đặt lại mật khẩu RunOut-Biliard (có hiệu lực trong 10 phút)',
        template: 'resetPassword',
        context: {
          name: user.name,
          resetURL,
        },
      });

      return true;
    } catch (error) {
      logger.error(`Lỗi quên mật khẩu: ${error.message}`);

      // Nếu gửi email thất bại, xóa các fields reset
      if (error.message.includes('email')) {
        try {
          const user = await User.findOne({ email });
          if (user) {
            user.resetPasswordToken = undefined;
            user.resetPasswordExpires = undefined;
            await user.save({ validateBeforeSave: false });
          }
        } catch (innerError) {
          logger.error(`Lỗi khi xóa token reset: ${innerError.message}`);
        }
      }

      throw error;
    }
  }

  /**
   * Đặt lại mật khẩu
   * @param {string} token - Reset token
   * @param {string} password - Mật khẩu mới
   * @returns {Promise<Object>} - Thông tin người dùng và token
   */
  async resetPassword(token, password) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // Tìm user với token và kiểm tra thời hạn
      const user = await User.findOne({
        resetPasswordToken: hashedToken,
        resetPasswordExpires: { $gt: Date.now() },
      });

      // Kiểm tra nếu token hợp lệ
      if (!user) {
        throw new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn');
      }

      // Cập nhật mật khẩu
      user.password = password;
      user.resetPasswordToken = undefined;
      user.resetPasswordExpires = undefined;
      await user.save();

      // Tạo token mới
      const jwtToken = this.generateToken(user);
      const refreshToken = this.generateRefreshToken(user);

      // Chuyển đổi user thành object và loại bỏ password
      const userObj = user.toObject();
      delete userObj.password;

      return {
        user: userObj,
        token: jwtToken,
        refreshToken,
      };
    } catch (error) {
      logger.error(`Lỗi đặt lại mật khẩu: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xác thực email
   * @param {string} token - Verification token
   * @returns {Promise<boolean>} - Thành công hay không
   */
  async verifyEmail(token) {
    try {
      // Hash token
      const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

      // Tìm user và kiểm tra thời hạn
      const user = await User.findOne({
        emailVerificationToken: hashedToken,
        emailVerificationExpires: { $gt: Date.now() },
      });

      // Kiểm tra nếu token hợp lệ
      if (!user) {
        throw new ApiError(400, 'Token không hợp lệ hoặc đã hết hạn');
      }

      // Cập nhật trạng thái xác thực
      user.emailVerified = true;
      user.emailVerificationToken = undefined;
      user.emailVerificationExpires = undefined;
      await user.save({ validateBeforeSave: false });

      return true;
    } catch (error) {
      logger.error(`Lỗi xác thực email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new AuthService();


--- File: server/src/services/base/baseService.js ---
/**
 * Base Service - cung cấp các phương thức CRUD cơ bản
 * @author Steve
 * @project RunOut-Biliard
 */

const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * Lớp BaseService cung cấp các phương thức CRUD cơ bản cho các service
 */
class BaseService {
  /**
   * Khởi tạo service với model tương ứng
   * @param {mongoose.Model} model - Mongoose model
   * @param {string} modelName - Tên của model (dùng cho log và thông báo lỗi)
   */
  constructor(model, modelName) {
    this.model = model;
    this.modelName = modelName || model.modelName;
  }

  /**
   * Lấy tất cả documents với filter, sort và pagination
   * @param {Object} filter - Điều kiện filter
   * @param {Object} options - Các options bổ sung (sort, pagination, select)
   * @returns {Promise<{data: Array, pagination: Object}>} - Dữ liệu và thông tin phân trang
   */
  async findAll(filter = {}, options = {}) {
    try {
      const { sort = '-createdAt', page = 1, limit = 10, select = '', populate = '' } = options;

      const skip = (page - 1) * limit;

      // Build query
      let query = this.model.find(filter);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query with sort, skip and limit
      const data = await query.sort(sort).skip(skip).limit(limit);

      // Count total documents matching filter
      const total = await this.model.countDocuments(filter);

      // Calculate pagination info
      const totalPages = Math.ceil(total / limit);
      const hasNext = page < totalPages;
      const hasPrev = page > 1;

      return {
        data,
        pagination: {
          total,
          page,
          limit,
          totalPages,
          hasNext,
          hasPrev,
        },
      };
    } catch (error) {
      logger.error(`Error in ${this.modelName}.findAll: ${error.message}`);
      throw error;
    }
  }

  /**
   * Lấy document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} options - Các options (select, populate)
   * @returns {Promise<Document>} - Document tìm thấy
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async findById(id, options = {}) {
    try {
      const { select = '', populate = '' } = options;

      // Build query
      let query = this.model.findById(id);

      // Apply select fields
      if (select) {
        query = query.select(select);
      }

      // Apply populate
      if (populate) {
        if (Array.isArray(populate)) {
          populate.forEach((field) => {
            query = query.populate(field);
          });
        } else {
          query = query.populate(populate);
        }
      }

      // Execute query
      const data = await query;

      // Throw error if not found
      if (!data) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return data;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.findById: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tạo document mới
   * @param {Object} data - Dữ liệu cho document mới
   * @returns {Promise<Document>} - Document đã tạo
   */
  async create(data) {
    try {
      const newDoc = await this.model.create(data);
      return newDoc;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.create: ${error.message}`);
      throw error;
    }
  }

  /**
   * Cập nhật document theo ID
   * @param {string} id - MongoDB ObjectId
   * @param {Object} data - Dữ liệu cập nhật
   * @param {Object} options - Các options (new, runValidators)
   * @returns {Promise<Document>} - Document đã cập nhật
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async update(id, data, options = {}) {
    try {
      const opts = {
        new: true,
        runValidators: true,
        ...options,
      };

      const updated = await this.model.findByIdAndUpdate(id, data, opts);

      if (!updated) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return updated;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.update: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xóa document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<Document>} - Document đã xóa
   * @throws {ApiError} - 404 nếu không tìm thấy
   */
  async delete(id) {
    try {
      const deleted = await this.model.findByIdAndDelete(id);

      if (!deleted) {
        throw new ApiError(404, `${this.modelName} không tìm thấy với ID: ${id}`);
      }

      return deleted;
    } catch (error) {
      // Rethrow ApiError
      if (error instanceof ApiError) {
        throw error;
      }

      logger.error(`Error in ${this.modelName}.delete: ${error.message}`);
      throw error;
    }
  }

  /**
   * Kiểm tra sự tồn tại của document theo ID
   * @param {string} id - MongoDB ObjectId
   * @returns {Promise<boolean>} - true nếu document tồn tại, false nếu không
   */
  async exists(id) {
    try {
      const count = await this.model.countDocuments({ _id: id });
      return count > 0;
    } catch (error) {
      logger.error(`Error in ${this.modelName}.exists: ${error.message}`);
      throw error;
    }
  }
}

module.exports = BaseService;


--- File: server/src/services/cache/redisCache.js ---
// server/src/services/cache/redisCache.js
const redis = require('redis');
const { promisify } = require('util');
const config = require('../../config/environment');
const { logger } = require('../../utils/logger'); // Sửa cách import logger

class RedisCache {
  constructor() {
    this.isConnected = false;
    this.client = redis.createClient({
      url: config.redis.url,
      retry_strategy: (options) => {
        if (options.error && options.error.code === 'ECONNREFUSED') {
          logger.error('Kết nối Redis bị từ chối. Đảm bảo Redis server đang chạy.');
          return new Error('Kết nối Redis bị từ chối');
        }
        if (options.total_retry_time > 1000 * 60 * 60) {
          logger.error('Đã vượt quá thời gian thử lại kết nối Redis.');
          return new Error('Đã vượt quá thời gian thử lại');
        }
        if (options.attempt > 10) {
          logger.error('Đã vượt quá số lần thử lại kết nối Redis.');
          return undefined;
        }
        // Thử lại sau một khoảng thời gian tăng dần
        return Math.min(options.attempt * 100, 3000);
      },
    });

    // Xử lý sự kiện Redis trước khi promisify
    this.client.on('error', (error) => {
      this.isConnected = false;
      logger.error('Lỗi Redis:', error);
    });

    this.client.on('connect', () => {
      this.isConnected = true;
      logger.info('Đã kết nối thành công đến Redis server');
    });

    this.client.on('reconnecting', () => {
      logger.info('Đang thử kết nối lại đến Redis server...');
    });

    this.client.on('end', () => {
      this.isConnected = false;
      logger.info('Kết nối Redis đã đóng');
    });

    // Promisify các phương thức Redis - Sửa cách thực hiện bind
    this._initPromisifiedMethods();
  }

  /**
   * Khởi tạo các phương thức Redis đã promisify với kiểm tra an toàn
   * @private
   */
  _initPromisifiedMethods() {
    try {
      // Kiểm tra xem client có tồn tại không
      if (!this.client) {
        throw new Error('Redis client chưa được khởi tạo');
      }

      // Sử dụng try-catch riêng cho từng phương thức
      try {
        if (typeof this.client.get === 'function')
          this.getAsync = promisify(this.client.get.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức get');
      }

      try {
        if (typeof this.client.set === 'function')
          this.setAsync = promisify(this.client.set.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức set');
      }

      try {
        if (typeof this.client.del === 'function')
          this.delAsync = promisify(this.client.del.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức del');
      }

      try {
        if (typeof this.client.keys === 'function')
          this.keysAsync = promisify(this.client.keys.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức keys');
      }

      try {
        if (typeof this.client.flushdb === 'function')
          this.flushdbAsync = promisify(this.client.flushdb.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức flushdb');
      }

      try {
        if (typeof this.client.exists === 'function')
          this.existsAsync = promisify(this.client.exists.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức exists');
      }

      try {
        if (typeof this.client.expire === 'function')
          this.expireAsync = promisify(this.client.expire.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức expire');
      }

      try {
        if (typeof this.client.ttl === 'function')
          this.ttlAsync = promisify(this.client.ttl.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức ttl');
      }

      try {
        if (typeof this.client.incr === 'function')
          this.incrAsync = promisify(this.client.incr.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức incr');
      }

      try {
        if (typeof this.client.decr === 'function')
          this.decrAsync = promisify(this.client.decr.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức decr');
      }

      try {
        if (typeof this.client.hgetall === 'function')
          this.hgetallAsync = promisify(this.client.hgetall.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hgetall');
      }

      try {
        if (typeof this.client.hset === 'function')
          this.hsetAsync = promisify(this.client.hset.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hset');
      }

      try {
        if (typeof this.client.hmset === 'function')
          this.hmsetAsync = promisify(this.client.hmset.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hmset');
      }

      try {
        if (typeof this.client.hdel === 'function')
          this.hdelAsync = promisify(this.client.hdel.bind(this.client));
      } catch (e) {
        logger.warn('Không thể promisify phương thức hdel');
      }

      logger.info('Các phương thức Redis đã được promisify thành công');
    } catch (error) {
      logger.error('Lỗi khi promisify các phương thức Redis:', error);
      throw new Error('Không thể khởi tạo các phương thức Redis: ' + error.message);
    }
  }

  /**
   * Kiểm tra trạng thái kết nối Redis
   * @returns {boolean} Trạng thái kết nối
   */
  isReady() {
    return this.isConnected;
  }

  /**
   * Lấy dữ liệu từ cache
   * @param {string} key - Khóa cache
   * @returns {Promise<any>} Dữ liệu đã lưu trong cache hoặc null
   */
  async get(key) {
    try {
      const data = await this.getAsync(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error(`Lỗi khi lấy cache với khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Lưu dữ liệu vào cache
   * @param {string} key - Khóa cache
   * @param {any} value - Dữ liệu cần lưu
   * @param {number} ttl - Thời gian sống (giây)
   * @returns {Promise<boolean>} Kết quả lưu cache
   */
  async set(key, value, ttl = 3600) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.setAsync(key, serializedValue, 'EX', ttl);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu cache với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Xóa dữ liệu khỏi cache
   * @param {string} key - Khóa cache
   * @returns {Promise<boolean>} Kết quả xóa cache
   */
  async delete(key) {
    try {
      const result = await this.delAsync(key);
      return result > 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa cache với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Tạo khóa cache từ prefix và tham số
   * @param {string} prefix - Tiền tố cho khóa
   * @param {object} params - Tham số để tạo khóa
   * @returns {string} Khóa cache đã tạo
   */
  generateKey(prefix, params) {
    if (typeof params === 'object') {
      // Sắp xếp các khóa để đảm bảo tính nhất quán
      const sortedParams = {};
      Object.keys(params)
        .sort()
        .forEach((key) => {
          sortedParams[key] = params[key];
        });
      return `${prefix}:${Buffer.from(JSON.stringify(sortedParams)).toString('base64')}`;
    }
    return `${prefix}:${params}`;
  }

  /**
   * Kiểm tra xem khóa có tồn tại trong cache không
   * @param {string} key - Khóa cache
   * @returns {Promise<boolean>} Kết quả kiểm tra
   */
  async exists(key) {
    try {
      const result = await this.existsAsync(key);
      return result === 1;
    } catch (error) {
      logger.error(`Lỗi khi kiểm tra tồn tại khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Cập nhật thời gian hết hạn cho khóa
   * @param {string} key - Khóa cache
   * @param {number} ttl - Thời gian sống mới (giây)
   * @returns {Promise<boolean>} Kết quả cập nhật
   */
  async expire(key, ttl) {
    try {
      const result = await this.expireAsync(key, ttl);
      return result === 1;
    } catch (error) {
      logger.error(`Lỗi khi cập nhật thời gian hết hạn cho khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Lấy thời gian còn lại trước khi khóa hết hạn
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Thời gian còn lại (giây)
   */
  async ttl(key) {
    try {
      return await this.ttlAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi lấy TTL cho khóa ${key}:`, error);
      return -2; // -2 là giá trị Redis trả về khi khóa không tồn tại
    }
  }

  /**
   * Tăng giá trị của khóa lên 1
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Giá trị mới
   */
  async increment(key) {
    try {
      return await this.incrAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi tăng giá trị cho khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Giảm giá trị của khóa đi 1
   * @param {string} key - Khóa cache
   * @returns {Promise<number>} Giá trị mới
   */
  async decrement(key) {
    try {
      return await this.decrAsync(key);
    } catch (error) {
      logger.error(`Lỗi khi giảm giá trị cho khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Xóa tất cả các khóa có cùng pattern
   * @param {string} pattern - Mẫu khóa cần xóa (ví dụ: 'products:*')
   * @returns {Promise<number>} Số lượng khóa đã xóa
   */
  async deleteByPattern(pattern) {
    try {
      const keys = await this.keysAsync(pattern);
      if (keys.length > 0) {
        return await this.delAsync(keys);
      }
      return 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa cache theo mẫu ${pattern}:`, error);
      return 0;
    }
  }

  /**
   * Xóa toàn bộ cache
   * @returns {Promise<boolean>} Kết quả xóa cache
   */
  async flush() {
    try {
      await this.flushdbAsync();
      logger.info('Đã xóa toàn bộ cache');
      return true;
    } catch (error) {
      logger.error('Lỗi khi xóa toàn bộ cache:', error);
      return false;
    }
  }

  /**
   * Lấy tất cả các trường và giá trị của một hash
   * @param {string} key - Khóa hash
   * @returns {Promise<object>} Đối tượng chứa các trường và giá trị
   */
  async getHash(key) {
    try {
      const data = await this.hgetallAsync(key);
      if (!data) return null;

      // Chuyển đổi các giá trị từ JSON string sang object
      const result = {};
      for (const field in data) {
        try {
          result[field] = JSON.parse(data[field]);
        } catch (e) {
          result[field] = data[field];
        }
      }
      return result;
    } catch (error) {
      logger.error(`Lỗi khi lấy hash với khóa ${key}:`, error);
      return null;
    }
  }

  /**
   * Lưu một trường vào hash
   * @param {string} key - Khóa hash
   * @param {string} field - Tên trường
   * @param {any} value - Giá trị cần lưu
   * @returns {Promise<boolean>} Kết quả lưu hash
   */
  async setHashField(key, field, value) {
    try {
      const serializedValue = JSON.stringify(value);
      await this.hsetAsync(key, field, serializedValue);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu trường hash ${field} với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Lưu nhiều trường vào hash
   * @param {string} key - Khóa hash
   * @param {object} fields - Đối tượng chứa các trường và giá trị
   * @returns {Promise<boolean>} Kết quả lưu hash
   */
  async setHash(key, fields) {
    try {
      const serializedFields = {};
      for (const field in fields) {
        serializedFields[field] = JSON.stringify(fields[field]);
      }
      await this.hmsetAsync(key, serializedFields);
      return true;
    } catch (error) {
      logger.error(`Lỗi khi lưu hash với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Xóa một trường khỏi hash
   * @param {string} key - Khóa hash
   * @param {string} field - Tên trường
   * @returns {Promise<boolean>} Kết quả xóa trường
   */
  async deleteHashField(key, field) {
    try {
      const result = await this.hdelAsync(key, field);
      return result > 0;
    } catch (error) {
      logger.error(`Lỗi khi xóa trường hash ${field} với khóa ${key}:`, error);
      return false;
    }
  }

  /**
   * Đóng kết nối Redis
   * @returns {Promise<void>}
   */
  async close() {
    return new Promise((resolve) => {
      this.client.quit(() => {
        logger.info('Kết nối Redis đã đóng');
        this.isConnected = false;
        resolve();
      });
    });
  }
}

module.exports = new RedisCache();


--- File: server/src/services/cart/cartService.js ---
/**
 * Cart Service
 * Xử lý logic nghiệp vụ cho giỏ hàng
 */

const { ApiError } = require('../../common/errors/apiError');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const crypto = require('crypto');

/**
 * Tạo ID phiên cho khách vãng lai
 * @returns {string} Session ID
 */
const generateSessionId = () => {
  return crypto.randomBytes(16).toString('hex');
};

/**
 * Lấy giỏ hàng đang active của người dùng hoặc khách vãng lai
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Thông tin giỏ hàng
 */
const getActiveCart = async (userId, sessionId) => {
  let cart;

  // Trường hợp 1: User đã đăng nhập
  if (userId) {
    cart = await cartRepository.findOne({ user: userId, status: 'active' });
  }
  // Trường hợp 2: Khách vãng lai
  else if (sessionId) {
    cart = await cartRepository.findOne({ sessionId, status: 'active' });
  }

  // Nếu chưa có giỏ hàng, tạo mới
  if (!cart) {
    const newCart = {
      user: userId || null,
      sessionId: userId ? null : sessionId,
      items: [],
      subtotal: 0,
      status: 'active',
      lastActivity: new Date(),
    };

    // Thời hạn cho giỏ hàng của khách vãng lai
    if (!userId && sessionId) {
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7); // 7 ngày
      newCart.expiresAt = expiryDate;
    }

    cart = await cartRepository.create(newCart);
  }

  return cart;
};

/**
 * Thêm sản phẩm vào giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} productId - ID của sản phẩm
 * @param {number} quantity - Số lượng sản phẩm
 * @param {Object} attributes - Các thuộc tính tùy chọn của sản phẩm
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi thêm sản phẩm
 */
const addItemToCart = async (userId, sessionId, productId, quantity, attributes = {}) => {
  // Kiểm tra sản phẩm tồn tại và còn hàng
  const product = await productRepository.findById(productId);

  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  if (!product.isActive) {
    throw new ApiError(400, 'Sản phẩm không khả dụng');
  }

  if (product.stock < quantity) {
    throw new ApiError(400, `Sản phẩm chỉ còn ${product.stock} trong kho`);
  }

  // Lấy giỏ hàng hiện tại hoặc tạo mới
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra xem sản phẩm đã có trong giỏ hàng chưa
  const existingItemIndex = cart.items.findIndex((item) => {
    return (
      item.product.toString() === productId &&
      JSON.stringify(item.attributes) === JSON.stringify(attributes)
    );
  });

  // Tính giá sản phẩm (ưu tiên giá khuyến mãi nếu có)
  const itemPrice = product.salePrice || product.price;

  // Nếu sản phẩm đã có trong giỏ, cập nhật số lượng
  if (existingItemIndex > -1) {
    const existingItem = cart.items[existingItemIndex];
    const newQuantity = existingItem.quantity + quantity;

    // Kiểm tra lại tồn kho
    if (product.stock < newQuantity) {
      throw new ApiError(400, `Không đủ hàng trong kho. Chỉ còn ${product.stock} sản phẩm.`);
    }

    // Cập nhật số lượng và tổng giá
    cart.items[existingItemIndex].quantity = newQuantity;
    cart.items[existingItemIndex].updatedAt = new Date();
  }
  // Nếu chưa có, thêm mới vào giỏ hàng
  else {
    cart.items.push({
      product: productId,
      quantity,
      price: itemPrice,
      attributes,
      addedAt: new Date(),
      updatedAt: new Date(),
    });
  }

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Cập nhật số lượng sản phẩm trong giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} itemId - ID của item trong giỏ hàng
 * @param {number} quantity - Số lượng mới
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi cập nhật
 */
const updateCartItem = async (userId, sessionId, itemId, quantity) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Tìm item trong giỏ hàng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm trong giỏ hàng');
  }

  // Lấy thông tin sản phẩm
  const cartItem = cart.items[itemIndex];
  const product = await productRepository.findById(cartItem.product);

  if (!product) {
    throw new ApiError(404, 'Sản phẩm không còn tồn tại');
  }

  // Kiểm tra tồn kho
  if (product.stock < quantity) {
    throw new ApiError(400, `Không đủ hàng trong kho. Chỉ còn ${product.stock} sản phẩm.`);
  }

  // Cập nhật số lượng
  cart.items[itemIndex].quantity = quantity;
  cart.items[itemIndex].updatedAt = new Date();

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Xóa sản phẩm khỏi giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} itemId - ID của item trong giỏ hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu có lỗi khi xóa sản phẩm
 */
const removeItemFromCart = async (userId, sessionId, itemId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra item tồn tại trong giỏ hàng
  const itemIndex = cart.items.findIndex((item) => item._id.toString() === itemId);

  if (itemIndex === -1) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm trong giỏ hàng');
  }

  // Xóa item khỏi giỏ hàng
  cart.items.splice(itemIndex, 1);

  // Tính lại tổng tiền
  cart.subtotal = calculateSubtotal(cart.items);

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Xóa toàn bộ giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng trống
 */
const clearCart = async (userId, sessionId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Xóa tất cả items
  cart.items = [];
  cart.subtotal = 0;

  // Xóa mã giảm giá nếu có
  if (cart.coupon) {
    cart.coupon = null;
  }

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Áp dụng mã giảm giá vào giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {string} code - Mã giảm giá
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 * @throws {ApiError} Nếu mã giảm giá không hợp lệ
 */
const applyCoupon = async (userId, sessionId, code) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Kiểm tra giỏ hàng có sản phẩm không
  if (cart.items.length === 0) {
    throw new ApiError(400, 'Giỏ hàng trống, không thể áp dụng mã giảm giá');
  }

  // TODO: Triển khai logic xác thực mã giảm giá thực tế
  // Ví dụ đơn giản: kiểm tra mã "WELCOME10" giảm 10% tổng giá trị
  if (code === 'WELCOME10') {
    const discount = Math.round(cart.subtotal * 0.1); // Giảm 10%

    cart.coupon = {
      code,
      discount,
      appliedAt: new Date(),
    };

    // Cập nhật thời gian hoạt động
    cart.lastActivity = new Date();

    // Lưu giỏ hàng
    return await cartRepository.update(cart._id, cart);
  }

  throw new ApiError(400, 'Mã giảm giá không hợp lệ hoặc đã hết hạn');
};

/**
 * Xóa mã giảm giá khỏi giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const removeCoupon = async (userId, sessionId) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Xóa mã giảm giá
  cart.coupon = null;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Hợp nhất giỏ hàng khi đăng nhập
 * @param {string} userId - ID của người dùng đã đăng nhập
 * @param {string} sessionId - ID phiên của khách vãng lai
 * @returns {Promise<Object>} Giỏ hàng đã hợp nhất
 */
const mergeCartsOnLogin = async (userId, sessionId) => {
  // Tìm giỏ hàng của khách vãng lai
  const guestCart = await cartRepository.findOne({ sessionId, status: 'active' });

  if (!guestCart) {
    return await getActiveCart(userId, null);
  }

  // Tìm hoặc tạo giỏ hàng của người dùng
  const userCart = await getActiveCart(userId, null);

  // Nếu giỏ hàng khách không có sản phẩm, không cần hợp nhất
  if (guestCart.items.length === 0) {
    // Đánh dấu giỏ hàng khách là đã hợp nhất
    await cartRepository.update(guestCart._id, {
      status: 'merged',
      updatedAt: new Date(),
    });

    return userCart;
  }

  // Hợp nhất các sản phẩm từ giỏ hàng khách vào giỏ hàng người dùng
  for (const guestItem of guestCart.items) {
    const existingItemIndex = userCart.items.findIndex((item) => {
      return (
        item.product.toString() === guestItem.product.toString() &&
        JSON.stringify(item.attributes) === JSON.stringify(guestItem.attributes)
      );
    });

    // Nếu sản phẩm đã có trong giỏ hàng người dùng, cộng số lượng
    if (existingItemIndex > -1) {
      // Lấy thông tin sản phẩm để kiểm tra tồn kho
      const product = await productRepository.findById(guestItem.product);

      if (product) {
        const newQuantity = userCart.items[existingItemIndex].quantity + guestItem.quantity;

        // Kiểm tra tồn kho
        if (product.stock >= newQuantity) {
          userCart.items[existingItemIndex].quantity = newQuantity;
        } else {
          // Nếu không đủ tồn kho, giới hạn số lượng
          userCart.items[existingItemIndex].quantity = product.stock;
        }

        userCart.items[existingItemIndex].updatedAt = new Date();
      }
    }
    // Nếu sản phẩm chưa có, thêm vào giỏ hàng người dùng
    else {
      // Kiểm tra lại sản phẩm và tồn kho
      const product = await productRepository.findById(guestItem.product);

      if (product && product.isActive) {
        // Điều chỉnh số lượng nếu vượt quá tồn kho
        const quantity = product.stock >= guestItem.quantity ? guestItem.quantity : product.stock;

        if (quantity > 0) {
          userCart.items.push({
            ...guestItem,
            quantity,
            updatedAt: new Date(),
          });
        }
      }
    }
  }

  // Tính lại tổng tiền
  userCart.subtotal = calculateSubtotal(userCart.items);

  // Áp dụng mã giảm giá từ giỏ hàng khách nếu có và giỏ hàng người dùng chưa có
  if (guestCart.coupon && !userCart.coupon) {
    userCart.coupon = {
      ...guestCart.coupon,
      appliedAt: new Date(),
    };
  }

  // Cập nhật thời gian hoạt động
  userCart.lastActivity = new Date();

  // Lưu giỏ hàng người dùng
  const updatedUserCart = await cartRepository.update(userCart._id, userCart);

  // Đánh dấu giỏ hàng khách là đã hợp nhất
  await cartRepository.update(guestCart._id, {
    status: 'merged',
    updatedAt: new Date(),
  });

  return updatedUserCart;
};

/**
 * Tính tổng tiền giỏ hàng
 * @param {Array} items - Các sản phẩm trong giỏ hàng
 * @returns {number} Tổng tiền
 */
const calculateSubtotal = (items) => {
  return items.reduce((total, item) => total + item.price * item.quantity, 0);
};

/**
 * Cập nhật thông tin vận chuyển cho giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {Object} shippingAddress - Thông tin địa chỉ giao hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const updateShippingAddress = async (userId, sessionId, shippingAddress) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Cập nhật địa chỉ giao hàng
  cart.shippingAddress = shippingAddress;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Cập nhật phương thức vận chuyển cho giỏ hàng
 * @param {string|null} userId - ID của người dùng (null nếu là khách vãng lai)
 * @param {string|null} sessionId - ID phiên của khách vãng lai
 * @param {Object} shippingMethod - Thông tin phương thức vận chuyển
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const updateShippingMethod = async (userId, sessionId, shippingMethod) => {
  // Lấy giỏ hàng hiện tại
  const cart = await getActiveCart(userId, sessionId);

  // Cập nhật phương thức vận chuyển
  cart.shippingMethod = shippingMethod;

  // Cập nhật thời gian hoạt động
  cart.lastActivity = new Date();

  // Lưu giỏ hàng
  return await cartRepository.update(cart._id, cart);
};

/**
 * Đánh dấu giỏ hàng là đã bị bỏ rơi
 * @param {string} cartId - ID của giỏ hàng
 * @returns {Promise<Object>} Giỏ hàng đã cập nhật
 */
const markCartAsAbandoned = async (cartId) => {
  return await cartRepository.update(cartId, {
    status: 'abandoned',
    updatedAt: new Date(),
  });
};

/**
 * Lấy danh sách giỏ hàng bị bỏ rơi để gửi email nhắc nhở
 * @param {number} hoursSinceLastActivity - Số giờ kể từ lần hoạt động cuối cùng
 * @returns {Promise<Array>} Danh sách giỏ hàng bị bỏ rơi
 */
const getAbandonedCarts = async (hoursSinceLastActivity = 24) => {
  const date = new Date();
  date.setHours(date.getHours() - hoursSinceLastActivity);

  return await cartRepository.find({
    status: 'active',
    lastActivity: { $lt: date },
    items: { $exists: true, $not: { $size: 0 } },
  });
};

module.exports = {
  generateSessionId,
  getActiveCart,
  addItemToCart,
  updateCartItem,
  removeItemFromCart,
  clearCart,
  applyCoupon,
  removeCoupon,
  mergeCartsOnLogin,
  updateShippingAddress,
  updateShippingMethod,
  markCartAsAbandoned,
  getAbandonedCarts,
};


--- File: server/src/services/category/categoryService.js ---
/**
 * Category Service
 * Xử lý logic nghiệp vụ cho danh mục sản phẩm
 */

const { ApiError } = require('../../common/errors/apiError');
const categoryRepository = require('../../data/repositories/categoryRepository');
const productRepository = require('../../data/repositories/productRepository');
const slugify = require('slugify');

/**
 * Lấy tất cả danh mục (có thể lọc, sắp xếp, phân trang)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Array>} Danh sách danh mục
 */
const getAllCategories = async (features = {}) => {
  return await categoryRepository.findAll(features);
};

/**
 * Lấy danh mục theo ID
 * @param {string} id - ID của danh mục
 * @returns {Promise<Object>} Thông tin danh mục
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const getCategoryById = async (id) => {
  const category = await categoryRepository.findById(id);
  if (!category) {
    throw new ApiError(404, 'Không tìm thấy danh mục');
  }
  return category;
};

/**
 * Lấy danh mục theo slug
 * @param {string} slug - Slug của danh mục
 * @returns {Promise<Object>} Thông tin danh mục
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const getCategoryBySlug = async (slug) => {
  const category = await categoryRepository.findOne({ slug });
  if (!category) {
    throw new ApiError(404, 'Không tìm thấy danh mục');
  }
  return category;
};

/**
 * Lấy tất cả sản phẩm trong danh mục
 * @param {string} categoryId - ID của danh mục
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Array>} Danh sách sản phẩm trong danh mục
 */
const getCategoryProducts = async (categoryId, features = {}) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(categoryId);
  
  // Thêm filter cho category vào features
  const categoryFilter = { ...features };
  categoryFilter.filter = { ...categoryFilter.filter, category: categoryId };
  
  // Lấy tất cả các danh mục con
  const subcategories = await getSubcategories(categoryId);
  
  // Nếu có danh mục con, thêm vào filter
  if (subcategories.length > 0) {
    const subcategoryIds = subcategories.map(subcat => subcat._id);
    categoryFilter.filter = { 
      ...categoryFilter.filter, 
      $or: [
        { category: categoryId },
        { category: { $in: subcategoryIds } }
      ]
    };
  }
  
  return await productRepository.findAll(categoryFilter);
};

/**
 * Tạo danh mục mới
 * @param {Object} categoryData - Dữ liệu danh mục
 * @returns {Promise<Object>} Danh mục đã tạo
 */
const createCategory = async (categoryData) => {
  // Nếu không có slug, tạo từ tên
  if (!categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Kiểm tra slug đã tồn tại chưa
  const existingCategory = await categoryRepository.findOne({ slug: categoryData.slug });
  if (existingCategory) {
    throw new ApiError(400, 'Slug đã tồn tại');
  }
  
  // Xử lý danh mục cha và ancestors
  if (categoryData.parent) {
    const parentCategory = await getCategoryById(categoryData.parent);
    
    // Thiết lập level và ancestors
    categoryData.level = parentCategory.level + 1;
    categoryData.ancestors = [
      ...parentCategory.ancestors,
      {
        _id: parentCategory._id,
        name: parentCategory.name,
        slug: parentCategory.slug
      }
    ];
  } else {
    // Danh mục gốc
    categoryData.level = 0;
    categoryData.ancestors = [];
  }
  
  return await categoryRepository.create(categoryData);
};

/**
 * Cập nhật danh mục
 * @param {string} id - ID của danh mục
 * @param {Object} categoryData - Dữ liệu cập nhật
 * @returns {Promise<Object>} Danh mục đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy danh mục
 */
const updateCategory = async (id, categoryData) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(id);
  
  // Nếu thay đổi tên và không cung cấp slug, cập nhật slug
  if (categoryData.name && !categoryData.slug) {
    categoryData.slug = slugify(categoryData.name, {
      lower: true,
      strict: true,
      locale: 'vi'
    });
  }
  
  // Kiểm tra slug mới có bị trùng không
  if (categoryData.slug && categoryData.slug !== category.slug) {
    const existingCategory = await categoryRepository.findOne({ 
      slug: categoryData.slug,
      _id: { $ne: id }
    });
    
    if (existingCategory) {
      throw new ApiError(400, 'Slug đã tồn tại');
    }
  }
  
  // Nếu thay đổi danh mục cha
  if (categoryData.parent !== undefined && categoryData.parent !== category.parent) {
    // Không cho phép đặt danh mục con làm cha của chính nó
    const subcategories = await getSubcategories(id);
    const subcategoryIds = subcategories.map(subcat => subcat._id.toString());
    
    if (categoryData.parent && (categoryData.parent === id || subcategoryIds.includes(categoryData.parent))) {
      throw new ApiError(400, 'Không thể đặt danh mục con làm cha của chính nó');
    }
    
    // Cập nhật level và ancestors
    if (categoryData.parent) {
      const parentCategory = await getCategoryById(categoryData.parent);
      
      categoryData.level = parentCategory.level + 1;
      categoryData.ancestors = [
        ...parentCategory.ancestors,
        {
          _id: parentCategory._id,
          name: parentCategory.name,
          slug: parentCategory.slug
        }
      ];
    } else {
      // Chuyển thành danh mục gốc
      categoryData.level = 0;
      categoryData.ancestors = [];
    }
    
    // Cập nhật tất cả danh mục con
    await updateSubcategoryAncestors(id, category.name, category.slug);
  }
  
  // Cập nhật danh mục
  const updatedCategory = await categoryRepository.update(id, categoryData);
  
  // Nếu thay đổi tên hoặc slug, cập nhật ancestors cho tất cả danh mục con
  if ((categoryData.name && categoryData.name !== category.name) ||
      (categoryData.slug && categoryData.slug !== category.slug)) {
    await updateSubcategoryAncestors(id, updatedCategory.name, updatedCategory.slug);
  }
  
  return updatedCategory;
};

/**
 * Xóa danh mục
 * @param {string} id - ID của danh mục
 * @returns {Promise<void>}
 * @throws {ApiError} Nếu không tìm thấy danh mục hoặc có danh mục con
 */
const deleteCategory = async (id) => {
  // Kiểm tra danh mục tồn tại
  const category = await getCategoryById(id);
  
  // Kiểm tra nếu có danh mục con
  const subcategories = await categoryRepository.find({ parent: id });
  if (subcategories.length > 0) {
    throw new ApiError(400, 'Không thể xóa danh mục có danh mục con');
  }
  
  // Kiểm tra nếu có sản phẩm trong danh mục
  const products = await productRepository.find({ category: id }, { limit: 1 });
  if (products.length > 0) {
    throw new ApiError(400, 'Không thể xóa danh mục có sản phẩm');
  }
  
  // Xóa danh mục
  await categoryRepository.delete(id);
};

/**
 * Lấy tất cả danh mục con trực tiếp
 * @param {string} parentId - ID của danh mục cha
 * @returns {Promise<Array>} Danh sách danh mục con
 */
const getDirectSubcategories = async (parentId) => {
  return await categoryRepository.find({ parent: parentId });
};

/**
 * Lấy tất cả danh mục con (bao gồm cả con của con)
 * @param {string} categoryId - ID của danh mục
 * @returns {Promise<Array>} Danh sách tất cả danh mục con
 */
const getSubcategories = async (categoryId) => {
  return await categoryRepository.findSubcategories(categoryId);
};

/**
 * Cập nhật ancestors cho tất cả danh mục con khi danh mục cha thay đổi
 * @param {string} categoryId - ID của danh mục cha
 * @param {string} categoryName - Tên mới của danh mục cha
 * @param {string} categorySlug - Slug mới của danh mục cha
 * @returns {Promise<void>}
 */
const updateSubcategoryAncestors = async (categoryId, categoryName, categorySlug) => {
  // Lấy tất cả danh mục con trực tiếp
  const directSubcategories = await getDirectSubcategories(categoryId);
  
  // Cập nhật ancestors cho từng danh mục con
  for (const subcategory of directSubcategories) {
    // Tìm vị trí của danh mục cha trong ancestors
    const ancestorIndex = subcategory.ancestors.findIndex(
      ancestor => ancestor._id.toString() === categoryId
    );
    
    if (ancestorIndex !== -1) {
      // Cập nhật thông tin ancestor
      const updatedAncestors = [...subcategory.ancestors];
      updatedAncestors[ancestorIndex] = {
        _id: categoryId,
        name: categoryName,
        slug: categorySlug
      };
      
      // Cập nhật danh mục con
      await categoryRepository.update(subcategory._id, {
        ancestors: updatedAncestors
      });
      
      // Đệ quy cập nhật các danh mục con của con
      await updateSubcategoryAncestors(
        subcategory._id,
        subcategory.name,
        subcategory.slug
      );
    }
  }
};

/**
 * Tạo breadcrumbs từ ancestors
 * @param {string} categoryId - ID của danh mục
 * @returns {Promise<Array>} Danh sách breadcrumbs
 */
const createBreadcrumbs = async (categoryId) => {
  const category = await getCategoryById(categoryId);
  
  // Tạo breadcrumbs từ ancestors và thêm danh mục hiện tại
  const breadcrumbs = [
    ...category.ancestors.map(ancestor => ({
      id: ancestor._id,
      name: ancestor.name,
      slug: ancestor.slug
    })),
    {
      id: category._id,
      name: category.name,
      slug: category.slug
    }
  ];
  
  return breadcrumbs;
};

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoryBySlug,
  getCategoryProducts,
  createCategory,
  updateCategory,
  deleteCategory,
  getDirectSubcategories,
  getSubcategories,
  createBreadcrumbs
};

--- File: server/src/services/email/emailService.js ---
/**
 * Email Service - xử lý gửi email
 * @author Steve
 * @project RunOut-Biliard
 */

const nodemailer = require('nodemailer');
const path = require('path');
const fs = require('fs').promises;
const handlebars = require('handlebars');
const logger = require('../../config/logger');
const environment = require('../../config/environment');

/**
 * Class EmailService - xử lý gửi email
 */
class EmailService {
  constructor() {
    // Thiết lập transporter
    this.setupTransporter();

    // Đường dẫn đến thư mục chứa templates
    this.templatesDir = path.resolve(__dirname, 'templates');

    // Cache cho templates đã compile
    this.templateCache = {};
  }

  /**
   * Thiết lập transporter cho Nodemailer
   */
  setupTransporter() {
    // Sử dụng cấu hình khác nhau tùy thuộc vào môi trường
    if (environment.app.environment === 'development') {
      // Sử dụng Ethereal cho môi trường development
      this.createTestAccount();
    } else {
      // Sử dụng cấu hình SMTP thực cho production
      this.transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST,
        port: process.env.EMAIL_PORT,
        secure: process.env.EMAIL_SECURE === 'true',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS,
        },
      });
    }
  }

  /**
   * Tạo test account với Ethereal cho môi trường development
   */
  async createTestAccount() {
    try {
      const testAccount = await nodemailer.createTestAccount();

      this.transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email',
        port: 587,
        secure: false,
        auth: {
          user: testAccount.user,
          pass: testAccount.pass,
        },
      });

      logger.info(`Đã tạo test account với Ethereal Email: ${testAccount.user}`);
    } catch (error) {
      logger.error(`Không thể tạo test account: ${error.message}`);

      // Fallback đến cấu hình giả lập
      this.transporter = {
        sendMail: async (mailOptions) => {
          logger.info('Gửi email giả lập:');
          logger.info(`Đến: ${mailOptions.to}`);
          logger.info(`Chủ đề: ${mailOptions.subject}`);
          logger.info(`Nội dung: ${mailOptions.text || mailOptions.html}`);

          return { messageId: `mock_${Date.now()}` };
        },
      };
    }
  }

  /**
   * Đọc và compile template email
   * @param {string} templateName - Tên template
   * @returns {Promise<Function>} - Template đã compile
   */
  async getTemplate(templateName) {
    // Kiểm tra cache
    if (this.templateCache[templateName]) {
      return this.templateCache[templateName];
    }

    try {
      // Đọc file template
      const templatePath = path.join(this.templatesDir, `${templateName}.hbs`);
      const templateSource = await fs.readFile(templatePath, 'utf8');

      // Compile template
      const template = handlebars.compile(templateSource);

      // Lưu vào cache
      this.templateCache[templateName] = template;

      return template;
    } catch (error) {
      logger.error(`Không thể đọc template email '${templateName}': ${error.message}`);
      throw error;
    }
  }

  /**
   * Gửi email
   * @param {Object} options - Tùy chọn email
   * @param {string} options.to - Người nhận
   * @param {string} options.subject - Chủ đề
   * @param {string} options.template - Tên template (không có phần mở rộng)
   * @param {Object} options.context - Dữ liệu cho template
   * @returns {Promise<Object>} - Kết quả gửi email
   */
  async sendEmail(options) {
    try {
      const { to, subject, template, context } = options;

      // Lấy template
      const compiledTemplate = await this.getTemplate(template);

      // Thêm vào các biến toàn cục
      const enhancedContext = {
        ...context,
        appName: environment.app.name,
        signature: environment.app.signature,
        year: new Date().getFullYear(),
        logoUrl: process.env.APP_LOGO_URL || 'https://example.com/logo.png',
      };

      // Render HTML từ template
      const html = compiledTemplate(enhancedContext);

      // Thiết lập mail options
      const mailOptions = {
        from: process.env.EMAIL_FROM || `"${environment.app.name}" <no-reply@example.com>`,
        to,
        subject,
        html,
      };

      // Gửi email
      const info = await this.transporter.sendMail(mailOptions);

      // Log URL để xem email (chỉ trong môi trường development với Ethereal)
      if (environment.app.environment === 'development' && info.messageId) {
        logger.info(`URL xem email: ${nodemailer.getTestMessageUrl(info)}`);
      }

      return info;
    } catch (error) {
      logger.error(`Lỗi gửi email: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new EmailService();

// Helper function để sử dụng service dễ dàng hơn
module.exports.sendEmail = (options) => module.exports.sendEmail(options);


--- File: server/src/services/order/orderService.js ---
/**
 * Order Service
 * Xử lý logic nghiệp vụ cho đơn hàng
 */

const { ApiError } = require('../../common/errors/apiError');
const orderRepository = require('../../data/repositories/orderRepository');
const cartRepository = require('../../data/repositories/cartRepository');
const productRepository = require('../../data/repositories/productRepository');
const emailService = require('../email/emailService');
const { generateOrderNumber } = require('../../utils/orderUtils');
const VNPayService = require('./vnpayService');

/**
 * Lấy tất cả đơn hàng (admin)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đơn hàng và thông tin phân trang
 */
const getAllOrders = async (features = {}) => {
  return await orderRepository.findAll(features);
};

/**
 * Lấy đơn hàng theo ID
 * @param {string} id - ID của đơn hàng
 * @param {string} userId - ID của người dùng đang yêu cầu
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Thông tin đơn hàng
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc không có quyền truy cập
 */
const getOrderById = async (id, userId, isAdmin) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra quyền truy cập
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền truy cập đơn hàng này');
  }

  return order;
};

/**
 * Lấy tất cả đơn hàng của một người dùng
 * @param {string} userId - ID của người dùng
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đơn hàng và thông tin phân trang
 */
const getOrdersByUserId = async (userId, features = {}) => {
  // Thêm filter cho user
  const userFilter = { ...features };
  userFilter.filter = { ...userFilter.filter, user: userId };

  return await orderRepository.findAll(userFilter);
};

/**
 * Tạo đơn hàng mới
 * @param {Object} orderData - Dữ liệu đơn hàng
 * @param {string} userId - ID của người dùng đặt hàng
 * @returns {Promise<Object>} Đơn hàng đã tạo
 * @throws {ApiError} Nếu có lỗi khi tạo đơn hàng
 */
const createOrder = async (orderData, userId) => {
  // Khởi tạo đơn hàng
  const orderInfo = {
    orderNumber: await generateOrderNumber(),
    user: userId,
    customerInfo: orderData.customerInfo,
    shippingAddress: orderData.shippingAddress,
    shippingMethod: orderData.shippingMethod,
    paymentMethod: orderData.paymentMethod,
    customerNotes: orderData.customerNotes,
    status: 'pending',
    statusHistory: [
      {
        status: 'pending',
        date: new Date(),
        note: 'Đơn hàng đã được tạo',
      },
    ],
  };

  let items = [];
  let subtotal = 0;

  // Trường hợp 1: Tạo đơn hàng từ giỏ hàng
  if (orderData.cartId) {
    const cart = await cartRepository.findById(orderData.cartId);

    if (!cart) {
      throw new ApiError(404, 'Không tìm thấy giỏ hàng');
    }

    // Kiểm tra quyền truy cập giỏ hàng
    if (cart.user.toString() !== userId) {
      throw new ApiError(403, 'Bạn không có quyền truy cập giỏ hàng này');
    }

    // Chuyển từ cart items sang order items
    items = await Promise.all(
      cart.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Không tìm thấy sản phẩm ${item.product}`);
        }

        // Kiểm tra tồn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `Sản phẩm ${product.name} chỉ còn ${product.stock} sản phẩm trong kho`
          );
        }

        return {
          product: item.product,
          name: product.name,
          price: item.price,
          quantity: item.quantity,
          totalPrice: item.price * item.quantity,
          attributes: item.attributes,
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // Tính tổng tiền
    subtotal = cart.subtotal;

    // Lấy thông tin khuyến mãi từ giỏ hàng
    if (cart.coupon) {
      orderInfo.discount = {
        amount: cart.coupon.discount,
        code: cart.coupon.code,
      };
    }

    // Đánh dấu giỏ hàng đã chuyển thành đơn hàng
    await cartRepository.update(cart._id, { status: 'converted' });
  }
  // Trường hợp 2: Tạo đơn hàng từ danh sách sản phẩm trực tiếp
  else if (orderData.items && orderData.items.length > 0) {
    items = await Promise.all(
      orderData.items.map(async (item) => {
        const product = await productRepository.findById(item.product);

        if (!product) {
          throw new ApiError(404, `Không tìm thấy sản phẩm ${item.product}`);
        }

        // Kiểm tra tồn kho
        if (product.stock < item.quantity) {
          throw new ApiError(
            400,
            `Sản phẩm ${product.name} chỉ còn ${product.stock} sản phẩm trong kho`
          );
        }

        const itemPrice = product.salePrice || product.price;
        const totalPrice = itemPrice * item.quantity;
        subtotal += totalPrice;

        return {
          product: item.product,
          name: product.name,
          price: itemPrice,
          quantity: item.quantity,
          totalPrice,
          attributes: item.attributes || {},
          sku: product.sku,
          image: product.images.length > 0 ? product.images[0].url : '',
        };
      })
    );

    // Áp dụng mã giảm giá nếu có
    if (orderData.couponCode) {
      // TODO: Triển khai logic áp dụng mã giảm giá
    }
  } else {
    throw new ApiError(400, 'Đơn hàng phải có ít nhất một sản phẩm');
  }

  // Tính giá vận chuyển
  const shippingCost = calculateShippingCost(
    orderData.shippingMethod,
    orderData.shippingAddress.country
  );

  // Tính thuế (nếu có)
  const tax = 0; // TODO: Triển khai tính thuế

  // Tính tổng tiền cuối cùng
  const discount = orderInfo.discount ? orderInfo.discount.amount : 0;
  const totalAmount = subtotal + shippingCost + tax - discount;

  // Hoàn thiện thông tin đơn hàng
  orderInfo.items = items;
  orderInfo.subtotal = subtotal;
  orderInfo.shippingCost = shippingCost;
  orderInfo.tax = tax;
  orderInfo.totalAmount = totalAmount;
  orderInfo.paymentStatus = orderData.paymentMethod === 'cod' ? 'pending' : 'pending';

  // Lưu đơn hàng vào database
  let newOrder;
  try {
    newOrder = await orderRepository.create(orderInfo);
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi tạo đơn hàng: ' + error.message);
  }

  // Cập nhật tồn kho
  try {
    await updateInventory(items);
  } catch (error) {
    // Nếu cập nhật tồn kho thất bại, xóa đơn hàng đã tạo
    try {
      await orderRepository.delete(newOrder._id);
    } catch (deleteError) {
      console.error('Không thể xóa đơn hàng sau khi cập nhật tồn kho thất bại:', deleteError);
    }
    throw new ApiError(500, 'Lỗi khi cập nhật tồn kho: ' + error.message);
  }

  // Tạo URL thanh toán nếu phương thức là vnpay
  if (orderData.paymentMethod === 'vnpay') {
    try {
      const paymentUrl = await VNPayService.createPaymentUrl({
        orderId: newOrder._id,
        amount: totalAmount,
        orderInfo: `Thanh toán đơn hàng ${newOrder.orderNumber}`,
      });

      // Trả về URL thanh toán cùng với đơn hàng
      return { order: newOrder, paymentUrl };
    } catch (error) {
      // Nếu tạo URL thanh toán thất bại, không cần xóa đơn hàng
      // Chỉ ghi log và trả về đơn hàng mà không có URL thanh toán
      console.error('Lỗi khi tạo URL thanh toán VNPay:', error);
      return newOrder;
    }
  }

  // Gửi email xác nhận đơn hàng
  try {
    await sendOrderConfirmationEmail(newOrder);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi nhưng không ảnh hưởng đến việc tạo đơn hàng
    console.error('Lỗi khi gửi email xác nhận đơn hàng:', error);
  }

  return newOrder;
};

/**
 * Cập nhật trạng thái đơn hàng
 * @param {string} id - ID của đơn hàng
 * @param {string} status - Trạng thái mới
 * @param {string} note - Ghi chú khi cập nhật trạng thái
 * @param {string} adminId - ID của admin thực hiện cập nhật
 * @returns {Promise<Object>} Đơn hàng đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc trạng thái không hợp lệ
 */
const updateOrderStatus = async (id, status, note, adminId) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra trạng thái hiện tại và trạng thái mới
  const validStatusTransitions = {
    pending: ['processing', 'cancelled'],
    processing: ['packed', 'cancelled'],
    packed: ['shipped', 'cancelled'],
    shipped: ['delivered', 'returned'],
    delivered: ['returned'],
    cancelled: [],
    returned: [],
  };

  if (!validStatusTransitions[order.status].includes(status)) {
    throw new ApiError(400, `Không thể chuyển từ trạng thái ${order.status} sang ${status}`);
  }

  // Cập nhật trạng thái đơn hàng
  const statusHistory = {
    status,
    date: new Date(),
    note: note || `Đơn hàng đã được chuyển sang trạng thái ${status}`,
    updatedBy: adminId,
  };

  const updateData = {
    status,
    statusHistory: [...order.statusHistory, statusHistory],
  };

  // Cập nhật các trường khác tùy theo trạng thái
  if (status === 'delivered') {
    updateData.completedAt = new Date();

    // Nếu thanh toán là COD, cập nhật trạng thái thanh toán
    if (order.paymentMethod === 'cod') {
      updateData.paymentStatus = 'paid';
      updateData.paymentDetails = {
        ...order.paymentDetails,
        paymentDate: new Date(),
      };
    }
  } else if (status === 'cancelled') {
    updateData.cancelledAt = new Date();

    // Hoàn trả sản phẩm vào kho
    await restoreInventory(order.items);
  } else if (status === 'returned') {
    // Hoàn trả sản phẩm vào kho
    await restoreInventory(order.items);
  }

  // Cập nhật đơn hàng
  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, updateData);
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi cập nhật đơn hàng: ' + error.message);
  }

  // Gửi email thông báo thay đổi trạng thái
  try {
    await sendOrderStatusUpdateEmail(updatedOrder);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi
    console.error('Lỗi khi gửi email thông báo thay đổi trạng thái:', error);
  }

  return updatedOrder;
};

/**
 * Hủy đơn hàng
 * @param {string} id - ID của đơn hàng
 * @param {string} userId - ID của người dùng yêu cầu hủy
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @param {string} reason - Lý do hủy đơn hàng
 * @returns {Promise<Object>} Đơn hàng đã hủy
 * @throws {ApiError} Nếu không tìm thấy đơn hàng hoặc không thể hủy
 */
const cancelOrder = async (id, userId, isAdmin, reason) => {
  const order = await orderRepository.findById(id);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Kiểm tra quyền truy cập
  if (!isAdmin && order.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền hủy đơn hàng này');
  }

  // Kiểm tra trạng thái hiện tại
  if (!['pending', 'processing'].includes(order.status)) {
    throw new ApiError(400, 'Chỉ có thể hủy đơn hàng ở trạng thái đang xử lý hoặc chờ xử lý');
  }

  // Nếu đơn hàng đã thanh toán, kiểm tra xem có thể hoàn tiền không
  if (order.paymentStatus === 'paid') {
    // TODO: Xử lý hoàn tiền
  }

  // Cập nhật trạng thái đơn hàng
  const statusHistory = {
    status: 'cancelled',
    date: new Date(),
    note: reason || 'Đơn hàng đã bị hủy bởi người dùng',
    updatedBy: isAdmin ? userId : null,
  };

  let updatedOrder;
  try {
    updatedOrder = await orderRepository.update(id, {
      status: 'cancelled',
      statusHistory: [...order.statusHistory, statusHistory],
      cancelledAt: new Date(),
    });
  } catch (error) {
    throw new ApiError(500, 'Lỗi khi cập nhật trạng thái đơn hàng: ' + error.message);
  }

  // Hoàn trả sản phẩm vào kho
  try {
    await restoreInventory(order.items);
  } catch (error) {
    // Nếu hoàn trả sản phẩm thất bại, ghi log lỗi nhưng vẫn giữ trạng thái đơn hàng đã hủy
    console.error('Lỗi khi hoàn trả sản phẩm vào kho:', error);
  }

  // Gửi email thông báo hủy đơn hàng
  try {
    await sendOrderCancelledEmail(updatedOrder, reason);
  } catch (error) {
    // Nếu gửi email thất bại, chỉ ghi log lỗi
    console.error('Lỗi khi gửi email thông báo hủy đơn hàng:', error);
  }

  return updatedOrder;
};

/**
 * Xử lý webhook từ cổng thanh toán VNPay
 * @param {Object} paymentData - Dữ liệu từ VNPay
 * @returns {Promise<void>}
 */
const processPaymentWebhook = async (paymentData) => {
  // Xác thực dữ liệu từ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'Dữ liệu thanh toán không hợp lệ');
  }

  // Lấy thông tin đơn hàng từ vnp_OrderInfo hoặc vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Cập nhật trạng thái thanh toán dựa vào response code
  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh toán thành công
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }

    // Gửi email xác nhận thanh toán
    try {
      const updatedOrder = await orderRepository.findById(orderId);
      await sendPaymentConfirmationEmail(updatedOrder);
    } catch (error) {
      // Nếu gửi email thất bại, chỉ ghi log lỗi
      console.error('Lỗi khi gửi email xác nhận thanh toán:', error);
    }
  } else {
    // Thanh toán thất bại
    try {
      await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  }
};

/**
 * Xử lý redirect URL từ cổng thanh toán VNPay
 * @param {Object} paymentData - Dữ liệu từ VNPay
 * @returns {Promise<Object>} Kết quả thanh toán
 */
const processPaymentReturn = async (paymentData) => {
  // Xác thực dữ liệu từ VNPay
  const isValid = VNPayService.verifyReturnUrl(paymentData);

  if (!isValid) {
    throw new ApiError(400, 'Dữ liệu thanh toán không hợp lệ');
  }

  // Lấy thông tin đơn hàng từ vnp_OrderInfo hoặc vnp_TxnRef
  const orderId = paymentData.vnp_OrderInfo;
  const order = await orderRepository.findById(orderId);

  if (!order) {
    throw new ApiError(404, 'Không tìm thấy đơn hàng');
  }

  // Cập nhật trạng thái thanh toán dựa vào response code
  let result = {};

  if (paymentData.vnp_ResponseCode === '00') {
    // Thanh toán thành công
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'paid',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          paymentDate: new Date(),
        },
      });

      // Gửi email xác nhận thanh toán
      try {
        await sendPaymentConfirmationEmail(updatedOrder);
      } catch (emailError) {
        console.error('Lỗi khi gửi email xác nhận thanh toán:', emailError);
      }

      result = {
        success: true,
        message: 'Thanh toán thành công',
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  } else {
    // Thanh toán thất bại
    try {
      const updatedOrder = await orderRepository.update(orderId, {
        paymentStatus: 'failed',
        paymentDetails: {
          provider: 'vnpay',
          transactionId: paymentData.vnp_TransactionNo,
          errorCode: paymentData.vnp_ResponseCode,
        },
      });

      result = {
        success: false,
        message: 'Thanh toán thất bại',
        errorCode: paymentData.vnp_ResponseCode,
        order: updatedOrder,
      };
    } catch (error) {
      throw new ApiError(500, 'Lỗi khi cập nhật trạng thái thanh toán: ' + error.message);
    }
  }

  return result;
};

/**
 * Tính phí vận chuyển dựa trên phương thức và địa chỉ
 * @param {string} method - Phương thức vận chuyển
 * @param {string} country - Quốc gia giao hàng
 * @returns {number} Phí vận chuyển
 */
const calculateShippingCost = (method, country) => {
  // TODO: Triển khai tính phí vận chuyển thực tế
  const baseCost = method === 'express' ? 50000 : 30000;

  // Tính phí vận chuyển dựa trên quốc gia
  if (country !== 'Việt Nam') {
    return baseCost * 3;
  }

  return baseCost;
};

/**
 * Cập nhật tồn kho sau khi tạo đơn hàng
 * @param {Array} items - Danh sách sản phẩm trong đơn hàng
 * @returns {Promise<void>}
 */
const updateInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, -item.quantity);
  }
};

/**
 * Hoàn trả sản phẩm vào kho khi hủy đơn hàng
 * @param {Array} items - Danh sách sản phẩm trong đơn hàng
 * @returns {Promise<void>}
 */
const restoreInventory = async (items) => {
  for (const item of items) {
    await productRepository.updateStock(item.product, item.quantity);
  }
};

/**
 * Gửi email xác nhận đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderConfirmationEmail = async (order) => {
  await emailService.sendOrderConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderDate: order.createdAt,
    orderItems: order.items,
    subtotal: order.subtotal,
    shippingCost: order.shippingCost,
    discount: order.discount ? order.discount.amount : 0,
    tax: order.tax,
    totalAmount: order.totalAmount,
    shippingAddress: order.shippingAddress,
    paymentMethod: order.paymentMethod,
  });
};

/**
 * Gửi email thông báo thay đổi trạng thái đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderStatusUpdateEmail = async (order) => {
  await emailService.sendOrderStatusUpdate(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    orderStatus: order.status,
    statusNote: order.statusHistory[order.statusHistory.length - 1].note,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * Gửi email thông báo hủy đơn hàng
 * @param {Object} order - Thông tin đơn hàng
 * @param {string} reason - Lý do hủy đơn hàng
 * @returns {Promise<void>}
 */
const sendOrderCancelledEmail = async (order, reason) => {
  await emailService.sendOrderCancelled(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    cancelReason: reason,
    orderItems: order.items,
    totalAmount: order.totalAmount,
  });
};

/**
 * Gửi email xác nhận thanh toán
 * @param {Object} order - Thông tin đơn hàng
 * @returns {Promise<void>}
 */
const sendPaymentConfirmationEmail = async (order) => {
  await emailService.sendPaymentConfirmation(order.customerInfo.email, {
    orderNumber: order.orderNumber,
    customerName: order.customerInfo.name,
    paymentMethod: order.paymentMethod,
    paymentDate: order.paymentDetails.paymentDate,
    totalAmount: order.totalAmount,
    transactionId: order.paymentDetails.transactionId,
  });
};

module.exports = {
  getAllOrders,
  getOrderById,
  getOrdersByUserId,
  createOrder,
  updateOrderStatus,
  cancelOrder,
  processPaymentWebhook,
  processPaymentReturn,
};


--- File: server/src/services/product/productService.js ---
/**
 * Product Service
 * Xử lý tất cả logic nghiệp vụ liên quan đến sản phẩm
 */

const productRepository = require('../../data/repositories/productRepository');
const categoryRepository = require('../../data/repositories/categoryRepository');
const reviewRepository = require('../../data/repositories/reviewRepository');
const ProductDTO = require('../../data/dto/productDTO');
const ApiFeatures = require('../../utils/apiFeatures');
const AppError = require('../../common/errors/apiError');
const redisClient = require('../cache/redisCache');
const { formatProductResponse } = require('../../common/utils/formatters');
const { validateProductData } = require('../../common/validators/productValidator');

class ProductService {
  constructor() {
    this.productRepository = productRepository;
    this.categoryRepository = categoryRepository;
    this.reviewRepository = reviewRepository;
    this.cacheExpiry = 3600; // 1 giờ
  }

  /**
   * Xử lý lỗi chung cho tất cả các phương thức
   * @param {Error} error - Lỗi cần xử lý
   * @param {string} defaultMessage - Thông báo mặc định nếu không phải AppError
   * @throws {AppError} - Ném lỗi đã được xử lý
   */
  handleError(error, defaultMessage) {
    console.error(`Error in ProductService: ${error.message}`, error);
    if (error instanceof AppError) throw error;
    throw new AppError(defaultMessage, 500);
  }

  /**
   * Quản lý cache
   * @param {string} key - Khóa cache
   * @param {number} expiry - Thời gian hết hạn (giây)
   * @param {Function} dataFn - Hàm lấy dữ liệu nếu cache miss
   * @returns {Promise<any>} - Dữ liệu từ cache hoặc từ hàm dataFn
   */
  async withCache(key, expiry, dataFn) {
    try {
      // Kiểm tra cache
      const cachedData = await redisClient.get(key);
      if (cachedData) {
        console.log(`Cache hit for ${key}`);
        return JSON.parse(cachedData);
      }

      // Cache miss, lấy dữ liệu mới
      const data = await dataFn();

      // Lưu vào cache
      await redisClient.setex(key, expiry || this.cacheExpiry, JSON.stringify(data));

      return data;
    } catch (error) {
      console.error(`Cache error for ${key}:`, error);
      // Nếu có lỗi cache, vẫn trả về dữ liệu
      return await dataFn();
    }
  }

  /**
   * Xóa cache theo pattern
   * @param {string} pattern - Pattern của khóa cache cần xóa
   */
  async invalidateCache(pattern) {
    try {
      if (pattern.includes('*')) {
        // Xóa theo pattern
        const keys = await redisClient.keys(pattern);
        if (keys.length > 0) {
          await redisClient.del(keys);
          console.log(`Invalidated ${keys.length} cache keys matching ${pattern}`);
        }
      } else {
        // Xóa một khóa cụ thể
        await redisClient.del(pattern);
        console.log(`Invalidated cache key: ${pattern}`);
      }
    } catch (error) {
      console.error(`Error invalidating cache ${pattern}:`, error);
      // Không ném lỗi, chỉ ghi log
    }
  }

  /**
   * Lấy danh sách sản phẩm với bộ lọc và phân trang
   * @param {Object} queryParams - Các tham số truy vấn
   * @returns {Promise<{products: Array, totalCount: Number, pagination: Object}>}
   */
  async getProducts(queryParams) {
    try {
      // Tạo khóa cache dựa trên tham số truy vấn
      const cacheKey = `products:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tạo đối tượng ApiFeatures để xử lý phân trang, sắp xếp và lọc
        const features = new ApiFeatures(this.productRepository.query(), queryParams)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Thực hiện truy vấn
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuyển đổi thành DTO
        const productDTOs = products.map((product) => new ProductDTO(product).toJSON());

        // Định dạng phản hồi sản phẩm trước khi trả về
        const formattedProducts = productDTOs.map((product) => formatProductResponse(product));

        // Kết quả trả về
        return {
          products: formattedProducts,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm');
    }
  }

  /**
   * Lấy chi tiết sản phẩm theo ID
   * @param {string} productId - ID của sản phẩm
   * @returns {Promise<Object>} - Thông tin chi tiết sản phẩm
   */
  async getProductById(productId) {
    try {
      const cacheKey = `product:${productId}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Lấy thông tin sản phẩm từ repository
        const product = await this.productRepository.findById(productId);

        if (!product) {
          throw new AppError(404, 'Không tìm thấy sản phẩm');
        }

        // Lấy thêm thông tin đánh giá
        const reviews = await this.reviewRepository.findByProductId(productId);

        // Kết hợp thông tin
        const productDTO = new ProductDTO(product).toJSON();
        productDTO.reviews = reviews;
        productDTO.averageRating =
          reviews.length > 0
            ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
            : 0;

        // Lấy thông tin danh mục
        if (product.categories && product.categories.length) {
          productDTO.categoryDetails = await this.categoryRepository.findByIds(product.categories);
        }

        // Định dạng phản hồi sản phẩm trước khi trả về
        return formatProductResponse(productDTO);
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy thông tin chi tiết sản phẩm');
    }
  }

  /**
   * Tạo sản phẩm mới
   * @param {Object} productData - Dữ liệu sản phẩm
   * @param {String} userId - ID của người dùng tạo sản phẩm
   * @returns {Promise<Object>} - Sản phẩm đã được tạo
   */
  async createProduct(productData, userId) {
    try {
      // Xác thực dữ liệu
      const { error } = validateProductData(productData);
      if (error) {
        throw new AppError(400, `Dữ liệu không hợp lệ: ${error.message}`);
      }

      // Kiểm tra danh mục tồn tại
      if (productData.categories && productData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(productData.categories);
        if (validCategories.length !== productData.categories.length) {
          throw new AppError(400, 'Một hoặc nhiều danh mục không tồn tại');
        }
      }

      // Tạo slug từ tên sản phẩm
      productData.slug = this.createSlugFromName(productData.name);

      // Thêm thông tin người tạo và ngày tạo
      productData.createdBy = userId;
      productData.createdAt = new Date();
      productData.updatedAt = new Date();

      // Lưu vào cơ sở dữ liệu
      const newProduct = await this.productRepository.create(productData);

      // Xóa các cache liên quan
      await this.invalidateCache('products:*');

      // Định dạng phản hồi sản phẩm trước khi trả về
      return formatProductResponse(new ProductDTO(newProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Không thể tạo sản phẩm mới');
    }
  }

  /**
   * Cập nhật sản phẩm
   * @param {string} productId - ID sản phẩm
   * @param {Object} updateData - Dữ liệu cập nhật
   * @param {String} userId - ID người dùng thực hiện cập nhật
   * @returns {Promise<Object>} - Sản phẩm đã được cập nhật
   */
  async updateProduct(productId, updateData, userId) {
    try {
      // Kiểm tra sản phẩm tồn tại
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Xác thực dữ liệu cập nhật
      if (Object.keys(updateData).length > 0) {
        const { error } = validateProductData(updateData, true);
        if (error) {
          throw new AppError(400, `Dữ liệu cập nhật không hợp lệ: ${error.message}`);
        }
      }

      // Kiểm tra danh mục tồn tại nếu được cập nhật
      if (updateData.categories && updateData.categories.length) {
        const validCategories = await this.categoryRepository.findByIds(updateData.categories);
        if (validCategories.length !== updateData.categories.length) {
          throw new AppError(400, 'Một hoặc nhiều danh mục không tồn tại');
        }
      }

      // Cập nhật slug nếu tên được thay đổi
      if (updateData.name) {
        updateData.slug = this.createSlugFromName(updateData.name);
      }

      // Thêm thông tin người cập nhật và ngày cập nhật
      updateData.updatedBy = userId;
      updateData.updatedAt = new Date();

      // Cập nhật trong cơ sở dữ liệu
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, updateData);

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      // Định dạng phản hồi sản phẩm trước khi trả về
      return formatProductResponse(new ProductDTO(updatedProduct).toJSON());
    } catch (error) {
      this.handleError(error, 'Không thể cập nhật sản phẩm');
    }
  }

  /**
   * Xóa sản phẩm
   * @param {string} productId - ID sản phẩm
   * @returns {Promise<Boolean>} - Kết quả xóa
   */
  async deleteProduct(productId) {
    try {
      // Kiểm tra sản phẩm tồn tại
      const existingProduct = await this.productRepository.findById(productId);
      if (!existingProduct) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Kiểm tra sản phẩm có trong đơn hàng không
      // TODO: Add this check when OrderRepository is available

      // Xóa sản phẩm
      await this.productRepository.findByIdAndDelete(productId);

      // Xóa các đánh giá của sản phẩm
      await this.reviewRepository.deleteByProductId(productId);

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);
      await this.invalidateCache('products:*');

      return true;
    } catch (error) {
      this.handleError(error, 'Không thể xóa sản phẩm');
    }
  }

  /**
   * Cập nhật số lượng tồn kho
   * @param {string} productId - ID sản phẩm
   * @param {number} quantity - Số lượng cập nhật
   * @returns {Promise<Object>} - Thông tin tồn kho đã cập nhật
   */
  async updateStock(productId, quantity) {
    try {
      if (isNaN(quantity)) {
        throw new AppError(400, 'Số lượng tồn kho không hợp lệ');
      }

      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Cập nhật tồn kho
      const updatedProduct = await this.productRepository.findByIdAndUpdate(productId, {
        stock: quantity,
        updatedAt: new Date(),
      });

      // Xóa cache
      await this.invalidateCache(`product:${productId}`);

      // Sử dụng updatedProduct để trả về thông tin cập nhật
      const stockInfo = {
        productId,
        name: updatedProduct.name,
        stock: updatedProduct.stock,
        status: updatedProduct.stock > 0 ? 'Còn hàng' : 'Hết hàng',
      };

      // Định dạng phản hồi trước khi trả về
      return formatProductResponse(stockInfo);
    } catch (error) {
      this.handleError(error, 'Không thể cập nhật tồn kho');
    }
  }

  /**
   * Lấy sản phẩm nổi bật
   * @param {number} limit - Số lượng sản phẩm trả về
   * @returns {Promise<Array>} - Danh sách sản phẩm nổi bật
   */
  async getTrendingProducts(limit = 10) {
    try {
      const cacheKey = `products:trending:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Thực hiện truy vấn
        const trending = await this.productRepository.getTrendingProducts(limit);

        // Chuyển đổi thành DTO và định dạng phản hồi
        return trending.map((product) => formatProductResponse(new ProductDTO(product).toJSON()));
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm nổi bật');
    }
  }

  /**
   * Lấy sản phẩm theo danh mục
   * @param {string} categoryId - ID danh mục
   * @param {Object} queryParams - Các tham số truy vấn
   * @returns {Promise<Object>} - Danh sách sản phẩm và thông tin phân trang
   */
  async getProductsByCategory(categoryId, queryParams) {
    try {
      // Kiểm tra danh mục tồn tại
      const category = await this.categoryRepository.findById(categoryId);
      if (!category) {
        throw new AppError(404, 'Không tìm thấy danh mục');
      }

      // Tạo khóa cache
      const cacheKey = `products:category:${categoryId}:${JSON.stringify(queryParams)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Thêm bộ lọc danh mục
        const categoryFilter = { categories: categoryId };
        const mergedQuery = { ...queryParams, ...categoryFilter };

        // Tạo đối tượng ApiFeatures
        const features = new ApiFeatures(this.productRepository.query(), mergedQuery)
          .filter()
          .sort()
          .limitFields()
          .paginate();

        // Thực hiện truy vấn
        const products = await features.query;
        const totalCount = await this.productRepository.countDocuments(features.getFilterObject());

        // Chuyển đổi thành DTO và định dạng phản hồi
        const productDTOs = products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // Thêm thông tin danh mục
        return {
          category: {
            id: category._id,
            name: category.name,
            description: category.description,
          },
          products: productDTOs,
          totalCount,
          pagination: features.getPaginationData(totalCount),
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm theo danh mục');
    }
  }

  /**
   * Tìm kiếm sản phẩm
   * @param {string} query - Từ khóa tìm kiếm
   * @param {Object} options - Các tùy chọn tìm kiếm
   * @returns {Promise<Object>} - Kết quả tìm kiếm
   */
  async searchProducts(query, options = {}) {
    try {
      if (!query || query.trim() === '') {
        throw new AppError(400, 'Từ khóa tìm kiếm không được để trống');
      }

      // Tạo khóa cache
      const cacheKey = `products:search:${query}:${JSON.stringify(options)}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tạo truy vấn tìm kiếm
        const searchOptions = {
          query,
          limit: options.limit || 10,
          page: options.page || 1,
          sort: options.sort || { relevance: -1 },
          filters: options.filters || {},
        };

        // Thực hiện tìm kiếm
        const searchResults = await this.productRepository.search(searchOptions);

        // Chuyển đổi thành DTO và định dạng phản hồi
        const productDTOs = searchResults.products.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );

        // Kết quả tìm kiếm
        return {
          products: productDTOs,
          totalCount: searchResults.total,
          pagination: {
            currentPage: searchOptions.page,
            pageSize: searchOptions.limit,
            totalPages: Math.ceil(searchResults.total / searchOptions.limit),
          },
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể tìm kiếm sản phẩm');
    }
  }

  /**
   * Lấy thống kê sản phẩm
   * @returns {Promise<Object>} Thống kê sản phẩm
   */
  async getProductStats() {
    try {
      const cacheKey = 'products:stats';

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Tổng số sản phẩm
        const totalProducts = await this.productRepository.countDocuments();

        // Số sản phẩm theo trạng thái
        const activeProducts = await this.productRepository.countDocuments({ status: 'active' });
        const draftProducts = await this.productRepository.countDocuments({ status: 'draft' });
        const discontinuedProducts = await this.productRepository.countDocuments({
          status: 'discontinued',
        });

        // Số sản phẩm có giảm giá
        const productsOnSale = await this.productRepository.countDocuments({
          salePrice: { $gt: 0 },
        });

        // Số sản phẩm hết hàng
        const outOfStockProducts = await this.productRepository.countDocuments({
          stock: 0,
          status: 'active',
        });

        // Số sản phẩm theo danh mục
        const categoryCounts = await this.productRepository.aggregateByCategoryWithCount();

        // Số sản phẩm theo thương hiệu
        const brandCounts = await this.productRepository.aggregateByBrandWithCount();

        // Sản phẩm được xem nhiều nhất
        const mostViewedProducts = await this.productRepository.findMostViewed(5);

        return {
          totalProducts,
          byStatus: {
            active: activeProducts,
            draft: draftProducts,
            discontinued: discontinuedProducts,
          },
          productsOnSale,
          outOfStockProducts,
          byCategory: categoryCounts,
          byBrand: brandCounts,
          mostViewed: mostViewedProducts,
        };
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy thống kê sản phẩm');
    }
  }

  /**
   * Tạo slug từ tên sản phẩm
   * @param {string} name - Tên sản phẩm
   * @returns {string} - Slug đã tạo
   */
  createSlugFromName(name) {
    return name
      .toLowerCase()
      .replace(/[^\w ]+/g, '')
      .replace(/ +/g, '-');
  }

  /**
   * Cập nhật số lượng xem sản phẩm
   * @param {string} productId - ID sản phẩm
   * @returns {Promise<void>}
   */
  async incrementViewCount(productId) {
    try {
      const product = await this.productRepository.findById(productId);
      if (!product) {
        throw new AppError(404, 'Không tìm thấy sản phẩm');
      }

      // Tăng số lượt xem
      await this.productRepository.findByIdAndUpdate(productId, {
        $inc: { viewCount: 1 },
        updatedAt: new Date(),
      });

      // Không cần xóa cache vì thông tin này không quan trọng để invalidate cache ngay lập tức
    } catch (error) {
      // Chỉ ghi log lỗi, không ném lỗi vì đây không phải thao tác quan trọng
      console.error(`Error incrementing view count for product ${productId}:`, error);
    }
  }

  /**
   * Lấy sản phẩm liên quan
   * @param {string} productId - ID sản phẩm
   * @param {number} limit - Số lượng sản phẩm trả về
   * @returns {Promise<Array>} - Danh sách sản phẩm liên quan
   */
  async getRelatedProducts(productId, limit = 5) {
    try {
      const cacheKey = `products:related:${productId}:${limit}`;

      return await this.withCache(cacheKey, this.cacheExpiry, async () => {
        // Lấy thông tin sản phẩm
        const product = await this.productRepository.findById(productId);
        if (!product) {
          throw new AppError(404, 'Không tìm thấy sản phẩm');
        }

        // Lấy sản phẩm cùng danh mục
        const relatedProducts = await this.productRepository.findRelated(
          productId,
          product.categories,
          limit
        );

        // Chuyển đổi thành DTO và định dạng phản hồi
        return relatedProducts.map((product) =>
          formatProductResponse(new ProductDTO(product).toJSON())
        );
      });
    } catch (error) {
      this.handleError(error, 'Không thể lấy danh sách sản phẩm liên quan');
    }
  }
}

module.exports = new ProductService();


--- File: server/src/services/review/reviewService.js ---
/**
 * Review Service
 * Xử lý logic nghiệp vụ cho đánh giá sản phẩm
 */

const { ApiError } = require('../../common/errors/apiError');
const reviewRepository = require('../../data/repositories/reviewRepository');
const productRepository = require('../../data/repositories/productRepository');
const orderRepository = require('../../data/repositories/orderRepository');
const userRepository = require('../../data/repositories/userRepository');

/**
 * Lấy tất cả đánh giá (có thể lọc, sắp xếp, phân trang)
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getAllReviews = async (features = {}) => {
  return await reviewRepository.findAll(features);
};

/**
 * Lấy đánh giá theo ID
 * @param {string} id - ID của đánh giá
 * @returns {Promise<Object>} Thông tin đánh giá
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const getReviewById = async (id) => {
  const review = await reviewRepository.findById(id);
  if (!review) {
    throw new ApiError(404, 'Không tìm thấy đánh giá');
  }
  return review;
};

/**
 * Lấy tất cả đánh giá cho một sản phẩm
 * @param {string} productId - ID của sản phẩm
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getProductReviews = async (productId, features = {}) => {
  // Kiểm tra sản phẩm tồn tại
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  // Thêm filter cho product vào features
  const productFilter = { ...features };
  productFilter.filter = {
    ...productFilter.filter,
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  };

  return await reviewRepository.findAll(productFilter);
};

/**
 * Lấy tất cả đánh giá của một người dùng
 * @param {string} userId - ID của người dùng
 * @param {Object} features - Các tham số truy vấn (filter, sort, pagination)
 * @returns {Promise<Object>} Danh sách đánh giá và thông tin phân trang
 */
const getUserReviews = async (userId, features = {}) => {
  // Kiểm tra người dùng tồn tại
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Không tìm thấy người dùng');
  }

  // Thêm filter cho user vào features
  const userFilter = { ...features };
  userFilter.filter = {
    ...userFilter.filter,
    user: userId,
  };

  return await reviewRepository.findAll(userFilter);
};

/**
 * Tạo đánh giá mới
 * @param {string} productId - ID của sản phẩm
 * @param {string} userId - ID của người dùng đánh giá
 * @param {Object} reviewData - Dữ liệu đánh giá
 * @returns {Promise<Object>} Đánh giá đã tạo
 * @throws {ApiError} Nếu có lỗi khi tạo đánh giá
 */
const createReview = async (productId, userId, reviewData) => {
  // Kiểm tra sản phẩm tồn tại
  const product = await productRepository.findById(productId);
  if (!product) {
    throw new ApiError(404, 'Không tìm thấy sản phẩm');
  }

  // Kiểm tra người dùng tồn tại
  const user = await userRepository.findById(userId);
  if (!user) {
    throw new ApiError(404, 'Không tìm thấy người dùng');
  }

  // Kiểm tra xem người dùng đã đánh giá sản phẩm này chưa
  const existingReview = await reviewRepository.findOne({
    product: productId,
    user: userId,
  });

  if (existingReview) {
    throw new ApiError(400, 'Bạn đã đánh giá sản phẩm này rồi');
  }

  // Kiểm tra xem người dùng đã mua sản phẩm này chưa
  const verificationResult = await verifyPurchase(userId, productId);

  // Khởi tạo đánh giá
  const newReview = {
    product: productId,
    user: userId,
    rating: reviewData.rating,
    title: reviewData.title,
    review: reviewData.review,
    images: reviewData.images || [],
    isVerifiedPurchase: verificationResult.isVerified,
    ratings: {
      average: 0,
      count: 0,
    },
  };

  // Nếu có đơn hàng và là mua hàng đã xác minh, thêm thông tin đơn hàng
  if (verificationResult.isVerified && verificationResult.orderId) {
    newReview.order = verificationResult.orderId;
    newReview.purchaseDate = verificationResult.purchaseDate;
  }

  // Kiểm tra nếu cần kiểm duyệt
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration) {
    newReview.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = false;
  } else {
    newReview.moderation = {
      status: 'approved',
      moderatedAt: new Date(),
      moderatedBy: null,
      reason: null,
    };
    newReview.isVisible = true;
  }

  // Tạo đánh giá mới
  const createdReview = await reviewRepository.create(newReview);

  // Nếu không cần kiểm duyệt, cập nhật rating của sản phẩm
  if (!needModeration) {
    await updateProductRating(productId);
  }

  return createdReview;
};

/**
 * Cập nhật đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng yêu cầu cập nhật
 * @param {Object} reviewData - Dữ liệu cập nhật
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Đánh giá đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc không có quyền
 */
const updateReview = async (id, userId, reviewData, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra quyền cập nhật
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền cập nhật đánh giá này');
  }

  // Dữ liệu cần cập nhật
  const updateData = {};

  // Chỉ cập nhật các trường được phép
  if (reviewData.rating !== undefined) updateData.rating = reviewData.rating;
  if (reviewData.title !== undefined) updateData.title = reviewData.title;
  if (reviewData.review !== undefined) updateData.review = reviewData.review;
  if (reviewData.images !== undefined) updateData.images = reviewData.images;

  // Cập nhật thời gian
  updateData.updatedAt = new Date();

  // Nếu cần kiểm duyệt, đưa về trạng thái chờ kiểm duyệt lại
  const needModeration = process.env.REVIEW_MODERATION_ENABLED === 'true';
  if (needModeration && !isAdmin) {
    updateData.moderation = {
      status: 'pending',
      moderatedAt: null,
      moderatedBy: null,
      reason: null,
    };
    updateData.isVisible = false;
  }

  // Cập nhật đánh giá
  const updatedReview = await reviewRepository.update(id, updateData);

  // Nếu không cần kiểm duyệt hoặc là admin, cập nhật rating của sản phẩm
  if (!needModeration || isAdmin) {
    await updateProductRating(review.product);
  }

  return updatedReview;
};

/**
 * Xóa đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng yêu cầu xóa
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<void>}
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc không có quyền
 */
const deleteReview = async (id, userId, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra quyền xóa
  if (!isAdmin && review.user.toString() !== userId) {
    throw new ApiError(403, 'Bạn không có quyền xóa đánh giá này');
  }

  // Lưu ID sản phẩm để cập nhật rating sau
  const productId = review.product;

  // Xóa đánh giá
  await reviewRepository.delete(id);

  // Cập nhật rating của sản phẩm
  await updateProductRating(productId);
};

/**
 * Vote (upvote/downvote) đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng vote
 * @param {number} vote - Loại vote (1: upvote, -1: downvote)
 * @returns {Promise<Object>} Đánh giá đã cập nhật
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const voteReview = async (id, userId, vote) => {
  // Kiểm tra vote hợp lệ
  if (vote !== 1 && vote !== -1) {
    throw new ApiError(400, 'Vote không hợp lệ');
  }

  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Người dùng không thể vote đánh giá của chính mình
  if (review.user.toString() === userId) {
    throw new ApiError(400, 'Bạn không thể vote đánh giá của chính mình');
  }

  // Kiểm tra xem người dùng đã vote chưa
  const existingVoteIndex = review.helpfulness.voters.findIndex(
    (voter) => voter.user.toString() === userId
  );

  // Nếu đã vote, cập nhật vote
  if (existingVoteIndex > -1) {
    const existingVote = review.helpfulness.voters[existingVoteIndex];

    // Nếu vote giống nhau, hủy vote
    if (existingVote.vote === vote) {
      // Cập nhật số lượng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes -= 1;
      } else {
        review.helpfulness.downvotes -= 1;
      }

      // Xóa vote khỏi danh sách
      review.helpfulness.voters.splice(existingVoteIndex, 1);
    }
    // Nếu vote khác nhau, cập nhật vote
    else {
      // Cập nhật số lượng upvote/downvote
      if (vote === 1) {
        review.helpfulness.upvotes += 1;
        review.helpfulness.downvotes -= 1;
      } else {
        review.helpfulness.upvotes -= 1;
        review.helpfulness.downvotes += 1;
      }

      // Cập nhật vote
      review.helpfulness.voters[existingVoteIndex] = {
        user: userId,
        vote: vote,
        votedAt: new Date(),
      };
    }
  }
  // Nếu chưa vote, thêm vote mới
  else {
    // Cập nhật số lượng upvote/downvote
    if (vote === 1) {
      review.helpfulness.upvotes += 1;
    } else {
      review.helpfulness.downvotes += 1;
    }

    // Thêm vote mới
    review.helpfulness.voters.push({
      user: userId,
      vote: vote,
      votedAt: new Date(),
    });
  }

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    helpfulness: review.helpfulness,
  });
};

/**
 * Kiểm duyệt đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} action - Hành động (approve/reject)
 * @param {string} reason - Lý do từ chối (nếu reject)
 * @param {string} adminId - ID của admin thực hiện kiểm duyệt
 * @returns {Promise<Object>} Đánh giá đã kiểm duyệt
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc action không hợp lệ
 */
const moderateReview = async (id, action, reason, adminId) => {
  // Kiểm tra action hợp lệ
  if (action !== 'approve' && action !== 'reject') {
    throw new ApiError(400, 'Action không hợp lệ');
  }

  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra nếu đã kiểm duyệt với cùng action
  if (review.moderation.status === action) {
    throw new ApiError(400, `Đánh giá đã được ${action === 'approve' ? 'duyệt' : 'từ chối'} rồi`);
  }

  // Dữ liệu cập nhật
  const updateData = {
    moderation: {
      status: action,
      moderatedAt: new Date(),
      moderatedBy: adminId,
      reason: action === 'reject' ? reason : null,
    },
    isVisible: action === 'approve',
  };

  // Cập nhật đánh giá
  const moderatedReview = await reviewRepository.update(id, updateData);

  // Cập nhật rating của sản phẩm
  await updateProductRating(review.product);

  return moderatedReview;
};

/**
 * Báo cáo đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng báo cáo
 * @param {string} reason - Lý do báo cáo
 * @param {string} description - Mô tả chi tiết
 * @returns {Promise<Object>} Đánh giá đã báo cáo
 * @throws {ApiError} Nếu không tìm thấy đánh giá hoặc đã báo cáo
 */
const reportReview = async (id, userId, reason, description) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Kiểm tra người dùng đã báo cáo chưa
  const alreadyReported = review.reports.some((report) => report.user.toString() === userId);

  if (alreadyReported) {
    throw new ApiError(400, 'Bạn đã báo cáo đánh giá này rồi');
  }

  // Thêm báo cáo mới
  const newReport = {
    user: userId,
    reason,
    description,
    createdAt: new Date(),
    status: 'pending',
  };

  review.reports.push(newReport);

  // Nếu có quá nhiều báo cáo, tự động ẩn đánh giá chờ kiểm duyệt
  if (review.reports.length >= 3 && review.isVisible) {
    review.isVisible = false;
    review.moderation.status = 'pending';
  }

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    reports: review.reports,
    isVisible: review.isVisible,
    moderation: review.moderation,
  });
};

/**
 * Thêm phản hồi cho đánh giá
 * @param {string} id - ID của đánh giá
 * @param {string} userId - ID của người dùng thêm phản hồi
 * @param {string} content - Nội dung phản hồi
 * @param {boolean} isAdmin - Người dùng có phải admin không
 * @returns {Promise<Object>} Đánh giá đã thêm phản hồi
 * @throws {ApiError} Nếu không tìm thấy đánh giá
 */
const addReviewResponse = async (id, userId, content, isAdmin) => {
  // Lấy đánh giá theo ID
  const review = await getReviewById(id);

  // Thêm phản hồi mới
  const newResponse = {
    user: userId,
    isAdmin,
    content,
    createdAt: new Date(),
  };

  // Nếu chưa có phản hồi, khởi tạo mảng
  if (!review.responses) {
    review.responses = [];
  }

  review.responses.push(newResponse);

  // Cập nhật đánh giá
  return await reviewRepository.update(review._id, {
    responses: review.responses,
  });
};

/**
 * Kiểm tra xem người dùng đã mua sản phẩm hay chưa
 * @param {string} userId - ID của người dùng
 * @param {string} productId - ID của sản phẩm
 * @returns {Promise<Object>} Kết quả xác minh
 */
const verifyPurchase = async (userId, productId) => {
  // Tìm đơn hàng đã hoàn thành chứa sản phẩm
  const orders = await orderRepository.find({
    user: userId,
    status: { $in: ['delivered', 'completed'] },
    'items.product': productId,
  });

  if (!orders || orders.length === 0) {
    return { isVerified: false };
  }

  // Sắp xếp theo thời gian để lấy đơn hàng gần nhất
  orders.sort((a, b) => b.createdAt - a.createdAt);
  const latestOrder = orders[0];

  return {
    isVerified: true,
    orderId: latestOrder._id,
    purchaseDate: latestOrder.createdAt,
  };
};

/**
 * Cập nhật rating trung bình của sản phẩm
 * @param {string} productId - ID của sản phẩm
 * @returns {Promise<void>}
 */
const updateProductRating = async (productId) => {
  // Lấy tất cả đánh giá đã được phê duyệt và hiển thị
  const reviews = await reviewRepository.find({
    product: productId,
    'moderation.status': 'approved',
    isVisible: true,
  });

  // Nếu không có đánh giá, đặt rating về 0
  if (!reviews || reviews.length === 0) {
    await productRepository.update(productId, {
      'ratings.average': 0,
      'ratings.count': 0,
    });
    return;
  }

  // Tính rating trung bình
  const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
  const averageRating = Number((totalRating / reviews.length).toFixed(1));

  // Cập nhật sản phẩm
  await productRepository.update(productId, {
    'ratings.average': averageRating,
    'ratings.count': reviews.length,
  });
};

module.exports = {
  getAllReviews,
  getReviewById,
  getProductReviews,
  getUserReviews,
  createReview,
  updateReview,
  deleteReview,
  voteReview,
  moderateReview,
  reportReview,
  addReviewResponse,
  verifyPurchase,
  updateProductRating,
};


--- File: server/src/services/user/userService.js ---
/**
 * User Service - xử lý logic quản lý người dùng
 * @author Steve
 * @project RunOut-Biliard
 */

const User = require('../../data/models/user.model');
const BaseService = require('../base/baseService');
const { ApiError } = require('../../api/middleware/errorHandler');
const logger = require('../../config/logger');

/**
 * Class UserService xử lý logic quản lý người dùng
 * Kế thừa từ BaseService để có các phương thức CRUD cơ bản
 */
class UserService extends BaseService {
  constructor() {
    super(User, 'User');
  }

  /**
   * Tạo người dùng mới
   * @override
   * @param {Object} userData - Thông tin người dùng
   * @returns {Promise<Object>} - Người dùng đã tạo
   */
  async create(userData) {
    try {
      // Kiểm tra email đã tồn tại chưa
      const existingUser = await User.findOne({ email: userData.email });
      if (existingUser) {
        throw new ApiError(409, 'Email đã được sử dụng');
      }

      // Người dùng được tạo bởi admin mặc định đã xác thực email
      const newUserData = {
        ...userData,
        emailVerified: true,
      };

      // Tạo người dùng mới
      const newUser = await super.create(newUserData);

      // Loại bỏ password khỏi response
      const userObj = newUser.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi tạo người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Cập nhật thông tin người dùng
   * @override
   * @param {string} id - ID người dùng
   * @param {Object} updateData - Thông tin cập nhật
   * @param {Object} options - Tùy chọn
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async update(id, updateData, options = {}) {
    try {
      // Tạo bản sao của đối tượng updateData
      const safeUpdateData = { ...updateData };

      // Danh sách các trường nhạy cảm cần loại bỏ
      const sensitiveFields = [
        'password',
        'emailVerified',
        'loginCount',
        'lastLogin',
        'resetPasswordToken',
        'resetPasswordExpires',
        'emailVerificationToken',
        'emailVerificationExpires',
      ];

      // Loại bỏ các trường nhạy cảm
      sensitiveFields.forEach((field) => {
        delete safeUpdateData[field];
      });

      // Xử lý riêng trường role
      const { role } = updateData;
      delete safeUpdateData.role;

      // Admin có thể cập nhật role
      if (options.isAdmin && role) {
        safeUpdateData.role = role;
      }

      // Cập nhật thông tin người dùng
      const updatedUser = await super.update(id, safeUpdateData);

      return updatedUser;
    } catch (error) {
      logger.error(`Lỗi cập nhật người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Thay đổi mật khẩu
   * @param {string} userId - ID người dùng
   * @param {string} currentPassword - Mật khẩu hiện tại
   * @param {string} newPassword - Mật khẩu mới
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async changePassword(userId, currentPassword, newPassword) {
    try {
      // Lấy user với password
      const user = await User.findById(userId).select('+password');

      if (!user) {
        throw new ApiError(404, 'Người dùng không tồn tại');
      }

      // Kiểm tra mật khẩu hiện tại
      if (!(await user.correctPassword(currentPassword, user.password))) {
        throw new ApiError(401, 'Mật khẩu hiện tại không đúng');
      }

      // Cập nhật mật khẩu
      user.password = newPassword;
      await user.save();

      // Loại bỏ password khỏi response
      const userObj = user.toObject();
      delete userObj.password;

      return userObj;
    } catch (error) {
      logger.error(`Lỗi thay đổi mật khẩu: ${error.message}`);
      throw error;
    }
  }

  /**
   * Vô hiệu hóa tài khoản
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async deactivateUser(userId) {
    try {
      const user = await this.findById(userId);

      // Cập nhật trạng thái active
      user.isActive = false;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`Lỗi vô hiệu hóa tài khoản: ${error.message}`);
      throw error;
    }
  }

  /**
   * Kích hoạt lại tài khoản
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Người dùng đã cập nhật
   */
  async activateUser(userId) {
    try {
      const user = await this.findById(userId);

      // Cập nhật trạng thái active
      user.isActive = true;
      await user.save({ validateBeforeSave: false });

      return user;
    } catch (error) {
      logger.error(`Lỗi kích hoạt tài khoản: ${error.message}`);
      throw error;
    }
  }

  /**
   * Tìm kiếm người dùng với các tiêu chí nâng cao
   * @param {Object} criteria - Tiêu chí tìm kiếm
   * @param {Object} options - Tùy chọn (pagination, sort)
   * @returns {Promise<Object>} - Kết quả tìm kiếm với phân trang
   */
  async search(criteria, options = {}) {
    try {
      const filter = {};

      // Xử lý các tiêu chí tìm kiếm
      if (criteria.name) {
        filter.name = { $regex: criteria.name, $options: 'i' };
      }

      if (criteria.email) {
        filter.email = { $regex: criteria.email, $options: 'i' };
      }

      if (criteria.phone) {
        filter.phone = { $regex: criteria.phone, $options: 'i' };
      }

      if (criteria.role) {
        filter.role = criteria.role;
      }

      if (criteria.isActive !== undefined) {
        filter.isActive = criteria.isActive;
      }

      if (criteria.emailVerified !== undefined) {
        filter.emailVerified = criteria.emailVerified;
      }

      // Tìm kiếm kết hợp theo text
      if (criteria.search) {
        filter.$or = [
          { name: { $regex: criteria.search, $options: 'i' } },
          { email: { $regex: criteria.search, $options: 'i' } },
          { phone: { $regex: criteria.search, $options: 'i' } },
        ];
      }

      // Tìm kiếm theo khoảng thời gian đăng ký
      if (criteria.createdFrom || criteria.createdTo) {
        filter.createdAt = {};

        if (criteria.createdFrom) {
          filter.createdAt.$gte = new Date(criteria.createdFrom);
        }

        if (criteria.createdTo) {
          filter.createdAt.$lte = new Date(criteria.createdTo);
        }
      }

      // Lấy kết quả với phân trang
      return await this.findAll(filter, {
        ...options,
        select: '-password',
      });
    } catch (error) {
      logger.error(`Lỗi tìm kiếm người dùng: ${error.message}`);
      throw error;
    }
  }

  /**
   * Xóa người dùng và dữ liệu liên quan
   * @override
   * @param {string} userId - ID người dùng
   * @returns {Promise<Object>} - Thông tin người dùng đã xóa
   */
  async delete(userId) {
    try {
      // Xóa dữ liệu liên quan đến người dùng trước (nếu cần)
      // TODO: Xóa dữ liệu liên quan như giỏ hàng, đơn hàng, đánh giá

      // Xóa người dùng
      const user = await super.delete(userId);

      return user;
    } catch (error) {
      logger.error(`Lỗi xóa người dùng: ${error.message}`);
      throw error;
    }
  }
}

// Export singleton instance
module.exports = new UserService();


--- File: server/src/types/express.d.ts ---
import { Document } from 'mongoose';

declare global {
  namespace Express {
    interface Request {
      user?: Document & {
        id: string;
        name: string;
        email: string;
        role: string;
        changedPasswordAfter?: (timestamp: number) => boolean;
        [key: string]: any;
      };
      resource?: Document & {
        user?: any;
        [key: string]: any;
      };
    }
  }
}

// Đảm bảo file này được coi là một module
export {};

--- File: server/src/utils/apiFeatures.js ---
/**
 * API Features Utility - xử lý các tính năng API phổ biến như filtering, sorting, pagination
 * @author Steve
 * @project RunOut-Biliard
 *
 * @typedef {import('mongoose').Query<any, any>} MongooseQuery
 */

class APIFeatures {
  /**
   * Khởi tạo class với query và queryString
   * @param {MongooseQuery} query - Mongoose query ban đầu
   * @param {Object} queryString - Query parameters từ request
   */
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  /**
   * Lọc dữ liệu theo các trường
   * @returns {APIFeatures} - Instance của class để chaining
   */
  filter() {
    // Tạo bản sao của query string
    const queryObj = { ...this.queryString };

    // Các trường loại trừ khỏi filtering
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'search'];
    excludedFields.forEach((field) => delete queryObj[field]);

    // Xử lý advanced filtering (gt, gte, lt, lte, in, nin)
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in|nin)\b/g, (match) => `$${match}`);

    // Áp dụng filter vào query
    this.query = this.query.find(JSON.parse(queryStr));

    return this;
  }

  /**
   * Thêm tìm kiếm text
   * @returns {APIFeatures} - Instance của class để chaining
   */
  search() {
    if (this.queryString.search) {
      // Tạo điều kiện tìm kiếm
      const searchQuery = {
        $or: [
          { name: { $regex: this.queryString.search, $options: 'i' } },
          { description: { $regex: this.queryString.search, $options: 'i' } },
        ],
      };

      // Áp dụng tìm kiếm vào query
      this.query = this.query.find(searchQuery);
    }

    return this;
  }

  /**
   * Sắp xếp kết quả
   * @returns {APIFeatures} - Instance của class để chaining
   */
  sort() {
    if (this.queryString.sort) {
      // Chuyển đổi chuỗi sort thành format cho MongoDB
      const sortBy = this.queryString.sort.split(',').join(' ');
      this.query = this.query.sort(sortBy);
    } else {
      // Mặc định sắp xếp theo thời gian tạo giảm dần
      this.query = this.query.sort('-createdAt');
    }

    return this;
  }

  /**
   * Giới hạn các trường được trả về
   * @returns {APIFeatures} - Instance của class để chaining
   */
  limitFields() {
    if (this.queryString.fields) {
      // Chuyển đổi chuỗi fields thành format cho MongoDB
      const fields = this.queryString.fields.split(',').join(' ');
      this.query = this.query.select(fields);
    } else {
      // Mặc định loại bỏ trường __v
      this.query = this.query.select('-__v');
    }

    return this;
  }

  /**
   * Phân trang kết quả
   * @returns {APIFeatures} - Instance của class để chaining
   */
  paginate() {
    // Chuyển đổi page và limit thành số
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 10;
    const skip = (page - 1) * limit;

    // Áp dụng skip và limit vào query
    this.query = this.query.skip(skip).limit(limit);

    return this;
  }

  /**
   * Áp dụng tất cả các tính năng vào query
   * @returns {MongooseQuery} - Query đã được xử lý
   */
  build() {
    return this.filter().search().sort().limitFields().paginate().query;
  }
}

module.exports = APIFeatures;


--- File: server/src/utils/catchAsync.js ---
/**
 * Utility wrapper để xử lý lỗi async cho controllers
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Bọc hàm async để xử lý lỗi mà không cần try-catch trong mỗi controller
 * @param {Function} fn - Hàm async cần được bọc
 * @returns {Function} - Middleware function với xử lý lỗi
 */
const catchAsync = (fn) => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

module.exports = catchAsync;


--- File: server/src/utils/logger.js ---
/**
 * Module logger sử dụng Winston
 * Cung cấp các phương thức để ghi log với các cấp độ khác nhau
 */
const winston = require('winston');
const path = require('path');
const fs = require('fs');

// Tạo thư mục logs nếu chưa tồn tại
const logDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

// Định dạng thời gian cho log
const timeFormat = () => {
  return new Date().toLocaleString('vi-VN', {
    timeZone: 'Asia/Ho_Chi_Minh',
  });
};

// Tạo logger với Winston
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp({ format: timeFormat }),
    winston.format.printf(({ timestamp, level, message }) => {
      return `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    })
  ),
  transports: [
    // Ghi log ra console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ timestamp, level, message }) => {
          return `[${timestamp}] ${level}: ${message}`;
        })
      ),
    }),
    // Ghi log lỗi vào file
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
    }),
    // Ghi tất cả log vào file
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
    }),
  ],
  exitOnError: false,
});

// Thêm stream để sử dụng với Morgan (nếu cần)
logger.stream = {
  write: function (message) {
    logger.info(message.trim());
  },
};

module.exports = { logger };


--- File: server/src/utils/queryAnalyzer.js ---
// src/utils/queryAnalyzer.js
// const mongoose = require('mongoose');
const fs = require('fs').promises;
const path = require('path');

/**
 * Lớp QueryAnalyzer cung cấp các công cụ để phân tích và tối ưu hóa truy vấn MongoDB
 */
class QueryAnalyzer {
  /**
   * Phân tích truy vấn find() và trả về thông tin chi tiết về hiệu suất
   * @param {mongoose.Model} model - Model Mongoose cần phân tích
   * @param {Object} query - Điều kiện truy vấn
   * @param {Object} options - Tùy chọn bổ sung (projection, sort, skip, limit)
   * @returns {Object} Kết quả phân tích truy vấn
   */
  static async analyzeQuery(model, query, options = {}) {
    // Ghi lại thời gian bắt đầu
    const startTime = Date.now();

    // Lấy explain plan cho truy vấn
    const explain = await model
      .find(query, options.projection)
      .sort(options.sort || {})
      .skip(options.skip || 0)
      .limit(options.limit || 10)
      .explain('executionStats');

    // Trích xuất thống kê thực thi
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Phân tích kết quả
    const result = {
      collection: model.collection.name,
      queryShape: JSON.stringify(query),
      executionTimeMs: executionStats.executionTimeMillis,
      totalDocsExamined: executionStats.totalDocsExamined,
      totalKeysExamined: executionStats.totalKeysExamined,
      docsReturned: executionStats.nReturned,
      indexesUsed: this._getIndexesUsed(queryPlanner.winningPlan),
      isOptimal: this._isQueryOptimal(executionStats),
      recommendations: this.generateRecommendations(explain),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log nếu truy vấn chậm
    if (result.executionTimeMs > 100) {
      await this.logSlowQuery(result);
    }

    return result;
  }

  /**
   * Phân tích truy vấn aggregate và trả về thông tin chi tiết về hiệu suất
   * @param {mongoose.Model} model - Model Mongoose cần phân tích
   * @param {Array} pipeline - Pipeline aggregation
   * @returns {Object} Kết quả phân tích truy vấn
   */
  static async analyzeAggregate(model, pipeline) {
    const startTime = Date.now();

    // Thêm stage $explain vào cuối pipeline
    const explainPipeline = [...pipeline, { $explain: true }];
    const explainResults = await model.aggregate(explainPipeline).exec();

    // Phân tích kết quả từ explain
    const result = {
      collection: model.collection.name,
      pipeline: JSON.stringify(pipeline),
      executionTimeMs: explainResults[0]?.executionStats?.executionTimeMillis || 0,
      stages: this._analyzeAggregateStages(explainResults[0]),
      recommendations: this._generateAggregateRecommendations(explainResults[0]),
      actualExecutionTime: Date.now() - startTime,
    };

    // Ghi log nếu truy vấn chậm
    if (result.executionTimeMs > 200) {
      await this.logSlowQuery(result, 'aggregate');
    }

    return result;
  }

  /**
   * Phân tích các stage trong aggregate pipeline
   * @private
   * @param {Object} explainResult - Kết quả từ explain
   * @returns {Array} Thông tin về các stage
   */
  static _analyzeAggregateStages(explainResult) {
    if (!explainResult || !explainResult.stages) {
      return [];
    }

    return explainResult.stages.map((stage) => {
      const stageName = Object.keys(stage)[0];
      return {
        name: stageName,
        timeMs: stage[stageName]?.executionTimeMillisEstimate || 0,
      };
    });
  }

  /**
   * Tạo khuyến nghị cho truy vấn aggregate
   * @private
   * @param {Object} explainResult - Kết quả từ explain
   * @returns {Array} Danh sách khuyến nghị
   */
  static _generateAggregateRecommendations(explainResult) {
    const recommendations = [];

    if (!explainResult) return recommendations;

    // Kiểm tra các stage tốn nhiều thời gian
    if (explainResult.stages) {
      const expensiveStages = explainResult.stages
        .filter((stage) => {
          const stageName = Object.keys(stage)[0];
          return stage[stageName]?.executionTimeMillisEstimate > 100;
        })
        .map((stage) => Object.keys(stage)[0]);

      if (expensiveStages.length > 0) {
        recommendations.push(
          `Các stage tốn nhiều thời gian: ${expensiveStages.join(', ')}. Xem xét tối ưu hóa hoặc thêm chỉ mục.`
        );
      }
    }

    // Kiểm tra sử dụng $match sớm
    const pipelineStr = JSON.stringify(explainResult);
    if (
      !pipelineStr.includes('"$match"') ||
      pipelineStr.indexOf('"$match"') > pipelineStr.indexOf('"$project"')
    ) {
      recommendations.push(
        'Đặt $match càng sớm càng tốt trong pipeline để lọc dữ liệu trước khi xử lý.'
      );
    }

    return recommendations;
  }

  /**
   * Lấy danh sách các chỉ mục được sử dụng
   * @private
   * @param {Object} plan - Kế hoạch thực thi
   * @returns {String} Tên chỉ mục hoặc thông báo không sử dụng chỉ mục
   */
  static _getIndexesUsed(plan) {
    if (!plan) return 'Không có thông tin kế hoạch';

    // Kiểm tra nếu kế hoạch trực tiếp có chỉ mục
    if (plan.indexName) {
      return plan.indexName;
    }

    // Kiểm tra trong inputStage
    if (plan.inputStage?.indexName) {
      return plan.inputStage.indexName;
    }

    // Kiểm tra đệ quy trong inputStages (cho trường hợp OR hoặc AND)
    if (plan.inputStages) {
      const indexNames = plan.inputStages
        .map((stage) => this._getIndexesUsed(stage))
        .filter((name) => name !== 'No index used (COLLSCAN)');

      if (indexNames.length > 0) {
        return indexNames.join(', ');
      }
    }

    return 'No index used (COLLSCAN)';
  }

  /**
   * Kiểm tra xem truy vấn có tối ưu không
   * @private
   * @param {Object} stats - Thống kê thực thi
   * @returns {Boolean} Truy vấn có tối ưu không
   */
  static _isQueryOptimal(stats) {
    // Truy vấn được coi là tối ưu nếu:
    // 1. Số lượng tài liệu kiểm tra gần với số lượng tài liệu trả về
    // 2. Thời gian thực thi dưới ngưỡng (ví dụ: 50ms)
    return stats.totalDocsExamined <= stats.nReturned * 1.2 && stats.executionTimeMillis < 50;
  }

  /**
   * Tạo khuyến nghị dựa trên kết quả explain
   * @param {Object} explain - Kết quả từ explain()
   * @returns {Array} Danh sách khuyến nghị
   */
  static generateRecommendations(explain) {
    const recommendations = [];
    const executionStats = explain.executionStats;
    const queryPlanner = explain.queryPlanner;

    // Kiểm tra việc sử dụng chỉ mục
    const indexesUsed = this._getIndexesUsed(queryPlanner.winningPlan);
    if (indexesUsed === 'No index used (COLLSCAN)') {
      recommendations.push(
        'Truy vấn không sử dụng chỉ mục nào. Xem xét thêm chỉ mục cho mẫu truy vấn này.'
      );

      // Đề xuất chỉ mục cụ thể
      const suggestedIndex = this.suggestIndex(queryPlanner.parsedQuery);
      if (suggestedIndex) {
        recommendations.push(`Chỉ mục đề xuất: ${suggestedIndex}`);
      }
    }

    // Kiểm tra nếu kiểm tra quá nhiều tài liệu
    if (executionStats.totalDocsExamined > executionStats.nReturned * 3) {
      recommendations.push(
        'Truy vấn đang kiểm tra quá nhiều tài liệu so với số lượng trả về. Xem xét sử dụng chỉ mục chọn lọc hơn.'
      );
    }

    // Kiểm tra thời gian thực thi
    if (executionStats.executionTimeMillis > 100) {
      recommendations.push(
        'Thời gian thực thi truy vấn cao. Xem xét tối ưu hóa truy vấn hoặc thêm chỉ mục.'
      );
    }

    // Kiểm tra sắp xếp
    const sortStage = this._findSortStage(queryPlanner.winningPlan);
    if (sortStage && sortStage.sortPattern) {
      const sortFields = Object.keys(sortStage.sortPattern);
      if (
        indexesUsed === 'No index used (COLLSCAN)' ||
        !this._isSortCoveredByIndex(sortFields, indexesUsed)
      ) {
        recommendations.push(
          `Sắp xếp không được hỗ trợ bởi chỉ mục. Xem xét thêm chỉ mục bao gồm các trường sắp xếp: ${sortFields.join(', ')}`
        );
      }
    }

    return recommendations;
  }

  /**
   * Tìm stage sắp xếp trong kế hoạch truy vấn
   * @private
   * @param {Object} plan - Kế hoạch truy vấn
   * @returns {Object|null} Stage sắp xếp hoặc null nếu không tìm thấy
   */
  static _findSortStage(plan) {
    if (!plan) return null;

    if (plan.stage === 'SORT') {
      return plan;
    }

    if (plan.inputStage) {
      return this._findSortStage(plan.inputStage);
    }

    if (plan.inputStages) {
      for (const stage of plan.inputStages) {
        const sortStage = this._findSortStage(stage);
        if (sortStage) return sortStage;
      }
    }

    return null;
  }

  /**
   * Kiểm tra xem sắp xếp có được hỗ trợ bởi chỉ mục không
   * @private
   * @param {Array} sortFields - Các trường sắp xếp
   * @param {String} indexName - Tên chỉ mục
   * @returns {Boolean} Sắp xếp có được hỗ trợ không
   */
  static _isSortCoveredByIndex(sortFields, indexName) {
    // Phương thức này cần thông tin về cấu trúc chỉ mục
    // Trong thực tế, bạn cần truy vấn thông tin chỉ mục từ MongoDB
    // Đây là một triển khai đơn giản
    if (indexName === 'No index used (COLLSCAN)') {
      return false;
    }

    // Giả định rằng tên chỉ mục có dạng: collection_field1_field2_...
    const indexFields = indexName.split('_').slice(1);

    // Kiểm tra xem tất cả các trường sắp xếp có trong chỉ mục không
    return sortFields.every((field) => indexFields.includes(field));
  }

  /**
   * Đề xuất chỉ mục dựa trên truy vấn
   * @param {Object} parsedQuery - Truy vấn đã phân tích
   * @returns {String} Đề xuất chỉ mục
   */
  static suggestIndex(parsedQuery) {
    if (!parsedQuery) return null;

    const fields = [];

    // Phân tích các trường trong truy vấn
    for (const field in parsedQuery) {
      // Bỏ qua các toán tử đặc biệt
      if (field.startsWith('$')) continue;

      fields.push(field);
    }

    if (fields.length === 0) return null;

    // Tạo chuỗi đề xuất chỉ mục
    return `{ ${fields.map((f) => `"${f}": 1`).join(', ')} }`;
  }

  /**
   * Ghi log truy vấn chậm
   * @param {Object} queryInfo - Thông tin truy vấn
   * @param {String} queryType - Loại truy vấn (find, aggregate, ...)
   * @returns {Promise<void>}
   */
  static async logSlowQuery(queryInfo, queryType = 'find') {
    try {
      const logDir = path.join(process.cwd(), 'logs');

      // Tạo thư mục logs nếu chưa tồn tại
      try {
        await fs.mkdir(logDir, { recursive: true });
      } catch (err) {
        if (err.code !== 'EEXIST') throw err;
      }

      const logFile = path.join(logDir, 'slow-queries.log');
      const timestamp = new Date().toISOString();

      const logEntry = {
        timestamp,
        queryType,
        ...queryInfo,
      };

      await fs.appendFile(logFile, JSON.stringify(logEntry) + '\n', 'utf8');
    } catch (error) {
      console.error('Lỗi khi ghi log truy vấn chậm:', error);
    }
  }

  /**
   * Phân tích tất cả các chỉ mục trong collection
   * @param {mongoose.Model} model - Model Mongoose
   * @returns {Promise<Array>} Danh sách chỉ mục và thông tin
   */
  static async analyzeIndexes(model) {
    // Lấy thông tin về tất cả các chỉ mục
    const indexes = await model.collection.indexes();

    // Phân tích từng chỉ mục
    return Promise.all(
      indexes.map(async (index) => {
        // Lấy thống kê sử dụng chỉ mục
        const stats = await model.collection.stats();

        return {
          name: index.name,
          fields: index.key,
          unique: !!index.unique,
          sparse: !!index.sparse,
          size: stats.indexSizes?.[index.name] || 0,
          usage: await this._getIndexUsageStats(model, index.name),
        };
      })
    );
  }

  /**
   * Lấy thống kê sử dụng chỉ mục
   * @private
   * @param {mongoose.Model} model - Model Mongoose
   * @param {String} indexName - Tên chỉ mục
   * @returns {Promise<Object>} Thống kê sử dụng
   */
  static async _getIndexUsageStats(model, indexName) {
    try {
      // Sử dụng aggregation để lấy thông tin sử dụng chỉ mục
      const result = await model.db.db.command({
        aggregate: model.collection.collectionName,
        pipeline: [{ $indexStats: {} }, { $match: { name: indexName } }],
        cursor: {},
      });

      if (result?.cursor?.firstBatch?.length > 0) {
        const stats = result.cursor.firstBatch[0];
        return {
          operations: stats.accesses.ops,
          since: stats.accesses.since,
        };
      }

      return { operations: 0, since: new Date() };
    } catch (error) {
      console.error(`Lỗi khi lấy thống kê sử dụng chỉ mục ${indexName}:`, error);
      return { operations: 0, since: new Date(), error: error.message };
    }
  }

  /**
   * Tạo báo cáo hiệu suất truy vấn
   * @param {mongoose.Model} model - Model Mongoose
   * @param {Number} days - Số ngày để phân tích
   * @returns {Promise<Object>} Báo cáo hiệu suất
   */
  static async generatePerformanceReport(model, days = 7) {
    try {
      // Phân tích chỉ mục
      const indexes = await this.analyzeIndexes(model);

      // Đọc log truy vấn chậm
      const slowQueries = await this._readSlowQueriesLog(days);

      // Lọc các truy vấn liên quan đến collection này
      const collectionQueries = slowQueries.filter((q) => q.collection === model.collection.name);

      // Phân tích các mẫu truy vấn phổ biến
      const queryPatterns = this._analyzeQueryPatterns(collectionQueries);

      // Tạo báo cáo
      return {
        collection: model.collection.name,
        indexes,
        slowQueriesCount: collectionQueries.length,
        averageExecutionTime: this._calculateAverage(
          collectionQueries.map((q) => q.executionTimeMs)
        ),
        commonQueryPatterns: queryPatterns,
        indexRecommendations: this._generateIndexRecommendations(queryPatterns, indexes),
      };
    } catch (error) {
      console.error('Lỗi khi tạo báo cáo hiệu suất:', error);
      return { error: error.message };
    }
  }

  /**
   * Đọc log truy vấn chậm
   * @private
   * @param {Number} days - Số ngày để đọc
   * @returns {Promise<Array>} Danh sách truy vấn chậm
   */
  static async _readSlowQueriesLog(days) {
    try {
      const logFile = path.join(process.cwd(), 'logs', 'slow-queries.log');

      // Kiểm tra xem file log có tồn tại không
      try {
        await fs.access(logFile);
      } catch (err) {
        return []; // File không tồn tại
      }

      // Đọc file log
      const content = await fs.readFile(logFile, 'utf8');
      const lines = content.split('\n').filter((line) => line.trim());

      // Phân tích từng dòng
      const queries = lines
        .map((line) => {
          try {
            return JSON.parse(line);
          } catch (err) {
            return null;
          }
        })
        .filter((q) => q !== null);

      // Lọc theo ngày
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      return queries.filter((q) => {
        const queryDate = new Date(q.timestamp);
        return queryDate >= cutoffDate;
      });
    } catch (error) {
      console.error('Lỗi khi đọc log truy vấn chậm:', error);
      return [];
    }
  }

  /**
   * Phân tích các mẫu truy vấn phổ biến
   * @private
   * @param {Array} queries - Danh sách truy vấn
   * @returns {Array} Các mẫu truy vấn phổ biến
   */
  static _analyzeQueryPatterns(queries) {
    const patterns = {};

    // Nhóm các truy vấn theo mẫu
    queries.forEach((query) => {
      if (!query.queryShape) return;

      if (!patterns[query.queryShape]) {
        patterns[query.queryShape] = {
          pattern: query.queryShape,
          count: 0,
          totalTime: 0,
          examples: [],
        };
      }

      patterns[query.queryShape].count++;
      patterns[query.queryShape].totalTime += query.executionTimeMs;

      // Lưu tối đa 3 ví dụ
      if (patterns[query.queryShape].examples.length < 3) {
        patterns[query.queryShape].examples.push({
          timestamp: query.timestamp,
          executionTimeMs: query.executionTimeMs,
        });
      }
    });

    // Chuyển đổi thành mảng và sắp xếp theo số lượng
    return Object.values(patterns)
      .map((p) => ({
        ...p,
        averageTime: p.totalTime / p.count,
      }))
      .sort((a, b) => b.count - a.count);
  }

  /**
   * Tạo đề xuất chỉ mục dựa trên mẫu truy vấn
   * @private
   * @param {Array} queryPatterns - Các mẫu truy vấn
   * @param {Array} existingIndexes - Các chỉ mục hiện có
   * @returns {Array} Đề xuất chỉ mục
   */
  static _generateIndexRecommendations(queryPatterns, existingIndexes) {
    const recommendations = [];

    queryPatterns.forEach((pattern) => {
      try {
        // Phân tích mẫu truy vấn
        const queryObj = JSON.parse(pattern.pattern);

        // Lấy các trường trong truy vấn
        const queryFields = Object.keys(queryObj).filter((key) => !key.startsWith('$'));

        if (queryFields.length === 0) return;

        // Kiểm tra xem đã có chỉ mục nào bao gồm các trường này chưa
        const hasMatchingIndex = existingIndexes.some((index) => {
          const indexFields = Object.keys(index.fields);
          return queryFields.every((field) => indexFields.includes(field));
        });

        if (!hasMatchingIndex) {
          recommendations.push({
            queryPattern: pattern.pattern,
            suggestedIndex: `{ ${queryFields.map((f) => `"${f}": 1`).join(', ')} }`,
            queryCount: pattern.count,
            averageTime: pattern.averageTime,
          });
        }
      } catch (error) {
        // Bỏ qua các mẫu không hợp lệ
      }
    });

    return recommendations;
  }

  /**
   * Tính giá trị trung bình của một mảng số
   * @private
   * @param {Array} values - Mảng các giá trị
   * @returns {Number} Giá trị trung bình
   */
  static _calculateAverage(values) {
    if (values.length === 0) return 0;
    return values.reduce((sum, val) => sum + val, 0) / values.length;
  }
}

module.exports = QueryAnalyzer;


--- File: server/src/utils/responseHandler.js ---
/**
 * Response Handler Utility - định dạng chuẩn hóa cho responses
 * @author Steve
 * @project RunOut-Biliard
 */

/**
 * Gửi response thành công
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo thành công
 * @param {*} data - Dữ liệu trả về
 */
exports.sendSuccess = (res, statusCode = 200, message = 'Success', data = null) => {
  const response = {
    status: 'success',
    message,
  };

  if (data !== null) {
    response.data = data;
  }

  res.status(statusCode).json(response);
};

/**
 * Gửi response lỗi
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo lỗi
 * @param {Object} errors - Chi tiết lỗi (optional)
 */
exports.sendError = (res, statusCode = 500, message = 'Error', errors = null) => {
  const response = {
    status: 'error',
    message,
  };

  if (errors !== null) {
    response.errors = errors;
  }

  res.status(statusCode).json(response);
};

/**
 * Gửi response với dữ liệu phân trang
 * @param {Object} res - Express response object
 * @param {number} statusCode - HTTP status code
 * @param {string} message - Thông báo
 * @param {Array} data - Dữ liệu trả về
 * @param {Object} pagination - Thông tin phân trang
 */
exports.sendPaginated = (
  res,
  statusCode = 200,
  message = 'Success',
  data = [],
  pagination = {}
) => {
  const response = {
    status: 'success',
    message,
    data,
    pagination,
  };

  res.status(statusCode).json(response);
};

/**
 * Gửi response cho created
 * @param {Object} res - Express response object
 * @param {string} message - Thông báo
 * @param {*} data - Dữ liệu trả về
 */
exports.sendCreated = (res, message = 'Created successfully', data = null) => {
  exports.sendSuccess(res, 201, message, data);
};

/**
 * Gửi response không có nội dung
 * @param {Object} res - Express response object
 */
exports.sendNoContent = (res) => {
  res.status(204).end();
};


--- File: server/src/utils/validatorUtils.js ---
/**
 * Validator Utilities - Các hàm hỗ trợ validate dữ liệu
 * @author Steve
 * @project RunOut-Biliard
 */

const mongoose = require('mongoose');

/**
 * Kiểm tra ID MongoDB hợp lệ
 * @param {string} id - ID cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isValidMongoId = (id) => {
  return mongoose.Types.ObjectId.isValid(id);
};

/**
 * Kiểm tra số điện thoại Việt Nam hợp lệ
 * @param {string} phone - Số điện thoại cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isValidVNPhone = (phone) => {
  return /^(0|\+84)[3|5|7|8|9][0-9]{8}$/.test(phone);
};

/**
 * Kiểm tra mật khẩu đủ mạnh
 * Yêu cầu:
 * - Ít nhất 8 ký tự
 * - Có ít nhất 1 chữ hoa
 * - Có ít nhất 1 chữ thường
 * - Có ít nhất 1 chữ số
 * @param {string} password - Mật khẩu cần kiểm tra
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isStrongPassword = (password) => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /[0-9]/.test(password);

  return password.length >= minLength && hasUpperCase && hasLowerCase && hasNumbers;
};

/**
 * Mã hóa một chuỗi thành slug
 * @param {string} text - Chuỗi cần mã hóa
 * @returns {string} - Slug đã tạo
 */
exports.slugify = (text) => {
  return text
    .toString()
    .normalize('NFD') // tách dấu thành các ký tự riêng biệt
    .replace(/[\u0300-\u036f]/g, '') // loại bỏ dấu
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // thay khoảng trắng bằng dấu gạch
    .replace(/[^\w-]+/g, '') // loại bỏ các ký tự đặc biệt
    .replace(/--+/g, '-'); // thay nhiều dấu gạch liên tiếp bằng một dấu
};

/**
 * Loại bỏ dấu tiếng Việt
 * @param {string} str - Chuỗi cần xử lý
 * @returns {string} - Chuỗi đã loại bỏ dấu
 */
exports.removeVietnameseAccents = (str) => {
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/đ/g, 'd')
    .replace(/Đ/g, 'D');
};

/**
 * Kiểm tra một giá trị có thuộc một enum không
 * @param {*} value - Giá trị cần kiểm tra
 * @param {Array} enumValues - Mảng các giá trị hợp lệ
 * @returns {boolean} - true nếu hợp lệ, false nếu không
 */
exports.isInEnum = (value, enumValues) => {
  return enumValues.includes(value);
};

/**
 * Tạo một mã ngẫu nhiên
 * @param {number} length - Độ dài mã
 * @returns {string} - Mã ngẫu nhiên
 */
exports.generateRandomCode = (length = 6) => {
  const characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let result = '';

  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
};

/**
 * Chuẩn hóa số điện thoại về định dạng 0xxxxxxxxx
 * @param {string} phone - Số điện thoại cần chuẩn hóa
 * @returns {string} - Số điện thoại đã chuẩn hóa
 */
exports.normalizePhone = (phone) => {
  if (!phone) return '';

  // Loại bỏ các ký tự không phải số
  let normalized = phone.replace(/\D/g, '');

  // Đổi +84 thành 0
  if (normalized.startsWith('84')) {
    normalized = '0' + normalized.substring(2);
  }

  return normalized;
};


--- File: server/tests/integration/repositories/repositoryConsistency.test.js ---
// server/src/tests/repositories/repositoryConsistency.test.js
const UserRepository = require('../../../src/data/repositories/userRepository');
const ProductRepository = require('../../../src/data/repositories/productRepository');
const CategoryRepository = require('../../../src/data/repositories/categoryRepository');
const OrderRepository = require('../../../src/data/repositories/orderRepository');
const CartRepository = require('../../../src/data/repositories/cartRepository');
const ReviewRepository = require('../../../src/data/repositories/reviewRepository');

describe('Repository Consistency', () => {
  const repositories = [
    { name: 'UserRepository', repo: new UserRepository() },
    { name: 'ProductRepository', repo: new ProductRepository() },
    { name: 'CategoryRepository', repo: new CategoryRepository() },
    { name: 'OrderRepository', repo: new OrderRepository() },
    { name: 'CartRepository', repo: new CartRepository() },
    { name: 'ReviewRepository', repo: new ReviewRepository() },
  ];

  test('All repositories should have the same base methods', () => {
    const requiredMethods = ['findAll', 'findById', 'create', 'update', 'delete'];

    repositories.forEach(({ name, repo }) => {
      requiredMethods.forEach((method) => {
        expect(typeof repo[method]).toBe('function', `${name} should have method ${method}`);
      });
    });
  });

  test('Repositories should have consistent parameter patterns', () => {
    repositories.forEach(({ name, repo }) => {
      // Check if constructor exists
      expect(repo.constructor).toBeDefined(`${name} should have a constructor`);

      // Check method parameter count
      const findByIdParameterCount = repo.findById.length;
      expect(findByIdParameterCount).toBe(1, `${name}.findById should accept 1 parameter (id)`);

      const updateParameterCount = repo.update.length;
      expect(updateParameterCount).toBe(2, `${name}.update should accept 2 parameters (id, data)`);
    });
  });
});


--- File: server/tests/integration/repositories/userRepository.test.js ---
// server/tests/repositories/userRepository.test.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const User = require('../../../src/data/models/user.model');
const UserRepository = require('../../../src/data/repositories/userRepository');

let mongoServer;
const userRepository = new UserRepository();

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  await mongoose.connect(mongoServer.getUri(), {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

beforeEach(async () => {
  await User.deleteMany({});
});

describe('UserRepository', () => {
  describe('create', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'user',
      };

      const user = await userRepository.create(userData);

      expect(user).toBeDefined();
      expect(user.name).toBe(userData.name);
      expect(user.email).toBe(userData.email);
      expect(user.role).toBe(userData.role);
    });
  });

  describe('findById', () => {
    it('should find a user by id', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'user',
      };

      const createdUser = await userRepository.create(userData);
      const foundUser = await userRepository.findById(createdUser.id);

      expect(foundUser).toBeDefined();
      expect(foundUser.id).toBe(createdUser.id);
      expect(foundUser.name).toBe(userData.name);
    });

    it('should return null if user not found', async () => {
      const foundUser = await userRepository.findById(mongoose.Types.ObjectId());
      expect(foundUser).toBeNull();
    });

    it('should return a user if found by valid id', async () => {
      const userData = {
        name: 'Another User',
        email: 'another@example.com',
        password: 'password456',
        role: 'admin',
      };

      const createdUser = await userRepository.create(userData);
      const foundUser = await userRepository.findById(createdUser.id);

      expect(foundUser).toBeDefined();
      expect(foundUser.id).toBe(createdUser.id);
      expect(foundUser.name).toBe(userData.name);
    });
  });

  // Thêm các test cases khác cho các phương thức còn lại
});


--- File: server/tests/setup.js ---
// Load biến môi trường từ .env.test nếu tồn tại
require('dotenv').config({ path: '.env.test' });

// Thiết lập cho MongoDB Memory Server nếu sử dụng cho testing
// Uncomment nếu sử dụng mongodb-memory-server cho test
// const { MongoMemoryServer } = require('mongodb-memory-server');
// const mongoose = require('mongoose');

// let mongoServer;

// Hàm thiết lập trước khi chạy tất cả tests
beforeAll(async () => {
  // Thiết lập các biến môi trường cần thiết cho tests
  process.env.NODE_ENV = 'test';

  // Nếu sử dụng MongoDB Memory Server
  /*
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  process.env.MONGODB_URI_TEST = mongoUri;
  
  await mongoose.connect(mongoUri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  */

  // Các thiết lập khác trước tests
  console.log('Test suite started');
});

// Hàm dọn dẹp sau mỗi test
afterEach(async () => {
  // Dọn dẹp mocks hoặc spy functions
  jest.clearAllMocks();

  // Xóa tất cả collections sau mỗi test
  /*
  if (mongoose.connection.readyState === 1) {
    const collections = mongoose.connection.collections;
    for (const key in collections) {
      await collections[key].deleteMany({});
    }
  }
  */
});

// Hàm dọn dẹp sau khi chạy tất cả tests
afterAll(async () => {
  // Đóng kết nối MongoDB nếu đang mở
  /*
  await mongoose.connection.close();
  if (mongoServer) {
    await mongoServer.stop();
  }
  */

  // Các dọn dẹp khác
  console.log('Test suite completed');
});

// Global matchers tùy chỉnh
expect.extend({
  // Ví dụ về custom matcher
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      };
    } else {
      return {
        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      };
    }
  },
});

